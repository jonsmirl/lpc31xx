Bottom: a68dd35f784fd69e6e41330f8c316dd50191ec6d
Top:    1a1cac63d435b53c2e7ae1dd04216364ddd3aa1f
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-07-09 10:19:54 -0400

Dump the clock in /proc/ccm


---

diff --git a/drivers/clk/sunxi/ccm_i.h b/drivers/clk/sunxi/ccm_i.h
new file mode 100644
index 0000000..81b07de
--- /dev/null
+++ b/drivers/clk/sunxi/ccm_i.h
@@ -0,0 +1,282 @@
+/*
+ * arch/arm/mach-sun7i/clock/ccm_i.h
+ * (c) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * James Deng <csjamesdeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __AW_CCMU_I_H__
+#define __AW_CCMU_I_H__
+
+#include <linux/kernel.h>
+#include <linux/printk.h>
+#include <asm/io.h>
+#include <asm/div64.h>
+//#include <mach/includes.h>
+#include "ccmu.h"
+
+
+#define CCU_DEBUG_LEVEL 2
+
+#if (CCU_DEBUG_LEVEL == 1)
+    #define CCU_DBG(format,args...)     do {} while (0)
+    #define CCU_INF(format,args...)     do {} while (0)
+    #define CCU_ERR(format,args...)     printk(KERN_ERR "[ccu-err] "format,##args)
+#elif (CCU_DEBUG_LEVEL == 2)
+    #define CCU_DBG(format,args...)     do {} while (0)
+    #define CCU_INF(format,args...)     printk(KERN_INFO"[ccu-inf] "format,##args)
+    #define CCU_ERR(format,args...)     printk(KERN_ERR "[ccu-err] "format,##args)
+#elif (CCU_DEBUG_LEVEL == 3)
+    #define CCU_DBG(format,args...)     printk(KERN_INFO"[ccu-dbg] "format,##args)
+    #define CCU_INF(format,args...)     printk(KERN_INFO"[ccu-inf] "format,##args)
+    #define CCU_ERR(format,args...)     printk(KERN_ERR "[ccu-err] "format,##args)
+#endif
+
+/* define system clock id */
+typedef enum __AW_CCU_CLK_ID
+{
+    AW_SYS_CLK_NONE,        /* invalid clock id                                 */
+
+    /* system clock defile */
+    AW_SYS_CLK_LOSC,        /* "losc"           ,LOSC, 32768 hz clock           */
+    AW_SYS_CLK_HOSC,        /* "hosc"           ,HOSC, 24Mhz clock              */
+    AW_SYS_CLK_PLL1,        /* "core_pll"       ,PLL1 clock                     */
+    AW_SYS_CLK_PLL2,        /* "audio_pll"      ,PLL2 clock                     */
+    AW_SYS_CLK_PLL2X8,      /* "audio_pllx8"    ,PLL2 8x clock                  */
+    AW_SYS_CLK_PLL3,        /* "video_pll0"     ,PLL3 clock                     */
+    AW_SYS_CLK_PLL3X2,      /* "video_pll0x2"   ,PLL3 2x clock                  */
+    AW_SYS_CLK_PLL4,        /* "ve_pll"         ,PLL4 clock                     */
+    AW_SYS_CLK_PLL5,        /* "sdram_pll"      ,PLL5 clock                     */
+    AW_SYS_CLK_PLL5M,       /* "sdram_pll_m"    ,PLL5 M clock                   */
+    AW_SYS_CLK_PLL5P,       /* "sdram_pll_p"    ,PLL5 P clock                   */
+    AW_SYS_CLK_PLL6,        /* "sata_pll"       ,PLL6 clock                     */
+    AW_SYS_CLK_PLL6M,       /* "sata_pll_m"     ,PLL6 M clock, just for SATA    */
+    AW_SYS_CLK_PLL62,       /* "sata_pll_2"     ,PLL6 2 clock, for module       */
+    AW_SYS_CLK_PLL6X2,      /* "sata_pllx2"     ,PLL6 2x clock, for module      */
+    AW_SYS_CLK_PLL7,        /* "video_pll1"     ,PLL7 clock                     */
+    AW_SYS_CLK_PLL7X2,      /* "video_pll1x2"   ,PLL7 2x clock                  */
+    AW_SYS_CLK_PLL8,        /* "gpu_pll"        ,PLL8 clock                     */
+    AW_SYS_CLK_CPU,         /* "cpu"            ,CPU clock                      */
+    AW_SYS_CLK_AXI,         /* "axi"            ,AXI clock                      */
+    AW_SYS_CLK_ATB,         /* "atb"            ,ATB clock                      */
+    AW_SYS_CLK_AHB,         /* "ahb"            ,AHB clock                      */
+    AW_SYS_CLK_APB0,        /* "apb"            ,APB0 clock                     */
+    AW_SYS_CLK_APB1,        /* "apb1"           ,APB1 clock                     */
+
+    AW_CCU_CLK_NULL,        /* invalid clock id                                 */
+
+    /* module clock define */
+    AW_MOD_CLK_NFC,         /* "nfc"                                            */
+    AW_MOD_CLK_MSC,         /* "msc"                                            */
+    AW_MOD_CLK_SDC0,        /* "sdc0"                                           */
+    AW_MOD_CLK_SDC1,        /* "sdc1"                                           */
+    AW_MOD_CLK_SDC2,        /* "sdc2"                                           */
+    AW_MOD_CLK_SDC3,        /* "sdc3"                                           */
+    AW_MOD_CLK_TS,          /* "ts"                                             */
+    AW_MOD_CLK_SS,          /* "ss"                                             */
+    AW_MOD_CLK_SPI0,        /* "spi0"                                           */
+    AW_MOD_CLK_SPI1,        /* "spi1"                                           */
+    AW_MOD_CLK_SPI2,        /* "spi2"                                           */
+    AW_MOD_CLK_PATA,        /* "pata"                                           */
+    AW_MOD_CLK_IR0,         /* "ir0"                                            */
+    AW_MOD_CLK_IR1,         /* "ir1"                                            */
+    AW_MOD_CLK_I2S0,        /* "i2s0"                                           */
+    AW_MOD_CLK_I2S1,        /* "i2s1"                                           */
+    AW_MOD_CLK_I2S2,        /* "i2s2"                                           */
+    AW_MOD_CLK_AC97,        /* "ac97"                                           */
+    AW_MOD_CLK_SPDIF,       /* "spdif"                                          */
+    AW_MOD_CLK_KEYPAD,      /* "key_pad"                                        */
+    AW_MOD_CLK_SATA,        /* "sata"                                           */
+    AW_MOD_CLK_USBPHY,      /* "usb_phy"                                        */
+    AW_MOD_CLK_USBPHY0,     /* "usb_phy0"                                       */
+    AW_MOD_CLK_USBPHY1,     /* "usb_phy1"                                       */
+    AW_MOD_CLK_USBPHY2,     /* "usb_phy2"                                       */
+    AW_MOD_CLK_USBOHCI0,    /* "usb_ohci0"                                      */
+    AW_MOD_CLK_USBOHCI1,    /* "usb_ohci1"                                      */
+    AW_MOD_CLK_GPS,         /* "com"                                            */
+    AW_MOD_CLK_SPI3,        /* "spi3"                                           */
+    AW_MOD_CLK_DEBE0,       /* "de_image0"                                      */
+    AW_MOD_CLK_DEBE1,       /* "de_image1"                                      */
+    AW_MOD_CLK_DEFE0,       /* "de_scale0"                                      */
+    AW_MOD_CLK_DEFE1,       /* "de_scale1"                                      */
+    AW_MOD_CLK_DEMIX,       /* "de_mix"                                         */
+    AW_MOD_CLK_LCD0CH0,     /* "lcd0_ch0"                                       */
+    AW_MOD_CLK_LCD1CH0,     /* "lcd1_ch0"                                       */
+    AW_MOD_CLK_CSIISP,      /* "csi_isp"                                        */
+    AW_MOD_CLK_TVDMOD1,     /* "tvdmod1"                                        */
+    AW_MOD_CLK_TVDMOD2,     /* "tvdmod2"                                        */
+    AW_MOD_CLK_LCD0CH1_S1,  /* "lcd0_ch1_s1"                                    */
+    AW_MOD_CLK_LCD0CH1_S2,  /* "lcd0_ch1_s2"                                    */
+    AW_MOD_CLK_LCD1CH1_S1,  /* "lcd1_ch1_s1"                                    */
+    AW_MOD_CLK_LCD1CH1_S2,  /* "lcd1_ch1_s2"                                    */
+    AW_MOD_CLK_CSI0,        /* "csi0"                                           */
+    AW_MOD_CLK_CSI1,        /* "csi1"                                           */
+    AW_MOD_CLK_VE,          /* "ve"                                             */
+    AW_MOD_CLK_ADDA,        /* "audio_codec"                                    */
+    AW_MOD_CLK_AVS,         /* "avs"                                            */
+    AW_MOD_CLK_ACE,         /* "ace"                                            */
+    AW_MOD_CLK_LVDS,        /* "lvds"                                           */
+    AW_MOD_CLK_HDMI,        /* "hdmi"                                           */
+    AW_MOD_CLK_MALI,        /* "mali"                                           */
+    AW_MOD_CLK_TWI0,        /* "twi0"                                           */
+    AW_MOD_CLK_TWI1,        /* "twi1"                                           */
+    AW_MOD_CLK_TWI2,        /* "twi2"                                           */
+    AW_MOD_CLK_TWI3,        /* "twi3"                                           */
+    AW_MOD_CLK_TWI4,        /* "twi4"                                           */
+    AW_MOD_CLK_CAN,         /* "can"                                            */
+    AW_MOD_CLK_SCR,         /* "scr"                                            */
+    AW_MOD_CLK_PS20,        /* "ps0"                                            */
+    AW_MOD_CLK_PS21,        /* "ps1"                                            */
+    AW_MOD_CLK_UART0,       /* "uart0"                                          */
+    AW_MOD_CLK_UART1,       /* "uart1"                                          */
+    AW_MOD_CLK_UART2,       /* "uart2"                                          */
+    AW_MOD_CLK_UART3,       /* "uart3"                                          */
+    AW_MOD_CLK_UART4,       /* "uart4"                                          */
+    AW_MOD_CLK_UART5,       /* "uart5"                                          */
+    AW_MOD_CLK_UART6,       /* "uart6"                                          */
+    AW_MOD_CLK_UART7,       /* "uart7"                                          */
+    AW_MOD_CLK_SMPTWD,      /* "smp_twd"                                        */
+    AW_MOD_CLK_MBUS,        /* "mbus"                                           */
+    AW_MOD_CLK_OUTA,        /* "clkout_a"                                       */
+    AW_MOD_CLK_OUTB,        /* "clkout_b"                                       */
+
+    /* clock gating for hang to AHB bus */
+    AW_AHB_CLK_USB0,        /* "ahb_usb0"                                       */
+    AW_AHB_CLK_EHCI0,       /* "ahb_ehci0"                                      */
+    AW_AHB_CLK_OHCI0,       /* "ahb_ohci0"                                      */
+    AW_AHB_CLK_SS,          /* "ahb_ss"                                         */
+    AW_AHB_CLK_DMA,         /* "ahb_dma"                                        */
+    AW_AHB_CLK_BIST,        /* "ahb_bist"                                       */
+    AW_AHB_CLK_SDMMC0,      /* "ahb_sdc0"                                       */
+    AW_AHB_CLK_SDMMC1,      /* "ahb_sdc1"                                       */
+    AW_AHB_CLK_SDMMC2,      /* "ahb_sdc2"                                       */
+    AW_AHB_CLK_SDMMC3,      /* "ahb_sdc3"                                       */
+    AW_AHB_CLK_MS,          /* "ahb_msc"                                        */
+    AW_AHB_CLK_NAND,        /* "ahb_nfc"                                        */
+    AW_AHB_CLK_SDRAM,       /* "ahb_sdramc"                                     */
+    AW_AHB_CLK_ACE,         /* "ahb_ace"                                        */
+    AW_AHB_CLK_EMAC,        /* "ahb_emac"                                       */
+    AW_AHB_CLK_TS,          /* "ahb_ts"                                         */
+    AW_AHB_CLK_SPI0,        /* "ahb_spi0"                                       */
+    AW_AHB_CLK_SPI1,        /* "ahb_spi1"                                       */
+    AW_AHB_CLK_SPI2,        /* "ahb_spi2"                                       */
+    AW_AHB_CLK_SPI3,        /* "ahb_spi3"                                       */
+    AW_AHB_CLK_PATA,        /* "ahb_pata"                                       */
+    AW_AHB_CLK_SATA,        /* "ahb_sata"                                       */
+    AW_AHB_CLK_GPS,         /* "ahb_com"                                        */
+    AW_AHB_CLK_VE,          /* "ahb_ve"                                         */
+    AW_AHB_CLK_TVD,         /* "ahb_tvd"                                        */
+    AW_AHB_CLK_TVE0,        /* "ahb_tve0"                                       */
+    AW_AHB_CLK_TVE1,        /* "ahb_tve1"                                       */
+    AW_AHB_CLK_LCD0,        /* "ahb_lcd0"                                       */
+    AW_AHB_CLK_LCD1,        /* "ahb_lcd1"                                       */
+    AW_AHB_CLK_CSI0,        /* "ahb_csi0"                                       */
+    AW_AHB_CLK_CSI1,        /* "ahb_csi1"                                       */
+    AW_AHB_CLK_HDMI1,       /* "ahb_hdmi1"                                      */
+    AW_AHB_CLK_HDMI,        /* "ahb_hdmi"                                       */
+    AW_AHB_CLK_DEBE0,       /* "ahb_de_image0"                                  */
+    AW_AHB_CLK_DEBE1,       /* "ahb_de_image1"                                  */
+    AW_AHB_CLK_DEFE0,       /* "ahb_de_scale0"                                  */
+    AW_AHB_CLK_DEFE1,       /* "ahb_de_scale1"                                  */
+    AW_AHB_CLK_GMAC,        /* "ahb_gmac" */
+    AW_AHB_CLK_MP,          /* "ahb_de_mix"                                     */
+    AW_AHB_CLK_MALI,        /* "ahb_mali"                                       */
+    AW_AHB_CLK_EHCI1,       /* "ahb_ehci1"                                      */
+    AW_AHB_CLK_OHCI1,       /* "ahb_ohci1"                                      */
+    AW_AHB_CLK_STMR,        /* "ahb_stmr"                                       */
+
+    /* clock gating for hang APB bus */
+    AW_APB_CLK_ADDA,        /* "apb_audio_codec"                                */
+    AW_APB_CLK_SPDIF,       /* "apb_spdif"                                      */
+    AW_APB_CLK_AC97,        /* "apb_ac97"                                       */
+    AW_APB_CLK_I2S0,        /* "apb_i2s0"                                       */
+    AW_APB_CLK_I2S1,        /* "apb_i2s1"                                       */
+    AW_APB_CLK_I2S2,        /* "apb_i2s2"                                       */
+    AW_APB_CLK_PIO,         /* "apb_pio"                                        */
+    AW_APB_CLK_IR0,         /* "apb_ir0"                                        */
+    AW_APB_CLK_IR1,         /* "apb_ir1"                                        */
+    AW_APB_CLK_KEYPAD,      /* "apb_key_pad"                                    */
+    AW_APB_CLK_TWI0,        /* "apb_twi0"                                       */
+    AW_APB_CLK_TWI1,        /* "apb_twi1"                                       */
+    AW_APB_CLK_TWI2,        /* "apb_twi2"                                       */
+    AW_APB_CLK_TWI3,        /* "apb_twi3"                                       */
+    AW_APB_CLK_TWI4,        /* "apb_twi4"                                       */
+    AW_APB_CLK_CAN,         /* "apb_can"                                        */
+    AW_APB_CLK_SCR,         /* "apb_scr"                                        */
+    AW_APB_CLK_PS20,        /* "apb_ps0"                                        */
+    AW_APB_CLK_PS21,        /* "apb_ps1"                                        */
+    AW_APB_CLK_UART0,       /* "apb_uart0"                                      */
+    AW_APB_CLK_UART1,       /* "apb_uart1"                                      */
+    AW_APB_CLK_UART2,       /* "apb_uart2"                                      */
+    AW_APB_CLK_UART3,       /* "apb_uart3"                                      */
+    AW_APB_CLK_UART4,       /* "apb_uart4"                                      */
+    AW_APB_CLK_UART5,       /* "apb_uart5"                                      */
+    AW_APB_CLK_UART6,       /* "apb_uart6"                                      */
+    AW_APB_CLK_UART7,       /* "apb_uart7"                                      */
+
+    /* clock gating for access dram */
+    AW_DRAM_CLK_VE,         /* "sdram_ve"                                       */
+    AW_DRAM_CLK_CSI0,       /* "sdram_csi0"                                     */
+    AW_DRAM_CLK_CSI1,       /* "sdram_csi1"                                     */
+    AW_DRAM_CLK_TS,         /* "sdram_ts"                                       */
+    AW_DRAM_CLK_TVD,        /* "sdram_tvd"                                      */
+    AW_DRAM_CLK_TVE0,       /* "sdram_tve0"                                     */
+    AW_DRAM_CLK_TVE1,       /* "sdram_tve1"                                     */
+    AW_DRAM_CLK_DEFE0,      /* "sdram_de_scale0"                                */
+    AW_DRAM_CLK_DEFE1,      /* "sdram_de_scale1"                                */
+    AW_DRAM_CLK_DEBE0,      /* "sdram_de_image0"                                */
+    AW_DRAM_CLK_DEBE1,      /* "sdram_de_image1"                                */
+    AW_DRAM_CLK_DEMP,       /* "sdram_de_mix"                                   */
+    AW_DRAM_CLK_ACE,        /* "sdram_ace"                                      */
+
+    AW_CCU_CLK_CNT,         /* invalid clock id                                 */
+
+} __aw_ccu_clk_id_e;
+
+
+/*
+ * calculate hash value of a string.
+ *
+ * @string: string
+ *
+ * Return hash value.
+ */
+static inline __s32 ccu_clk_calc_hash(char *string)
+{
+    __s32 tmpLen, i, tmpHash = 0;
+
+    if (!string) {
+        return 0;
+    }
+
+    tmpLen = strlen(string);
+    for (i = 0; i < tmpLen; i++) {
+        tmpHash += string[i];
+    }
+
+    return tmpHash;
+}
+
+static inline __u64 ccu_clk_uldiv(__u64 dividend, __u32 divisior)
+{
+    __u32 rem = 0;
+
+    /* quotient stored in dividend */
+    rem = do_div(dividend, divisior);
+    if (0 != rem)
+        dividend += 1;
+
+    return dividend;
+}
+
+
+extern __ccmu_reg_list_t *aw_ccu_reg;
+
+
+#endif
diff --git a/drivers/clk/sunxi/ccmu.h b/drivers/clk/sunxi/ccmu.h
new file mode 100644
index 0000000..f141ac7
--- /dev/null
+++ b/drivers/clk/sunxi/ccmu.h
@@ -0,0 +1,620 @@
+/*
+ * arch/arm/mach-sun7i/include/mach/ccmu.h
+ * (c) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * James Deng <csjamesdeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __CCMU_REGS_H__
+#define __CCMU_REGS_H__
+
+/*
+ * TODO:
+ *
+ * 1. Update Description of clock register bit.
+ *
+ */
+
+typedef struct ___CCMU_PLL1_CORE_REG0000 {
+    __u32   FactorM: 2;         //bit0,  PLL1 Factor M
+    __u32   SigmaEn: 1;         //bit2,  Sigma-delta pattern enable
+    __u32   SigmaIn: 1;         //bit3,  Sigma-delta pattern input
+    __u32   FactorK: 2;         //bit4,  PLL1 factor K
+    __u32   reserved0: 2;       //bit6,  reserved
+    __u32   FactorN: 5;         //bit8,  PLL1 Factor N
+    __u32   LockTime: 3;        //bit13, PLL1 lock timer control
+    __u32   PLLDivP: 2;         //bit16, PLL1 output external divider P
+    __u32   reserved1: 2;       //bit18, reserved
+    __u32   PLLBias: 5;         //bit20, PLL1 bias current control
+    __u32   ExchangeEn: 1;      //bit25, PLL1 exchange with PLL4 Enable
+    __u32   VCOBias: 4;         //bit26, PLL1 VCO bias control
+    __u32   VCORstIn: 1;        //bit30, VCO reset in
+    __u32   PLLEn: 1;           //bit31, 0-disable, 1-enable, (24Mhz*N*K)/(M*P)
+} __ccmu_pll1_core_reg0000_t;
+
+typedef struct __CCMU_PLL2_AUDIO_REG0008 {
+    __u32   PrevDiv: 5;         //bit0,  PLL2 prev division
+    __u32   reserved0: 3;       //bit5,  reserved
+    __u32   FactorN: 7;         //bit8,  PLL2 factor N
+    __u32   reserved1: 1;       //bit15, reserved
+    __u32   PLLBias: 5;         //bit16, PLL2 bias current
+    __u32   VcoBias: 5;         //bit21, PLL2 VCO bias current
+    __u32   PostDiv: 4;         //bit26, PLL2 post division
+    __u32   reserved2: 1;       //bit30, reserved
+    __u32   PLLEn: 1;           //bit31, PLL2 enable
+} __ccmu_pll2_audio_reg0008_t;
+
+typedef struct __CCMU_PLL3_VIDEO_REG0010 {
+    __u32   FactorM: 7;         //bit0,  PLL3 FactorM, 9<= M <=127
+    __u32   reserved0: 1;       //bit7,  reserved
+    __u32   PLLBias: 5;         //bit8,  PLL3 bias control
+    __u32   reserved1: 1;       //bit13, reserved
+    __u32   FracSet: 1;         //bit14, PLL3 fractional setting, 0-270Mhz, 1-297Mhz
+    __u32   ModeSel: 1;         //bit15, PLL3 mode select
+    __u32   VCOBias: 5;         //bit16, PLL3 VCO Bias control
+    __u32   reserved2: 3;       //bit21, reserved
+    __u32   DampFactor: 3;      //bit24, PLL3 damping factor controlf
+    __u32   reserved3: 4;       //bit27, reserved
+    __u32   PLLEn: 1;           //bit31, PLL3 enable
+} __ccmu_pll3_video_reg0010_t;
+
+typedef struct __CCMU_PLL4_VE_REG0018 {
+    __u32   FactorM: 2;         //bit0,  PLL4 factor M
+    __u32   reserved0: 2;       //bit2,  reserved
+    __u32   FactorK: 2;         //bit4,  PLL4 factor K
+    __u32   DampFactor: 2;      //bit6,  PLL4 damping factor control
+    __u32   FactorN: 5;         //bit8,  PLL4 factor N
+    __u32   reserved1: 2;       //bit13, reserved
+    __u32   BandWidth: 1;       //bit15, PLL4 band width control
+    __u32   reserved2: 4;       //bit16, reserved
+    __u32   PLLBias: 5;         //bit20, PLL4 Bias control
+    __u32   VCOBias: 5;         //bit25, PLL4 VCO bias control
+    __u32   PLLBypass: 1;       //bit30, PLL4 output bypass enable
+    __u32   PLLEn: 1;           //bit31, PLL4 Enable, 24MHz*N*K
+} __ccmu_pll4_ve_reg0018_t;
+
+typedef struct __CCMU_PLL5_DDR_REG0020 {
+    __u32   FactorM: 2;         //bit0,  PLL5 factor M
+    __u32   FactorM1: 2;        //bit3,  PLL5 factor M1
+    __u32   FactorK: 2;         //bit4,  PLL5 factor K
+    __u32   reserved0: 1;       //bit6,  reserved
+    __u32   LDO2En: 1;          //bit7,  LDO2 enable
+    __u32   FactorN: 5;         //bit8,  PLL5 factor N
+    __u32   VCOGain: 3;         //bit13, PLL5 VCO gain control
+    __u32   FactorP: 2;         //bit16, PLL5 output external divider P
+    __u32   BandWidth: 1;       //bit18, PLL5 band width control, 0-narrow, 1-wide
+    __u32   VCOGainEn: 1;       //bit19, PLL5 VCO gain control enable
+    __u32   PLLBias: 5;         //bit20, PLL5 bias current control
+    __u32   VCOBias: 4;         //bit25, PLL5 VCO bias
+    __u32   OutputEn: 1;        //bit29, DDR clock output enable
+    __u32   PLLBypass: 1;       //bit30, PLL5 output bypass enable
+    __u32   PLLEn: 1;           //bit31, PLL5 Enable
+} __ccmu_pll5_ddr_reg0020_t;
+
+typedef struct __CCMU_PLL6_SATA_REG0028 {
+    __u32   FactorM: 2;         //bit0,  PLL6 factor M
+    __u32   reserved0: 2;       //bit2,  reserved
+    __u32   FactorK: 2;         //bit4,  PLL6 factor K
+    __u32   DampFactor: 2;      //bit6,  PLL6 damping factor control
+    __u32   FactorN: 5;         //bit8,  PLL6 factor N
+    __u32   reserved1: 1;       //bit13, reserved
+    __u32   OutputEn: 1;        //bit14, sata clock output enable
+    __u32   BandWidth: 1;       //bit15, PLL6 band width control
+    __u32   reserved2: 4;       //bit16, reserved
+    __u32   PLLBias: 5;         //bit20, PLL6 bias current control
+    __u32   VCOBias: 5;         //bit25, PLL6 VCO bias
+    __u32   PLLBypass: 1;       //bit30, PLL6 output bypass enable
+    __u32   PLLEn: 1;           //bit31, PLL6 enable
+} __ccmu_pll6_sata_reg0028_t;
+
+typedef struct __CCMU_PLL7_VIDEO1_REG0030 {
+    __u32   FactorM: 7;         //bit0,  PLL7 factor M
+    __u32   reserved0: 1;       //bit7,  reserved
+    __u32   PLLBias: 5;         //bit8,  PLL7 bias control
+    __u32   reserved1: 1;       //bit13, reserved
+    __u32   FracSet: 1;         //bit14, PLL7 fractional setting, 0-270Mhz, 1-297Mhz
+    __u32   ModeSel: 1;         //bit15, PLL7 mode select, 0-integer, 1-fractional
+    __u32   VCOBias: 5;         //bit16, PLL7 bias control
+    __u32   reserved2: 3;       //bit21, reserved
+    __u32   DampFactor: 3;      //bit24, PLL7 damping factor control
+    __u32   reserved3: 4;       //bit27, reserved
+    __u32   PLLEn: 1;           //bit31, PLL7 enable
+} __ccmu_pll7_video1_reg0030_t;
+
+typedef struct __CCMU_PLL8_GPU_REG0040 {
+    __u32   FactorM: 2;         //bit0,  PLL8 factor M
+    __u32   reserved0: 2;       //bit2,  reserved
+    __u32   FactorK: 2;         //bit4,  PLL8 factor K
+    __u32   DampFactor: 2;      //bit6,  PLL8 damping factor control
+    __u32   FactorN: 5;         //bit8,  PLL8 factor N
+    __u32   reserved1: 2;       //bit13, reserved
+    __u32   BandWidth: 1;       //bit15, PLL8 band width control
+    __u32   reserved2: 4;       //bit16, reserved
+    __u32   PLLBias: 5;         //bit20, PLL8 bias current control
+    __u32   VCOBias: 5;         //bit25, PLL8 VCO bias
+    __u32   PLLBypass: 1;       //bit30, PLL8 output bypass enable
+    __u32   PLLEn: 1;           //bit31, PLL8 enable
+} __ccmu_pll8_gpu_reg0040_t;
+
+/*
+ * TODO - Check again.
+ */
+typedef struct __CCMU_OSC24M_REG0050 {
+    __u32   OSC24MEn: 1;        //bit0,  OSC24M enable
+    __u32   OSC24MGsm: 1;       //bit1,  OSC24M GSM
+    __u32   reserved0: 13;      //bit2,  reserved
+    __u32   PLLBiasEn: 1;       //bit15, PLL bias enable
+    __u32   LDOEn: 1;           //bit16, LDO enable
+    __u32   PLLInPower: 1;      //bit17, PLL intput power select, 0-2.5v, 1-3.3v
+    __u32   LDOOutput: 3;       //bit18, LDO output control, 100-1.25v for ex.
+    __u32   reserved1: 3;       //bit21, reserved
+    __u32   KeyField: 8;        //bit24, key field for LDO enable, 0xa7, bit24~bit31 is valid
+} __ccmu_osc24m_reg0050_t;
+
+typedef struct __CCMU_SYSCLK_RATIO_REG0054 {
+    __u32   AXIClkDiv: 2;       //bit0,  AXI clock divide ratio, 00-1, 01-2, 10-3, 11-4
+    __u32   reserved0: 2;       //bit2,  reserved
+    __u32   AHBClkDiv: 2;       //bit4,  AHB clock divide ration, 00-1, 01-2, 10-4, 11-8
+    __u32   AHBClkSrc: 2;       //bit6,  AHB clock source select
+    __u32   APB0ClkDiv: 2;      //bit8,  APB0 clock divide ratio, APB0 clock source is AHB, 00-2, 01-2, 10-4, 11-8
+    __u32   reserved1: 1;       //bit10, reserved
+    __u32   AtbApbClkDiv: 2;    //bit11, ATB/APB clock div, 00-1, 01-2, 1x-4
+    __u32   reserved2: 3;       //bit13, reserved
+    __u32   AC327ClkSrc: 2;     //bit16, CPU1/2 clock source select, 00-internal LOSC, 01-HOSC, 10-PLL1, 11-200MHz
+    __u32   reserved3: 13;      //bit18, reserved
+    __u32   DVFSStart: 1;       //bit31, DVFS start
+} __ccmu_sysclkl_ratio_reg0054_t;
+
+typedef struct __CCMU_APB1CLK_RATIO_REG0058 {
+    __u32   ClkDiv: 5;          //bit0,  clock divide ratio, diveded by (m+1), 1~32 ex.
+    __u32   reserved0: 11;      //bit5,  reserved
+    __u32   PreDiv: 2;          //bit16, clock pre-divide ratio, pre-devided by 2^, 1/2/4/8 ex.
+    __u32   reserved1: 6;       //bit18, reserved
+    __u32   ClkSrc: 2;          //bit24, clock source select, 00-HOSC, 01-PLL6, 10-LOSC, 11-reserved
+    __u32   reserved2: 6;       //bit26, reserved
+} __ccmu_apb1clk_ratio_reg0058_t;
+
+typedef struct __CCMU_AHBCLK_GATE0_REG0060 {
+    __u32   Usb0Gate: 1;        //bit0,  gating AHB clock for USB0, 0-mask, 1-pass
+    __u32   Ehci0Gate: 1;       //bit1,  gating AHB clock for EHCI0, 0-mask, 1-pass
+    __u32   Ohci0Gate: 1;       //bit2,  gating AHB clock for OHCI0, 0-mask, 1-pass
+    __u32   Ehci1Gate: 1;       //bit3,  gating AHB clock for EHCI1, 0-mask, 1-pass
+    __u32   Ohci1Gate: 1;       //bit4,  gating AHB clock for OHCI1, 0-mask, 1-pass
+    __u32   SsGate: 1;          //bit5,  gating AHB clock for SS, 0-mask, 1-pass
+    __u32   DmaGate: 1;         //bit6,  gating AHB clock for DMA, 0-mask, 1-pass
+    __u32   BistGate: 1;        //bit7,  gating AHB clock for BIST, 0-mask, 1-pass
+    __u32   Sdmmc0Gate: 1;      //bit8,  gating AHB clock for SD/MMC0, 0-mask, 1-pass
+    __u32   Sdmmc1Gate: 1;      //bit9,  gating AHB clock for SD/MMC1, 0-mask, 1-pass
+    __u32   Sdmmc2Gate: 1;      //bit10, gating AHB clock for SD/MMC2, 0-mask, 1-pass
+    __u32   Sdmmc3Gate: 1;      //bit11, gating AHB clock for SD/MMC3, 0-mask, 1-pass
+    __u32   MsGate: 1;          //bit12, gating AHB clock for MS, 0-mask, 1-pass
+    __u32   NandGate: 1;        //bit13, gating AHB clock for NAND, 0-mask, 1-pass
+    __u32   SdramGate: 1;       //bit14, gating AHB clock for SDRAM, 0-mask, 1-pass
+    __u32   reserved0: 1;       //bit15, reserved
+    __u32   AceGate: 1;         //bit16, gating AHB clock for ACE, 0-mask, 1-pass
+    __u32   EmacGate: 1;        //bit17, gating AHB clock for EMAC, 0-mask, 1-pass
+    __u32   TsGate: 1;          //bit18, gating AHB clock for TS, 0-mask, 1-pass
+    __u32   reserved1: 1;       //bit19, reserved
+    __u32   Spi0Gate: 1;        //bit20, gating AHB clock for SPI0, 0-mask, 1-pass
+    __u32   Spi1Gate: 1;        //bit21, gating AHB clock for SPI1, 0-mask, 1-pass
+    __u32   Spi2Gate: 1;        //bit22, gating AHB clock for SPI2, 0-mask, 1-pass
+    __u32   Spi3Gate: 1;        //bit23, gating AHB clock for SPI3, 0-mask, 1-pass
+    __u32   reserved2: 1;       //bit24, reserved
+    __u32   SataGate: 1;        //bit25, gating AHB clock for SATA, 0-mask, 1-pass
+    __u32   reserved3: 2;       //bit26, reserved
+    __u32   StmrGate: 1;        //bit28, gating AHB clock for Sync timer
+    __u32   reserved4: 3;       //bit29, reserved
+} __ccmu_ahbclk_gate0_reg0060_t;
+
+typedef struct __CCMU_AHBCLK_GATE1_REG0064 {
+    __u32   VeGate: 1;          //bit0,  gating AHB clock for VE, 0-mask, 1-pass
+    __u32   TvdGate: 1;         //bit1,  gating AHB clock for TVD, 0-mask, 1-pass
+    __u32   Tve0Gate: 1;        //bit2,  gating AHB clock for TVE0, 0-mask, 1-pass
+    __u32   Tve1Gate: 1;        //bit3,  gating AHB clock for TVE1, 0-mask, 1-pass
+    __u32   Lcd0Gate: 1;        //bit4,  gating AHB clock for LCD0, 0-mask, 1-pass
+    __u32   Lcd1Gate: 1;        //bit5,  gating AHB clock for LCD1, 0-mask, 1-pass
+    __u32   reserved0: 2;       //bit6,  reserved
+    __u32   Csi0Gate: 1;        //bit8,  gating AHB clock for CSI0, 0-mask, 1-pass
+    __u32   Csi1Gate: 1;        //bit9,  gating AHB clock for CSI1, 0-mask, 1-pass
+    __u32   Hdmi1Gate: 1;       //bit10, gating AHB clock for HDMI1
+    __u32   HdmiDGate: 1;       //bit11, gating AHB clock for HDMI, 0-mask, 1-pass
+    __u32   DeBe0Gate: 1;       //bit12, gating AHB clock for DE-BE0, 0-mask, 1-pass
+    __u32   DeBe1Gate: 1;       //bit13, gating AHB clock for DE-BE1, 0-mask, 1-pass
+    __u32   DeFe0Gate: 1;       //bit14, gating AHB clock for DE-FE0, 0-mask, 1-pass
+    __u32   DeFe1Gate: 1;       //bit15, gating AHB clock for DE-FE1, 0-mask, 1-pass
+    __u32   reserved1: 1;       //bit16, reserved
+    __u32   GmacGate: 1;        //bit17, gating AHB clock for GMAC, 0-mask, 1:pass
+    __u32   MpGate: 1;          //bit18, gating AHB clock for MP, 0-mask, 1-pass
+    __u32   reserved2: 1;       //bit19, reserved
+    __u32   Gpu3DGate: 1;       //bit20, gating AHB clock for GPU-3D, 0-mask, 1-pass
+    __u32   reserved3: 11;      //bit21, reserved
+} __ccmu_ahbclk_gate1_reg0064_t;
+
+typedef struct __CCMU_APB0CLK_GATE_REG0068 {
+    __u32   AddaGate: 1;        //bit0,  gating APB clock for audio codec, 0-mask, 1-pass
+    __u32   SpdifGate: 1;       //bit1,  gating APB clock for SPDIF, 0-mask, 1-pass
+    __u32   Ac97Gate: 1;        //bit2,  gating APB clock for AC97, 0-mask, 1-pass
+    __u32   Iis0Gate: 1;        //bit3,  gating APB clock for IIS0, 0-mask, 1-pass
+    __u32   Iis1Gate: 1;        //bit4,  gating APB clock for IIS1, 0-mask, 1-pass
+    __u32   PioGate: 1;         //bit5,  gating APB clock for PIO, 0-mask, 1-pass
+    __u32   Ir0Gate: 1;         //bit6,  gating APB clock for IR0, 0-mask, 1-pass
+    __u32   Ir1Gate: 1;         //bit7,  gating APB clock for IR1, 0-mask, 1-pass
+    __u32   Iis2Gate: 1;        //bit8,  gating APB clock for IIS2, 0-mask, 1-pass
+    __u32   reserved0: 1;       //bit9,  reserved
+    __u32   KeypadGate: 1;      //bit10, gating APB clock for keypad, 0-mask, 1-pass
+    __u32   reserved1: 21;      //bit11, reserved
+} __ccmu_apb0clk_gate_reg0068_t;
+
+typedef struct __CCMU_APB1CLK_GATE_REG006C {
+    __u32   Twi0Gate: 1;        //bit0,  gating APB clock for TWI0, 0-mask, 1-pass
+    __u32   Twi1Gate: 1;        //bit1,  gating APB clock for TWI1, 0-mask, 1-pass
+    __u32   Twi2Gate: 1;        //bit2,  gating APB clock for TWI2, 0-mask, 1-pass
+    __u32   Twi3Gate: 1;        //bit3,  gating APB clock for TWI3, 0-mask, 1-pass
+    __u32   CanGate: 1;         //bit4,  gating APB clock for CAN, 0-mask, 1-pass
+    __u32   ScrGate: 1;         //bit5,  gating APB clock for SCR, 0-mask, 1-pass
+    __u32   Ps20Gate: 1;        //bit6,  gating APB clock for PS2-0, 0-mask, 1-pass
+    __u32   Ps21Gate: 1;        //bit7,  gating APB clock for PS2-1, 0-mask, 1-pass
+    __u32   reserved0: 7;       //bit8,  reserved
+    __u32   Twi4Gate: 1;        //bit15, gating AHB clock for TWI4, 0-mask, 1-pass
+    __u32   Uart0Gate: 1;       //bit16, gating APB clock for UART0, 0-mask, 1-pass
+    __u32   Uart1Gate: 1;       //bit17, gating APB clock for UART1, 0-mask, 1-pass
+    __u32   Uart2Gate: 1;       //bit18, gating APB clock for UART2, 0-mask, 1-pass
+    __u32   Uart3Gate: 1;       //bit19, gating APB clock for UART3, 0-mask, 1-pass
+    __u32   Uart4Gate: 1;       //bit20, gating APB clock for UART4, 0-mask, 1-pass
+    __u32   Uart5Gate: 1;       //bit21, gating APB clock for UART5, 0-mask, 1-pass
+    __u32   Uart6Gate: 1;       //bit22, gating APB clock for UART6, 0-mask, 1-pass
+    __u32   Uart7Gate: 1;       //bit23, gating APB clock for UART7, 0-mask, 1-pass
+    __u32   reserved1: 8;       //bit24, reserved
+} __ccmu_apb1clk_gate_reg006c_t;
+
+/* module clock type 0, used for NAND, MS, SDMMC0/1/2/3, TS, SS, SPI0/1/2/3, PATA, IR0/1, */
+/* register address is 0x0080~0x00B4, 0x00D4 */
+typedef struct __CCMU_MODULE0_CLK {
+    __u32   ClkDiv: 4;          //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0: 4;       //bit4,  reserved
+    __u32   OutClkPhase: 3;     //bit8,  Just for SDMMC0/1/2/3, Output Clock Phase Control
+    __u32   reserved1: 5;       //bit11, reserved
+    __u32   ClkPreDiv: 2;       //bit16, clock pre-divide ratio, predivided by 2^n , 1/2/4/8 ex.
+    __u32   reserved2: 2;       //bit18, reserved
+    __u32   SampleClkPhase: 3;  //bit20, Just for SDMMC0/1/2/3, Sample Clock Phase Control.
+    __u32   reserved3: 1;       //bit23, reserved
+    __u32   ClkSrc: 2;          //bit24, clock source select, 00-HOSC, 01-PLL6, 10-PLL5, 11-reserved(LOSC,just for IR0/1)
+    __u32   reserved4: 5;       //bit26, reserved
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_module0_clk_t;
+
+/* module clock type 1, used for IIS, AC97, SPDIF*/
+/* register address is 0x00B8~0x00C0 */
+typedef struct __CCMU_MODULE1_CLK {
+    __u32   reserved0: 16;      //bit0,  reserved
+    __u32   ClkDiv: 2;          //bit16, clock pre-divide ratio, predivided by 2^n , 1/2/4/8 ex. source is 8xPLL2
+    __u32   reserved1: 13;      //bit18, reserved
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_module1_clk_t;
+
+typedef struct __CCMU_KEYPAD_CLK_REG00C4 {
+    __u32   ClkDiv: 5;          //bit0,  clock divide ratio
+    __u32   reserved0: 11;      //bit5,  reserved
+    __u32   ClkPreDiv: 2;       //bit16, clock pre-divide ratio, pre-divided by 2^n, 1/2/4/8 ex.
+    __u32   reserved1: 6;       //bit18, reserved
+    __u32   ClkSrc: 2;          //bit24, clock select, 00-HOSC, 01-reserved, 10-LOSC, 11-reserved
+    __u32   reserved2: 5;       //bit26, reserved
+    __u32   SpecClkGate: 1;     //bit31, gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_keypad_clk_reg00c4_t;
+
+typedef struct __CCMU_SATA_CLK_REG00C8 {
+    __u32   reserved0: 24;      //bit0,  reserved
+    __u32   ClkSrc: 1;          //bit24, Clock source select, 0-PLL6, 1-External clock
+    __u32   reserved1: 6;       //bit25, reserved
+    __u32   SpecClkGate: 1;     //bit31, gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_sata_clk_reg00c8_t;
+
+typedef struct __CCMU_USB_CLK_REG00CC {
+    __u32   UsbPhy0Rst: 1;      //bit0,  USB PHY0 reset control, 0-reset valid, 1-reset invalid
+    __u32   UsbPhy1Rst: 1;      //bit1,  USB PHY1 reset control, 0-reset valid, 1-reset invalid
+    __u32   UsbPhy2Rst: 1;      //bit2,  USB PHY2 reset control, 0-reset valid, 1-reset invalid
+    __u32   reserved0: 3;       //bit3,  reserved
+    __u32   OHCI0SpecClkGate: 1; //bit6,  gating special clock for OHCI0, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   OHCI1SpecClkGate: 1; //bit7,  gating special clock for OHCI1, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   PhySpecClkGate: 1;  //bit8,  gating special clock for USB PHY0/1/2, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   reserved2: 23;      //bit9,  reserved
+} __ccmu_usb_clk_reg00cc_t;
+
+/* REMOVED */
+//typedef struct __CCMU_GPS_CLK_REG00D0 {
+//    __u32   ClkDivRatio: 3;     //bit0,  clock divide ratio(m)
+//    __u32   reserved0: 21;      //bit3,  reserved
+//    __u32   ClkSrc: 2;          //bit24, GPU Clock Source Select: 00-osc24M, 01-PLL6, 10-PLL7, 11-PLL4.
+//    __u32   reserved1: 4;       //bit26, reserved
+//    __u32   Reset: 1;           //bit30, GPS reset control
+//    __u32   SpecClkGate: 1;     //bit31, gating special clock for GPS, 0-CLK OFF, 1-CLK ON
+//} __ccmu_gps_clk_reg00d0_t;
+
+typedef struct __CCMU_DRAM_GATE_REG0100 {
+    __u32   VeGate: 1;          //bit0,  Gating dram clock for VE, 0-mask, 1-pass
+    __u32   Csi0Gate: 1;        //bit1,  Gating dram clock for CSI0, 0-mask, 1-pass
+    __u32   Csi1Gate: 1;        //bit2,  Gating dram clock for CSI1, 0-mask, 1-pass
+    __u32   TsGate: 1;          //bit3,  Gating dram clock for TS, 0-mask, 1-pass
+    __u32   TvdGate: 1;         //bit4,  Gating dram clock for TVD, 0-mask, 1-pass
+    __u32   Tve0Gate: 1;        //bit5,  Gating dram clock for TVE0, 0-mask, 1-pass
+    __u32   Tve1Gate: 1;        //bit6,  Gating dram clock for TVE1, 0-mask, 1-pass
+    __u32   reserved0: 8;       //bit7,  reserved
+    __u32   ClkOutputEn: 1;     //bit15, DRAM clock output enable, 0-disable, 1-enable
+    __u32   reserved1: 8;       //bit16, reserved
+    __u32   DeFe1Gate: 1;       //bit24, Gating dram clock for DE_FE1, 0-mask, 1-pass
+    __u32   DeFe0Gate: 1;       //bit25, Gating dram clock for DE_FE0, 0-mask, 1-pass
+    __u32   DeBe0Gate: 1;       //bit26, Gating dram clock for DE_BE0, 0-mask, 1-pass
+    __u32   DeBe1Gate: 1;       //bit27, Gating dram clock for DE_BE1, 0-mask, 1-pass
+    __u32   DeMpGate: 1;        //bit28, Gating dram clock for DE_MP, 0-mask, 1-pass
+    __u32   AceGate: 1;         //bit29, Gating dram clock for ACE, 0-mask, 1-pass
+    __u32   reserved2: 2;       //bit30, reserved
+} __ccmu_dram_gate_reg0100_t;
+
+/* FEBEMP module clock type, used for DE-BE0, DE-BE1, DE-FE0, DE-FE1, DE-MP */
+/* register address is 0x0104~0x0114 */
+typedef struct __CCMU_FEDEMP_CLK {
+    __u32   ClkDiv: 4;          //bit0,  clock divide ratio, divied by (m+1), 1~16 ex.
+    __u32   reserved0: 20;      //bit4,  reserved
+    __u32   ClkSrc: 2;          //bit24, clock source select, 00-PLL3, 01-PLL7, 10-PLL5, 11-reserved
+    __u32   reserved1: 4;       //bit26, reserved
+    __u32   Reset: 1;           //bit30, module reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate: 1;     //bit31, gating special clock, 0-clock off, 1-clock on
+} __ccmu_fedemp_clk_t;
+
+/* LCDCH0 module clock type, used for LCD0_CH0, LCD1_CH0 */
+/* register address is 0x0118~0x011C */
+typedef struct __CCMU_LCDCH0_CLK {
+    __u32   reserved0: 24;      //bit0,  reserved
+    __u32   ClkSrc: 2;          //bit24, clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)(PLL6*2 Just for LCD0_CH0)
+    __u32   reserved1: 4;       //bit26, reserved
+    __u32   Reset: 1;           //bit30, module reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate: 1;     //bit31, gating special clock, 0-clock off, 1-clock on
+} __ccmu_lcdch0_clk_t;
+
+typedef struct __CCMU_CSIISP_CLK_REG0120 {
+    __u32   ClkDiv: 4;          //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0: 20;      //bit4,  reserved
+    __u32   ClkSrc: 2;          //bit24, special clock2 source select, 00-PLL3(1x), 01-PLL4, 10-PLL5, 11-PLL6
+    __u32   reserved1: 5;       //bit26, reserved
+    __u32   SpecClkGate: 1;     //bit31, gating special clock, 0-clock off, 1-clock on
+} __ccmu_csiisp_clk_reg0120_t;
+
+typedef struct __CCMU_TVD_CLK_REG0128 {
+    __u32   Clk1Div: 4;         //bit0, Clock divide ratio1(M)
+    __u32   reserved0: 4;       //bit4, reserved
+    __u32   Clk1Src: 1;         //bit8, clock1 source select, 0-PLL3, 1-PLL7
+    __u32   reserved1: 6;       //bit9, reserved
+    __u32   Clk1Gate: 1;        //bit15, gating special clock, 0-clock off, 1-clock on
+    __u32   Clk2Div: 4;         //bit16, Clock divide ratio2(M)
+    __u32   reserved2: 4;       //bit20, reserved
+    __u32   Clk2Src: 1;         //bit24, clock2 source select, 0-PLL3, 1-PLL7
+    __u32   reserved3: 6;       //bit25, reserved
+    __u32   Clk2Gate: 1;        //bit31, gating special clock, 0-clock off, 1-clock on
+} __ccmu_tvd_clk_reg0128_t;
+
+/* LCD-CH1 module clock type, used for LCD0_CH1, LCD1_CH1 */
+/* register address is 0x012C~0x0130 */
+typedef struct __CCMU_LCDCH1_CLK {
+    __u32   ClkDiv: 4;          //bit0,  clock division
+    __u32   reserved0: 7;       //bit4,  reserved
+    __u32   SpecClk1Src: 1;     //bit11, special clock 1 source select, 0-special clock2,
+    __u32   reserved1: 3;       //bit12, reserved
+    __u32   SpecClk1Gate: 1;    //bit15, gating special clock1, 0-clock off, 1-clock on
+    __u32   reserved2: 8;       //bit16, reserved
+    __u32   SpecClk2Src: 2;     //bit24, clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)
+    __u32   reserved3: 5;       //bit26, reserved
+    __u32   SpecClk2Gate: 1;    //bit31, gating special clock2, 0-clock off, 1-clock on
+} __ccmu_lcdch1_clk_t;
+
+/* CSI module clock type, used for CSI0/1 */
+/* register address is 0x0134~0x0138 */
+typedef struct __CCMU_CSI_CLK {
+    __u32   ClkDiv: 5;          //bit0,  clock divide ratio, divided by (m+1), 1~32, ex.
+    __u32   reserved0: 19;      //bit5,  reserved
+    __u32   ClkSrc: 3;          //bit24, clock source select, 000-HOSC, 001-PLL3(1x), 010-PLL7(1x), 011/100/111-reserved, 101-PLL3(2x), 110:PLL7(2x)
+    __u32   reserved1: 3;       //bit27, reserved
+    __u32   Reset: 1;           //bit30, CSI reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_csi_clk_t;
+
+typedef struct __CCMU_VE_CLK_REG013C {
+    __u32   Reset: 1;           //bit0,  VE reset, 0-reset valid, 1-reset invalid
+    __u32   reserved0: 15;      //bit1,  reserved
+    __u32   ClkDiv: 3;          //bit16, Clock pre-divide ratio, divided by (n+1), 1~8 ex.
+    __u32   reserved1: 12;      //bit19, reserved
+    __u32   SpecClkGate: 1;     //bit31, gating special clock for VE, 0-mask, 1-pass
+} __ccmu_ve_clk_reg013c_t;
+
+typedef struct __CCMU_ADDA_CLK_REG0140 {
+    __u32   reserved0: 31;      //bit0,  reserved
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_adda_clk_reg0140_t;
+
+typedef struct __CCMU_AVS_CLK_REG0144 {
+    __u32   reserved0: 31;      //bit0,  reserved
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_avs_clk_reg0144_t;
+
+typedef struct __CCMU_ACE_CLK_REG0148 {
+    __u32   ClkDiv: 4;          //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0: 12;      //bit4,  reserved
+    __u32   Reset: 1;           //bit16, ACE reset, 0-reset valid, 1-reset invalid
+    __u32   reserved1: 7;       //bit17, reserved
+    __u32   ClkSrc: 1;          //bit24, Clock source select, 0-PLL4, 1-PLL5
+    __u32   reserved2: 6;       //bit25, reserved
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_ace_clk_reg0148_t;
+
+typedef struct __CCMU_LVDS_CLK_REG014C {
+    __u32   Reset: 1;           //bit0,  LVDS reset
+    __u32   reserved0: 31;      //bit1,  reserved
+} __ccmu_lvds_clk_reg014c_t;
+
+typedef struct __CCMU_HDMI_CLK_REG0150 {
+    __u32   ClkDiv: 4;          //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0: 20;      //bit4,  reserved
+    __u32   ClkSrc: 2;          //bit24, clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)
+    __u32   reserved1: 5;       //bit26, reserved
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_hdmi_clk_reg0150_t;
+
+typedef struct __CCMU_MALI400_CLK_REG0154 {
+    __u32   ClkDiv: 4;          //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0: 20;      //bit4,  reserved
+    __u32   ClkSrc: 3;          //bit24, clolck source select, 000-PLL3, 001-PLL4, 010-PLL5, 011-PLL7, 100-pll8, 101~111-reserved
+    __u32   reserved1: 3;       //bit27, reserved
+    __u32   Reset: 1;           //bit30, Mali400 reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_mali400_clk_reg0154_t;
+
+typedef struct __CCMU_MBUS_CLK_REG015C {
+    __u32   ClkDivM: 4;         //bit0,  clock divide ratioM
+    __u32   reserved0: 12;      //bit4,  reserved
+    __u32   ClkDivN: 2;         //bit16, clock pre-divide ratio, pre-divided by 2^n, 1/2/4/8 ex.
+    __u32   reserved1: 6;       //bit18, reserved
+    __u32   ClkSrc: 2;          //bit24, clock select, 00-HOSC, 01-PLL6*2, 10-PLL5, 11-reserved
+    __u32   reserved2: 5;       //bit26, reserved
+    __u32   ClkGate: 1;         //bit31, gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_mbus_clk_reg015c_t;
+
+typedef struct __CCMU_GMAC_CLK_REG0164 {
+    __u32   TxClkSrc: 2;        //bit0,  GMAC Transmit Clock Source
+    __u32   PhyIT: 1;           //bit2,  GMAC Phy Interface Type
+    __u32   TxClkInv: 1;        //bit3,  Enable GMAC Transmit Clock Invertor, 0-Disable, 1-Enable
+    __u32   RxClkInv: 1;        //bit4,  Enable GMAC Receive Clock Invertor
+    __u32   RxDlyChain: 3;      //bit5,  Configure GMAC Receive Clock Delay Chain
+    __u32   ClkDiv: 2;          //bit8,  Clock pre-divide ratio(n)
+    __u32   reserved0: 22;      //bit10, reserved
+} __ccmu_gmac_clk_reg0164_t;
+
+typedef struct __CCMU_HDMI1_RST_REG0170 {
+    __u32   hrst: 1;            //bit0,  hreset
+    __u32   sysrst: 1;          //bit1,  HDMI1 system reset
+    __u32   AudioDmaRst: 1;     //bit2,  Audio dma reset
+    __u32   reserved0: 29;      //bit3,  reserved
+} __ccmu_hdmi1_rst_reg0170_t;
+
+typedef struct __CCMU_HDMI1_CTL_REG0174 {
+    __u32   ctl;                //bit0,  HDMI1 System Control Register
+} __ccmu_hdmi1_ctl_reg0174_t;
+
+typedef struct __CCMU_HDMI1_SHW_CLK_REG0178 {
+    __u32   reserved0: 31;      //bit0,  reserved
+    __u32   ClkEn: 1;           //bit31, Clock Output Enable
+} __ccmu_hdmi1_shw_clk_reg0178_t;
+
+typedef struct __CCMU_HDMI1_RPT_CLK_REG017C {
+    __u32   ClkDiv: 4;          //bit0,  Clock divide ratio(m)
+    __u32   reserved0: 20;      //bit4,  reserved
+    __u32   ClkSrc: 2;          //bit24, Clock Source Select
+    __u32   reserved1: 5;       //bit26, reserved
+    __u32   ClkEn: 1;           //bit31, Clock Output Enable
+} __ccmu_hdmi1_rpt_clk_reg017c_t;
+
+/* Clock output, used for clock outA/clock outB */
+/* register address is 0x01F0, 0x01F4 */
+typedef struct __CCMU_CLKOUT {
+    __u32   reserved0: 8;       //bit0,  reserved
+    __u32   ClkDivM: 5;         //bit8,  clock output divide Factor M (1~31)
+    __u32   reserved1: 7;       //bit13, reserved
+    __u32   ClkDivN: 2;         //bit20, Clock Output Divede FactorN, pre-divided by 2^n, 1/2/4/8 ex.
+    __u32   reserved2: 2;       //bit22, reserved
+    __u32   ClkSrc: 2;          //bit24, clock select, 00-HOSC/750=32K, 01-Ext.Losc(32768), 10-HOSC, 11-reserved
+    __u32   reserved3: 5;       //bit26, reserved
+    __u32   ClkEn: 1;           //bit31, Clock Output Enable, 0-Disable, 1-Enable
+} __ccmu_clkout_t;
+
+typedef struct __CCMU_REG_LIST {
+    volatile __ccmu_pll1_core_reg0000_t     Pll1Ctl;    //0x0000, PLL1 control
+    volatile __u32                          reserved0;  //0x0004, reserved
+    volatile __ccmu_pll2_audio_reg0008_t    Pll2Ctl;    //0x0008, PLL2 control
+    volatile __u32                          reserved1;  //0x000C, reserved
+    volatile __ccmu_pll3_video_reg0010_t    Pll3Ctl;    //0x0010, PLL3 control
+    volatile __u32                          reserved2;  //0x0014, reserved
+    volatile __ccmu_pll4_ve_reg0018_t       Pll4Ctl;    //0x0018, PLL4 control
+    volatile __u32                          reserved3;  //0x001C, reserved
+    volatile __ccmu_pll5_ddr_reg0020_t      Pll5Ctl;    //0x0020, PLL5 control
+    volatile __u32                          reserved4;  //0x0024, reserved
+    volatile __ccmu_pll6_sata_reg0028_t     Pll6Ctl;    //0x0028, PLL6 control
+    volatile __u32                          reserved5;  //0x002C, reserved
+    volatile __ccmu_pll7_video1_reg0030_t   Pll7Ctl;    //0x0030, Pll7 control
+    volatile __u32                          reserved6[3];   //0x0034, reserved
+    volatile __ccmu_pll8_gpu_reg0040_t      Pll8Ctl;    //0x0040, pll8 control
+    volatile __u32                          reserved7[3];   //0x0044, reserved
+    volatile __ccmu_osc24m_reg0050_t        HoscCtl;    //0x0050, OSC24M control
+    volatile __ccmu_sysclkl_ratio_reg0054_t SysClkDiv;  //0x0054, AC328/AHB/APB0 divide ratio
+    volatile __ccmu_apb1clk_ratio_reg0058_t Apb1ClkDiv; //0x0058, APB1 clock dividor
+    volatile __u32                          reserved8;  //0x005C, reserved
+    volatile __ccmu_ahbclk_gate0_reg0060_t  AhbGate0;   //0x0060, AHB module clock gating 0
+    volatile __ccmu_ahbclk_gate1_reg0064_t  AhbGate1;   //0x0064, AHB module clock gating 1
+    volatile __ccmu_apb0clk_gate_reg0068_t  Apb0Gate;   //0x0068, APB0 module clock gating
+    volatile __ccmu_apb1clk_gate_reg006c_t  Apb1Gate;   //0x006C, APB1 module clock gating
+    volatile __u32                          reserved9[4];   //0x0070, reserved
+    volatile __ccmu_module0_clk_t           NandClk;    //0x0080, nand module clock control
+    volatile __ccmu_module0_clk_t           MsClk;      //0x0084, MS module clock control
+    volatile __ccmu_module0_clk_t           SdMmc0Clk;  //0x0088, SD/MMC0 module clock control
+    volatile __ccmu_module0_clk_t           SdMmc1Clk;  //0x008C, SD/MMC1 module clock control
+    volatile __ccmu_module0_clk_t           SdMmc2Clk;  //0x0090, SD/MMC2 module clock control
+    volatile __ccmu_module0_clk_t           SdMmc3Clk;  //0x0094, SD/MMC3 module clock control
+    volatile __ccmu_module0_clk_t           TsClk;      //0x0098, TS module clock control
+    volatile __ccmu_module0_clk_t           SsClk;      //0x009C, SS module clock control
+    volatile __ccmu_module0_clk_t           Spi0Clk;    //0x00A0, SPI0 module clock control
+    volatile __ccmu_module0_clk_t           Spi1Clk;    //0x00A4, SPI1 module clock control
+    volatile __ccmu_module0_clk_t           Spi2Clk;    //0x00A8, SPI2 module clock control
+    volatile __ccmu_module0_clk_t           PataClk;    //0x00AC, PATA module clock control
+    volatile __ccmu_module0_clk_t           Ir0Clk;     //0x00B0, IR0 module clock control
+    volatile __ccmu_module0_clk_t           Ir1Clk;     //0x00B4, IR1 module clock control
+    volatile __ccmu_module1_clk_t           I2s0Clk;    //0x00B8, IIS0 module clock control
+    volatile __ccmu_module1_clk_t           Ac97Clk;    //0x00BC, AC97 module clock control
+    volatile __ccmu_module1_clk_t           SpdifClk;   //0x00C0, SPDIF module clock control
+    volatile __ccmu_keypad_clk_reg00c4_t    KeyPadClk;  //0x00C4, KEYPAD module clock control
+    volatile __ccmu_sata_clk_reg00c8_t      SataClk;    //0x00C8, SATA module clock control
+    volatile __ccmu_usb_clk_reg00cc_t       UsbClk;     //0x00CC, USB module clock control
+    volatile __u32                          reserved10; //0x00D0, reserved
+    volatile __ccmu_module0_clk_t           Spi3Clk;    //0x00D4, SPI3 module clock control
+    volatile __ccmu_module1_clk_t           I2s1Clk;    //0x00D8, IIS1 module clock control
+    volatile __ccmu_module1_clk_t           I2s2Clk;    //0x00DC, IIS2 module clock control
+    volatile __u32                          reserved11[8];  //0x00E0, reserved
+    volatile __ccmu_dram_gate_reg0100_t     DramGate;   //0x0100, DRAM gating
+    volatile __ccmu_fedemp_clk_t            DeBe0Clk;   //0x0104, DE-BE 0 module clock control
+    volatile __ccmu_fedemp_clk_t            DeBe1Clk;   //0x0108, DE-BE 1 module clock control
+    volatile __ccmu_fedemp_clk_t            DeFe0Clk;   //0x010C, DE-FE 0 module clock control
+    volatile __ccmu_fedemp_clk_t            DeFe1Clk;   //0x0110, DE-FE 1 module clock control
+    volatile __ccmu_fedemp_clk_t            DeMpClk;    //0x0114, DE-MP module clock control
+    volatile __ccmu_lcdch0_clk_t            Lcd0Ch0Clk; //0x0118, LCD0 CH0 module clock control
+    volatile __ccmu_lcdch0_clk_t            Lcd1Ch0Clk; //0x011C, LCD1 CH0 module clock control
+    volatile __ccmu_csiisp_clk_reg0120_t    CsiIspClk;  //0x0120, CSI-ISP module clock control
+    volatile __u32                          reserved12; //0x0124, reserved
+    volatile __ccmu_tvd_clk_reg0128_t       TvdClk;     //0x0128, TVD module clock control
+    volatile __ccmu_lcdch1_clk_t            Lcd0Ch1Clk; //0x012C, LCD0 CH1 module clock control
+    volatile __ccmu_lcdch1_clk_t            Lcd1Ch1Clk; //0x0130, LCD1 CH1 module clock control
+    volatile __ccmu_csi_clk_t               Csi0Clk;    //0x0134, CSI0 module clock control
+    volatile __ccmu_csi_clk_t               Csi1Clk;    //0x0138, CSI1 module clock control
+    volatile __ccmu_ve_clk_reg013c_t        VeClk;      //0x013C, VE module clock control
+    volatile __ccmu_adda_clk_reg0140_t      AddaClk;    //0x0140, audio codec clock control
+    volatile __ccmu_avs_clk_reg0144_t       AvsClk;     //0x0144, AVS module clock control
+    volatile __ccmu_ace_clk_reg0148_t       AceClk;     //0x0148, ACE module clock control
+    volatile __ccmu_lvds_clk_reg014c_t      LvdsClk;    //0x014C, LVDS module clock control
+    volatile __ccmu_hdmi_clk_reg0150_t      HdmiClk;    //0x0150, HDMI module clock control
+    volatile __ccmu_mali400_clk_reg0154_t   MaliClk;    //0x0154, MALI400 module clock control
+    volatile __u32                          reserved13; //0x0158, reserved
+    volatile __ccmu_mbus_clk_reg015c_t      MBusClk;    //0x015C, MBus module clock control
+    volatile __u32                          reserved14; //0x0160, reserved
+    volatile __ccmu_gmac_clk_reg0164_t      GmacClk;    //0x0164, GMAC module clock control
+    volatile __u32                          reserved15[2];  //0x0168, reserved
+    volatile __ccmu_hdmi1_rst_reg0170_t     Hdmi1Rst;   //0x0170, HDMI1 Reset Register
+    volatile __ccmu_hdmi1_ctl_reg0174_t     Hdmi1Ctl;   //0x0174, HDMI1 Control Register
+    volatile __ccmu_hdmi1_shw_clk_reg0178_t Hdmi1ShwClk;//0x0178, HDMI1 Show Clock Register
+    volatile __ccmu_hdmi1_rpt_clk_reg017c_t Hdmi1RptClk;//0x017C, HDMI1 Repeat Clock Register
+    volatile __u32                          reserved16[28]; //0x0180, reserved
+    volatile __ccmu_clkout_t                ClkOutA;    //0x01F0, Clock output A control
+    volatile __ccmu_clkout_t                ClkOutB;    //0x01F4, Clock output B control
+} __ccmu_reg_list_t;
+
+#endif
diff --git a/drivers/clk/sunxi/ccu_dbg.c b/drivers/clk/sunxi/ccu_dbg.c
new file mode 100644
index 0000000..79fde4a
--- /dev/null
+++ b/drivers/clk/sunxi/ccu_dbg.c
@@ -0,0 +1,1049 @@
+/*
+ * arch/arm/mach-sun7i/clock/ccu_dbg.c
+ * (c) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * James Deng <csjamesdeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/cpufreq.h>
+#include <linux/debugfs.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include "ccm_i.h"
+
+__ccmu_reg_list_t *aw_ccu_reg;
+
+#define print_clk_inf(x, y) do { printk(#x"."#y":%d\n", aw_ccu_reg->x.y); } while (0)
+
+void clk_dbg_inf(void)
+{
+    printk("---------------------------------------------\n");
+    printk("    dump clock information                   \n");
+    printk("---------------------------------------------\n");
+
+    printk("PLL1 infor:\n");
+    print_clk_inf(Pll1Ctl, FactorM);
+    print_clk_inf(Pll1Ctl, SigmaEn);
+    print_clk_inf(Pll1Ctl, SigmaIn);
+    print_clk_inf(Pll1Ctl, FactorK);
+    print_clk_inf(Pll1Ctl, FactorN);
+    print_clk_inf(Pll1Ctl, LockTime);
+    print_clk_inf(Pll1Ctl, PLLDivP);
+    print_clk_inf(Pll1Ctl, PLLBias);
+    print_clk_inf(Pll1Ctl, ExchangeEn);
+    print_clk_inf(Pll1Ctl, VCOBias);
+    print_clk_inf(Pll1Ctl, VCORstIn);
+    print_clk_inf(Pll1Ctl, PLLEn);
+
+    printk("\nPLL2 infor:\n");
+    print_clk_inf(Pll2Ctl, PrevDiv);
+    print_clk_inf(Pll2Ctl, FactorN);
+    print_clk_inf(Pll2Ctl, PLLBias);
+    print_clk_inf(Pll2Ctl, VcoBias);
+    print_clk_inf(Pll2Ctl, PostDiv);
+    print_clk_inf(Pll2Ctl, PLLEn);
+
+    printk("\nPLL3 infor:\n");
+    print_clk_inf(Pll3Ctl, FactorM);
+    print_clk_inf(Pll3Ctl, PLLBias);
+    print_clk_inf(Pll3Ctl, FracSet);
+    print_clk_inf(Pll3Ctl, ModeSel);
+    print_clk_inf(Pll3Ctl, VCOBias);
+    print_clk_inf(Pll3Ctl, DampFactor);
+    print_clk_inf(Pll3Ctl, PLLEn);
+
+    printk("\nPLL4 infor:\n");
+    print_clk_inf(Pll4Ctl, FactorM);
+    print_clk_inf(Pll4Ctl, FactorK);
+    print_clk_inf(Pll4Ctl, DampFactor);
+    print_clk_inf(Pll4Ctl, FactorN);
+    print_clk_inf(Pll4Ctl, BandWidth);
+    print_clk_inf(Pll4Ctl, PLLBias);
+    print_clk_inf(Pll4Ctl, VCOBias);
+    print_clk_inf(Pll4Ctl, PLLBypass);
+    print_clk_inf(Pll4Ctl, PLLEn);
+
+    printk("\nPLL5 infor:\n");
+    print_clk_inf(Pll5Ctl, FactorM);
+    print_clk_inf(Pll5Ctl, FactorM1);
+    print_clk_inf(Pll5Ctl, FactorK);
+    print_clk_inf(Pll5Ctl, LDO2En);
+    print_clk_inf(Pll5Ctl, FactorN);
+    print_clk_inf(Pll5Ctl, VCOGain);
+    print_clk_inf(Pll5Ctl, FactorP);
+    print_clk_inf(Pll5Ctl, BandWidth);
+    print_clk_inf(Pll5Ctl, VCOGainEn);
+    print_clk_inf(Pll5Ctl, PLLBias);
+    print_clk_inf(Pll5Ctl, VCOBias);
+    print_clk_inf(Pll5Ctl, OutputEn);
+    print_clk_inf(Pll5Ctl, PLLBypass);
+    print_clk_inf(Pll5Ctl, PLLEn);
+
+    printk("\nPLL6 infor:\n");
+    print_clk_inf(Pll6Ctl, FactorM);
+    print_clk_inf(Pll6Ctl, FactorK);
+    print_clk_inf(Pll6Ctl, DampFactor);
+    print_clk_inf(Pll6Ctl, FactorN);
+    print_clk_inf(Pll6Ctl, OutputEn);
+    print_clk_inf(Pll6Ctl, BandWidth);
+    print_clk_inf(Pll6Ctl, PLLBias);
+    print_clk_inf(Pll6Ctl, VCOBias);
+    print_clk_inf(Pll6Ctl, PLLBypass);
+    print_clk_inf(Pll6Ctl, PLLEn);
+
+    printk("\nPLL7 infor:\n");
+    print_clk_inf(Pll7Ctl, FactorM);
+    print_clk_inf(Pll7Ctl, PLLBias);
+    print_clk_inf(Pll7Ctl, FracSet);
+    print_clk_inf(Pll7Ctl, ModeSel);
+    print_clk_inf(Pll7Ctl, VCOBias);
+    print_clk_inf(Pll7Ctl, DampFactor);
+    print_clk_inf(Pll7Ctl, PLLEn);
+
+    printk("\nPLL8 infor:\n");
+    print_clk_inf(Pll8Ctl, FactorM);
+    print_clk_inf(Pll8Ctl, FactorK);
+    print_clk_inf(Pll8Ctl, DampFactor);
+    print_clk_inf(Pll8Ctl, FactorN);
+    print_clk_inf(Pll8Ctl, BandWidth);
+    print_clk_inf(Pll8Ctl, PLLBias);
+    print_clk_inf(Pll8Ctl, VCOBias);
+    print_clk_inf(Pll8Ctl, PLLBypass);
+    print_clk_inf(Pll8Ctl, PLLEn);
+
+    printk("\nHOSC infor:\n");
+    print_clk_inf(HoscCtl, OSC24MEn);
+    print_clk_inf(HoscCtl, OSC24MGsm);
+    print_clk_inf(HoscCtl, PLLBiasEn);
+    print_clk_inf(HoscCtl, LDOEn);
+    print_clk_inf(HoscCtl, PLLInPower);
+    print_clk_inf(HoscCtl, LDOOutput);
+    print_clk_inf(HoscCtl, KeyField);
+
+    printk("\nCPU clk infor:\n");
+    print_clk_inf(SysClkDiv, AXIClkDiv);
+    print_clk_inf(SysClkDiv, AHBClkDiv);
+    print_clk_inf(SysClkDiv, AHBClkSrc);
+    print_clk_inf(SysClkDiv, APB0ClkDiv);
+    print_clk_inf(SysClkDiv, AtbApbClkDiv);
+    print_clk_inf(SysClkDiv, AC327ClkSrc);
+    print_clk_inf(SysClkDiv, DVFSStart);
+
+    printk("\nAPB1 clk infor:\n");
+    print_clk_inf(Apb1ClkDiv, ClkDiv);
+    print_clk_inf(Apb1ClkDiv, PreDiv);
+    print_clk_inf(Apb1ClkDiv, ClkSrc);
+
+    printk("\nAhbGate0 clk infor:\n");
+    print_clk_inf(AhbGate0, Usb0Gate);
+    print_clk_inf(AhbGate0, Ehci0Gate);
+    print_clk_inf(AhbGate0, Ohci0Gate);
+    print_clk_inf(AhbGate0, Ehci1Gate);
+    print_clk_inf(AhbGate0, Ohci1Gate);
+    print_clk_inf(AhbGate0, SsGate);
+    print_clk_inf(AhbGate0, DmaGate);
+    print_clk_inf(AhbGate0, BistGate);
+    print_clk_inf(AhbGate0, Sdmmc0Gate);
+    print_clk_inf(AhbGate0, Sdmmc1Gate);
+    print_clk_inf(AhbGate0, Sdmmc2Gate);
+    print_clk_inf(AhbGate0, Sdmmc3Gate);
+    print_clk_inf(AhbGate0, MsGate);
+    print_clk_inf(AhbGate0, NandGate);
+    print_clk_inf(AhbGate0, SdramGate);
+    print_clk_inf(AhbGate0, AceGate);
+    print_clk_inf(AhbGate0, EmacGate);
+    print_clk_inf(AhbGate0, TsGate);
+    print_clk_inf(AhbGate0, Spi0Gate);
+    print_clk_inf(AhbGate0, Spi1Gate);
+    print_clk_inf(AhbGate0, Spi2Gate);
+    print_clk_inf(AhbGate0, Spi3Gate);
+    /* REMOVED */
+    //print_clk_inf(AhbGate0, PataGate);
+    print_clk_inf(AhbGate0, SataGate);
+    /* REMOVED */
+    //print_clk_inf(AhbGate0, GpsGate);
+    print_clk_inf(AhbGate0, StmrGate);
+
+    printk("\nAhbGate1 clk infor:\n");
+    print_clk_inf(AhbGate1, VeGate);
+    print_clk_inf(AhbGate1, TvdGate);
+    print_clk_inf(AhbGate1, Tve0Gate);
+    print_clk_inf(AhbGate1, Tve1Gate);
+    print_clk_inf(AhbGate1, Lcd0Gate);
+    print_clk_inf(AhbGate1, Lcd1Gate);
+    print_clk_inf(AhbGate1, Csi0Gate);
+    print_clk_inf(AhbGate1, Csi1Gate);
+    print_clk_inf(AhbGate1, Hdmi1Gate);
+    print_clk_inf(AhbGate1, HdmiDGate);
+    print_clk_inf(AhbGate1, DeBe0Gate);
+    print_clk_inf(AhbGate1, DeBe1Gate);
+    print_clk_inf(AhbGate1, DeFe0Gate);
+    print_clk_inf(AhbGate1, DeFe1Gate);
+    print_clk_inf(AhbGate1, MpGate);
+    print_clk_inf(AhbGate1, Gpu3DGate);
+
+    printk("\nApb0Gate clk infor:\n");
+    print_clk_inf(Apb0Gate, AddaGate);
+    print_clk_inf(Apb0Gate, SpdifGate);
+    print_clk_inf(Apb0Gate, Ac97Gate);
+    print_clk_inf(Apb0Gate, Iis0Gate);
+    print_clk_inf(Apb0Gate, Iis1Gate);
+    print_clk_inf(Apb0Gate, PioGate);
+    print_clk_inf(Apb0Gate, Ir0Gate);
+    print_clk_inf(Apb0Gate, Ir1Gate);
+    print_clk_inf(Apb0Gate, Iis2Gate);
+    print_clk_inf(Apb0Gate, KeypadGate);
+
+    printk("\nApb1Gate clk infor:\n");
+    print_clk_inf(Apb1Gate, Twi0Gate);
+    print_clk_inf(Apb1Gate, Twi1Gate);
+    print_clk_inf(Apb1Gate, Twi2Gate);
+    print_clk_inf(Apb1Gate, Twi3Gate);
+    print_clk_inf(Apb1Gate, CanGate);
+    print_clk_inf(Apb1Gate, ScrGate);
+    print_clk_inf(Apb1Gate, Ps20Gate);
+    print_clk_inf(Apb1Gate, Ps21Gate);
+    print_clk_inf(Apb1Gate, Twi4Gate);
+    print_clk_inf(Apb1Gate, Uart0Gate);
+    print_clk_inf(Apb1Gate, Uart1Gate);
+    print_clk_inf(Apb1Gate, Uart2Gate);
+    print_clk_inf(Apb1Gate, Uart3Gate);
+    print_clk_inf(Apb1Gate, Uart4Gate);
+    print_clk_inf(Apb1Gate, Uart5Gate);
+    print_clk_inf(Apb1Gate, Uart6Gate);
+    print_clk_inf(Apb1Gate, Uart7Gate);
+
+    printk("\nNandClk clk infor:\n");
+    print_clk_inf(NandClk, ClkDiv);
+    print_clk_inf(NandClk, ClkPreDiv);
+    print_clk_inf(NandClk, ClkSrc);
+    print_clk_inf(NandClk, SpecClkGate);
+
+    printk("\nMsClk clk infor:\n");
+    print_clk_inf(MsClk, ClkDiv);
+    print_clk_inf(MsClk, ClkPreDiv);
+    print_clk_inf(MsClk, ClkSrc);
+    print_clk_inf(MsClk, SpecClkGate);
+
+    printk("\nSdMmc0Clk clk infor:\n");
+    print_clk_inf(SdMmc0Clk, ClkDiv);
+    print_clk_inf(SdMmc0Clk, ClkPreDiv);
+    print_clk_inf(SdMmc0Clk, ClkSrc);
+    print_clk_inf(SdMmc0Clk, SpecClkGate);
+
+    printk("\nSdMmc1Clk clk infor:\n");
+    print_clk_inf(SdMmc1Clk, ClkDiv);
+    print_clk_inf(SdMmc1Clk, ClkPreDiv);
+    print_clk_inf(SdMmc1Clk, ClkSrc);
+    print_clk_inf(SdMmc1Clk, SpecClkGate);
+
+    printk("\nSdMmc2Clk clk infor:\n");
+    print_clk_inf(SdMmc2Clk, ClkDiv);
+    print_clk_inf(SdMmc2Clk, ClkPreDiv);
+    print_clk_inf(SdMmc2Clk, ClkSrc);
+    print_clk_inf(SdMmc2Clk, SpecClkGate);
+
+    printk("\nSdMmc3Clk clk infor:\n");
+    print_clk_inf(SdMmc3Clk, ClkDiv);
+    print_clk_inf(SdMmc3Clk, ClkPreDiv);
+    print_clk_inf(SdMmc3Clk, ClkSrc);
+    print_clk_inf(SdMmc3Clk, SpecClkGate);
+
+    printk("\nTsClk clk infor:\n");
+    print_clk_inf(TsClk, ClkDiv);
+    print_clk_inf(TsClk, ClkPreDiv);
+    print_clk_inf(TsClk, ClkSrc);
+    print_clk_inf(TsClk, SpecClkGate);
+
+    printk("\nSsClk clk infor:\n");
+    print_clk_inf(SsClk, ClkDiv);
+    print_clk_inf(SsClk, ClkPreDiv);
+    print_clk_inf(SsClk, ClkSrc);
+    print_clk_inf(SsClk, SpecClkGate);
+
+    printk("\nSpi0Clk clk infor:\n");
+    print_clk_inf(Spi0Clk, ClkDiv);
+    print_clk_inf(Spi0Clk, ClkPreDiv);
+    print_clk_inf(Spi0Clk, ClkSrc);
+    print_clk_inf(Spi0Clk, SpecClkGate);
+
+    printk("\nSpi1Clk clk infor:\n");
+    print_clk_inf(Spi1Clk, ClkDiv);
+    print_clk_inf(Spi1Clk, ClkPreDiv);
+    print_clk_inf(Spi1Clk, ClkSrc);
+    print_clk_inf(Spi1Clk, SpecClkGate);
+
+    printk("\nSpi2Clk clk infor:\n");
+    print_clk_inf(Spi2Clk, ClkDiv);
+    print_clk_inf(Spi2Clk, ClkPreDiv);
+    print_clk_inf(Spi2Clk, ClkSrc);
+    print_clk_inf(Spi2Clk, SpecClkGate);
+
+    printk("\nPataClk clk infor:\n");
+    print_clk_inf(PataClk, ClkDiv);
+    print_clk_inf(PataClk, ClkPreDiv);
+    print_clk_inf(PataClk, ClkSrc);
+    print_clk_inf(PataClk, SpecClkGate);
+
+    printk("\nIr0Clk clk infor:\n");
+    print_clk_inf(Ir0Clk, ClkDiv);
+    print_clk_inf(Ir0Clk, ClkPreDiv);
+    print_clk_inf(Ir0Clk, ClkSrc);
+    print_clk_inf(Ir0Clk, SpecClkGate);
+
+    printk("\nIr1Clk clk infor:\n");
+    print_clk_inf(Ir1Clk, ClkDiv);
+    print_clk_inf(Ir1Clk, ClkPreDiv);
+    print_clk_inf(Ir1Clk, ClkSrc);
+    print_clk_inf(Ir1Clk, SpecClkGate);
+
+    printk("\nI2s0Clk clk infor:\n");
+    print_clk_inf(I2s0Clk, ClkDiv);
+    print_clk_inf(I2s0Clk, SpecClkGate);
+
+    printk("\nAc97Clk clk infor:\n");
+    print_clk_inf(Ac97Clk, ClkDiv);
+    print_clk_inf(Ac97Clk, SpecClkGate);
+
+    printk("\nSpdifClk clk infor:\n");
+    print_clk_inf(SpdifClk, ClkDiv);
+    print_clk_inf(SpdifClk, SpecClkGate);
+
+    printk("\nKeyPadClk clk infor:\n");
+    print_clk_inf(KeyPadClk, ClkDiv);
+    print_clk_inf(KeyPadClk, ClkPreDiv);
+    print_clk_inf(KeyPadClk, ClkSrc);
+    print_clk_inf(KeyPadClk, SpecClkGate);
+
+    printk("\nSataClk clk infor:\n");
+    print_clk_inf(SataClk, ClkSrc);
+    print_clk_inf(SataClk, SpecClkGate);
+
+    printk("\nUsbClk clk infor:\n");
+    print_clk_inf(UsbClk, UsbPhy0Rst);
+    print_clk_inf(UsbClk, UsbPhy1Rst);
+    print_clk_inf(UsbClk, UsbPhy2Rst);
+    /* REMOVED */
+    //print_clk_inf(UsbClk, OHCIClkSrc);
+    print_clk_inf(UsbClk, OHCI0SpecClkGate);
+    print_clk_inf(UsbClk, OHCI1SpecClkGate);
+    print_clk_inf(UsbClk, PhySpecClkGate);
+
+    /* REMOVED */
+    //printk("\nGpsClk clk infor:\n");
+    //print_clk_inf(GpsClk, ClkDivRatio);
+    //print_clk_inf(GpsClk, ClkSrc);
+    //print_clk_inf(GpsClk, Reset);
+    //print_clk_inf(GpsClk, SpecClkGate);
+
+    printk("\nSpi3Clk clk infor:\n");
+    print_clk_inf(Spi3Clk, ClkDiv);
+    print_clk_inf(Spi3Clk, ClkPreDiv);
+    print_clk_inf(Spi3Clk, ClkSrc);
+    print_clk_inf(Spi3Clk, SpecClkGate);
+
+    printk("\nI2s1Clk clk infor:\n");
+    print_clk_inf(I2s1Clk, ClkDiv);
+    print_clk_inf(I2s1Clk, SpecClkGate);
+
+    printk("\nI2s2Clk clk infor:\n");
+    print_clk_inf(I2s2Clk, ClkDiv);
+    print_clk_inf(I2s2Clk, SpecClkGate);
+
+    printk("\nDramGate clk infor:\n");
+    print_clk_inf(DramGate, VeGate);
+    print_clk_inf(DramGate, Csi0Gate);
+    print_clk_inf(DramGate, Csi1Gate);
+    print_clk_inf(DramGate, TsGate);
+    print_clk_inf(DramGate, TvdGate);
+    print_clk_inf(DramGate, Tve0Gate);
+    print_clk_inf(DramGate, Tve1Gate);
+    print_clk_inf(DramGate, ClkOutputEn);
+    print_clk_inf(DramGate, DeFe0Gate);
+    print_clk_inf(DramGate, DeFe1Gate);
+    print_clk_inf(DramGate, DeBe0Gate);
+    print_clk_inf(DramGate, DeBe1Gate);
+    print_clk_inf(DramGate, DeMpGate);
+    print_clk_inf(DramGate, AceGate);
+
+    printk("\nDeBe0Clk clk infor:\n");
+    print_clk_inf(DeBe0Clk, ClkDiv);
+    print_clk_inf(DeBe0Clk, ClkSrc);
+    print_clk_inf(DeBe0Clk, Reset);
+    print_clk_inf(DeBe0Clk, SpecClkGate);
+
+    printk("\nDeBe1Clk clk infor:\n");
+    print_clk_inf(DeBe1Clk, ClkDiv);
+    print_clk_inf(DeBe1Clk, ClkSrc);
+    print_clk_inf(DeBe1Clk, Reset);
+    print_clk_inf(DeBe1Clk, SpecClkGate);
+
+    printk("\nDeFe0Clk clk infor:\n");
+    print_clk_inf(DeFe0Clk, ClkDiv);
+    print_clk_inf(DeFe0Clk, ClkSrc);
+    print_clk_inf(DeFe0Clk, Reset);
+    print_clk_inf(DeFe0Clk, SpecClkGate);
+
+    printk("\nDeFe1Clk clk infor:\n");
+    print_clk_inf(DeFe1Clk, ClkDiv);
+    print_clk_inf(DeFe1Clk, ClkSrc);
+    print_clk_inf(DeFe1Clk, Reset);
+    print_clk_inf(DeFe1Clk, SpecClkGate);
+
+    printk("\nDeMpClk clk infor:\n");
+    print_clk_inf(DeMpClk, ClkDiv);
+    print_clk_inf(DeMpClk, ClkSrc);
+    print_clk_inf(DeMpClk, Reset);
+    print_clk_inf(DeMpClk, SpecClkGate);
+
+    printk("\nLcd0Ch0Clk clk infor:\n");
+    print_clk_inf(Lcd0Ch0Clk, ClkSrc);
+    print_clk_inf(Lcd0Ch0Clk, Reset);
+    print_clk_inf(Lcd0Ch0Clk, SpecClkGate);
+
+    printk("\nLcd1Ch0Clk clk infor:\n");
+    print_clk_inf(Lcd1Ch0Clk, ClkSrc);
+    print_clk_inf(Lcd1Ch0Clk, Reset);
+    print_clk_inf(Lcd1Ch0Clk, SpecClkGate);
+
+    printk("\nCsiIspClk clk infor:\n");
+    print_clk_inf(CsiIspClk, ClkDiv);
+    print_clk_inf(CsiIspClk, ClkSrc);
+    print_clk_inf(CsiIspClk, SpecClkGate);
+
+    printk("\nTvdClk clk infor:\n");
+    print_clk_inf(TvdClk, Clk1Div);
+    print_clk_inf(TvdClk, Clk1Src);
+    print_clk_inf(TvdClk, Clk1Gate);
+    print_clk_inf(TvdClk, Clk2Div);
+    print_clk_inf(TvdClk, Clk2Src);
+    print_clk_inf(TvdClk, Clk2Gate);
+
+    printk("\nLcd0Ch1Clk clk infor:\n");
+    print_clk_inf(Lcd0Ch1Clk, ClkDiv);
+    print_clk_inf(Lcd0Ch1Clk, SpecClk1Src);
+    print_clk_inf(Lcd0Ch1Clk, SpecClk1Gate);
+    print_clk_inf(Lcd0Ch1Clk, SpecClk2Src);
+    print_clk_inf(Lcd0Ch1Clk, SpecClk2Gate);
+
+    printk("\nLcd1Ch1Clk clk infor:\n");
+    print_clk_inf(Lcd1Ch1Clk, ClkDiv);
+    print_clk_inf(Lcd1Ch1Clk, SpecClk1Src);
+    print_clk_inf(Lcd1Ch1Clk, SpecClk1Gate);
+    print_clk_inf(Lcd1Ch1Clk, SpecClk2Src);
+    print_clk_inf(Lcd1Ch1Clk, SpecClk2Gate);
+
+    printk("\nCsi0Clk clk infor:\n");
+    print_clk_inf(Csi0Clk, ClkDiv);
+    print_clk_inf(Csi0Clk, ClkSrc);
+    print_clk_inf(Csi0Clk, Reset);
+    print_clk_inf(Csi0Clk, SpecClkGate);
+
+    printk("\nCsi1Clk clk infor:\n");
+    print_clk_inf(Csi1Clk, ClkDiv);
+    print_clk_inf(Csi1Clk, ClkSrc);
+    print_clk_inf(Csi1Clk, Reset);
+    print_clk_inf(Csi1Clk, SpecClkGate);
+
+    printk("\nVeClk clk infor:\n");
+    print_clk_inf(VeClk, Reset);
+    print_clk_inf(VeClk, ClkDiv);
+    print_clk_inf(VeClk, SpecClkGate);
+
+    printk("\nAddaClk clk infor:\n");
+    print_clk_inf(AddaClk, SpecClkGate);
+
+    printk("\nAvsClk clk infor:\n");
+    print_clk_inf(AvsClk, SpecClkGate);
+
+    printk("\nAceClk clk infor:\n");
+    print_clk_inf(AceClk, ClkDiv);
+    print_clk_inf(AceClk, Reset);
+    print_clk_inf(AceClk, ClkSrc);
+    print_clk_inf(AceClk, SpecClkGate);
+
+    printk("\nLvdsClk clk infor:\n");
+    print_clk_inf(LvdsClk, Reset);
+
+    printk("\nHdmiClk clk infor:\n");
+    print_clk_inf(HdmiClk, ClkDiv);
+    print_clk_inf(HdmiClk, ClkSrc);
+    print_clk_inf(HdmiClk, SpecClkGate);
+
+    printk("\nMaliClk clk infor:\n");
+    print_clk_inf(MaliClk, ClkDiv);
+    print_clk_inf(MaliClk, ClkSrc);
+    print_clk_inf(MaliClk, Reset);
+    print_clk_inf(MaliClk, SpecClkGate);
+
+    printk("\nMBusClk clk infor:\n");
+    print_clk_inf(MBusClk, ClkDivM);
+    print_clk_inf(MBusClk, ClkDivN);
+    print_clk_inf(MBusClk, ClkSrc);
+    print_clk_inf(MBusClk, ClkGate);
+
+    printk("\nGmacClk clk infor:\n");
+    print_clk_inf(GmacClk, TxClkSrc);
+    print_clk_inf(GmacClk, PhyIT);
+    print_clk_inf(GmacClk, TxClkInv);
+    print_clk_inf(GmacClk, RxClkInv);
+    print_clk_inf(GmacClk, RxDlyChain);
+    print_clk_inf(GmacClk, ClkDiv);
+
+    printk("\nClkOutA clk infor:\n");
+    print_clk_inf(ClkOutA, ClkDivM);
+    print_clk_inf(ClkOutA, ClkDivN);
+    print_clk_inf(ClkOutA, ClkSrc);
+    print_clk_inf(ClkOutA, ClkEn);
+
+    printk("\nClkOutB clk infor:\n");
+    print_clk_inf(ClkOutB, ClkDivM);
+    print_clk_inf(ClkOutB, ClkDivN);
+    print_clk_inf(ClkOutB, ClkSrc);
+    print_clk_inf(ClkOutB, ClkEn);
+}
+EXPORT_SYMBOL(clk_dbg_inf);
+
+#ifdef CONFIG_PROC_FS
+
+#define sprintf_clk_inf(buf, x, y) do { seq_printf(buf, "\t"#x"."#y":%d\n", aw_ccu_reg->x.y); } while(0)
+static int ccmu_stats_show(struct seq_file *m, void *unused)
+{
+    seq_printf(m, "---------------------------------------------\n");
+    seq_printf(m, "clock information:                           \n");
+    seq_printf(m, "---------------------------------------------\n");
+
+    seq_printf(m, "\nPLL1 infor:\n");
+    sprintf_clk_inf(m, Pll1Ctl, FactorM);
+    sprintf_clk_inf(m, Pll1Ctl, SigmaEn);
+    sprintf_clk_inf(m, Pll1Ctl, SigmaIn);
+    sprintf_clk_inf(m, Pll1Ctl, FactorK);
+    sprintf_clk_inf(m, Pll1Ctl, FactorN);
+    sprintf_clk_inf(m, Pll1Ctl, LockTime);
+    sprintf_clk_inf(m, Pll1Ctl, PLLDivP);
+    sprintf_clk_inf(m, Pll1Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll1Ctl, ExchangeEn);
+    sprintf_clk_inf(m, Pll1Ctl, VCOBias);
+    sprintf_clk_inf(m, Pll1Ctl, VCORstIn);
+    sprintf_clk_inf(m, Pll1Ctl, PLLEn);
+
+    seq_printf(m, "\nPLL2 infor(0x%x):\n", *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl);
+    sprintf_clk_inf(m, Pll2Ctl, PrevDiv);
+    sprintf_clk_inf(m, Pll2Ctl, FactorN);
+    sprintf_clk_inf(m, Pll2Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll2Ctl, VcoBias);
+    sprintf_clk_inf(m, Pll2Ctl, PostDiv);
+    sprintf_clk_inf(m, Pll2Ctl, PLLEn);
+
+    seq_printf(m, "\nPLL3 infor:\n");
+    sprintf_clk_inf(m, Pll3Ctl, FactorM);
+    sprintf_clk_inf(m, Pll3Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll3Ctl, FracSet);
+    sprintf_clk_inf(m, Pll3Ctl, ModeSel);
+    sprintf_clk_inf(m, Pll3Ctl, VCOBias);
+    sprintf_clk_inf(m, Pll3Ctl, DampFactor);
+    sprintf_clk_inf(m, Pll3Ctl, PLLEn);
+
+    seq_printf(m, "\nPLL4 infor:\n");
+    sprintf_clk_inf(m, Pll4Ctl, FactorM);
+    sprintf_clk_inf(m, Pll4Ctl, FactorK);
+    sprintf_clk_inf(m, Pll4Ctl, DampFactor);
+    sprintf_clk_inf(m, Pll4Ctl, FactorN);
+    sprintf_clk_inf(m, Pll4Ctl, BandWidth);
+    sprintf_clk_inf(m, Pll4Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll4Ctl, VCOBias);
+    sprintf_clk_inf(m, Pll4Ctl, PLLBypass);
+    sprintf_clk_inf(m, Pll4Ctl, PLLEn);
+
+    seq_printf(m, "\nPLL5 infor:\n");
+    sprintf_clk_inf(m, Pll5Ctl, FactorM);
+    sprintf_clk_inf(m, Pll5Ctl, FactorM1);
+    sprintf_clk_inf(m, Pll5Ctl, FactorK);
+    sprintf_clk_inf(m, Pll5Ctl, LDO2En);
+    sprintf_clk_inf(m, Pll5Ctl, FactorN);
+    sprintf_clk_inf(m, Pll5Ctl, VCOGain);
+    sprintf_clk_inf(m, Pll5Ctl, FactorP);
+    sprintf_clk_inf(m, Pll5Ctl, BandWidth);
+    sprintf_clk_inf(m, Pll5Ctl, VCOGainEn);
+    sprintf_clk_inf(m, Pll5Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll5Ctl, VCOBias);
+    sprintf_clk_inf(m, Pll5Ctl, OutputEn);
+    sprintf_clk_inf(m, Pll5Ctl, PLLBypass);
+    sprintf_clk_inf(m, Pll5Ctl, PLLEn);
+
+    seq_printf(m, "\nPLL6 infor:\n");
+    sprintf_clk_inf(m, Pll6Ctl, FactorM);
+    sprintf_clk_inf(m, Pll6Ctl, FactorK);
+    sprintf_clk_inf(m, Pll6Ctl, DampFactor);
+    sprintf_clk_inf(m, Pll6Ctl, FactorN);
+    sprintf_clk_inf(m, Pll6Ctl, OutputEn);
+    sprintf_clk_inf(m, Pll6Ctl, BandWidth);
+    sprintf_clk_inf(m, Pll6Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll6Ctl, VCOBias);
+    sprintf_clk_inf(m, Pll6Ctl, PLLBypass);
+    sprintf_clk_inf(m, Pll6Ctl, PLLEn);
+
+    seq_printf(m, "\nPLL7 infor:\n");
+    sprintf_clk_inf(m, Pll7Ctl, FactorM);
+    sprintf_clk_inf(m, Pll7Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll7Ctl, FracSet);
+    sprintf_clk_inf(m, Pll7Ctl, ModeSel);
+    sprintf_clk_inf(m, Pll7Ctl, VCOBias);
+    sprintf_clk_inf(m, Pll7Ctl, DampFactor);
+    sprintf_clk_inf(m, Pll7Ctl, PLLEn);
+
+    seq_printf(m, "\nPLL8 infor:\n");
+    sprintf_clk_inf(m, Pll8Ctl, FactorM);
+    sprintf_clk_inf(m, Pll8Ctl, FactorK);
+    sprintf_clk_inf(m, Pll8Ctl, DampFactor);
+    sprintf_clk_inf(m, Pll8Ctl, FactorN);
+    sprintf_clk_inf(m, Pll8Ctl, BandWidth);
+    sprintf_clk_inf(m, Pll8Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll8Ctl, VCOBias);
+    sprintf_clk_inf(m, Pll8Ctl, PLLBypass);
+    sprintf_clk_inf(m, Pll8Ctl, PLLEn);
+
+    seq_printf(m, "\nHOSC infor:\n");
+    sprintf_clk_inf(m, HoscCtl, OSC24MEn);
+    sprintf_clk_inf(m, HoscCtl, OSC24MGsm);
+    sprintf_clk_inf(m, HoscCtl, PLLBiasEn);
+    sprintf_clk_inf(m, HoscCtl, LDOEn);
+    sprintf_clk_inf(m, HoscCtl, PLLInPower);
+    sprintf_clk_inf(m, HoscCtl, LDOOutput);
+    sprintf_clk_inf(m, HoscCtl, KeyField);
+
+    seq_printf(m, "\nCPU clk infor:\n");
+    sprintf_clk_inf(m, SysClkDiv, AXIClkDiv);
+    sprintf_clk_inf(m, SysClkDiv, AHBClkDiv);
+    sprintf_clk_inf(m, SysClkDiv, AHBClkSrc);
+    sprintf_clk_inf(m, SysClkDiv, APB0ClkDiv);
+    sprintf_clk_inf(m, SysClkDiv, AtbApbClkDiv);
+    sprintf_clk_inf(m, SysClkDiv, AC327ClkSrc);
+    sprintf_clk_inf(m, SysClkDiv, DVFSStart);
+
+    seq_printf(m, "\nAPB1 clk infor:\n");
+    sprintf_clk_inf(m, Apb1ClkDiv, ClkDiv);
+    sprintf_clk_inf(m, Apb1ClkDiv, PreDiv);
+    sprintf_clk_inf(m, Apb1ClkDiv, ClkSrc);
+
+    seq_printf(m, "\nAhbGate0 clk infor:\n");
+    sprintf_clk_inf(m, AhbGate0, Usb0Gate);
+    sprintf_clk_inf(m, AhbGate0, Ehci0Gate);
+    sprintf_clk_inf(m, AhbGate0, Ohci0Gate);
+    sprintf_clk_inf(m, AhbGate0, Ehci1Gate);
+    sprintf_clk_inf(m, AhbGate0, Ohci1Gate);
+    sprintf_clk_inf(m, AhbGate0, SsGate);
+    sprintf_clk_inf(m, AhbGate0, DmaGate);
+    sprintf_clk_inf(m, AhbGate0, BistGate);
+    sprintf_clk_inf(m, AhbGate0, Sdmmc0Gate);
+    sprintf_clk_inf(m, AhbGate0, Sdmmc1Gate);
+    sprintf_clk_inf(m, AhbGate0, Sdmmc2Gate);
+    sprintf_clk_inf(m, AhbGate0, Sdmmc3Gate);
+    sprintf_clk_inf(m, AhbGate0, MsGate);
+    sprintf_clk_inf(m, AhbGate0, NandGate);
+    sprintf_clk_inf(m, AhbGate0, SdramGate);
+    sprintf_clk_inf(m, AhbGate0, AceGate);
+    sprintf_clk_inf(m, AhbGate0, EmacGate);
+    sprintf_clk_inf(m, AhbGate0, TsGate);
+    sprintf_clk_inf(m, AhbGate0, Spi0Gate);
+    sprintf_clk_inf(m, AhbGate0, Spi1Gate);
+    sprintf_clk_inf(m, AhbGate0, Spi2Gate);
+    sprintf_clk_inf(m, AhbGate0, Spi3Gate);
+    /* REMOVED */
+    //sprintf_clk_inf(m, AhbGate0, PataGate);
+    sprintf_clk_inf(m, AhbGate0, SataGate);
+    /* REMOVED */
+    //sprintf_clk_inf(m, AhbGate0, GpsGate);
+    sprintf_clk_inf(m, AhbGate0, StmrGate);
+
+    seq_printf(m, "\nAhbGate1 clk infor:\n");
+    sprintf_clk_inf(m, AhbGate1, VeGate);
+    sprintf_clk_inf(m, AhbGate1, TvdGate);
+    sprintf_clk_inf(m, AhbGate1, Tve0Gate);
+    sprintf_clk_inf(m, AhbGate1, Tve1Gate);
+    sprintf_clk_inf(m, AhbGate1, Lcd0Gate);
+    sprintf_clk_inf(m, AhbGate1, Lcd1Gate);
+    sprintf_clk_inf(m, AhbGate1, Csi0Gate);
+    sprintf_clk_inf(m, AhbGate1, Csi1Gate);
+    sprintf_clk_inf(m, AhbGate1, Hdmi1Gate);
+    sprintf_clk_inf(m, AhbGate1, HdmiDGate);
+    sprintf_clk_inf(m, AhbGate1, DeBe0Gate);
+    sprintf_clk_inf(m, AhbGate1, DeBe1Gate);
+    sprintf_clk_inf(m, AhbGate1, DeFe0Gate);
+    sprintf_clk_inf(m, AhbGate1, DeFe1Gate);
+    sprintf_clk_inf(m, AhbGate1, GmacGate);
+    sprintf_clk_inf(m, AhbGate1, MpGate);
+    sprintf_clk_inf(m, AhbGate1, Gpu3DGate);
+
+    seq_printf(m, "\nApb0Gate clk infor:\n");
+    sprintf_clk_inf(m, Apb0Gate, AddaGate);
+    sprintf_clk_inf(m, Apb0Gate, SpdifGate);
+    sprintf_clk_inf(m, Apb0Gate, Ac97Gate);
+    sprintf_clk_inf(m, Apb0Gate, Iis0Gate);
+    sprintf_clk_inf(m, Apb0Gate, Iis1Gate);
+    sprintf_clk_inf(m, Apb0Gate, PioGate);
+    sprintf_clk_inf(m, Apb0Gate, Ir0Gate);
+    sprintf_clk_inf(m, Apb0Gate, Ir1Gate);
+    sprintf_clk_inf(m, Apb0Gate, Iis2Gate);
+    sprintf_clk_inf(m, Apb0Gate, KeypadGate);
+
+    seq_printf(m, "\nApb1Gate clk infor:\n");
+    sprintf_clk_inf(m, Apb1Gate, Twi0Gate);
+    sprintf_clk_inf(m, Apb1Gate, Twi1Gate);
+    sprintf_clk_inf(m, Apb1Gate, Twi2Gate);
+    sprintf_clk_inf(m, Apb1Gate, Twi3Gate);
+    sprintf_clk_inf(m, Apb1Gate, CanGate);
+    sprintf_clk_inf(m, Apb1Gate, ScrGate);
+    sprintf_clk_inf(m, Apb1Gate, Ps20Gate);
+    sprintf_clk_inf(m, Apb1Gate, Ps21Gate);
+    sprintf_clk_inf(m, Apb1Gate, Twi4Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart0Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart1Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart2Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart3Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart4Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart5Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart6Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart7Gate);
+
+    seq_printf(m, "\nNandClk clk infor:\n");
+    sprintf_clk_inf(m, NandClk, ClkDiv);
+    sprintf_clk_inf(m, NandClk, ClkPreDiv);
+    sprintf_clk_inf(m, NandClk, ClkSrc);
+    sprintf_clk_inf(m, NandClk, SpecClkGate);
+
+    seq_printf(m, "\nMsClk clk infor:\n");
+    sprintf_clk_inf(m, MsClk, ClkDiv);
+    sprintf_clk_inf(m, MsClk, ClkPreDiv);
+    sprintf_clk_inf(m, MsClk, ClkSrc);
+    sprintf_clk_inf(m, MsClk, SpecClkGate);
+
+    seq_printf(m, "\nSdMmc0Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc0Clk, ClkDiv);
+    sprintf_clk_inf(m, SdMmc0Clk, ClkPreDiv);
+    sprintf_clk_inf(m, SdMmc0Clk, ClkSrc);
+    sprintf_clk_inf(m, SdMmc0Clk, SpecClkGate);
+
+    seq_printf(m, "\nSdMmc1Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc1Clk, ClkDiv);
+    sprintf_clk_inf(m, SdMmc1Clk, ClkPreDiv);
+    sprintf_clk_inf(m, SdMmc1Clk, ClkSrc);
+    sprintf_clk_inf(m, SdMmc1Clk, SpecClkGate);
+
+    seq_printf(m, "\nSdMmc2Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc2Clk, ClkDiv);
+    sprintf_clk_inf(m, SdMmc2Clk, ClkPreDiv);
+    sprintf_clk_inf(m, SdMmc2Clk, ClkSrc);
+    sprintf_clk_inf(m, SdMmc2Clk, SpecClkGate);
+
+    seq_printf(m, "\nSdMmc3Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc3Clk, ClkDiv);
+    sprintf_clk_inf(m, SdMmc3Clk, ClkPreDiv);
+    sprintf_clk_inf(m, SdMmc3Clk, ClkSrc);
+    sprintf_clk_inf(m, SdMmc3Clk, SpecClkGate);
+
+    seq_printf(m, "\nTsClk clk infor:\n");
+    sprintf_clk_inf(m, TsClk, ClkDiv);
+    sprintf_clk_inf(m, TsClk, ClkPreDiv);
+    sprintf_clk_inf(m, TsClk, ClkSrc);
+    sprintf_clk_inf(m, TsClk, SpecClkGate);
+
+    seq_printf(m, "\nSsClk clk infor:\n");
+    sprintf_clk_inf(m, SsClk, ClkDiv);
+    sprintf_clk_inf(m, SsClk, ClkPreDiv);
+    sprintf_clk_inf(m, SsClk, ClkSrc);
+    sprintf_clk_inf(m, SsClk, SpecClkGate);
+
+    seq_printf(m, "\nSpi0Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi0Clk, ClkDiv);
+    sprintf_clk_inf(m, Spi0Clk, ClkPreDiv);
+    sprintf_clk_inf(m, Spi0Clk, ClkSrc);
+    sprintf_clk_inf(m, Spi0Clk, SpecClkGate);
+
+    seq_printf(m, "\nSpi1Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi1Clk, ClkDiv);
+    sprintf_clk_inf(m, Spi1Clk, ClkPreDiv);
+    sprintf_clk_inf(m, Spi1Clk, ClkSrc);
+    sprintf_clk_inf(m, Spi1Clk, SpecClkGate);
+
+    seq_printf(m, "\nSpi2Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi2Clk, ClkDiv);
+    sprintf_clk_inf(m, Spi2Clk, ClkPreDiv);
+    sprintf_clk_inf(m, Spi2Clk, ClkSrc);
+    sprintf_clk_inf(m, Spi2Clk, SpecClkGate);
+
+    seq_printf(m, "\nPataClk clk infor:\n");
+    sprintf_clk_inf(m, PataClk, ClkDiv);
+    sprintf_clk_inf(m, PataClk, ClkPreDiv);
+    sprintf_clk_inf(m, PataClk, ClkSrc);
+    sprintf_clk_inf(m, PataClk, SpecClkGate);
+
+    seq_printf(m, "\nIr0Clk clk infor:\n");
+    sprintf_clk_inf(m, Ir0Clk, ClkDiv);
+    sprintf_clk_inf(m, Ir0Clk, ClkPreDiv);
+    sprintf_clk_inf(m, Ir0Clk, ClkSrc);
+    sprintf_clk_inf(m, Ir0Clk, SpecClkGate);
+
+    seq_printf(m, "\nIr1Clk clk infor:\n");
+    sprintf_clk_inf(m, Ir1Clk, ClkDiv);
+    sprintf_clk_inf(m, Ir1Clk, ClkPreDiv);
+    sprintf_clk_inf(m, Ir1Clk, ClkSrc);
+    sprintf_clk_inf(m, Ir1Clk, SpecClkGate);
+
+    seq_printf(m, "\nI2sClk clk infor:\n");
+    sprintf_clk_inf(m, I2s0Clk, ClkDiv);
+    sprintf_clk_inf(m, I2s0Clk, SpecClkGate);
+
+
+    seq_printf(m, "\nAc97Clk clk infor:\n");
+    sprintf_clk_inf(m, Ac97Clk, ClkDiv);
+    sprintf_clk_inf(m, Ac97Clk, SpecClkGate);
+
+    seq_printf(m, "\nSpdifClk clk infor:\n");
+    sprintf_clk_inf(m, SpdifClk, ClkDiv);
+    sprintf_clk_inf(m, SpdifClk, SpecClkGate);
+
+    seq_printf(m, "\nKeyPadClk clk infor:\n");
+    sprintf_clk_inf(m, KeyPadClk, ClkDiv);
+    sprintf_clk_inf(m, KeyPadClk, ClkPreDiv);
+    sprintf_clk_inf(m, KeyPadClk, ClkSrc);
+    sprintf_clk_inf(m, KeyPadClk, SpecClkGate);
+
+    seq_printf(m, "\nSataClk clk infor:\n");
+    sprintf_clk_inf(m, SataClk, ClkSrc);
+    sprintf_clk_inf(m, SataClk, SpecClkGate);
+
+    seq_printf(m, "\nUsbClk clk infor:\n");
+    sprintf_clk_inf(m, UsbClk, UsbPhy0Rst);
+    sprintf_clk_inf(m, UsbClk, UsbPhy1Rst);
+    sprintf_clk_inf(m, UsbClk, UsbPhy2Rst);
+    /* REMOVED */
+    //sprintf_clk_inf(m, UsbClk, OHCIClkSrc);
+    sprintf_clk_inf(m, UsbClk, OHCI0SpecClkGate);
+    sprintf_clk_inf(m, UsbClk, OHCI1SpecClkGate);
+    sprintf_clk_inf(m, UsbClk, PhySpecClkGate);
+
+    /* REMOVED */
+    //seq_printf(m, "\nGpsClk clk infor:\n");
+    //sprintf_clk_inf(m, GpsClk, ClkDivRatio);
+    //sprintf_clk_inf(m, GpsClk, ClkSrc);
+    //sprintf_clk_inf(m, GpsClk, Reset);
+    //sprintf_clk_inf(m, GpsClk, SpecClkGate);
+
+    seq_printf(m, "\nSpi3Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi3Clk, ClkDiv);
+    sprintf_clk_inf(m, Spi3Clk, ClkPreDiv);
+    sprintf_clk_inf(m, Spi3Clk, ClkSrc);
+    sprintf_clk_inf(m, Spi3Clk, SpecClkGate);
+
+    seq_printf(m, "\nI2s1Clk clk infor:\n");
+    sprintf_clk_inf(m, I2s1Clk, ClkDiv);
+    sprintf_clk_inf(m, I2s1Clk, SpecClkGate);
+
+    seq_printf(m, "\nI2s2Clk clk infor:\n");
+    sprintf_clk_inf(m, I2s2Clk, ClkDiv);
+    sprintf_clk_inf(m, I2s2Clk, SpecClkGate);
+
+    seq_printf(m, "\nDramGate clk infor:\n");
+    sprintf_clk_inf(m, DramGate, VeGate);
+    sprintf_clk_inf(m, DramGate, Csi0Gate);
+    sprintf_clk_inf(m, DramGate, Csi1Gate);
+    sprintf_clk_inf(m, DramGate, TsGate);
+    sprintf_clk_inf(m, DramGate, TvdGate);
+    sprintf_clk_inf(m, DramGate, Tve0Gate);
+    sprintf_clk_inf(m, DramGate, Tve1Gate);
+    sprintf_clk_inf(m, DramGate, ClkOutputEn);
+    sprintf_clk_inf(m, DramGate, DeFe0Gate);
+    sprintf_clk_inf(m, DramGate, DeFe1Gate);
+    sprintf_clk_inf(m, DramGate, DeBe0Gate);
+    sprintf_clk_inf(m, DramGate, DeBe1Gate);
+    sprintf_clk_inf(m, DramGate, DeMpGate);
+    sprintf_clk_inf(m, DramGate, AceGate);
+
+    seq_printf(m, "\nDeBe0Clk clk infor:\n");
+    sprintf_clk_inf(m, DeBe0Clk, ClkDiv);
+    sprintf_clk_inf(m, DeBe0Clk, ClkSrc);
+    sprintf_clk_inf(m, DeBe0Clk, Reset);
+    sprintf_clk_inf(m, DeBe0Clk, SpecClkGate);
+
+    seq_printf(m, "\nDeBe1Clk clk infor:\n");
+    sprintf_clk_inf(m, DeBe1Clk, ClkDiv);
+    sprintf_clk_inf(m, DeBe1Clk, ClkSrc);
+    sprintf_clk_inf(m, DeBe1Clk, Reset);
+    sprintf_clk_inf(m, DeBe1Clk, SpecClkGate);
+
+    seq_printf(m, "\nDeFe0Clk clk infor:\n");
+    sprintf_clk_inf(m, DeFe0Clk, ClkDiv);
+    sprintf_clk_inf(m, DeFe0Clk, ClkSrc);
+    sprintf_clk_inf(m, DeFe0Clk, Reset);
+    sprintf_clk_inf(m, DeFe0Clk, SpecClkGate);
+
+    seq_printf(m, "\nDeFe1Clk clk infor:\n");
+    sprintf_clk_inf(m, DeFe1Clk, ClkDiv);
+    sprintf_clk_inf(m, DeFe1Clk, ClkSrc);
+    sprintf_clk_inf(m, DeFe1Clk, Reset);
+    sprintf_clk_inf(m, DeFe1Clk, SpecClkGate);
+
+    seq_printf(m, "\nDeMpClk clk infor:\n");
+    sprintf_clk_inf(m, DeMpClk, ClkDiv);
+    sprintf_clk_inf(m, DeMpClk, ClkSrc);
+    sprintf_clk_inf(m, DeMpClk, Reset);
+    sprintf_clk_inf(m, DeMpClk, SpecClkGate);
+
+    seq_printf(m, "\nLcd0Ch0Clk clk infor:\n");
+    sprintf_clk_inf(m, Lcd0Ch0Clk, ClkSrc);
+    sprintf_clk_inf(m, Lcd0Ch0Clk, Reset);
+    sprintf_clk_inf(m, Lcd0Ch0Clk, SpecClkGate);
+
+    seq_printf(m, "\nLcd1Ch0Clk clk infor:\n");
+    sprintf_clk_inf(m, Lcd1Ch0Clk, ClkSrc);
+    sprintf_clk_inf(m, Lcd1Ch0Clk, Reset);
+    sprintf_clk_inf(m, Lcd1Ch0Clk, SpecClkGate);
+
+    seq_printf(m, "\nCsiIspClk clk infor:\n");
+    sprintf_clk_inf(m, CsiIspClk, ClkDiv);
+    sprintf_clk_inf(m, CsiIspClk, ClkSrc);
+    sprintf_clk_inf(m, CsiIspClk, SpecClkGate);
+
+    seq_printf(m, "\nTvdClk clk infor:\n");
+    sprintf_clk_inf(m, TvdClk, Clk1Div);
+    sprintf_clk_inf(m, TvdClk, Clk1Src);
+    sprintf_clk_inf(m, TvdClk, Clk1Gate);
+    sprintf_clk_inf(m, TvdClk, Clk2Div);
+    sprintf_clk_inf(m, TvdClk, Clk2Src);
+    sprintf_clk_inf(m, TvdClk, Clk2Gate);
+
+    seq_printf(m, "\nLcd0Ch1Clk clk infor:\n");
+    sprintf_clk_inf(m, Lcd0Ch1Clk, ClkDiv);
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk1Src);
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk1Gate);
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk2Src);
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk2Gate);
+
+    seq_printf(m, "\nLcd1Ch1Clk clk infor:\n");
+    sprintf_clk_inf(m, Lcd1Ch1Clk, ClkDiv);
+    sprintf_clk_inf(m, Lcd1Ch1Clk, SpecClk1Src);
+    sprintf_clk_inf(m, Lcd1Ch1Clk, SpecClk1Gate);
+    sprintf_clk_inf(m, Lcd1Ch1Clk, SpecClk2Src);
+    sprintf_clk_inf(m, Lcd1Ch1Clk, SpecClk2Gate);
+
+    seq_printf(m, "\nCsi0Clk clk infor:\n");
+    sprintf_clk_inf(m, Csi0Clk, ClkDiv);
+    sprintf_clk_inf(m, Csi0Clk, ClkSrc);
+    sprintf_clk_inf(m, Csi0Clk, Reset);
+    sprintf_clk_inf(m, Csi0Clk, SpecClkGate);
+
+    seq_printf(m, "\nCsi1Clk clk infor:\n");
+    sprintf_clk_inf(m, Csi1Clk, ClkDiv);
+    sprintf_clk_inf(m, Csi1Clk, ClkSrc);
+    sprintf_clk_inf(m, Csi1Clk, Reset);
+    sprintf_clk_inf(m, Csi1Clk, SpecClkGate);
+
+    seq_printf(m, "\nVeClk clk infor:\n");
+    sprintf_clk_inf(m, VeClk, Reset);
+    sprintf_clk_inf(m, VeClk, ClkDiv);
+    sprintf_clk_inf(m, VeClk, SpecClkGate);
+
+    seq_printf(m, "\nAddaClk clk infor:\n");
+    sprintf_clk_inf(m, AddaClk, SpecClkGate);
+
+    seq_printf(m, "\nAvsClk clk infor:\n");
+    sprintf_clk_inf(m, AvsClk, SpecClkGate);
+
+    seq_printf(m, "\nAceClk clk infor:\n");
+    sprintf_clk_inf(m, AceClk, ClkDiv);
+    sprintf_clk_inf(m, AceClk, Reset);
+    sprintf_clk_inf(m, AceClk, ClkSrc);
+    sprintf_clk_inf(m, AceClk, SpecClkGate);
+
+    seq_printf(m, "\nLvdsClk clk infor:\n");
+    sprintf_clk_inf(m, LvdsClk, Reset);
+
+    seq_printf(m, "\nHdmiClk clk infor:\n");
+    sprintf_clk_inf(m, HdmiClk, ClkDiv);
+    sprintf_clk_inf(m, HdmiClk, ClkSrc);
+    sprintf_clk_inf(m, HdmiClk, SpecClkGate);
+
+    seq_printf(m, "\nMaliClk clk infor:\n");
+    sprintf_clk_inf(m, MaliClk, ClkDiv);
+    sprintf_clk_inf(m, MaliClk, ClkSrc);
+    sprintf_clk_inf(m, MaliClk, Reset);
+    sprintf_clk_inf(m, MaliClk, SpecClkGate);
+
+    seq_printf(m, "\nMBusClk clk infor:\n");
+    sprintf_clk_inf(m, MBusClk, ClkDivM);
+    sprintf_clk_inf(m, MBusClk, ClkDivN);
+    sprintf_clk_inf(m, MBusClk, ClkSrc);
+    sprintf_clk_inf(m, MBusClk, ClkGate);
+
+    seq_printf(m, "\nGmacClk clk infor:\n");
+    sprintf_clk_inf(m, GmacClk, TxClkSrc);
+    sprintf_clk_inf(m, GmacClk, PhyIT);
+    sprintf_clk_inf(m, GmacClk, TxClkInv);
+    sprintf_clk_inf(m, GmacClk, RxClkInv);
+    sprintf_clk_inf(m, GmacClk, RxDlyChain);
+    sprintf_clk_inf(m, GmacClk, ClkDiv);
+
+    seq_printf(m, "\nClkOutA clk infor:\n");
+    sprintf_clk_inf(m, ClkOutA, ClkDivM);
+    sprintf_clk_inf(m, ClkOutA, ClkDivN);
+    sprintf_clk_inf(m, ClkOutA, ClkSrc);
+    sprintf_clk_inf(m, ClkOutA, ClkEn);
+
+    seq_printf(m, "\nClkOutB clk infor:\n");
+    sprintf_clk_inf(m, ClkOutB, ClkDivM);
+    sprintf_clk_inf(m, ClkOutB, ClkDivN);
+    sprintf_clk_inf(m, ClkOutB, ClkSrc);
+    sprintf_clk_inf(m, ClkOutB, ClkEn);
+
+    return 0;
+}
+
+
+static int ccmu_stats_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, ccmu_stats_show, NULL);
+}
+
+static const struct file_operations ccmu_dbg_fops = {
+    .owner = THIS_MODULE,
+    .open = ccmu_stats_open,
+    .read = seq_read,
+    .llseek = seq_lseek,
+    .release = single_release,
+};
+
+static int __init ccu_dbg_init(void)
+{
+
+     aw_ccu_reg = ioremap(0x01c20000, 0x0200);
+    /* create /proc/ccmu */
+    proc_create("ccmu", S_IRUGO, NULL, &ccmu_dbg_fops);
+    return 0;
+}
+
+static void  __exit ccu_dbg_exit(void)
+{
+    remove_proc_entry("ccmu", NULL);
+}
+
+core_initcall(ccu_dbg_init);
+module_exit(ccu_dbg_exit);
+
+#endif
