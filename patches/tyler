Bottom: 4e66e9c5a88e22a68319fdf2517ebee1954ad140
Top:    f4b0d0d0e46935b8c70254c5761a3099887ecf53
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-07-18 14:38:45 -0400

TAS5716 support for Tyler


---

diff --git a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
index e316509..df6414e 100644
--- a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
+++ b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
@@ -112,13 +112,19 @@
 			status = "okay";
 		};
 
-		codec@01c22c00 {
+		ir0: ir@01c21800 {
+			pinctrl-names = "default";
+			pinctrl-0 = <&ir0_pins_a>;
 			status = "okay";
 		};
 
-		ir0: ir@01c21800 {
+		iis0: iis@01c22000 {
 			pinctrl-names = "default";
-			pinctrl-0 = <&ir0_pins_a>;
+			/*pinctrl-0 = <&iis0_pins_a>;*/
+			status = "okay";
+		};
+
+		codec: codec@01c22c00 {
 			status = "okay";
 		};
 
@@ -148,6 +154,12 @@
 			pinctrl-names = "default";
 			pinctrl-0 = <&i2c1_pins_a>;
 			status = "okay";
+
+			tas5716: tas5716@36 {
+				compatible = "ti,tas5716";
+				reg = <0x36>;
+				#sound-dai-cells = <0>;
+			};
 		};
 
 		i2c2: i2c@01c2b400 {
@@ -169,6 +181,33 @@
 		};
 	};
 
+	sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,routing =
+			"Headphone Jack", "HPL",
+			"Headphone Jack", "HPR",
+			"Speaker", "SPKOUT",
+			"Speaker", "SPKOUTN",
+			"MIC1", "Mic Jack",
+			"MIC2", "Mic Jack";
+		simple-audio-card,widgets =
+			"Headphone", "Headphone Jack",
+			"Speaker", "Speaker",
+			"Microphone", "Mic Jack";
+
+		simple-audio-card,mclk-fs = <256>;
+
+		simple-audio-card,cpu {
+			sound-dai = <&iis0>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&tas5716>;
+		};
+	};
+
+
 	leds {
 		compatible = "gpio-leds";
 		pinctrl-names = "default";
diff --git a/arch/arm/boot/dts/sun7i-a20.dtsi b/arch/arm/boot/dts/sun7i-a20.dtsi
index b06f9b0..db6d51b 100644
--- a/arch/arm/boot/dts/sun7i-a20.dtsi
+++ b/arch/arm/boot/dts/sun7i-a20.dtsi
@@ -874,6 +874,42 @@
 			status = "disabled";
 		};
 
+		iis0: iis@01c22000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun7i-a20-iis";
+			reg = <0x01C22000 0x40>;
+			interrupts = <0 16 4>;
+			clocks = <&pll2 0>, <&apb0_gates 3>, <&iis0_clk>;
+			clock-names = "pll2", "apb", "iis";
+			dmas = <&dma 0 3>, <&dma 0 3>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		iis1: iis@01c22400 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun7i-a20-iis";
+			reg = <0x01C22400 0x40>;
+			interrupts = <0 87 4>;
+			clocks = <&pll2 0>, <&apb0_gates 4>, <&iis1_clk>;
+			clock-names = "pll2", "apb", "iis";
+			dmas = <&dma 0 4>, <&dma 0 4>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		iis2: iis@01c24400 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun7i-a20-iis";
+			reg = <0x01C24400 0x40>;
+			interrupts = <0 90 4>;
+			clocks = <&pll2 0>, <&apb0_gates 8>, <&iis2_clk>;
+			clock-names = "pll2", "apb", "iis";
+			dmas = <&dma 0 6>, <&dma 0 6>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
 		codec: codec@01c22c00 {
 			#sound-dai-cells = <0>;
 			compatible = "allwinner,sun7i-a20-codec";
diff --git a/include/sound/tas5716.h b/include/sound/tas5716.h
new file mode 100644
index 0000000..33e1be3
--- /dev/null
+++ b/include/sound/tas5716.h
@@ -0,0 +1,57 @@
+/*
+ * Platform data for TI TAS5716 ASoC codec driver.
+ *
+ * Copyright: 2014 Raumfeld GmbH
+ * Author: Sven Brandau <info@brandau.biz>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifndef __LINUX_SND__TAS5716_H
+#define __LINUX_SND__TAS5716_H
+
+#define TAS5716_OCFG_2CH		0
+#define TAS5716_OCFG_2_1CH	1
+#define TAS5716_OCFG_1CH		3
+
+#define TAS5716_OM_CH1		0
+#define TAS5716_OM_CH2		1
+#define TAS5716_OM_CH3		2
+
+#define TAS5716_THERMAL_ADJUSTMENT_ENABLE	1
+#define TAS5716_THERMAL_RECOVERY_ENABLE		2
+#define TAS5716_FAULT_DETECT_RECOVERY_BYPASS	1
+
+#define TAS5716_FFX_PM_DROP_COMP			0
+#define TAS5716_FFX_PM_TAPERED_COMP		1
+#define TAS5716_FFX_PM_FULL_POWER		2
+#define TAS5716_FFX_PM_VARIABLE_DROP_COMP	3
+
+
+struct tas5716_platform_data {
+	u8 output_conf;
+	u8 ch1_output_mapping;
+	u8 ch2_output_mapping;
+	u8 ch3_output_mapping;
+	u8 ffx_power_output_mode;
+	u8 drop_compensation_ns;
+	u8 powerdown_delay_divider;
+	unsigned int thermal_warning_recovery:1;
+	unsigned int thermal_warning_adjustment:1;
+	unsigned int fault_detect_recovery:1;
+	unsigned int oc_warning_adjustment:1;
+	unsigned int max_power_use_mpcc:1;
+	unsigned int max_power_correction:1;
+	unsigned int am_reduction_mode:1;
+	unsigned int odd_pwm_speed_mode:1;
+	unsigned int distortion_compensation:1;
+	unsigned int invalid_input_detect_mute:1;
+	unsigned int activate_mute_output:1;
+	unsigned int bridge_immediate_off:1;
+	unsigned int noise_shape_dc_cut:1;
+	unsigned int powerdown_master_vol:1;
+};
+
+#endif /* __LINUX_SND__TAS5716_H */
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 0b9571c..94a6bc8 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -92,6 +92,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_STA529 if I2C
 	select SND_SOC_STAC9766 if SND_SOC_AC97_BUS
 	select SND_SOC_TAS5086 if I2C
+	select SND_SOC_TAS5716 if I2C
 	select SND_SOC_TLV320AIC23_I2C if I2C
 	select SND_SOC_TLV320AIC23_SPI if SPI_MASTER
 	select SND_SOC_TLV320AIC26 if SPI_MASTER
@@ -525,6 +526,11 @@ config SND_SOC_TAS5086
 	tristate "Texas Instruments TAS5086 speaker amplifier"
 	depends on I2C
 
+config SND_SOC_TAS5716
+	tristate "Texas Instruments TAS5716 speaker amplifier"
+	select REGMAP_I2C
+	depends on I2C
+
 config SND_SOC_TLV320AIC23
 	tristate
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 1bd6e1c..dc18e5d 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -93,6 +93,7 @@ snd-soc-sta350-objs := sta350.o
 snd-soc-sta529-objs := sta529.o
 snd-soc-stac9766-objs := stac9766.o
 snd-soc-tas5086-objs := tas5086.o
+snd-soc-tas5716-objs := tas5716.o
 snd-soc-tlv320aic23-objs := tlv320aic23.o
 snd-soc-tlv320aic23-i2c-objs := tlv320aic23-i2c.o
 snd-soc-tlv320aic23-spi-objs := tlv320aic23-spi.o
@@ -256,6 +257,7 @@ obj-$(CONFIG_SND_SOC_STA350)   += snd-soc-sta350.o
 obj-$(CONFIG_SND_SOC_STA529)   += snd-soc-sta529.o
 obj-$(CONFIG_SND_SOC_STAC9766)	+= snd-soc-stac9766.o
 obj-$(CONFIG_SND_SOC_TAS5086)	+= snd-soc-tas5086.o
+obj-$(CONFIG_SND_SOC_TAS5716)	+= snd-soc-tas5716.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23)	+= snd-soc-tlv320aic23.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23_I2C)	+= snd-soc-tlv320aic23-i2c.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23_SPI)	+= snd-soc-tlv320aic23-spi.o
diff --git a/sound/soc/codecs/tas5716.c b/sound/soc/codecs/tas5716.c
new file mode 100644
index 0000000..2e3316d
--- /dev/null
+++ b/sound/soc/codecs/tas5716.c
@@ -0,0 +1,1315 @@
+/*
+ * Codec driver for TI TAS5716 2.1-channel high-efficiency digital audio system
+ *
+ * Copyright: 2014 Raumfeld GmbH
+ * Author: Sven Brandau <info@brandau.biz>
+ *
+ * based on code from:
+ *	Raumfeld GmbH
+ *	  Johannes Stezenbach <js@sig21.net>
+ *	Wolfson Microelectronics PLC.
+ *	  Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *	Freescale Semiconductor, Inc.
+ *	  Timur Tabi <timur@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ":%s:%d: " fmt, __func__, __LINE__
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/gpio/consumer.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include <sound/tas5716.h>
+#include "tas5716.h"
+
+#define TAS5716_RATES (SNDRV_PCM_RATE_32000 | \
+		      SNDRV_PCM_RATE_44100 | \
+		      SNDRV_PCM_RATE_48000 | \
+		      SNDRV_PCM_RATE_88200 | \
+		      SNDRV_PCM_RATE_96000 | \
+		      SNDRV_PCM_RATE_176400 | \
+		      SNDRV_PCM_RATE_192000)
+
+#define TAS5716_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE  | SNDRV_PCM_FMTBIT_S16_BE  | \
+	 SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S18_3BE | \
+	 SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S20_3BE | \
+	 SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_3BE | \
+	 SNDRV_PCM_FMTBIT_S24_LE  | SNDRV_PCM_FMTBIT_S24_BE  | \
+	 SNDRV_PCM_FMTBIT_S32_LE  | SNDRV_PCM_FMTBIT_S32_BE)
+
+/* Power-up register defaults */
+static const struct reg_default tas5716_regs[] = {
+	{  0x0, 0x63 },
+	{  0x1, 0x80 },
+	{  0x2, 0xdf },
+	{  0x3, 0x40 },
+	{  0x4, 0xc2 },
+	{  0x5, 0x5c },
+	{  0x6, 0x00 },
+	{  0x7, 0xff },
+	{  0x8, 0x60 },
+	{  0x9, 0x60 },
+	{  0xa, 0x60 },
+	{  0xb, 0x00 },
+	{  0xc, 0x00 },
+	{  0xd, 0x00 },
+	{  0xe, 0x00 },
+	{  0xf, 0x40 },
+	{ 0x10, 0x80 },
+	{ 0x11, 0x77 },
+	{ 0x12, 0x6a },
+	{ 0x13, 0x69 },
+	{ 0x14, 0x6a },
+	{ 0x15, 0x69 },
+	{ 0x16, 0x00 },
+	{ 0x17, 0x00 },
+	{ 0x18, 0x00 },
+	{ 0x19, 0x00 },
+	{ 0x1a, 0x00 },
+	{ 0x1b, 0x00 },
+	{ 0x1c, 0x00 },
+	{ 0x1d, 0x00 },
+	{ 0x1e, 0x00 },
+	{ 0x1f, 0x00 },
+	{ 0x20, 0x00 },
+	{ 0x21, 0x00 },
+	{ 0x22, 0x00 },
+	{ 0x23, 0x00 },
+	{ 0x24, 0x00 },
+	{ 0x25, 0x00 },
+	{ 0x26, 0x00 },
+	{ 0x27, 0x2a },
+	{ 0x28, 0xc0 },
+	{ 0x29, 0xf3 },
+	{ 0x2a, 0x33 },
+	{ 0x2b, 0x00 },
+	{ 0x2c, 0x0c },
+	{ 0x31, 0x00 },
+	{ 0x36, 0x00 },
+	{ 0x37, 0x00 },
+	{ 0x38, 0x00 },
+	{ 0x39, 0x01 },
+	{ 0x3a, 0xee },
+	{ 0x3b, 0xff },
+	{ 0x3c, 0x7e },
+	{ 0x3d, 0xc0 },
+	{ 0x3e, 0x26 },
+	{ 0x3f, 0x00 },
+	{ 0x48, 0x00 },
+	{ 0x49, 0x00 },
+	{ 0x4a, 0x00 },
+	{ 0x4b, 0x04 },
+	{ 0x4c, 0x00 },
+};
+
+static const struct regmap_range tas5716_write_regs_range[] = {
+	regmap_reg_range(TAS5716_CONFA,  TAS5716_AUTO2),
+	regmap_reg_range(TAS5716_C1CFG,  TAS5716_FDRC2),
+	regmap_reg_range(TAS5716_EQCFG,  TAS5716_EVOLRES),
+	regmap_reg_range(TAS5716_NSHAPE, TAS5716_MISC2),
+};
+
+static const struct regmap_range tas5716_read_regs_range[] = {
+	regmap_reg_range(TAS5716_CONFA,  TAS5716_AUTO2),
+	regmap_reg_range(TAS5716_C1CFG,  TAS5716_STATUS),
+	regmap_reg_range(TAS5716_EQCFG,  TAS5716_EVOLRES),
+	regmap_reg_range(TAS5716_NSHAPE, TAS5716_MISC2),
+};
+
+static const struct regmap_range tas5716_volatile_regs_range[] = {
+	regmap_reg_range(TAS5716_CFADDR2, TAS5716_CFUD),
+	regmap_reg_range(TAS5716_STATUS,  TAS5716_STATUS),
+};
+
+static const struct regmap_access_table tas5716_write_regs = {
+	.yes_ranges =	tas5716_write_regs_range,
+	.n_yes_ranges =	ARRAY_SIZE(tas5716_write_regs_range),
+};
+
+static const struct regmap_access_table tas5716_read_regs = {
+	.yes_ranges =	tas5716_read_regs_range,
+	.n_yes_ranges =	ARRAY_SIZE(tas5716_read_regs_range),
+};
+
+static const struct regmap_access_table tas5716_volatile_regs = {
+	.yes_ranges =	tas5716_volatile_regs_range,
+	.n_yes_ranges =	ARRAY_SIZE(tas5716_volatile_regs_range),
+};
+
+/* regulator power supply names */
+static const char * const tas5716_supply_names[] = {
+	"vdd-dig",	/* digital supply, 3.3V */
+	"vdd-pll",	/* pll supply, 3.3V */
+	"vcc"		/* power amp supply, 5V - 26V */
+};
+
+/* codec private data */
+struct tas5716_priv {
+	struct regmap *regmap;
+	struct regulator_bulk_data supplies[ARRAY_SIZE(tas5716_supply_names)];
+	struct tas5716_platform_data *pdata;
+
+	unsigned int mclk;
+	unsigned int format;
+
+	u32 coef_shadow[TAS5716_COEF_COUNT];
+	int shutdown;
+
+	struct gpio_desc *gpiod_nreset;
+	struct gpio_desc *gpiod_power_down;
+
+	struct mutex coeff_lock;
+};
+
+static const DECLARE_TLV_DB_SCALE(mvol_tlv, -12750, 50, 1);
+static const DECLARE_TLV_DB_SCALE(chvol_tlv, -7950, 50, 1);
+static const DECLARE_TLV_DB_SCALE(tone_tlv, -1200, 200, 0);
+
+static const char * const tas5716_drc_ac[] = {
+	"Anti-Clipping", "Dynamic Range Compression"
+};
+static const char * const tas5716_auto_gc_mode[] = {
+	"User", "AC no clipping", "AC limited clipping (10%)",
+	"DRC nighttime listening mode"
+};
+static const char * const tas5716_auto_xo_mode[] = {
+	"User", "80Hz", "100Hz", "120Hz", "140Hz", "160Hz", "180Hz",
+	"200Hz", "220Hz", "240Hz", "260Hz", "280Hz", "300Hz", "320Hz",
+	"340Hz", "360Hz"
+};
+static const char * const tas5716_binary_output[] = {
+	"FFX 3-state output - normal operation", "Binary output"
+};
+static const char * const tas5716_limiter_select[] = {
+	"Limiter Disabled", "Limiter #1", "Limiter #2"
+};
+static const char * const tas5716_limiter_attack_rate[] = {
+	"3.1584", "2.7072", "2.2560", "1.8048", "1.3536", "0.9024",
+	"0.4512", "0.2256", "0.1504", "0.1123", "0.0902", "0.0752",
+	"0.0645", "0.0564", "0.0501", "0.0451"
+};
+static const char * const tas5716_limiter_release_rate[] = {
+	"0.5116", "0.1370", "0.0744", "0.0499", "0.0360", "0.0299",
+	"0.0264", "0.0208", "0.0198", "0.0172", "0.0147", "0.0137",
+	"0.0134", "0.0117", "0.0110", "0.0104"
+};
+static const char * const tas5716_noise_shaper_type[] = {
+	"Third order", "Fourth order"
+};
+
+static DECLARE_TLV_DB_RANGE(tas5716_limiter_ac_attack_tlv,
+	0, 7, TLV_DB_SCALE_ITEM(-1200, 200, 0),
+	8, 16, TLV_DB_SCALE_ITEM(300, 100, 0),
+);
+
+static DECLARE_TLV_DB_RANGE(tas5716_limiter_ac_release_tlv,
+	0, 0, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 0),
+	1, 1, TLV_DB_SCALE_ITEM(-2900, 0, 0),
+	2, 2, TLV_DB_SCALE_ITEM(-2000, 0, 0),
+	3, 8, TLV_DB_SCALE_ITEM(-1400, 200, 0),
+	8, 16, TLV_DB_SCALE_ITEM(-700, 100, 0),
+);
+
+static DECLARE_TLV_DB_RANGE(tas5716_limiter_drc_attack_tlv,
+	0, 7, TLV_DB_SCALE_ITEM(-3100, 200, 0),
+	8, 13, TLV_DB_SCALE_ITEM(-1600, 100, 0),
+	14, 16, TLV_DB_SCALE_ITEM(-1000, 300, 0),
+);
+
+static DECLARE_TLV_DB_RANGE(tas5716_limiter_drc_release_tlv,
+	0, 0, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 0),
+	1, 2, TLV_DB_SCALE_ITEM(-3800, 200, 0),
+	3, 4, TLV_DB_SCALE_ITEM(-3300, 200, 0),
+	5, 12, TLV_DB_SCALE_ITEM(-3000, 200, 0),
+	13, 16, TLV_DB_SCALE_ITEM(-1500, 300, 0),
+);
+
+static SOC_ENUM_SINGLE_DECL(tas5716_drc_ac_enum,
+			    TAS5716_CONFD, TAS5716_CONFD_DRC_SHIFT,
+			    tas5716_drc_ac);
+static SOC_ENUM_SINGLE_DECL(tas5716_noise_shaper_enum,
+			    TAS5716_CONFE, TAS5716_CONFE_NSBW_SHIFT,
+			    tas5716_noise_shaper_type);
+static SOC_ENUM_SINGLE_DECL(tas5716_auto_gc_enum,
+			    TAS5716_AUTO1, TAS5716_AUTO1_AMGC_SHIFT,
+			    tas5716_auto_gc_mode);
+static SOC_ENUM_SINGLE_DECL(tas5716_auto_xo_enum,
+			    TAS5716_AUTO2, TAS5716_AUTO2_XO_SHIFT,
+			    tas5716_auto_xo_mode);
+static SOC_ENUM_SINGLE_DECL(tas5716_binary_output_ch1_enum,
+			    TAS5716_C1CFG, TAS5716_CxCFG_BO_SHIFT,
+			    tas5716_binary_output);
+static SOC_ENUM_SINGLE_DECL(tas5716_binary_output_ch2_enum,
+			    TAS5716_C2CFG, TAS5716_CxCFG_BO_SHIFT,
+			    tas5716_binary_output);
+static SOC_ENUM_SINGLE_DECL(tas5716_binary_output_ch3_enum,
+			    TAS5716_C3CFG, TAS5716_CxCFG_BO_SHIFT,
+			    tas5716_binary_output);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter_ch1_enum,
+			    TAS5716_C1CFG, TAS5716_CxCFG_LS_SHIFT,
+			    tas5716_limiter_select);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter_ch2_enum,
+			    TAS5716_C2CFG, TAS5716_CxCFG_LS_SHIFT,
+			    tas5716_limiter_select);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter_ch3_enum,
+			    TAS5716_C3CFG, TAS5716_CxCFG_LS_SHIFT,
+			    tas5716_limiter_select);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter1_attack_rate_enum,
+			    TAS5716_L1AR, TAS5716_LxA_SHIFT,
+			    tas5716_limiter_attack_rate);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter2_attack_rate_enum,
+			    TAS5716_L2AR, TAS5716_LxA_SHIFT,
+			    tas5716_limiter_attack_rate);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter1_release_rate_enum,
+			    TAS5716_L1AR, TAS5716_LxR_SHIFT,
+			    tas5716_limiter_release_rate);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter2_release_rate_enum,
+			    TAS5716_L2AR, TAS5716_LxR_SHIFT,
+			    tas5716_limiter_release_rate);
+
+/*
+ * byte array controls for setting biquad, mixer, scaling coefficients;
+ * for biquads all five coefficients need to be set in one go,
+ * mixer and pre/postscale coefs can be set individually;
+ * each coef is 24bit, the bytes are ordered in the same way
+ * as given in the TAS5716 data sheet (big endian; b1, b2, a1, a2, b0)
+ */
+
+static int tas5716_coefficient_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+	int numcoef = kcontrol->private_value >> 16;
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	uinfo->count = 3 * numcoef;
+	return 0;
+}
+
+static int tas5716_coefficient_get(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	int numcoef = kcontrol->private_value >> 16;
+	int index = kcontrol->private_value & 0xffff;
+	unsigned int cfud, val;
+	int i, ret = 0;
+
+	mutex_lock(&tas5716->coeff_lock);
+
+	/* preserve reserved bits in TAS5716_CFUD */
+	regmap_read(tas5716->regmap, TAS5716_CFUD, &cfud);
+	cfud &= 0xf0;
+	/*
+	 * chip documentation does not say if the bits are self clearing,
+	 * so do it explicitly
+	 */
+	regmap_write(tas5716->regmap, TAS5716_CFUD, cfud);
+
+	regmap_write(tas5716->regmap, TAS5716_CFADDR2, index);
+	if (numcoef == 1) {
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud | 0x04);
+	} else if (numcoef == 5) {
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud | 0x08);
+	} else {
+		ret = -EINVAL;
+		goto exit_unlock;
+	}
+
+	for (i = 0; i < 3 * numcoef; i++) {
+		regmap_read(tas5716->regmap, TAS5716_B1CF1 + i, &val);
+		ucontrol->value.bytes.data[i] = val;
+	}
+
+exit_unlock:
+	mutex_unlock(&tas5716->coeff_lock);
+
+	return ret;
+}
+
+static int tas5716_coefficient_put(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	int numcoef = kcontrol->private_value >> 16;
+	int index = kcontrol->private_value & 0xffff;
+	unsigned int cfud;
+	int i;
+
+	/* preserve reserved bits in TAS5716_CFUD */
+	regmap_read(tas5716->regmap, TAS5716_CFUD, &cfud);
+	cfud &= 0xf0;
+	/*
+	 * chip documentation does not say if the bits are self clearing,
+	 * so do it explicitly
+	 */
+	regmap_write(tas5716->regmap, TAS5716_CFUD, cfud);
+
+	regmap_write(tas5716->regmap, TAS5716_CFADDR2, index);
+	for (i = 0; i < numcoef && (index + i < TAS5716_COEF_COUNT); i++)
+		tas5716->coef_shadow[index + i] =
+			  (ucontrol->value.bytes.data[3 * i] << 16)
+			| (ucontrol->value.bytes.data[3 * i + 1] << 8)
+			| (ucontrol->value.bytes.data[3 * i + 2]);
+	for (i = 0; i < 3 * numcoef; i++)
+		regmap_write(tas5716->regmap, TAS5716_B1CF1 + i,
+			     ucontrol->value.bytes.data[i]);
+	if (numcoef == 1)
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud | 0x01);
+	else if (numcoef == 5)
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud | 0x02);
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int tas5716_sync_coef_shadow(struct snd_soc_codec *codec)
+{
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	unsigned int cfud;
+	int i;
+
+	/* preserve reserved bits in TAS5716_CFUD */
+	regmap_read(tas5716->regmap, TAS5716_CFUD, &cfud);
+	cfud &= 0xf0;
+
+	for (i = 0; i < TAS5716_COEF_COUNT; i++) {
+		regmap_write(tas5716->regmap, TAS5716_CFADDR2, i);
+		regmap_write(tas5716->regmap, TAS5716_B1CF1,
+			     (tas5716->coef_shadow[i] >> 16) & 0xff);
+		regmap_write(tas5716->regmap, TAS5716_B1CF2,
+			     (tas5716->coef_shadow[i] >> 8) & 0xff);
+		regmap_write(tas5716->regmap, TAS5716_B1CF3,
+			     (tas5716->coef_shadow[i]) & 0xff);
+		/*
+		 * chip documentation does not say if the bits are
+		 * self-clearing, so do it explicitly
+		 */
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud);
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud | 0x01);
+	}
+	return 0;
+}
+
+static int tas5716_cache_sync(struct snd_soc_codec *codec)
+{
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	unsigned int mute;
+	int rc;
+
+	/* mute during register sync */
+	regmap_read(tas5716->regmap, TAS5716_CFUD, &mute);
+	regmap_write(tas5716->regmap, TAS5716_MMUTE, mute | TAS5716_MMUTE_MMUTE);
+	tas5716_sync_coef_shadow(codec);
+	rc = regcache_sync(tas5716->regmap);
+	regmap_write(tas5716->regmap, TAS5716_MMUTE, mute);
+	return rc;
+}
+
+#define SINGLE_COEF(xname, index) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = tas5716_coefficient_info, \
+	.get = tas5716_coefficient_get,\
+	.put = tas5716_coefficient_put, \
+	.private_value = index | (1 << 16) }
+
+#define BIQUAD_COEFS(xname, index) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = tas5716_coefficient_info, \
+	.get = tas5716_coefficient_get,\
+	.put = tas5716_coefficient_put, \
+	.private_value = index | (5 << 16) }
+
+static const struct snd_kcontrol_new tas5716_snd_controls[] = {
+SOC_SINGLE_TLV("Master Volume", TAS5716_MVOL, 0, 0xff, 1, mvol_tlv),
+/* VOL */
+SOC_SINGLE_TLV("Ch1 Volume", TAS5716_C1VOL, 0, 0xff, 1, chvol_tlv),
+SOC_SINGLE_TLV("Ch2 Volume", TAS5716_C2VOL, 0, 0xff, 1, chvol_tlv),
+SOC_SINGLE_TLV("Ch3 Volume", TAS5716_C3VOL, 0, 0xff, 1, chvol_tlv),
+/* CONFD */
+SOC_SINGLE("High Pass Filter Bypass Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_HPB_SHIFT, 1, 1),
+SOC_SINGLE("De-emphasis Filter Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_DEMP_SHIFT, 1, 0),
+SOC_SINGLE("DSP Bypass Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_DSPB_SHIFT, 1, 0),
+SOC_SINGLE("Post-scale Link Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_PSL_SHIFT, 1, 0),
+SOC_SINGLE("Biquad Coefficient Link Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_BQL_SHIFT, 1, 0),
+SOC_ENUM("Compressor/Limiter Switch", tas5716_drc_ac_enum),
+SOC_ENUM("Noise Shaper Bandwidth", tas5716_noise_shaper_enum),
+SOC_SINGLE("Zero-detect Mute Enable Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_ZDE_SHIFT, 1, 0),
+SOC_SINGLE("Submix Mode Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_SME_SHIFT, 1, 0),
+/* CONFE */
+SOC_SINGLE("Zero Cross Switch", TAS5716_CONFE, TAS5716_CONFE_ZCE_SHIFT, 1, 0),
+SOC_SINGLE("Soft Ramp Switch", TAS5716_CONFE, TAS5716_CONFE_SVE_SHIFT, 1, 0),
+/* MUTE */
+SOC_SINGLE("Master Switch", TAS5716_MMUTE, TAS5716_MMUTE_MMUTE_SHIFT, 1, 1),
+SOC_SINGLE("Ch1 Switch", TAS5716_MMUTE, TAS5716_MMUTE_C1M_SHIFT, 1, 1),
+SOC_SINGLE("Ch2 Switch", TAS5716_MMUTE, TAS5716_MMUTE_C2M_SHIFT, 1, 1),
+SOC_SINGLE("Ch3 Switch", TAS5716_MMUTE, TAS5716_MMUTE_C3M_SHIFT, 1, 1),
+/* AUTOx */
+SOC_ENUM("Automode GC", tas5716_auto_gc_enum),
+SOC_ENUM("Automode XO", tas5716_auto_xo_enum),
+/* CxCFG */
+SOC_SINGLE("Ch1 Tone Control Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_TCB_SHIFT, 1, 0),
+SOC_SINGLE("Ch2 Tone Control Bypass Switch",
+	   TAS5716_C2CFG, TAS5716_CxCFG_TCB_SHIFT, 1, 0),
+SOC_SINGLE("Ch1 EQ Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_EQBP_SHIFT, 1, 0),
+SOC_SINGLE("Ch2 EQ Bypass Switch",
+	   TAS5716_C2CFG, TAS5716_CxCFG_EQBP_SHIFT, 1, 0),
+SOC_SINGLE("Ch1 Master Volume Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_VBP_SHIFT, 1, 0),
+SOC_SINGLE("Ch2 Master Volume Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_VBP_SHIFT, 1, 0),
+SOC_SINGLE("Ch3 Master Volume Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_VBP_SHIFT, 1, 0),
+SOC_ENUM("Ch1 Binary Output Select", tas5716_binary_output_ch1_enum),
+SOC_ENUM("Ch2 Binary Output Select", tas5716_binary_output_ch2_enum),
+SOC_ENUM("Ch3 Binary Output Select", tas5716_binary_output_ch3_enum),
+SOC_ENUM("Ch1 Limiter Select", tas5716_limiter_ch1_enum),
+SOC_ENUM("Ch2 Limiter Select", tas5716_limiter_ch2_enum),
+SOC_ENUM("Ch3 Limiter Select", tas5716_limiter_ch3_enum),
+/* TONE */
+SOC_SINGLE_RANGE_TLV("Bass Tone Control Volume",
+		     TAS5716_TONE, TAS5716_TONE_BTC_SHIFT, 1, 13, 0, tone_tlv),
+SOC_SINGLE_RANGE_TLV("Treble Tone Control Volume",
+		     TAS5716_TONE, TAS5716_TONE_TTC_SHIFT, 1, 13, 0, tone_tlv),
+SOC_ENUM("Limiter1 Attack Rate (dB/ms)", tas5716_limiter1_attack_rate_enum),
+SOC_ENUM("Limiter2 Attack Rate (dB/ms)", tas5716_limiter2_attack_rate_enum),
+SOC_ENUM("Limiter1 Release Rate (dB/ms)", tas5716_limiter1_release_rate_enum),
+SOC_ENUM("Limiter2 Release Rate (dB/ms)", tas5716_limiter2_release_rate_enum),
+
+/*
+ * depending on mode, the attack/release thresholds have
+ * two different enum definitions; provide both
+ */
+SOC_SINGLE_TLV("Limiter1 Attack Threshold (AC Mode)",
+	       TAS5716_L1ATRT, TAS5716_LxA_SHIFT,
+	       16, 0, tas5716_limiter_ac_attack_tlv),
+SOC_SINGLE_TLV("Limiter2 Attack Threshold (AC Mode)",
+	       TAS5716_L2ATRT, TAS5716_LxA_SHIFT,
+	       16, 0, tas5716_limiter_ac_attack_tlv),
+SOC_SINGLE_TLV("Limiter1 Release Threshold (AC Mode)",
+	       TAS5716_L1ATRT, TAS5716_LxR_SHIFT,
+	       16, 0, tas5716_limiter_ac_release_tlv),
+SOC_SINGLE_TLV("Limiter2 Release Threshold (AC Mode)",
+	       TAS5716_L2ATRT, TAS5716_LxR_SHIFT,
+	       16, 0, tas5716_limiter_ac_release_tlv),
+SOC_SINGLE_TLV("Limiter1 Attack Threshold (DRC Mode)",
+	       TAS5716_L1ATRT, TAS5716_LxA_SHIFT,
+	       16, 0, tas5716_limiter_drc_attack_tlv),
+SOC_SINGLE_TLV("Limiter2 Attack Threshold (DRC Mode)",
+	       TAS5716_L2ATRT, TAS5716_LxA_SHIFT,
+	       16, 0, tas5716_limiter_drc_attack_tlv),
+SOC_SINGLE_TLV("Limiter1 Release Threshold (DRC Mode)",
+	       TAS5716_L1ATRT, TAS5716_LxR_SHIFT,
+	       16, 0, tas5716_limiter_drc_release_tlv),
+SOC_SINGLE_TLV("Limiter2 Release Threshold (DRC Mode)",
+	       TAS5716_L2ATRT, TAS5716_LxR_SHIFT,
+	       16, 0, tas5716_limiter_drc_release_tlv),
+
+BIQUAD_COEFS("Ch1 - Biquad 1", 0),
+BIQUAD_COEFS("Ch1 - Biquad 2", 5),
+BIQUAD_COEFS("Ch1 - Biquad 3", 10),
+BIQUAD_COEFS("Ch1 - Biquad 4", 15),
+BIQUAD_COEFS("Ch2 - Biquad 1", 20),
+BIQUAD_COEFS("Ch2 - Biquad 2", 25),
+BIQUAD_COEFS("Ch2 - Biquad 3", 30),
+BIQUAD_COEFS("Ch2 - Biquad 4", 35),
+BIQUAD_COEFS("High-pass", 40),
+BIQUAD_COEFS("Low-pass", 45),
+SINGLE_COEF("Ch1 - Prescale", 50),
+SINGLE_COEF("Ch2 - Prescale", 51),
+SINGLE_COEF("Ch1 - Postscale", 52),
+SINGLE_COEF("Ch2 - Postscale", 53),
+SINGLE_COEF("Ch3 - Postscale", 54),
+SINGLE_COEF("Thermal warning - Postscale", 55),
+SINGLE_COEF("Ch1 - Mix 1", 56),
+SINGLE_COEF("Ch1 - Mix 2", 57),
+SINGLE_COEF("Ch2 - Mix 1", 58),
+SINGLE_COEF("Ch2 - Mix 2", 59),
+SINGLE_COEF("Ch3 - Mix 1", 60),
+SINGLE_COEF("Ch3 - Mix 2", 61),
+};
+
+static const struct snd_soc_dapm_widget tas5716_dapm_widgets[] = {
+SND_SOC_DAPM_DAC("DAC", NULL, SND_SOC_NOPM, 0, 0),
+SND_SOC_DAPM_OUTPUT("LEFT"),
+SND_SOC_DAPM_OUTPUT("RIGHT"),
+SND_SOC_DAPM_OUTPUT("SUB"),
+};
+
+static const struct snd_soc_dapm_route tas5716_dapm_routes[] = {
+	{ "LEFT", NULL, "DAC" },
+	{ "RIGHT", NULL, "DAC" },
+	{ "SUB", NULL, "DAC" },
+	{ "DAC", NULL, "Playback" },
+};
+
+/* MCLK interpolation ratio per fs */
+static struct {
+	int fs;
+	int ir;
+} interpolation_ratios[] = {
+	{ 32000, 0 },
+	{ 44100, 0 },
+	{ 48000, 0 },
+	{ 88200, 1 },
+	{ 96000, 1 },
+	{ 176400, 2 },
+	{ 192000, 2 },
+};
+
+/* MCLK to fs clock ratios */
+static int mcs_ratio_table[3][6] = {
+	{ 768, 512, 384, 256, 128, 576 },
+	{ 384, 256, 192, 128,  64,   0 },
+	{ 192, 128,  96,  64,  32,   0 },
+};
+
+/**
+ * tas5716_set_dai_sysclk - configure MCLK
+ * @codec_dai: the codec DAI
+ * @clk_id: the clock ID (ignored)
+ * @freq: the MCLK input frequency
+ * @dir: the clock direction (ignored)
+ *
+ * The value of MCLK is used to determine which sample rates are supported
+ * by the TAS5716, based on the mcs_ratio_table.
+ *
+ * This function must be called by the machine driver's 'startup' function,
+ * otherwise the list of supported sample rates will not be available in
+ * time for ALSA.
+ */
+static int tas5716_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				 int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(codec->dev, "mclk=%u\n", freq);
+	tas5716->mclk = freq;
+
+	return 0;
+}
+
+/**
+ * tas5716_set_dai_fmt - configure the codec for the selected audio format
+ * @codec_dai: the codec DAI
+ * @fmt: a SND_SOC_DAIFMT_x value indicating the data format
+ *
+ * This function takes a bitmask of SND_SOC_DAIFMT_x bits and programs the
+ * codec accordingly.
+ */
+static int tas5716_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			      unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	unsigned int confb = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+	case SND_SOC_DAIFMT_RIGHT_J:
+	case SND_SOC_DAIFMT_LEFT_J:
+		tas5716->format = fmt & SND_SOC_DAIFMT_FORMAT_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		confb |= TAS5716_CONFB_C2IM;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		confb |= TAS5716_CONFB_C1IM;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return regmap_update_bits(tas5716->regmap, TAS5716_CONFB,
+				  TAS5716_CONFB_C1IM | TAS5716_CONFB_C2IM, confb);
+}
+
+/**
+ * tas5716_hw_params - program the TAS5716 with the given hardware parameters.
+ * @substream: the audio stream
+ * @params: the hardware parameters to set
+ * @dai: the SOC DAI (ignored)
+ *
+ * This function programs the hardware with the values provided.
+ * Specifically, the sample rate and the data format.
+ */
+static int tas5716_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	int i, mcs = -EINVAL, ir = -EINVAL;
+	unsigned int confa, confb;
+	unsigned int rate, ratio;
+	int ret;
+
+	if (!tas5716->mclk) {
+		dev_err(codec->dev,
+			"tas5716->mclk is unset. Unable to determine ratio\n");
+		return -EIO;
+	}
+
+	rate = params_rate(params);
+	ratio = tas5716->mclk / rate;
+	dev_dbg(codec->dev, "rate: %u, ratio: %u\n", rate, ratio);
+
+	for (i = 0; i < ARRAY_SIZE(interpolation_ratios); i++) {
+		if (interpolation_ratios[i].fs == rate) {
+			ir = interpolation_ratios[i].ir;
+			break;
+		}
+	}
+
+	if (ir < 0) {
+		dev_err(codec->dev, "Unsupported samplerate: %u\n", rate);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < 6; i++) {
+		if (mcs_ratio_table[ir][i] == ratio) {
+			mcs = i;
+			break;
+		}
+	}
+
+	if (mcs < 0) {
+		dev_err(codec->dev, "Unresolvable ratio: %u\n", ratio);
+		return -EINVAL;
+	}
+
+	confa = (ir << TAS5716_CONFA_IR_SHIFT) |
+		(mcs << TAS5716_CONFA_MCS_SHIFT);
+	confb = 0;
+
+	switch (params_width(params)) {
+	case 24:
+		dev_dbg(codec->dev, "24bit\n");
+		/* fall through */
+	case 32:
+		dev_dbg(codec->dev, "24bit or 32bit\n");
+		switch (tas5716->format) {
+		case SND_SOC_DAIFMT_I2S:
+			confb |= 0x0;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			confb |= 0x1;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			confb |= 0x2;
+			break;
+		}
+
+		break;
+	case 20:
+		dev_dbg(codec->dev, "20bit\n");
+		switch (tas5716->format) {
+		case SND_SOC_DAIFMT_I2S:
+			confb |= 0x4;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			confb |= 0x5;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			confb |= 0x6;
+			break;
+		}
+
+		break;
+	case 18:
+		dev_dbg(codec->dev, "18bit\n");
+		switch (tas5716->format) {
+		case SND_SOC_DAIFMT_I2S:
+			confb |= 0x8;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			confb |= 0x9;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			confb |= 0xa;
+			break;
+		}
+
+		break;
+	case 16:
+		dev_dbg(codec->dev, "16bit\n");
+		switch (tas5716->format) {
+		case SND_SOC_DAIFMT_I2S:
+			confb |= 0x0;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			confb |= 0xd;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			confb |= 0xe;
+			break;
+		}
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = regmap_update_bits(tas5716->regmap, TAS5716_CONFA,
+				 TAS5716_CONFA_MCS_MASK | TAS5716_CONFA_IR_MASK,
+				 confa);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_update_bits(tas5716->regmap, TAS5716_CONFB,
+				 TAS5716_CONFB_SAI_MASK | TAS5716_CONFB_SAIFB,
+				 confb);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int tas5716_startup_sequence(struct tas5716_priv *tas5716)
+{
+	if (tas5716->gpiod_power_down)
+		gpiod_set_value(tas5716->gpiod_power_down, 1);
+
+	if (tas5716->gpiod_nreset) {
+		gpiod_set_value(tas5716->gpiod_nreset, 0);
+		mdelay(1);
+		gpiod_set_value(tas5716->gpiod_nreset, 1);
+		mdelay(1);
+	}
+
+	return 0;
+}
+
+/**
+ * tas5716_set_bias_level - DAPM callback
+ * @codec: the codec device
+ * @level: DAPM power level
+ *
+ * This is called by ALSA to put the codec into low power mode
+ * or to wake it up.  If the codec is powered off completely
+ * all registers must be restored after power on.
+ */
+static int tas5716_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	dev_dbg(codec->dev, "level = %d\n", level);
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+		/* Full power on */
+		regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+				   TAS5716_CONFF_PWDN | TAS5716_CONFF_EAPD,
+				   TAS5716_CONFF_PWDN | TAS5716_CONFF_EAPD);
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
+			ret = regulator_bulk_enable(
+				ARRAY_SIZE(tas5716->supplies),
+				tas5716->supplies);
+			if (ret < 0) {
+				dev_err(codec->dev,
+					"Failed to enable supplies: %d\n",
+					ret);
+				return ret;
+			}
+			tas5716_startup_sequence(tas5716);
+			tas5716_cache_sync(codec);
+		}
+
+		/* Power down */
+		regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+				   TAS5716_CONFF_PWDN | TAS5716_CONFF_EAPD,
+				   0);
+
+		break;
+
+	case SND_SOC_BIAS_OFF:
+		/* The chip runs through the power down sequence for us */
+		regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+				   TAS5716_CONFF_PWDN | TAS5716_CONFF_EAPD, 0);
+
+		/* power down: low */
+		if (tas5716->gpiod_power_down)
+			gpiod_set_value(tas5716->gpiod_power_down, 0);
+
+		if (tas5716->gpiod_nreset)
+			gpiod_set_value(tas5716->gpiod_nreset, 0);
+
+		regulator_bulk_disable(ARRAY_SIZE(tas5716->supplies),
+				       tas5716->supplies);
+		break;
+	}
+	codec->dapm.bias_level = level;
+	return 0;
+}
+
+static const struct snd_soc_dai_ops tas5716_dai_ops = {
+	.hw_params	= tas5716_hw_params,
+	.set_sysclk	= tas5716_set_dai_sysclk,
+	.set_fmt	= tas5716_set_dai_fmt,
+};
+
+static struct snd_soc_dai_driver tas5716_dai = {
+	.name = "tas5716-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = TAS5716_RATES,
+		.formats = TAS5716_FORMATS,
+	},
+	.ops = &tas5716_dai_ops,
+};
+
+#ifdef CONFIG_PM
+static int tas5716_suspend(struct snd_soc_codec *codec)
+{
+	tas5716_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int tas5716_resume(struct snd_soc_codec *codec)
+{
+	tas5716_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	return 0;
+}
+#else
+#define tas5716_suspend NULL
+#define tas5716_resume NULL
+#endif
+
+static int tas5716_probe(struct snd_soc_codec *codec)
+{
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	struct tas5716_platform_data *pdata = tas5716->pdata;
+	int i, ret = 0, thermal = 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(tas5716->supplies),
+				    tas5716->supplies);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to enable supplies: %d\n", ret);
+		return ret;
+	}
+
+	ret = tas5716_startup_sequence(tas5716);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to startup device\n");
+		return ret;
+	}
+
+	/* CONFA */
+	if (!pdata->thermal_warning_recovery)
+		thermal |= TAS5716_CONFA_TWAB;
+	if (!pdata->thermal_warning_adjustment)
+		thermal |= TAS5716_CONFA_TWRB;
+	if (!pdata->fault_detect_recovery)
+		thermal |= TAS5716_CONFA_FDRB;
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFA,
+			   TAS5716_CONFA_TWAB | TAS5716_CONFA_TWRB |
+			   TAS5716_CONFA_FDRB,
+			   thermal);
+
+	/* CONFC */
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFC,
+			   TAS5716_CONFC_OM_MASK,
+			   pdata->ffx_power_output_mode
+				<< TAS5716_CONFC_OM_SHIFT);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFC,
+			   TAS5716_CONFC_CSZ_MASK,
+			   pdata->drop_compensation_ns
+				<< TAS5716_CONFC_CSZ_SHIFT);
+	regmap_update_bits(tas5716->regmap,
+			   TAS5716_CONFC,
+			   TAS5716_CONFC_OCRB,
+			   pdata->oc_warning_adjustment ?
+				TAS5716_CONFC_OCRB : 0);
+
+	/* CONFE */
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_MPCV,
+			   pdata->max_power_use_mpcc ?
+				TAS5716_CONFE_MPCV : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_MPC,
+			   pdata->max_power_correction ?
+				TAS5716_CONFE_MPC : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_AME,
+			   pdata->am_reduction_mode ?
+				TAS5716_CONFE_AME : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_PWMS,
+			   pdata->odd_pwm_speed_mode ?
+				TAS5716_CONFE_PWMS : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_DCCV,
+			   pdata->distortion_compensation ?
+				TAS5716_CONFE_DCCV : 0);
+	/*  CONFF */
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+			   TAS5716_CONFF_IDE,
+			   pdata->invalid_input_detect_mute ?
+				TAS5716_CONFF_IDE : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+			   TAS5716_CONFF_OCFG_MASK,
+			   pdata->output_conf
+				<< TAS5716_CONFF_OCFG_SHIFT);
+
+	/* channel to output mapping */
+	regmap_update_bits(tas5716->regmap, TAS5716_C1CFG,
+			   TAS5716_CxCFG_OM_MASK,
+			   pdata->ch1_output_mapping
+				<< TAS5716_CxCFG_OM_SHIFT);
+	regmap_update_bits(tas5716->regmap, TAS5716_C2CFG,
+			   TAS5716_CxCFG_OM_MASK,
+			   pdata->ch2_output_mapping
+				<< TAS5716_CxCFG_OM_SHIFT);
+	regmap_update_bits(tas5716->regmap, TAS5716_C3CFG,
+			   TAS5716_CxCFG_OM_MASK,
+			   pdata->ch3_output_mapping
+				<< TAS5716_CxCFG_OM_SHIFT);
+
+	/* miscellaneous registers */
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC1,
+			   TAS5716_MISC1_CPWMEN,
+			   pdata->activate_mute_output ?
+				TAS5716_MISC1_CPWMEN : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC1,
+			   TAS5716_MISC1_BRIDGOFF,
+			   pdata->bridge_immediate_off ?
+				TAS5716_MISC1_BRIDGOFF : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC1,
+			   TAS5716_MISC1_NSHHPEN,
+			   pdata->noise_shape_dc_cut ?
+				TAS5716_MISC1_NSHHPEN : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC1,
+			   TAS5716_MISC1_RPDNEN,
+			   pdata->powerdown_master_vol ?
+				TAS5716_MISC1_RPDNEN: 0);
+
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC2,
+			   TAS5716_MISC2_PNDLSL_MASK,
+			   pdata->powerdown_delay_divider
+				<< TAS5716_MISC2_PNDLSL_SHIFT);
+
+	/* initialize coefficient shadow RAM with reset values */
+	for (i = 4; i <= 49; i += 5)
+		tas5716->coef_shadow[i] = 0x400000;
+	for (i = 50; i <= 54; i++)
+		tas5716->coef_shadow[i] = 0x7fffff;
+	tas5716->coef_shadow[55] = 0x5a9df7;
+	tas5716->coef_shadow[56] = 0x7fffff;
+	tas5716->coef_shadow[59] = 0x7fffff;
+	tas5716->coef_shadow[60] = 0x400000;
+	tas5716->coef_shadow[61] = 0x400000;
+
+	tas5716_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	/* Bias level configuration will have done an extra enable */
+	regulator_bulk_disable(ARRAY_SIZE(tas5716->supplies), tas5716->supplies);
+
+	return 0;
+}
+
+static int tas5716_remove(struct snd_soc_codec *codec)
+{
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+
+	tas5716_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	regulator_bulk_disable(ARRAY_SIZE(tas5716->supplies), tas5716->supplies);
+
+	return 0;
+}
+
+static const struct snd_soc_codec_driver tas5716_codec = {
+	.probe =		tas5716_probe,
+	.remove =		tas5716_remove,
+	.suspend =		tas5716_suspend,
+	.resume =		tas5716_resume,
+	.set_bias_level =	tas5716_set_bias_level,
+	.controls =		tas5716_snd_controls,
+	.num_controls =		ARRAY_SIZE(tas5716_snd_controls),
+	.dapm_widgets =		tas5716_dapm_widgets,
+	.num_dapm_widgets =	ARRAY_SIZE(tas5716_dapm_widgets),
+	.dapm_routes =		tas5716_dapm_routes,
+	.num_dapm_routes =	ARRAY_SIZE(tas5716_dapm_routes),
+};
+
+static const struct regmap_config tas5716_regmap = {
+	.reg_bits =		8,
+	.val_bits =		8,
+	.max_register =		TAS5716_MISC2,
+	.reg_defaults =		tas5716_regs,
+	.num_reg_defaults =	ARRAY_SIZE(tas5716_regs),
+	.cache_type =		REGCACHE_RBTREE,
+	.wr_table =		&tas5716_write_regs,
+	.rd_table =		&tas5716_read_regs,
+	.volatile_table =	&tas5716_volatile_regs,
+};
+
+#ifdef CONFIG_OF
+static const struct of_device_id tas5716_dt_ids[] = {
+	{ .compatible = "ti,tas5716", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, tas5716_dt_ids);
+
+static const char * const tas5716_ffx_modes[] = {
+	[TAS5716_FFX_PM_DROP_COMP]		= "drop-compensation",
+	[TAS5716_FFX_PM_TAPERED_COMP]		= "tapered-compensation",
+	[TAS5716_FFX_PM_FULL_POWER]		= "full-power-mode",
+	[TAS5716_FFX_PM_VARIABLE_DROP_COMP]	= "variable-drop-compensation",
+};
+
+static int tas5716_probe_dt(struct device *dev, struct tas5716_priv *tas5716)
+{
+	struct device_node *np = dev->of_node;
+	struct tas5716_platform_data *pdata;
+	const char *ffx_power_mode;
+	u16 tmp;
+	u8 tmp8;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	of_property_read_u8(np, "ti,output-conf",
+			    &pdata->output_conf);
+	of_property_read_u8(np, "ti,ch1-output-mapping",
+			    &pdata->ch1_output_mapping);
+	of_property_read_u8(np, "ti,ch2-output-mapping",
+			    &pdata->ch2_output_mapping);
+	of_property_read_u8(np, "ti,ch3-output-mapping",
+			    &pdata->ch3_output_mapping);
+
+	if (of_get_property(np, "ti,thermal-warning-recovery", NULL))
+		pdata->thermal_warning_recovery = 1;
+	if (of_get_property(np, "ti,thermal-warning-adjustment", NULL))
+		pdata->thermal_warning_adjustment = 1;
+	if (of_get_property(np, "ti,fault-detect-recovery", NULL))
+		pdata->fault_detect_recovery = 1;
+
+	pdata->ffx_power_output_mode = TAS5716_FFX_PM_VARIABLE_DROP_COMP;
+	if (!of_property_read_string(np, "ti,ffx-power-output-mode",
+				     &ffx_power_mode)) {
+		int i, mode = -EINVAL;
+
+		for (i = 0; i < ARRAY_SIZE(tas5716_ffx_modes); i++)
+			if (!strcasecmp(ffx_power_mode, tas5716_ffx_modes[i]))
+				mode = i;
+
+		if (mode < 0)
+			dev_warn(dev, "Unsupported ffx output mode: %s\n",
+				 ffx_power_mode);
+		else
+			pdata->ffx_power_output_mode = mode;
+	}
+
+	tmp = 140;
+	of_property_read_u16(np, "ti,drop-compensation-ns", &tmp);
+	pdata->drop_compensation_ns = clamp_t(u16, tmp, 0, 300) / 20;
+
+	if (of_get_property(np, "ti,overcurrent-warning-adjustment", NULL))
+		pdata->oc_warning_adjustment = 1;
+
+	/* CONFE */
+	if (of_get_property(np, "ti,max-power-use-mpcc", NULL))
+		pdata->max_power_use_mpcc = 1;
+
+	if (of_get_property(np, "ti,max-power-correction", NULL))
+		pdata->max_power_correction = 1;
+
+	if (of_get_property(np, "ti,am-reduction-mode", NULL))
+		pdata->am_reduction_mode = 1;
+
+	if (of_get_property(np, "ti,odd-pwm-speed-mode", NULL))
+		pdata->odd_pwm_speed_mode = 1;
+
+	if (of_get_property(np, "ti,distortion-compensation", NULL))
+		pdata->distortion_compensation = 1;
+
+	/* CONFF */
+	if (of_get_property(np, "ti,invalid-input-detect-mute", NULL))
+		pdata->invalid_input_detect_mute = 1;
+
+	/* MISC */
+	if (of_get_property(np, "ti,activate-mute-output", NULL))
+		pdata->activate_mute_output = 1;
+
+	if (of_get_property(np, "ti,bridge-immediate-off", NULL))
+		pdata->bridge_immediate_off = 1;
+
+	if (of_get_property(np, "ti,noise-shape-dc-cut", NULL))
+		pdata->noise_shape_dc_cut = 1;
+
+	if (of_get_property(np, "ti,powerdown-master-volume", NULL))
+		pdata->powerdown_master_vol = 1;
+
+	if (!of_property_read_u8(np, "ti,powerdown-delay-divider", &tmp8)) {
+		if (is_power_of_2(tmp8) && tmp8 >= 1 && tmp8 <= 128)
+			pdata->powerdown_delay_divider = ilog2(tmp8);
+		else
+			dev_warn(dev, "Unsupported powerdown delay divider %d\n",
+				 tmp8);
+	}
+
+	tas5716->pdata = pdata;
+
+	return 0;
+}
+#endif
+
+static int tas5716_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct device *dev = &i2c->dev;
+	struct tas5716_priv *tas5716;
+	int ret, i;
+
+	printk("JDS - tas5716_i2c_probe\n");
+	tas5716 = devm_kzalloc(dev, sizeof(struct tas5716_priv), GFP_KERNEL);
+	if (!tas5716)
+		return -ENOMEM;
+
+	mutex_init(&tas5716->coeff_lock);
+	tas5716->pdata = dev_get_platdata(dev);
+
+	if (dev->of_node) {
+		ret = tas5716_probe_dt(dev, tas5716);
+		if (ret < 0)
+			return ret;
+	}
+
+	printk("JDS - tas5716_i2c_probe a\n");
+	/* GPIOs */
+	tas5716->gpiod_nreset = devm_gpiod_get(dev, "reset");
+	if (IS_ERR(tas5716->gpiod_nreset)) {
+		ret = PTR_ERR(tas5716->gpiod_nreset);
+		if (ret != -ENOENT && ret != -ENOSYS)
+			return ret;
+
+		tas5716->gpiod_nreset = NULL;
+	} else {
+		gpiod_direction_output(tas5716->gpiod_nreset, 0);
+	}
+
+	printk("JDS - tas5716_i2c_probe b\n");
+	tas5716->gpiod_power_down = devm_gpiod_get(dev, "power-down");
+	if (IS_ERR(tas5716->gpiod_power_down)) {
+		ret = PTR_ERR(tas5716->gpiod_power_down);
+		if (ret != -ENOENT && ret != -ENOSYS)
+			return ret;
+
+		tas5716->gpiod_power_down = NULL;
+	} else {
+		gpiod_direction_output(tas5716->gpiod_power_down, 0);
+	}
+
+	/* regulators */
+	for (i = 0; i < ARRAY_SIZE(tas5716->supplies); i++)
+		tas5716->supplies[i].supply = tas5716_supply_names[i];
+
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(tas5716->supplies),
+				      tas5716->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to request supplies: %d\n", ret);
+		return ret;
+	}
+
+	printk("JDS - tas5716_i2c_probe c\n");
+	tas5716->regmap = devm_regmap_init_i2c(i2c, &tas5716_regmap);
+	if (IS_ERR(tas5716->regmap)) {
+		ret = PTR_ERR(tas5716->regmap);
+		dev_err(dev, "Failed to init regmap: %d\n", ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(i2c, tas5716);
+
+	printk("JDS - tas5716_i2c_probe d\n");
+	ret = snd_soc_register_codec(dev, &tas5716_codec, &tas5716_dai, 1);
+	if (ret < 0)
+		dev_err(dev, "Failed to register codec (%d)\n", ret);
+
+	printk("JDS - tas5716_i2c_probe e\n");
+	return ret;
+}
+
+static int tas5716_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+	return 0;
+}
+
+static const struct i2c_device_id tas5716_i2c_id[] = {
+	{ "tas5716", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, tas5716_i2c_id);
+
+static struct i2c_driver tas5716_i2c_driver = {
+	.driver = {
+		.name = "tas5716",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(tas5716_dt_ids),
+	},
+	.probe =    tas5716_i2c_probe,
+	.remove =   tas5716_i2c_remove,
+	.id_table = tas5716_i2c_id,
+};
+
+module_i2c_driver(tas5716_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC TAS5716 driver");
+MODULE_AUTHOR("Sven Brandau <info@brandau.biz>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/tas5716.h b/sound/soc/codecs/tas5716.h
new file mode 100644
index 0000000..c90dd50
--- /dev/null
+++ b/sound/soc/codecs/tas5716.h
@@ -0,0 +1,238 @@
+/*
+ * Codec driver for ST TAS5716 2.1-channel high-efficiency digital audio system
+ *
+ * Copyright: 2011 Raumfeld GmbH
+ * Author: Sven Brandau <info@brandau.biz>
+ *
+ * based on code from:
+ *      Raumfeld GmbH
+ *        Johannes Stezenbach <js@sig21.net>
+ *	Wolfson Microelectronics PLC.
+ *	  Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifndef _ASOC_TAS_5716_H
+#define _ASOC_TAS_5716_H
+
+/* STA50 register addresses */
+
+#define TAS5716_REGISTER_COUNT	0x4D
+#define TAS5716_COEF_COUNT 62
+
+#define TAS5716_CONFA	0x00
+#define TAS5716_CONFB    0x01
+#define TAS5716_CONFC    0x02
+#define TAS5716_CONFD    0x03
+#define TAS5716_CONFE    0x04
+#define TAS5716_CONFF    0x05
+#define TAS5716_MMUTE    0x06
+#define TAS5716_MVOL     0x07
+#define TAS5716_C1VOL    0x08
+#define TAS5716_C2VOL    0x09
+#define TAS5716_C3VOL    0x0a
+#define TAS5716_AUTO1    0x0b
+#define TAS5716_AUTO2    0x0c
+#define TAS5716_AUTO3    0x0d
+#define TAS5716_C1CFG    0x0e
+#define TAS5716_C2CFG    0x0f
+#define TAS5716_C3CFG    0x10
+#define TAS5716_TONE     0x11
+#define TAS5716_L1AR     0x12
+#define TAS5716_L1ATRT   0x13
+#define TAS5716_L2AR     0x14
+#define TAS5716_L2ATRT   0x15
+#define TAS5716_CFADDR2  0x16
+#define TAS5716_B1CF1    0x17
+#define TAS5716_B1CF2    0x18
+#define TAS5716_B1CF3    0x19
+#define TAS5716_B2CF1    0x1a
+#define TAS5716_B2CF2    0x1b
+#define TAS5716_B2CF3    0x1c
+#define TAS5716_A1CF1    0x1d
+#define TAS5716_A1CF2    0x1e
+#define TAS5716_A1CF3    0x1f
+#define TAS5716_A2CF1    0x20
+#define TAS5716_A2CF2    0x21
+#define TAS5716_A2CF3    0x22
+#define TAS5716_B0CF1    0x23
+#define TAS5716_B0CF2    0x24
+#define TAS5716_B0CF3    0x25
+#define TAS5716_CFUD     0x26
+#define TAS5716_MPCC1    0x27
+#define TAS5716_MPCC2    0x28
+#define TAS5716_DCC1     0x29
+#define TAS5716_DCC2     0x2a
+#define TAS5716_FDRC1    0x2b
+#define TAS5716_FDRC2    0x2c
+#define TAS5716_STATUS   0x2d
+/* reserved: 0x2d - 0x30 */
+#define TAS5716_EQCFG    0x31
+#define TAS5716_EATH1    0x32
+#define TAS5716_ERTH1    0x33
+#define TAS5716_EATH2    0x34
+#define TAS5716_ERTH2    0x35
+#define TAS5716_CONFX    0x36
+#define TAS5716_SVCA     0x37
+#define TAS5716_SVCB     0x38
+#define TAS5716_RMS0A    0x39
+#define TAS5716_RMS0B    0x3a
+#define TAS5716_RMS0C    0x3b
+#define TAS5716_RMS1A    0x3c
+#define TAS5716_RMS1B    0x3d
+#define TAS5716_RMS1C    0x3e
+#define TAS5716_EVOLRES  0x3f
+/* reserved: 0x40 - 0x47 */
+#define TAS5716_NSHAPE   0x48
+#define TAS5716_CTXB4B1  0x49
+#define TAS5716_CTXB7B5  0x4a
+#define TAS5716_MISC1    0x4b
+#define TAS5716_MISC2    0x4c
+
+/* 0x00 CONFA */
+#define TAS5716_CONFA_MCS_MASK	0x03
+#define TAS5716_CONFA_MCS_SHIFT	0
+#define TAS5716_CONFA_IR_MASK	0x18
+#define TAS5716_CONFA_IR_SHIFT	3
+#define TAS5716_CONFA_TWRB	BIT(5)
+#define TAS5716_CONFA_TWAB	BIT(6)
+#define TAS5716_CONFA_FDRB	BIT(7)
+
+/* 0x01 CONFB */
+#define TAS5716_CONFB_SAI_MASK	0x0f
+#define TAS5716_CONFB_SAI_SHIFT	0
+#define TAS5716_CONFB_SAIFB	BIT(4)
+#define TAS5716_CONFB_DSCKE	BIT(5)
+#define TAS5716_CONFB_C1IM	BIT(6)
+#define TAS5716_CONFB_C2IM	BIT(7)
+
+/* 0x02 CONFC */
+#define TAS5716_CONFC_OM_MASK	0x03
+#define TAS5716_CONFC_OM_SHIFT	0
+#define TAS5716_CONFC_CSZ_MASK	0x3c
+#define TAS5716_CONFC_CSZ_SHIFT	2
+#define TAS5716_CONFC_OCRB	BIT(7)
+
+/* 0x03 CONFD */
+#define TAS5716_CONFD_HPB_SHIFT	0
+#define TAS5716_CONFD_DEMP_SHIFT	1
+#define TAS5716_CONFD_DSPB_SHIFT	2
+#define TAS5716_CONFD_PSL_SHIFT	3
+#define TAS5716_CONFD_BQL_SHIFT	4
+#define TAS5716_CONFD_DRC_SHIFT	5
+#define TAS5716_CONFD_ZDE_SHIFT	6
+#define TAS5716_CONFD_SME_SHIFT	7
+
+/* 0x04 CONFE */
+#define TAS5716_CONFE_MPCV	BIT(0)
+#define TAS5716_CONFE_MPCV_SHIFT	0
+#define TAS5716_CONFE_MPC	BIT(1)
+#define TAS5716_CONFE_MPC_SHIFT	1
+#define TAS5716_CONFE_NSBW	BIT(2)
+#define TAS5716_CONFE_NSBW_SHIFT	2
+#define TAS5716_CONFE_AME	BIT(3)
+#define TAS5716_CONFE_AME_SHIFT	3
+#define TAS5716_CONFE_PWMS	BIT(4)
+#define TAS5716_CONFE_PWMS_SHIFT	4
+#define TAS5716_CONFE_DCCV	BIT(5)
+#define TAS5716_CONFE_DCCV_SHIFT	5
+#define TAS5716_CONFE_ZCE	BIT(6)
+#define TAS5716_CONFE_ZCE_SHIFT	6
+#define TAS5716_CONFE_SVE	BIT(7)
+#define TAS5716_CONFE_SVE_SHIFT	7
+
+/* 0x05 CONFF */
+#define TAS5716_CONFF_OCFG_MASK	0x03
+#define TAS5716_CONFF_OCFG_SHIFT	0
+#define TAS5716_CONFF_IDE	BIT(2)
+#define TAS5716_CONFF_BCLE	BIT(3)
+#define TAS5716_CONFF_LDTE	BIT(4)
+#define TAS5716_CONFF_ECLE	BIT(5)
+#define TAS5716_CONFF_PWDN	BIT(6)
+#define TAS5716_CONFF_EAPD	BIT(7)
+
+/* 0x06 MMUTE */
+#define TAS5716_MMUTE_MMUTE		0x01
+#define TAS5716_MMUTE_MMUTE_SHIFT	0
+#define TAS5716_MMUTE_C1M		0x02
+#define TAS5716_MMUTE_C1M_SHIFT		1
+#define TAS5716_MMUTE_C2M		0x04
+#define TAS5716_MMUTE_C2M_SHIFT		2
+#define TAS5716_MMUTE_C3M		0x08
+#define TAS5716_MMUTE_C3M_SHIFT		3
+#define TAS5716_MMUTE_LOC_MASK		0xC0
+#define TAS5716_MMUTE_LOC_SHIFT		6
+
+/* 0x0b AUTO1 */
+#define TAS5716_AUTO1_AMGC_MASK	0x30
+#define TAS5716_AUTO1_AMGC_SHIFT	4
+
+/* 0x0c AUTO2 */
+#define TAS5716_AUTO2_AMAME	0x01
+#define TAS5716_AUTO2_AMAM_MASK	0x0e
+#define TAS5716_AUTO2_AMAM_SHIFT	1
+#define TAS5716_AUTO2_XO_MASK	0xf0
+#define TAS5716_AUTO2_XO_SHIFT	4
+
+/* 0x0d AUTO3 */
+#define TAS5716_AUTO3_PEQ_MASK	0x1f
+#define TAS5716_AUTO3_PEQ_SHIFT	0
+
+/* 0x0e 0x0f 0x10 CxCFG */
+#define TAS5716_CxCFG_TCB_SHIFT	0
+#define TAS5716_CxCFG_EQBP_SHIFT	1
+#define TAS5716_CxCFG_VBP_SHIFT	2
+#define TAS5716_CxCFG_BO_SHIFT	3
+#define TAS5716_CxCFG_LS_SHIFT	4
+#define TAS5716_CxCFG_OM_MASK	0xc0
+#define TAS5716_CxCFG_OM_SHIFT	6
+
+/* 0x11 TONE */
+#define TAS5716_TONE_BTC_SHIFT	0
+#define TAS5716_TONE_TTC_SHIFT	4
+
+/* 0x12 0x13 0x14 0x15 limiter attack/release */
+#define TAS5716_LxA_SHIFT	0
+#define TAS5716_LxR_SHIFT	4
+
+/* 0x26 CFUD */
+#define TAS5716_CFUD_W1		0x01
+#define TAS5716_CFUD_WA		0x02
+#define TAS5716_CFUD_R1		0x04
+#define TAS5716_CFUD_RA		0x08
+
+
+/* biquad filter coefficient table offsets */
+#define TAS5716_C1_BQ_BASE	0
+#define TAS5716_C2_BQ_BASE	20
+#define TAS5716_CH_BQ_NUM	4
+#define TAS5716_BQ_NUM_COEF	5
+#define TAS5716_XO_HP_BQ_BASE	40
+#define TAS5716_XO_LP_BQ_BASE	45
+#define TAS5716_C1_PRESCALE	50
+#define TAS5716_C2_PRESCALE	51
+#define TAS5716_C1_POSTSCALE	52
+#define TAS5716_C2_POSTSCALE	53
+#define TAS5716_C3_POSTSCALE	54
+#define TAS5716_TW_POSTSCALE	55
+#define TAS5716_C1_MIX1		56
+#define TAS5716_C1_MIX2		57
+#define TAS5716_C2_MIX1		58
+#define TAS5716_C2_MIX2		59
+#define TAS5716_C3_MIX1		60
+#define TAS5716_C3_MIX2		61
+
+/* miscellaneous register 1 */
+#define TAS5716_MISC1_CPWMEN	BIT(2)
+#define TAS5716_MISC1_BRIDGOFF	BIT(5)
+#define TAS5716_MISC1_NSHHPEN	BIT(6)
+#define TAS5716_MISC1_RPDNEN	BIT(7)
+
+/* miscellaneous register 2 */
+#define TAS5716_MISC2_PNDLSL_MASK	0x1c
+#define TAS5716_MISC2_PNDLSL_SHIFT	2
+
+#endif /* _ASOC_TAS_5716_H */
diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
index 79511ae..3b8d2b3 100644
--- a/sound/soc/sunxi/Kconfig
+++ b/sound/soc/sunxi/Kconfig
@@ -7,4 +7,14 @@ config SND_SUNXI_SOC_CODEC
 	select REGMAP_MMIO
 	default y
 
+config SND_SUNXI_SOC_I2S
+	tristate "Sunxi I2S support"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	default y
+
+source "sound/soc/sunxi/i2s/Kconfig"
+
+
 endmenu
+
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
index b8950d3..b40e4cb 100644
--- a/sound/soc/sunxi/Makefile
+++ b/sound/soc/sunxi/Makefile
@@ -1,2 +1,5 @@
 obj-$(CONFIG_SND_SUNXI_SOC_CODEC) += sunxi-codec.o
-
+obj-$(CONFIG_SND_SUNXI_SOC_I2S) += sunxi-i2s.o
+obj-$(CONFIG_SND_SUNXI_SOC_HDMI_INTERFACE) += hdmiaudio/
+obj-$(CONFIG_SND_SUNXI_SOC_SPDIF_INTERFACE) += spdif/
+obj-$(CONFIG_SND_SUNXI_SOC_I2S_INTERFACE) += i2s/
diff --git a/sound/soc/sunxi/sunxi-i2s.c b/sound/soc/sunxi/sunxi-i2s.c
new file mode 100644
index 0000000..12d3515
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-i2s.c
@@ -0,0 +1,641 @@
+/*
+ * Copyright 2014 Emilio Lpez <emilio@elopez.com.ar>
+ * Copyright 2014 Jon Smirl <jonsmirl@gmail.com>
+ *
+ * Based on the Allwinner SDK driver, released under the GPL.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/clk.h>
+#include <linux/regmap.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "sunxi-i2s.h"
+
+void sunxi_snd_txctrl_i2s(struct sunxi_priv *priv, struct snd_pcm_substream *substream, int on)
+{
+	u32 reg_val;
+
+	regmap_update_bits(priv->regmap, SUNXI_I2S_TXCHSEL, SUNXI_I2STXCHSEL_CHNUM_MASK, 
+				(substream->runtime->channels - 1) << SUNXI_I2STXCHSEL_CHNUM_SHIFT);
+
+	regmap_raw_read(priv->regmap, SUNXI_I2S_TXCHMAP, &reg_val, sizeof(reg_val));
+	reg_val = 0;
+	if (priv->revision == SUN4I) {
+		if(substream->runtime->channels == 1) {
+			reg_val = 0x76543200;
+		} else {
+			reg_val = 0x76543210;
+		}
+	} else {
+		if(substream->runtime->channels == 1) {
+			reg_val = 0x00000000;
+		} else {
+			reg_val = 0x00000010;
+		}
+	}
+	regmap_write(priv->regmap, SUNXI_I2S_TXCHMAP, reg_val);
+
+	regmap_read(priv->regmap, SUNXI_I2S_CTL, &reg_val);
+	if (priv->revision == SUN4I) {
+		reg_val &= ~SUNXI_I2SCTL_SDOEN_ALL;
+		switch(substream->runtime->channels) {
+			case 1:
+			case 2:
+				reg_val |= SUNXI_I2SCTL_SDO0EN;
+				break;
+			case 3:
+			case 4:
+				reg_val |= SUNXI_I2SCTL_SDO0EN;
+				reg_val |= SUNXI_I2SCTL_SDO1EN;
+				break;
+			case 5:
+			case 6:
+				reg_val |= SUNXI_I2SCTL_SDO0EN;
+				reg_val |= SUNXI_I2SCTL_SDO1EN;
+				reg_val |= SUNXI_I2SCTL_SDO2EN;
+				break;
+			case 7:
+			case 8:
+				reg_val |= SUNXI_I2SCTL_SDO0EN;
+				reg_val |= SUNXI_I2SCTL_SDO1EN;
+				reg_val |= SUNXI_I2SCTL_SDO2EN;
+				reg_val |= SUNXI_I2SCTL_SDO3EN;
+				break;
+			default:
+				reg_val |= SUNXI_I2SCTL_SDO0EN;
+		}
+	} else {
+		reg_val |= SUNXI_I2SCTL_SDO0EN;
+	}
+	regmap_write(priv->regmap, SUNXI_I2S_CTL, reg_val);
+
+	//flush TX FIFO
+	regmap_update_bits(priv->regmap, SUNXI_I2S_FCTL, SUNXI_I2SFCTL_FTX_MASK, SUNXI_I2SFCTL_FTX);
+
+	//clear TX counter
+	regmap_write(priv->regmap, SUNXI_I2S_TXCNT, 0);
+
+	if (on) {
+		/* IIS TX ENABLE */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_TXEN_MASK, SUNXI_I2SCTL_TXEN);
+
+		/* enable DMA DRQ mode for play */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_INT, SUNXI_I2SINT_TXDRQEN_MASK, SUNXI_I2SINT_TXDRQEN);
+
+		//Global Enable Digital Audio Interface
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_GEN_MASK, SUNXI_I2SCTL_GEN);
+
+	} else {
+		/* IIS TX DISABLE */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_TXEN_MASK, 0);
+
+		/* DISBALE dma DRQ mode */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_INT, SUNXI_I2SINT_TXDRQEN_MASK, 0);
+
+		//Global disable Digital Audio Interface
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_GEN_MASK, 0);
+	}
+}
+
+void sunxi_snd_rxctrl_i2s(struct sunxi_priv *priv, int on)
+{
+	//flush RX FIFO
+	regmap_update_bits(priv->regmap, SUNXI_I2S_FCTL, SUNXI_I2SFCTL_FRX_MASK, SUNXI_I2SFCTL_FRX);
+
+	//clear RX counter
+	regmap_write(priv->regmap, SUNXI_I2S_RXCNT, 0);
+
+	if (on) {
+		/* IIS RX ENABLE */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_RXEN_MASK, SUNXI_I2SCTL_RXEN);
+
+		/* enable DMA DRQ mode for record */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_INT, SUNXI_I2SINT_RXDRQEN_MASK, SUNXI_I2SINT_RXDRQEN);
+
+		//Global Enable Digital Audio Interface
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_GEN_MASK, SUNXI_I2SCTL_GEN);
+
+	} else {
+		/* IIS RX DISABLE */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_RXEN_MASK, 0);
+
+		/* DISBALE dma DRQ mode */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_INT, SUNXI_I2SINT_RXDRQEN_MASK, 0);
+
+		//Global disable Digital Audio Interface
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_GEN_MASK, 0);
+	}
+}
+
+static inline int sunxi_snd_is_clkmaster(struct sunxi_priv *priv)
+{
+	u32 reg_val;
+
+	regmap_read(priv->regmap, SUNXI_I2S_CTL, &reg_val);
+	return ((reg_val & SUNXI_I2SCTL_MS_MASK) ? 0 : 1);
+}
+
+static int sunxi_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 reg_val;
+
+	//SDO ON
+	if (priv->revision == SUN4I) {
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_SDOEN_ALL, SUNXI_I2SCTL_SDOEN_ALL);
+	} else {
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_SDO0EN_MASK, SUNXI_I2SCTL_SDO0EN);
+	}
+
+
+	/* master or slave selection */
+	switch(fmt & SND_SOC_DAIFMT_MASTER_MASK){
+	case SND_SOC_DAIFMT_CBM_CFM:   /* codec clk & frm master */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_MS_MASK, SUNXI_I2SCTL_MS);
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:   /* codec clk & frm slave */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_MS_MASK, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* pcm or i2s mode selection */
+	switch(fmt & SND_SOC_DAIFMT_FORMAT_MASK){
+	case SND_SOC_DAIFMT_I2S:        /* I2S mode */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_PCM_MASK, SUNXI_I2SCTL_PCM);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_FMT_MASK, SUNXI_I2SFAT0_FMT_I2S);
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:    /* Right Justified mode */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_PCM_MASK, 0);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_FMT_MASK, SUNXI_I2SFAT0_FMT_RGT);
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:     /* Left Justified mode */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_PCM_MASK, 0);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_FMT_MASK, SUNXI_I2SFAT0_FMT_LFT);
+		break;
+	case SND_SOC_DAIFMT_DSP_A:      /* L data msb after FRM LRC */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_PCM_MASK, SUNXI_I2SCTL_PCM);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_LRCP_MASK, 0);
+		break;
+	case SND_SOC_DAIFMT_DSP_B:      /* L data msb during FRM LRC */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_PCM_MASK, SUNXI_I2SCTL_PCM);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_LRCP_MASK, SUNXI_I2SFAT0_LRCP);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* DAI signal inversions */
+	switch(fmt & SND_SOC_DAIFMT_INV_MASK){
+	case SND_SOC_DAIFMT_NB_NF:     /* normal bit clock + frame */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_LRCP_MASK, 0);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_BCP_MASK, 0);
+		break;
+	case SND_SOC_DAIFMT_NB_IF:     /* normal bclk + inv frm */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_LRCP_MASK, SUNXI_I2SFAT0_LRCP);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_BCP_MASK, 0);
+		break;
+	case SND_SOC_DAIFMT_IB_NF:     /* invert bclk + nor frm */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_LRCP_MASK, 0);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_BCP_MASK, SUNXI_I2SFAT0_BCP);
+		break;
+	case SND_SOC_DAIFMT_IB_IF:     /* invert bclk + frm */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_LRCP_MASK, SUNXI_I2SFAT0_LRCP);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_BCP_MASK, SUNXI_I2SFAT0_BCP);
+		break;
+	}
+
+	/* word select size */
+	if(priv->ws_size == 16)
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_WSS_MASK, SUNXI_I2SFAT0_WSS_16BCLK);
+	else if(priv->ws_size == 20)
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_WSS_MASK, SUNXI_I2SFAT0_WSS_20BCLK);
+	else if(priv->ws_size == 24)
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_WSS_MASK, SUNXI_I2SFAT0_WSS_24BCLK);
+	else
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_WSS_MASK, SUNXI_I2SFAT0_WSS_32BCLK);
+
+	/* PCM REGISTER setup */
+	reg_val = priv->pcm_txtype & 0x3;
+	reg_val |= priv->pcm_rxtype << 2;
+
+	if(!priv->pcm_sync_type)
+		reg_val |= SUNXI_I2SFAT1_SSYNC;				// short sync
+	if(priv->pcm_sw == 16)
+		reg_val |= SUNXI_I2SFAT1_SW;
+
+	reg_val |= ((priv->pcm_start_slot - 1) << SUNXI_I2SFAT1_SI_SHIFT) & SUNXI_I2SFAT1_SI_MASK; // start slot index
+
+	reg_val |= priv->pcm_lsb_first << SUNXI_I2SFAT1_MLS_SHIFT;	// MSB or LSB first
+
+	if(priv->pcm_sync_period == 256)
+		reg_val |= SUNXI_I2SFAT1_SYNCLEN_256BCLK;
+	else if (priv->pcm_sync_period == 128)
+		reg_val |= SUNXI_I2SFAT1_SYNCLEN_128BCLK;
+	else if (priv->pcm_sync_period == 64)
+		reg_val |= SUNXI_I2SFAT1_SYNCLEN_64BCLK;
+	else if (priv->pcm_sync_period == 32)
+		reg_val |= SUNXI_I2SFAT1_SYNCLEN_32BCLK;
+	regmap_write(priv->regmap, SUNXI_I2S_FAT1, reg_val);
+
+	/* set FIFO control register */
+	reg_val = SUNXI_I2SFCTL_RXOM_MOD0;
+	reg_val |= SUNXI_I2SFCTL_TXIM_MOD1;
+	reg_val |= SUNXI_I2SFCTL_RXTL(0xf);				//RX FIFO trigger level
+	reg_val |= SUNXI_I2SFCTL_TXTL(0x40);				//TX FIFO empty trigger level
+	regmap_write(priv->regmap, SUNXI_I2S_FCTL, reg_val);
+	return 0;
+}
+
+static int sunxi_i2s_hw_params(struct snd_pcm_substream *substream, 
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *cpu_dai)
+{
+	return 0;
+}
+
+static int sunxi_i2s_trigger(struct snd_pcm_substream *substream,
+                              int cmd, struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret = 0;
+
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+				sunxi_snd_rxctrl_i2s(priv, 1);
+			} else {
+				sunxi_snd_txctrl_i2s(priv, substream, 1);
+			}
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+				sunxi_snd_rxctrl_i2s(priv, 0);
+			} else {
+				sunxi_snd_txctrl_i2s(priv, substream, 0);
+			}
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+
+	return ret;
+}
+
+//freq:   1: 22.5792MHz   0: 24.576MHz
+static int sunxi_i2s_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id, unsigned int freq, int dir)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	if (!freq) {
+		clk_set_rate(priv->clk_pll2, 24576000);
+	} else {
+		clk_set_rate(priv->clk_pll2, 22579200);
+	}
+
+	return 0;
+}
+
+static int sunxi_i2s_set_clkdiv(struct snd_soc_dai *cpu_dai, int div_id, int div)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 reg;
+
+	switch (div_id) {
+	case SUNXI_DIV_MCLK:
+		if (div >= 64)
+			div = SUNXI_I2SCLKD_MCLKDIV_64;
+		else if (div >= 48)
+			div = SUNXI_I2SCLKD_MCLKDIV_48;
+		else if (div >= 32)
+			div = SUNXI_I2SCLKD_MCLKDIV_32;
+		else if (div >= 24)
+			div = SUNXI_I2SCLKD_MCLKDIV_24;
+		else if (div >= 16)
+			div  = SUNXI_I2SCLKD_MCLKDIV_16;
+		else if (div >= 12)
+			div  = SUNXI_I2SCLKD_MCLKDIV_12;
+		else if (div >= 8)
+			div  = SUNXI_I2SCLKD_MCLKDIV_8;
+		else if (div >= 6)
+			div  = SUNXI_I2SCLKD_MCLKDIV_6;
+		else if (div >= 4)
+			div  = SUNXI_I2SCLKD_MCLKDIV_4;
+		else 
+			div  = SUNXI_I2SCLKD_MCLKDIV_2;
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CLKD, SUNXI_I2SCLKD_MCLKDIV_MASK, div);
+		break;
+	case SUNXI_DIV_BCLK:
+		if (div >= 64)
+			div = SUNXI_I2SCLKD_BCLKDIV_64;
+		else if (div >= 32)
+			div = SUNXI_I2SCLKD_BCLKDIV_32;
+		else if (div >= 16)
+			div  = SUNXI_I2SCLKD_BCLKDIV_16;
+		else if (div >= 8)
+			div  = SUNXI_I2SCLKD_BCLKDIV_8;
+		else if (div >= 6)
+			div  = SUNXI_I2SCLKD_BCLKDIV_6;
+		else if (div >= 4)
+			div  = SUNXI_I2SCLKD_BCLKDIV_4;
+		else 
+			div  = SUNXI_I2SCLKD_BCLKDIV_2;
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CLKD, SUNXI_I2SCLKD_BCLKDIV_MASK, div);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	//diable MCLK output when high samplerate
+	regmap_read(priv->regmap, SUNXI_I2S_CLKD, &reg);
+	if (!(reg & SUNXI_I2SCLKD_MCLKDIV_MASK)) {
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CLKD, SUNXI_I2SCLKD_MCLKOEN_MASK, 0);
+	} else {
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CLKD, SUNXI_I2SCLKD_MCLKOEN_MASK, SUNXI_I2SCLKD_MCLKOEN);
+	}
+	return 0;
+}
+
+static int sunxi_i2s_dai_probe(struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	snd_soc_dai_init_dma_data(cpu_dai, &priv->playback_dma_data, &priv->capture_dma_data);
+
+	return 0;
+}
+
+static int sunxi_i2s_dai_remove(struct snd_soc_dai *cpu_dai)
+{
+	return 0;
+}
+
+static void iisregsave(void)
+{
+	/*regsave[0] = readl(priv->regs + SUNXI_I2S_CTL);
+	regsave[1] = readl(priv->regs + SUNXI_I2S_FAT0);
+	regsave[2] = readl(priv->regs + SUNXI_I2S_FAT1);
+	regsave[3] = readl(priv->regs + SUNXI_I2S_FCTL) | (0x3<<24);
+	regsave[4] = readl(priv->regs + SUNXI_I2S_INT);
+	regsave[5] = readl(priv->regs + SUNXI_I2S_CLKD);
+	regsave[6] = readl(priv->regs + SUNXI_TXCHSEL);
+	regsave[7] = readl(priv->regs + SUNXI_TXCHMAP);*/
+}
+
+static void iisregrestore(void)
+{
+	/*writel(regsave[0], priv->regs + SUNXI_I2S_CTL);
+	writel(regsave[1], priv->regs + SUNXI_I2S_FAT0);
+	writel(regsave[2], priv->regs + SUNXI_I2S_FAT1);
+	writel(regsave[3], priv->regs + SUNXI_I2S_FCTL);
+	writel(regsave[4], priv->regs + SUNXI_I2S_INT);
+	writel(regsave[5], priv->regs + SUNXI_I2S_CLKD);
+	writel(regsave[6], priv->regs + SUNXI_TXCHSEL);
+	writel(regsave[7], priv->regs + SUNXI_TXCHMAP);*/
+}
+
+static int sunxi_i2s_suspend(struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	printk("[IIS]Entered %s\n", __func__);
+
+	//Global Enable Digital Audio Interface
+	regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_GEN_MASK, 0);
+
+	iisregsave();
+
+	//release the module clock
+	clk_disable(priv->clk_module);
+
+	clk_disable(priv->clk_apb);
+
+	//printk("[IIS]PLL2 0x01c20008 = %#x\n", *(volatile int*)0xF1C20008);
+	printk("[IIS]SPECIAL CLK 0x01c20068 = %#x, line= %d\n", *(volatile int*)0xF1C20068, __LINE__);
+	printk("[IIS]SPECIAL CLK 0x01c200B8 = %#x, line = %d\n", *(volatile int*)0xF1C200B8, __LINE__);
+
+	return 0;
+}
+static int sunxi_i2s_resume(struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	printk("[IIS]Entered %s\n", __func__);
+
+	//release the module clock
+	clk_enable(priv->clk_apb);
+
+	//release the module clock
+	clk_enable(priv->clk_module);
+
+	iisregrestore();
+
+	//Global Enable Digital Audio Interface
+	regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_GEN_MASK, SUNXI_I2SCTL_GEN);
+
+	//printk("[IIS]PLL2 0x01c20008 = %#x\n", *(volatile int*)0xF1C20008);
+	printk("[IIS]SPECIAL CLK 0x01c20068 = %#x, line= %d\n", *(volatile int*)0xF1C20068, __LINE__);
+	printk("[IIS]SPECIAL CLK 0x01c200B8 = %#x, line = %d\n", *(volatile int*)0xF1C200B8, __LINE__);
+
+	return 0;
+}
+
+#define SUNXI_I2S_RATES (SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT)
+static struct snd_soc_dai_ops sunxi_i2s_dai_ops = {
+	.trigger 	= sunxi_i2s_trigger,
+	.hw_params 	= sunxi_i2s_hw_params,
+	.set_fmt 	= sunxi_i2s_set_fmt,
+	.set_clkdiv = sunxi_i2s_set_clkdiv,
+	.set_sysclk = sunxi_i2s_set_sysclk,
+};
+
+static struct snd_soc_dai_driver sunxi_i2s_dai = {
+	.probe 		= sunxi_i2s_dai_probe,
+	.suspend 	= sunxi_i2s_suspend,
+	.resume 	= sunxi_i2s_resume,
+	.remove 	= sunxi_i2s_dai_remove,
+	.playback 	= {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.capture 	= {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.symmetric_rates = 1,
+	.ops 		= &sunxi_i2s_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_i2s_component = {
+	.name = "sunxi-i2s",
+};
+
+static const struct regmap_config sunxi_i2s_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_I2S_RXCHMAP,
+};
+
+static const struct of_device_id sunxi_i2s_of_match[] = {
+	{ .compatible = "allwinner,sun4i-a10-iis", .data = (void *)SUN4I},
+	{ .compatible = "allwinner,sun5i-a13-iis", .data = (void *)SUN5I},
+	{ .compatible = "allwinner,sun7i-a20-iis", .data = (void *)SUN7I},
+	{}
+};
+MODULE_DEVICE_TABLE(of, sunxi_i2s_of_match);
+
+static int sunxi_i2s_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct sunxi_priv *priv;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	of_id = of_match_device(sunxi_i2s_of_match, dev);
+	if (!of_id)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->revision = (enum sunxi_soc_family)of_id->data;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	priv->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					     &sunxi_i2s_regmap_config);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	/* Get the clocks from the DT */
+	priv->clk_apb = devm_clk_get(dev, "apb");
+	if (IS_ERR(priv->clk_apb)) {
+		dev_err(dev, "failed to get apb clock\n");
+		return PTR_ERR(priv->clk_apb);
+	}
+	priv->clk_pll2 = devm_clk_get(dev, "pll2");
+	if (IS_ERR(priv->clk_pll2)) {
+		dev_err(dev, "failed to get pll2 clock\n");
+		return PTR_ERR(priv->clk_pll2);
+	}
+	priv->clk_module = devm_clk_get(dev, "iis");
+	if (IS_ERR(priv->clk_module)) {
+		dev_err(dev, "failed to get iis clock\n");
+		return PTR_ERR(priv->clk_module);
+	}
+
+	/* Enable PLL2 on a basic rate */
+	ret = clk_set_rate(priv->clk_pll2, 24576000);
+	if (ret) {
+		dev_err(dev, "failed to set i2s base clock rate\n");
+		return ret;
+	}
+	if (clk_prepare_enable(priv->clk_pll2)) {
+		dev_err(dev, "failed to enable pll2 clock\n");
+		return -EINVAL;
+	}
+
+	/* Enable the bus clock */
+	if (clk_prepare_enable(priv->clk_apb)) {
+		dev_err(dev, "failed to enable apb clock\n");
+		clk_disable_unprepare(priv->clk_pll2);
+		return -EINVAL;
+	}
+
+	/* DMA configuration for TX FIFO */
+	priv->playback_dma_data.addr = res->start + SUNXI_I2S_TXFIFO;
+	priv->playback_dma_data.maxburst = 4;
+	priv->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	/* DMA configuration for RX FIFO */
+	priv->capture_dma_data.addr = res->start + SUNXI_I2S_RXFIFO;
+	priv->capture_dma_data.maxburst = 4;
+	priv->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	dev_set_drvdata(&pdev->dev, priv);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_i2s_component, &sunxi_i2s_dai, 1);
+	if (ret)
+		goto err_clk_disable;
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret)
+		goto err_clk_disable;
+
+	return 0;
+
+err_clk_disable:
+	clk_disable_unprepare(priv->clk_apb);
+	clk_disable_unprepare(priv->clk_pll2);
+	return ret;
+}
+
+static int sunxi_i2s_remove(struct platform_device *pdev)
+{
+	struct sunxi_priv *priv = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(priv->clk_apb);
+	clk_disable_unprepare(priv->clk_pll2);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_i2s_driver = {
+	.driver = {
+		.name = "sunxi-i2s",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_i2s_of_match,
+	},
+	.probe = sunxi_i2s_probe,
+	.remove = sunxi_i2s_remove,
+};
+module_platform_driver(sunxi_i2s_driver);
+
+MODULE_DESCRIPTION("sunxi i2s ASoC driver");
+MODULE_AUTHOR("Jon Smirl <jonsmirl@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-i2s.h b/sound/soc/sunxi/sunxi-i2s.h
new file mode 100644
index 0000000..9f04dd6
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-i2s.h
@@ -0,0 +1,431 @@
+/*
+ * sound\soc\sunxi\i2s\sunxi-i2s.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef SUNXI_I2S_H_
+#define SUNXI_I2S_H_
+
+/*------------------------------------------------------------*/
+/* REGISTER definitions */
+
+#define SUNXI_I2S_CTL		0x00 /* Digital Audio Control Register */
+#define SUNXI_I2S_FAT0		0x04 /* Digital Audio Format Register 0 */
+#define SUNXI_I2S_FAT1		0x08 /* Digital Audio Format Register 1 */
+#define SUNXI_I2S_TXFIFO	0x0C /* Digital Audio TX FIFO Register */
+#define SUNXI_I2S_RXFIFO	0x10 /* Digital Audio RX FIFO Register */
+#define SUNXI_I2S_FCTL		0x14 /* Digital Audio FIFO Control Register */
+#define SUNXI_I2S_FSTA		0x18 /* Digital Audio FIFO Status Register */
+#define SUNXI_I2S_INT		0x1C /* Digital Audio Interrupt Control Register */
+#define SUNXI_I2S_ISTA		0x20 /* Digital Audio Interrupt Status Register */
+#define SUNXI_I2S_CLKD		0x24 /* Digital Audio Clock Divide Register */
+#define SUNXI_I2S_RXCNT		0x28 /* Digital Audio RX Sample Counter Register */
+#define SUNXI_I2S_TXCNT		0x2C /* Digital Audio TX Sample Counter Register */
+#define SUNXI_I2S_TXCHSEL	0x30 /* Digital Audio TX Channel Select register */
+#define SUNXI_I2S_TXCHMAP	0x34 /* Digital Audio TX Channel Mapping Register */
+#define SUNXI_I2S_RXCHSEL	0x38 /* Digital Audio RX Channel Select register */
+#define SUNXI_I2S_RXCHMAP	0x3C /* Digital Audio RX Channel Mapping Register */
+
+
+/* SUNXI_I2S_CTL	0x00 	 Digital Audio Control Register */
+#define SUNXI_I2SCTL_SDO3EN		(1<<11)
+#define SUNXI_I2SCTL_SDO3EN_MASK	(1<<11)
+#define SUNXI_I2SCTL_SDO3EN_SHIFT	11
+#define SUNXI_I2SCTL_SDO3EN_WIDTH	1
+#define SUNXI_I2SCTL_SDO2EN		(1<<10)
+#define SUNXI_I2SCTL_SDO2EN_MASK	(1<<10)
+#define SUNXI_I2SCTL_SDO2EN_SHIFT	10
+#define SUNXI_I2SCTL_SDO2EN_WIDTH	1
+#define SUNXI_I2SCTL_SDO1EN		(1<<9)
+#define SUNXI_I2SCTL_SDO1EN_MASK	(1<<9)
+#define SUNXI_I2SCTL_SDO1EN_SHIFT	9
+#define SUNXI_I2SCTL_SDO1EN_WIDTH	1
+#define SUNXI_I2SCTL_SDO0EN		(1<<8)
+#define SUNXI_I2SCTL_SDO0EN_MASK	(1<<8)
+#define SUNXI_I2SCTL_SDO0EN_SHIFT	8
+#define SUNXI_I2SCTL_SDO0EN_WIDTH	1
+#define SUNXI_I2SCTL_SDOEN_ALL (SUNXI_I2SCTL_SDO3EN | SUNXI_I2SCTL_SDO2EN | SUNXI_I2SCTL_SDO1EN| SUNXI_I2SCTL_SDO0EN)
+
+#define SUNXI_I2SCTL_ASS		(1<<6)
+#define SUNXI_I2SCTL_ASS_MASK		(1<<6)
+#define SUNXI_I2SCTL_ASS_SHIFT		6
+#define SUNXI_I2SCTL_ASS_WIDTH		1
+#define SUNXI_I2SCTL_MS			(1<<5)
+#define SUNXI_I2SCTL_MS_MASK		(1<<5)
+#define SUNXI_I2SCTL_MS_SHIFT		5
+#define SUNXI_I2SCTL_MS_WIDTH		1
+#define SUNXI_I2SCTL_PCM		(1<<4)
+#define SUNXI_I2SCTL_PCM_MASK		(1<<4)
+#define SUNXI_I2SCTL_PCM_SHIFT		4
+#define SUNXI_I2SCTL_PCM_WIDTH		1
+#define SUNXI_I2SCTL_LOOP		(1<<3)
+#define SUNXI_I2SCTL_LOOP_MASK		(1<<3)
+#define SUNXI_I2SCTL_LOOP_SHIFT		3
+#define SUNXI_I2SCTL_LOOP_WIDTH		1
+#define SUNXI_I2SCTL_TXEN		(1<<2)
+#define SUNXI_I2SCTL_TXEN_MASK		(1<<2)
+#define SUNXI_I2SCTL_TXEN_SHIFT		2
+#define SUNXI_I2SCTL_TXEN_WIDTH		1
+#define SUNXI_I2SCTL_RXEN		(1<<1)
+#define SUNXI_I2SCTL_RXEN_MASK		(1<<1)
+#define SUNXI_I2SCTL_RXEN_SHIFT		1
+#define SUNXI_I2SCTL_RXEN_WIDTH		1
+#define SUNXI_I2SCTL_GEN		(1<<0)
+#define SUNXI_I2SCTL_GEN_MASK		(1<<0)
+#define SUNXI_I2SCTL_GEN_SHIFT		0
+#define SUNXI_I2SCTL_GEN_WIDTH		1
+
+/* SUNXI_I2S_FAT0	0x04 	 Digital Audio Format Register 0 */
+
+#define SUNXI_I2SFAT0_LRCP		(1<<7)
+#define SUNXI_I2SFAT0_LRCP_MASK		(1<<7)
+#define SUNXI_I2SFAT0_LRCP_SHIFT	7
+#define SUNXI_I2SFAT0_LRCP_WIDTH	1
+#define SUNXI_I2SFAT0_BCP		(1<<6)
+#define SUNXI_I2SFAT0_BCP_MASK		(1<<6)
+#define SUNXI_I2SFAT0_BCP_SHIFT		6
+#define SUNXI_I2SFAT0_BCP_WIDTH		1
+#define SUNXI_I2SFAT0_SR_MASK		(3<<4)
+#define SUNXI_I2SFAT0_SR_16BIT		(0<<4)
+#define	SUNXI_I2SFAT0_SR_20BIT		(1<<4)
+#define SUNXI_I2SFAT0_SR_24BIT		(2<<4)
+#define SUNXI_I2SFAT0_SR_SHIFT		4
+#define SUNXI_I2SFAT0_SR_WIDTH		2
+#define SUNXI_I2SFAT0_WSS_MASK		(3<<2)
+#define SUNXI_I2SFAT0_WSS_16BCLK	(0<<2)
+#define SUNXI_I2SFAT0_WSS_20BCLK	(1<<2)
+#define SUNXI_I2SFAT0_WSS_24BCLK	(2<<2)
+#define SUNXI_I2SFAT0_WSS_32BCLK	(3<<2)
+#define SUNXI_I2SFAT0_WSS_SHIFT		2
+#define SUNXI_I2SFAT0_WSS_WIDTH		2
+#define SUNXI_I2SFAT0_FMT_MASK		(3<<0)
+#define SUNXI_I2SFAT0_FMT_I2S		(0<<0)
+#define SUNXI_I2SFAT0_FMT_LFT		(1<<0)
+#define SUNXI_I2SFAT0_FMT_RGT		(2<<0)
+#define SUNXI_I2SFAT0_FMT_RVD		(3<<0)
+#define SUNXI_I2SFAT0_FMT_SHIFT		0
+#define SUNXI_I2SFAT0_FMT_WIDTH		2
+
+/* SUNXI_I2S_FAT1	0x08 	 Digital Audio Format Register 1 */
+
+#define SUNXI_I2SFAT1_SYNCLEN_MASK	(7<<12)
+#define SUNXI_I2SFAT1_SYNCLEN_16BCLK	(0<<12)
+#define SUNXI_I2SFAT1_SYNCLEN_32BCLK	(1<<12)
+#define SUNXI_I2SFAT1_SYNCLEN_64BCLK	(2<<12)
+#define SUNXI_I2SFAT1_SYNCLEN_128BCLK	(3<<12)
+#define SUNXI_I2SFAT1_SYNCLEN_256BCLK	(4<<12)
+#define SUNXI_I2SFAT1_SYNCLEN_SHIFT	12
+#define SUNXI_I2SFAT1_SYNCLEN_WIDTH	3
+#define SUNXI_I2SFAT1_SYNCOUTEN		(1<<11)
+#define SUNXI_I2SFAT1_SYNCOUTEN_MASK	(1<<11)
+#define SUNXI_I2SFAT1_SYNCOUTEN_SHIFT	11
+#define SUNXI_I2SFAT1_SYNCOUTEN_WIDTH	1
+#define SUNXI_I2SFAT1_OUTMUTE		(1<<10)
+#define SUNXI_I2SFAT1_OUTMUTE_MASK	(1<<10)
+#define SUNXI_I2SFAT1_OUTMUTE_SHIFT	10
+#define SUNXI_I2SFAT1_OUTMUTE_WIDTH	1
+#define SUNXI_I2SFAT1_MLS		(1<<9)
+#define SUNXI_I2SFAT1_MLS_MASK		(1<<9)
+#define SUNXI_I2SFAT1_MLS_SHIFT		9
+#define SUNXI_I2SFAT1_MLS_WIDTH		1
+#define SUNXI_I2SFAT1_SEXT		(1<<8)
+#define SUNXI_I2SFAT1_SEXT_MASK		(1<<8)
+#define SUNXI_I2SFAT1_SEXT_SHIFT	8
+#define SUNXI_I2SFAT1_SEXT_WIDTH	1
+#define SUNXI_I2SFAT1_SI_MASK		(3<<6)
+#define SUNXI_I2SFAT1_SI_1ST		(0<<6)
+#define SUNXI_I2SFAT1_SI_2ND		(1<<6)
+#define SUNXI_I2SFAT1_SI_3RD		(2<<6)
+#define SUNXI_I2SFAT1_SI_4TH		(3<<6)
+#define SUNXI_I2SFAT1_SI_SHIFT		6
+#define SUNXI_I2SFAT1_SI_WIDTH		2
+#define SUNXI_I2SFAT1_SW		(1<<5)
+#define SUNXI_I2SFAT1_SW_MASK		(1<<5)
+#define SUNXI_I2SFAT1_SW_SHIFT		5
+#define SUNXI_I2SFAT1_SW_WIDTH		1
+#define SUNXI_I2SFAT1_SSYNC		(1<<4)
+#define SUNXI_I2SFAT1_SSYNC_MASK	(1<<4)
+#define SUNXI_I2SFAT1_SSYNC_SHIFT	4
+#define SUNXI_I2SFAT1_SSYNC_WIDTH	1
+#define SUNXI_I2SFAT1_RXPDM_MASK	(3<<2)
+#define SUNXI_I2SFAT1_RXPDM_16PCM	(0<<2)
+#define SUNXI_I2SFAT1_RXPDM_8PCM	(1<<2)
+#define SUNXI_I2SFAT1_RXPDM_8ULAW	(2<<2)
+#define SUNXI_I2SFAT1_RXPDM_8ALAW  	(3<<2)
+#define SUNXI_I2SFAT1_RXPDM_SHIFT	2
+#define SUNXI_I2SFAT1_RXPDM_WIDTH	2
+#define SUNXI_I2SFAT1_TXPDM_MASK	(3<<0)
+#define SUNXI_I2SFAT1_TXPDM_16PCM	(0<<0)
+#define SUNXI_I2SFAT1_TXPDM_8PCM	(1<<0)
+#define SUNXI_I2SFAT1_TXPDM_8ULAW	(2<<0)
+#define SUNXI_I2SFAT1_TXPDM_8ALAW  	(3<<0)
+#define SUNXI_I2SFAT1_TXPDM_SHIFT	0
+#define SUNXI_I2SFAT1_TXPDM_WIDTH	2
+
+/* SUNXI_I2S_TXFIFO	0x0C 	 Digital Audio TX FIFO Register */
+
+/* SUNXI_I2S_RXFIFO	0x10 	 Digital Audio RX FIFO Register */
+
+/* SUNXI_I2S_FCTL	0x14 	 Digital Audio FIFO Control Register */
+
+#define SUNXI_I2SFCTL_FIFOSRC		(1<<31)
+#define SUNXI_I2SFCTL_FIFOSRC_MASK	(1<<31)
+#define SUNXI_I2SFCTL_FIFOSRC_SHIFT	31
+#define SUNXI_I2SFCTL_FIFOSRC_WIDTH	1
+#define SUNXI_I2SFCTL_FTX		(1<<25)
+#define SUNXI_I2SFCTL_FTX_MASK		(1<<25)
+#define SUNXI_I2SFCTL_FTX_SHIFT		25
+#define SUNXI_I2SFCTL_FTX_WIDTH		1
+#define SUNXI_I2SFCTL_FRX		(1<<24)
+#define SUNXI_I2SFCTL_FRX_MASK		(1<<24)
+#define SUNXI_I2SFCTL_FRX_SHIFT		24
+#define SUNXI_I2SFCTL_FRX_WIDTH		1
+#define SUNXI_I2SFCTL_TXTL(x) ((x << SUNXI_I2SFCTL_TXTL_SHIFT) & SUNXI_I2SFCTL_TXTL_MASK)
+#define SUNXI_I2SFCTL_TXTL_MASK		(0x3F<<12)
+#define SUNXI_I2SFCTL_TXTL_SHIFT	12
+#define SUNXI_I2SFCTL_TXTL_WIDTH	7
+#define SUNXI_I2SFCTL_RXTL(x) ((x << SUNXI_I2SFCTL_RXTL_SHIFT) & SUNXI_I2SFCTL_RXTL_MASK)
+#define SUNXI_I2SFCTL_RXTL_MASK		(0x3F<<4)
+#define SUNXI_I2SFCTL_RXTL_SHIFT	4
+#define SUNXI_I2SFCTL_RXTL_WIDTH	7
+#define SUNXI_I2SFCTL_TXIM_MASK		(1<<2)
+#define SUNXI_I2SFCTL_TXIM_MOD0		(0<<2)
+#define SUNXI_I2SFCTL_TXIM_MOD1		(1<<2)
+#define SUNXI_I2SFCTL_TXIM_SHIFT	2
+#define SUNXI_I2SFCTL_TXIM_WIDTH	1
+#define SUNXI_I2SFCTL_RXOM_MASK		(3<<0)
+#define SUNXI_I2SFCTL_RXOM_MOD0		(0<<0)
+#define SUNXI_I2SFCTL_RXOM_MOD1		(1<<0)
+#define SUNXI_I2SFCTL_RXOM_MOD2		(2<<0)
+#define SUNXI_I2SFCTL_RXOM_MOD3		(3<<0)
+#define SUNXI_I2SFCTL_RXOM_SHIFT	0
+#define SUNXI_I2SFCTL_RXOM_WIDTH	2
+
+/* SUNXI_I2S_FSTA	0x18 	 Digital Audio FIFO Status Register */
+
+#define SUNXI_I2SFSTA_TXE		(1<<28)
+#define SUNXI_I2SFSTA_TXE_MASK		(1<<28)
+#define SUNXI_I2SFSTA_TXE_SHIFT		28
+#define SUNXI_I2SFSTA_TXE_WIDTH		1
+#define SUNXI_I2SFSTA_TXECNT_MASK	(0xFF<<16)
+#define SUNXI_I2SFSTA_TXECNT_SHIFT	16
+#define SUNXI_I2SFSTA_TXECNT_WIDTH	8
+#define SUNXI_I2SFSTA_RXA		(1<<8)
+#define SUNXI_I2SFSTA_RXA_MASK		(1<<8)
+#define SUNXI_I2SFSTA_RXA_SHIFT		8
+#define SUNXI_I2SFSTA_RXA_WIDTH		1
+#define SUNXI_I2SFSTA_RXACNT_MASK	(0x3F<<0)
+#define SUNXI_I2SFSTA_RXACNT_SHIFT	0
+#define SUNXI_I2SFSTA_RXACNT_WIDTH	7
+
+/* SUNXI_I2S_INT	0x1C 	 Digital Audio Interrupt Control Register */
+
+#define SUNXI_I2SINT_TXDRQEN		(1<<7)
+#define SUNXI_I2SINT_TXDRQEN_MASK	(1<<7)
+#define SUNXI_I2SINT_TXDRQEN_SHIFT	7
+#define SUNXI_I2SINT_TXDRQEN_WIDTH	1
+#define SUNXI_I2SINT_TXUIEN		(1<<6)
+#define SUNXI_I2SINT_TXUIEN_MASK	(1<<6)
+#define SUNXI_I2SINT_TXUIEN_SHIFT	6
+#define SUNXI_I2SINT_TXUIEN_WIDTH	1
+#define SUNXI_I2SINT_TXOIEN		(1<<5)
+#define SUNXI_I2SINT_TXOIEN_MASK	(1<<5)
+#define SUNXI_I2SINT_TXOIEN_SHIFT	5
+#define SUNXI_I2SINT_TXOIEN_WIDTH	1
+#define SUNXI_I2SINT_TXEIEN		(1<<4)
+#define SUNXI_I2SINT_TXEIEN_MASK	(1<<4)
+#define SUNXI_I2SINT_TXEIEN_SHIFT	4
+#define SUNXI_I2SINT_TXEIEN_WIDTH	1
+#define SUNXI_I2SINT_RXDRQEN		(1<<3)
+#define SUNXI_I2SINT_RXDRQEN_MASK	(1<<3)
+#define SUNXI_I2SINT_RXDRQEN_SHIFT	3
+#define SUNXI_I2SINT_RXDRQEN_WIDTH	1
+#define SUNXI_I2SINT_RXUIEN		(1<<2)
+#define SUNXI_I2SINT_RXUIEN_MASK	(1<<2)
+#define SUNXI_I2SINT_RXUIEN_SHIFT	2
+#define SUNXI_I2SINT_RXUIEN_WIDTH	1
+#define SUNXI_I2SINT_RXOIEN		(1<<1)
+#define SUNXI_I2SINT_RXOIEN_MASK	(1<<1)
+#define SUNXI_I2SINT_RXOIEN_SHIFT	1
+#define SUNXI_I2SINT_RXOIEN_WIDTH	1
+#define SUNXI_I2SINT_RXAIEN		(1<<0)
+#define SUNXI_I2SINT_RXAIEN_MASK	(1<<0)
+#define SUNXI_I2SINT_RXAIEN_SHIFT	0
+#define SUNXI_I2SINT_RXAIEN_WIDTH	1
+
+/* SUNXI_I2S_ISTA	0x20 	 Digital Audio Interrupt Status Register */
+
+#define SUNXI_I2SSTA_TXUIEN		(1<<6)
+#define SUNXI_I2SSTA_TXUIEN_MASK	(1<<6)
+#define SUNXI_I2SSTA_TXUIEN_SHIFT	6
+#define SUNXI_I2SSTA_TXUIEN_WIDTH	1
+#define SUNXI_I2SSTA_TXOIEN		(1<<5)
+#define SUNXI_I2SSTA_TXOIEN_MASK	(1<<5)
+#define SUNXI_I2SSTA_TXOIEN_SHIFT	5
+#define SUNXI_I2SSTA_TXOIEN_WIDTH	1
+#define SUNXI_I2SSTA_TXEIEN		(1<<4)
+#define SUNXI_I2SSTA_TXEIEN_MASK	(1<<4)
+#define SUNXI_I2SSTA_TXEIEN_SHIFT	4
+#define SUNXI_I2SSTA_TXEIEN_WIDTH	1
+#define SUNXI_I2SSTA_RXUIEN		(1<<2)
+#define SUNXI_I2SSTA_RXUIEN_MASK	(1<<2)
+#define SUNXI_I2SSTA_RXUIEN_SHIFT	2
+#define SUNXI_I2SSTA_RXUIEN_WIDTH	1
+#define SUNXI_I2SSTA_RXOIEN		(1<<1)
+#define SUNXI_I2SSTA_RXOIEN_MASK	(1<<1)
+#define SUNXI_I2SSTA_RXOIEN_SHIFT	1
+#define SUNXI_I2SSTA_RXOIEN_WIDTH	1
+#define SUNXI_I2SSTA_RXAIEN		(1<<0)
+#define SUNXI_I2SSTA_RXAIEN_MASK	(1<<0)
+#define SUNXI_I2SSTA_RXAIEN_SHIFT	0
+#define SUNXI_I2SSTA_RXAIEN_WIDTH	1
+
+/* SUNXI_I2S_CLKD	0x24 	 Digital Audio Clock Divide Register */
+
+#define SUNXI_I2SCLKD_MCLKOEN		(1<<7)
+#define SUNXI_I2SCLKD_MCLKOEN_MASK	(1<<7)
+#define SUNXI_I2SCLKD_MCLKOEN_SHIFT	7
+#define SUNXI_I2SCLKD_MCLKOEN_WIDTH	1
+#define SUNXI_I2SCLKD_BCLKDIV_MASK	(7<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_2		(0<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_4		(1<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_6		(2<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_8		(3<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_12	(4<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_16	(5<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_32	(6<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_64	(7<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_SHIFT	4
+#define SUNXI_I2SCLKD_BCLKDIV_WIDTH	3
+#define SUNXI_I2SCLKD_MCLKDIV_MASK	(0xF<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_1		(0<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_2		(1<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_4		(2<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_6		(3<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_8		(4<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_12	(5<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_16	(6<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_24	(7<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_32	(8<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_48	(9<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_64	(10<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_SHIFT	0
+#define SUNXI_I2SCLKD_MCLKDIV_WIDTH	4
+
+/* SUNXI_I2S_RXCNT	0x28 	 Digital Audio RX Sample Counter Register */
+
+/* SUNXI_I2S_TXCNT	0x2C 	 Digital Audio TX Sample Counter Register */
+
+/* SUNXI_I2S_TXCHSEL	0x30 	 Digital Audio TX Channel Select register */
+
+#define SUNXI_I2STXCHSEL_CHNUM_MASK	(7<<0)
+#define SUNXI_I2STXCHSEL_CHNUM_SHIFT	0
+#define SUNXI_I2STXCHSEL_CHNUM_WIDTH	3
+
+/* SUNXI_I2S_TXCHMAP	0x34 	 Digital Audio TX Channel Mapping Register */
+
+#define SUNXI_I2STXCHMAP_CH7_MASK	(7<<28)
+#define SUNXI_I2STXCHMAP_CH7_SHIFT	28
+#define SUNXI_I2STXCHMAP_CH7_WIDTH	3
+#define SUNXI_I2STXCHMAP_CH6_MASK	(7<<24)
+#define SUNXI_I2STXCHMAP_CH6_SHIFT	24
+#define SUNXI_I2STXCHMAP_CH6_WIDTH	3
+#define SUNXI_I2STXCHMAP_CH5_MASK	(7<<20)
+#define SUNXI_I2STXCHMAP_CH5_SHIFT	20
+#define SUNXI_I2STXCHMAP_CH5_WIDTH	3
+#define SUNXI_I2STXCHMAP_CH4_MASK	(7<<16)
+#define SUNXI_I2STXCHMAP_CH4_SHIFT	16
+#define SUNXI_I2STXCHMAP_CH4_WIDTH	3
+#define SUNXI_I2STXCHMAP_CH3_MASK	(7<<12)
+#define SUNXI_I2STXCHMAP_CH3_SHIFT	12
+#define SUNXI_I2STXCHMAP_CH3_WIDTH	3
+#define SUNXI_I2STXCHMAP_CH2_MASK	(7<<8)
+#define SUNXI_I2STXCHMAP_CH2_SHIFT	8
+#define SUNXI_I2STXCHMAP_CH2_WIDTH	3
+#define SUNXI_I2STXCHMAP_CH1_MASK	(7<<4)
+#define SUNXI_I2STXCHMAP_CH1_SHIFT	4
+#define SUNXI_I2STXCHMAP_CH1_WIDTH	3
+#define SUNXI_I2STXCHMAP_CH0_MASK	(7<<0)
+#define SUNXI_I2STXCHMAP_CH0_SHIFT	0
+#define SUNXI_I2STXCHMAP_CH0_WIDTH	3
+
+/* SUNXI_I2S_RXCHSEL	0x38 	 Digital Audio RX Channel Select register */
+
+#define SUNXI_I2SRXCHSEL_CHNUM_MASK	(7<<0)
+#define SUNXI_I2SRXCHSEL_CHNUM_SHIFT	0
+#define SUNXI_I2SRXCHSEL_CHNUM_WIDTH	3
+
+/* SUNXI_I2S_RXCHMAP	0x3C 	 Digital Audio RX Channel Mapping Register */
+
+#define SUNXI_I2SRXCHMAP_CH3_MASK	(7<<12)
+#define SUNXI_I2SRXCHMAP_CH3_SHIFT	12
+#define SUNXI_I2SRXCHMAP_CH3_WIDTH	3
+#define SUNXI_I2SRXCHMAP_CH2_MASK	(7<<8)
+#define SUNXI_I2SRXCHMAP_CH2_SHIFT	8
+#define SUNXI_I2SRXCHMAP_CH2_WIDTH	3
+#define SUNXI_I2SRXCHMAP_CH1_MASK	(7<<4)
+#define SUNXI_I2SRXCHMAP_CH1_SHIFT	4
+#define SUNXI_I2SRXCHMAP_CH1_WIDTH	3
+#define SUNXI_I2SRXCHMAP_CH0_MASK	(7<<0)
+#define SUNXI_I2SRXCHMAP_CH0_SHIFT	0
+#define SUNXI_I2SRXCHMAP_CH0_WIDTH	3
+
+
+/*------------------------------------------------------------*/
+/* Clock dividers */
+#define SUNXI_DIV_MCLK	0
+#define SUNXI_DIV_BCLK	1
+
+#define SUNXI_I2SCLKD_MCLK_MASK   0x0f
+#define SUNXI_I2SCLKD_MCLK_OFFS   0
+#define SUNXI_I2SCLKD_BCLK_MASK   0x070
+#define SUNXI_I2SCLKD_BCLK_OFFS   4
+#define SUNXI_I2SCLKD_MCLKEN_OFFS 7
+
+/* Supported SoC families - used for quirks */
+enum sunxi_soc_family {
+	SUN4IA,	/* A10 SoC - revision A */
+	SUN4I,	/* A10 SoC - later revisions */
+	SUN5I,	/* A10S/A13 SoCs */
+	SUN7I,	/* A20 SoC */
+};
+
+struct sunxi_priv {
+	struct regmap *regmap;
+	struct clk *clk_apb, *clk_pll2, *clk_module;
+
+	enum sunxi_soc_family revision;
+
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+
+	u32 slave;		//0: master, 1: slave
+	u32 mono;		//0: stereo, 1: mono
+	u32 samp_fs;		//audio sample rate (unit in kHz)
+	u32 samp_res;		//16 bits, 20 bits , 24 bits, 32 bits)
+	u32 samp_format;	//audio sample format (0: standard I2S, 1: left-justified, 2: right-justified, 3: pcm)
+	u32 ws_size;		//16 BCLK, 20 BCLK, 24 BCLK, 32 BCLK)
+	u32 mclk_rate;		//mclk frequency divide by fs (128fs, 192fs, 256fs, 384fs, 512fs, 768fs)
+	u32 lrc_pol;		//LRC clock polarity (0: normal ,1: inverted)
+	u32 bclk_pol;		//BCLK polarity (0: normal, 1: inverted)
+	u32 pcm_txtype;		//PCM transmitter type (0: 16-bits linear mode, 1: 8-bits linear mode, 2: u-law, 3: A-law)
+	u32 pcm_rxtype;		//PCM receiver type  (0: 16-bits linear mode, 1: 8-bits linear mode, 2: u-law, 3: A-law)
+	u32 pcm_sw;		//PCM slot width (8: 8 bits, 16: 16 bits)
+	u32 pcm_sync_period;	//PCM sync period (16/32/64/128/256)
+	u32 pcm_sync_type;	//PCM sync symbol size (0: short sync, 1: long sync)
+	u32 pcm_start_slot;	//PCM start slot index (1--4)
+	u32 pcm_lsb_first;	//0: MSB first, 1: LSB first
+	u32 pcm_ch_num;		//PCM channel number (1: one channel, 2: two channel)
+};
+
+#endif
