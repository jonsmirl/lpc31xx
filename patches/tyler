Bottom: 4e66e9c5a88e22a68319fdf2517ebee1954ad140
Top:    91647c43a3a5a2f5fd3f57a22c409e494539f7c9
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-07-18 14:38:45 -0400

TAS5716 support for Tyler


---

diff --git a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
index e316509..3c913e4 100644
--- a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
+++ b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
@@ -122,6 +122,16 @@
 			status = "okay";
 		};
 
+		i2s0: i2s@01c22000 {
+			pinctrl-names = "default";
+			/*pinctrl-0 = <&i2s0_pins_a>;*/
+			status = "okay";
+		};
+
+		codec: codec@01c22c00 {
+			status = "okay";
+		};
+
 		uart0: serial@01c28000 {
 			pinctrl-names = "default";
 			pinctrl-0 = <&uart0_pins_a>;
@@ -148,6 +158,12 @@
 			pinctrl-names = "default";
 			pinctrl-0 = <&i2c1_pins_a>;
 			status = "okay";
+
+			tas5716: tas5716@36 {
+				compatible = "ti,tas5716";
+				reg = <0x36>;
+				#sound-dai-cells = <0>;
+			};
 		};
 
 		i2c2: i2c@01c2b400 {
@@ -169,6 +185,33 @@
 		};
 	};
 
+	sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,routing =
+			"Headphone Jack", "HPL",
+			"Headphone Jack", "HPR",
+			"Speaker", "SPKOUT",
+			"Speaker", "SPKOUTN",
+			"MIC1", "Mic Jack",
+			"MIC2", "Mic Jack";
+		simple-audio-card,widgets =
+			"Headphone", "Headphone Jack",
+			"Speaker", "Speaker",
+			"Microphone", "Mic Jack";
+
+		simple-audio-card,mclk-fs = <256>;
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s0>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&tas5716>;
+		};
+	};
+
+
 	leds {
 		compatible = "gpio-leds";
 		pinctrl-names = "default";
diff --git a/arch/arm/boot/dts/sun7i-a20.dtsi b/arch/arm/boot/dts/sun7i-a20.dtsi
index b06f9b0..8ed5b85 100644
--- a/arch/arm/boot/dts/sun7i-a20.dtsi
+++ b/arch/arm/boot/dts/sun7i-a20.dtsi
@@ -335,29 +335,53 @@
 			clock-output-names = "ir1";
 		};
 
+<<<<<<< current
 		iis0_clk: clk@01c200b8 {
 			#clock-cells = <0>;
 			compatible = "allwinner,sun4i-a10-mod1-clk";
 			reg = <0x01c200b8 0x4>;
 			clocks = <&pll2 0>, <&pll2 1>, <&pll2 2>, <&pll2 3>;
 			clock-output-names = "iis0";
+=======
+		i2s0_clk: clk@01c200b8 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200b8 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s0";
+>>>>>>> patched
 		};
 
 		ac97_clk: clk@01c200bc {
 			#clock-cells = <0>;
+<<<<<<< current
 			compatible = "allwinner,sun4i-a10-mod1-clk";
 			reg = <0x01c200bc 0x4>;
 			clocks = <&pll2 3>, <&pll2 2>, <&pll2 1>, <&pll2 0>;
+=======
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200bc 0x4>;
+			clocks = <&pll2>;
+>>>>>>> patched
 			clock-output-names = "ac97";
 		};
 
 		spdif_clk: clk@01c200c0 {
 			#clock-cells = <0>;
+<<<<<<< current
 			compatible = "allwinner,sun4i-a10-mod1-clk";
 			reg = <0x01c200c0 0x4>;
 			clocks = <&pll2 0>, <&pll2 1>, <&pll2 2>, <&pll2 3>;
 			clock-output-names = "spdif";
 		};
+=======
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200c0 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "spdif";
+		};
+
+>>>>>>> patched
 		usb_clk: clk@01c200cc {
 			#clock-cells = <1>;
 		        #reset-cells = <1>;
@@ -375,6 +399,7 @@
 			clock-output-names = "spi3";
 		};
 
+<<<<<<< current
 		iis1_clk: clk@01c200d8 {
 			#clock-cells = <0>;
 			compatible = "allwinner,sun4i-a10-mod1-clk";
@@ -389,6 +414,22 @@
 			reg = <0x01c200dc 0x4>;
 			clocks = <&pll2 0>, <&pll2 1>, <&pll2 2>, <&pll2 3>;
 			clock-output-names = "iis2";
+=======
+		i2s1_clk: clk@01c200d8 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200d8 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s1";
+		};
+
+		i2s2_clk: clk@01c200dc {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200dc 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s2";
+>>>>>>> patched
 		};
 
 		codec_clk: clk@01c20140 {
@@ -865,12 +906,67 @@
 			status = "disabled";
 		};
 
+<<<<<<< current
 		ir1: ir@01c21c00 {
 			compatible = "allwinner,sun4i-a10-ir";
 			clocks = <&apb0_gates 7>, <&ir1_clk>;
 			clock-names = "apb", "ir";
 			interrupts = <0 6 4>;
 			reg = <0x01c21c00 0x40>;
+=======
+		spdif@01c21000 {
+			compatible = "allwinner,sun7i-a20-spdif";
+			reg = <0x01C21000 0x40>;
+			interrupts = <0 13 4>;
+			clocks = <&pll2>, <&apb0_gates 1>, <&spdif_clk>;
+			clock-names = "pll2", "apb", "spdif";
+			dmas = <&dma 0 2>, <&dma 0 2>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		ac97@01c21400 {
+			compatible = "allwinner,sun7i-a20-ac97";
+			reg = <0x01C21400 0x40>;
+			interrupts = <0 14 4>;
+			clocks = <&pll2>, <&apb0_gates 2>, <&ac97_clk>;
+			clock-names = "pll2", "apb", "ac97";
+			dmas = <&dma 0 5>, <&dma 0 5>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s0: i2s@01c22000 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C22000 0x40>;
+			interrupts = <0 16 4>;
+			clocks = <&pll2>, <&apb0_gates 3>, <&i2s0_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 3>, <&dma 0 3>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s1: i2s@01c22400 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C22400 0x40>;
+			interrupts = <0 87 4>;
+			clocks = <&pll2>, <&apb0_gates 4>, <&i2s1_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 4>, <&dma 0 4>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s2: i2s@01c24400 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C24400 0x40>;
+			interrupts = <0 90 4>;
+			clocks = <&pll2>, <&apb0_gates 8>, <&i2s2_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 6>, <&dma 0 6>;
+			dma-names = "rx", "tx";
+>>>>>>> patched
 			status = "disabled";
 		};
 
diff --git a/include/sound/tas5716.h b/include/sound/tas5716.h
new file mode 100644
index 0000000..33e1be3
--- /dev/null
+++ b/include/sound/tas5716.h
@@ -0,0 +1,57 @@
+/*
+ * Platform data for TI TAS5716 ASoC codec driver.
+ *
+ * Copyright: 2014 Raumfeld GmbH
+ * Author: Sven Brandau <info@brandau.biz>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifndef __LINUX_SND__TAS5716_H
+#define __LINUX_SND__TAS5716_H
+
+#define TAS5716_OCFG_2CH		0
+#define TAS5716_OCFG_2_1CH	1
+#define TAS5716_OCFG_1CH		3
+
+#define TAS5716_OM_CH1		0
+#define TAS5716_OM_CH2		1
+#define TAS5716_OM_CH3		2
+
+#define TAS5716_THERMAL_ADJUSTMENT_ENABLE	1
+#define TAS5716_THERMAL_RECOVERY_ENABLE		2
+#define TAS5716_FAULT_DETECT_RECOVERY_BYPASS	1
+
+#define TAS5716_FFX_PM_DROP_COMP			0
+#define TAS5716_FFX_PM_TAPERED_COMP		1
+#define TAS5716_FFX_PM_FULL_POWER		2
+#define TAS5716_FFX_PM_VARIABLE_DROP_COMP	3
+
+
+struct tas5716_platform_data {
+	u8 output_conf;
+	u8 ch1_output_mapping;
+	u8 ch2_output_mapping;
+	u8 ch3_output_mapping;
+	u8 ffx_power_output_mode;
+	u8 drop_compensation_ns;
+	u8 powerdown_delay_divider;
+	unsigned int thermal_warning_recovery:1;
+	unsigned int thermal_warning_adjustment:1;
+	unsigned int fault_detect_recovery:1;
+	unsigned int oc_warning_adjustment:1;
+	unsigned int max_power_use_mpcc:1;
+	unsigned int max_power_correction:1;
+	unsigned int am_reduction_mode:1;
+	unsigned int odd_pwm_speed_mode:1;
+	unsigned int distortion_compensation:1;
+	unsigned int invalid_input_detect_mute:1;
+	unsigned int activate_mute_output:1;
+	unsigned int bridge_immediate_off:1;
+	unsigned int noise_shape_dc_cut:1;
+	unsigned int powerdown_master_vol:1;
+};
+
+#endif /* __LINUX_SND__TAS5716_H */
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 0b9571c..94a6bc8 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -92,6 +92,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_STA529 if I2C
 	select SND_SOC_STAC9766 if SND_SOC_AC97_BUS
 	select SND_SOC_TAS5086 if I2C
+	select SND_SOC_TAS5716 if I2C
 	select SND_SOC_TLV320AIC23_I2C if I2C
 	select SND_SOC_TLV320AIC23_SPI if SPI_MASTER
 	select SND_SOC_TLV320AIC26 if SPI_MASTER
@@ -525,6 +526,11 @@ config SND_SOC_TAS5086
 	tristate "Texas Instruments TAS5086 speaker amplifier"
 	depends on I2C
 
+config SND_SOC_TAS5716
+	tristate "Texas Instruments TAS5716 speaker amplifier"
+	select REGMAP_I2C
+	depends on I2C
+
 config SND_SOC_TLV320AIC23
 	tristate
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 1bd6e1c..dc18e5d 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -93,6 +93,7 @@ snd-soc-sta350-objs := sta350.o
 snd-soc-sta529-objs := sta529.o
 snd-soc-stac9766-objs := stac9766.o
 snd-soc-tas5086-objs := tas5086.o
+snd-soc-tas5716-objs := tas5716.o
 snd-soc-tlv320aic23-objs := tlv320aic23.o
 snd-soc-tlv320aic23-i2c-objs := tlv320aic23-i2c.o
 snd-soc-tlv320aic23-spi-objs := tlv320aic23-spi.o
@@ -256,6 +257,7 @@ obj-$(CONFIG_SND_SOC_STA350)   += snd-soc-sta350.o
 obj-$(CONFIG_SND_SOC_STA529)   += snd-soc-sta529.o
 obj-$(CONFIG_SND_SOC_STAC9766)	+= snd-soc-stac9766.o
 obj-$(CONFIG_SND_SOC_TAS5086)	+= snd-soc-tas5086.o
+obj-$(CONFIG_SND_SOC_TAS5716)	+= snd-soc-tas5716.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23)	+= snd-soc-tlv320aic23.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23_I2C)	+= snd-soc-tlv320aic23-i2c.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23_SPI)	+= snd-soc-tlv320aic23-spi.o
diff --git a/sound/soc/codecs/tas5716.c b/sound/soc/codecs/tas5716.c
new file mode 100644
index 0000000..37947cd
--- /dev/null
+++ b/sound/soc/codecs/tas5716.c
@@ -0,0 +1,1317 @@
+/*
+ * Codec driver for ST TAS5716 2.1-channel high-efficiency digital audio system
+ *
+ * Copyright: 2014 Raumfeld GmbH
+ * Author: Sven Brandau <info@brandau.biz>
+ *
+ * based on code from:
+ *	Raumfeld GmbH
+ *	  Johannes Stezenbach <js@sig21.net>
+ *	Wolfson Microelectronics PLC.
+ *	  Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *	Freescale Semiconductor, Inc.
+ *	  Timur Tabi <timur@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ":%s:%d: " fmt, __func__, __LINE__
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/gpio/consumer.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include <sound/tas5716.h>
+#include "tas5716.h"
+
+#define TAS5716_RATES (SNDRV_PCM_RATE_32000 | \
+		      SNDRV_PCM_RATE_44100 | \
+		      SNDRV_PCM_RATE_48000 | \
+		      SNDRV_PCM_RATE_88200 | \
+		      SNDRV_PCM_RATE_96000 | \
+		      SNDRV_PCM_RATE_176400 | \
+		      SNDRV_PCM_RATE_192000)
+
+#define TAS5716_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE  | SNDRV_PCM_FMTBIT_S16_BE  | \
+	 SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S18_3BE | \
+	 SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S20_3BE | \
+	 SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_3BE | \
+	 SNDRV_PCM_FMTBIT_S24_LE  | SNDRV_PCM_FMTBIT_S24_BE  | \
+	 SNDRV_PCM_FMTBIT_S32_LE  | SNDRV_PCM_FMTBIT_S32_BE)
+
+/* Power-up register defaults */
+static const struct reg_default tas5716_regs[] = {
+	{  0x0, 0x63 },
+	{  0x1, 0x80 },
+	{  0x2, 0xdf },
+	{  0x3, 0x40 },
+	{  0x4, 0xc2 },
+	{  0x5, 0x5c },
+	{  0x6, 0x00 },
+	{  0x7, 0xff },
+	{  0x8, 0x60 },
+	{  0x9, 0x60 },
+	{  0xa, 0x60 },
+	{  0xb, 0x00 },
+	{  0xc, 0x00 },
+	{  0xd, 0x00 },
+	{  0xe, 0x00 },
+	{  0xf, 0x40 },
+	{ 0x10, 0x80 },
+	{ 0x11, 0x77 },
+	{ 0x12, 0x6a },
+	{ 0x13, 0x69 },
+	{ 0x14, 0x6a },
+	{ 0x15, 0x69 },
+	{ 0x16, 0x00 },
+	{ 0x17, 0x00 },
+	{ 0x18, 0x00 },
+	{ 0x19, 0x00 },
+	{ 0x1a, 0x00 },
+	{ 0x1b, 0x00 },
+	{ 0x1c, 0x00 },
+	{ 0x1d, 0x00 },
+	{ 0x1e, 0x00 },
+	{ 0x1f, 0x00 },
+	{ 0x20, 0x00 },
+	{ 0x21, 0x00 },
+	{ 0x22, 0x00 },
+	{ 0x23, 0x00 },
+	{ 0x24, 0x00 },
+	{ 0x25, 0x00 },
+	{ 0x26, 0x00 },
+	{ 0x27, 0x2a },
+	{ 0x28, 0xc0 },
+	{ 0x29, 0xf3 },
+	{ 0x2a, 0x33 },
+	{ 0x2b, 0x00 },
+	{ 0x2c, 0x0c },
+	{ 0x31, 0x00 },
+	{ 0x36, 0x00 },
+	{ 0x37, 0x00 },
+	{ 0x38, 0x00 },
+	{ 0x39, 0x01 },
+	{ 0x3a, 0xee },
+	{ 0x3b, 0xff },
+	{ 0x3c, 0x7e },
+	{ 0x3d, 0xc0 },
+	{ 0x3e, 0x26 },
+	{ 0x3f, 0x00 },
+	{ 0x48, 0x00 },
+	{ 0x49, 0x00 },
+	{ 0x4a, 0x00 },
+	{ 0x4b, 0x04 },
+	{ 0x4c, 0x00 },
+};
+
+static const struct regmap_range tas5716_write_regs_range[] = {
+	regmap_reg_range(TAS5716_CONFA,  TAS5716_AUTO2),
+	regmap_reg_range(TAS5716_C1CFG,  TAS5716_FDRC2),
+	regmap_reg_range(TAS5716_EQCFG,  TAS5716_EVOLRES),
+	regmap_reg_range(TAS5716_NSHAPE, TAS5716_MISC2),
+};
+
+static const struct regmap_range tas5716_read_regs_range[] = {
+	regmap_reg_range(TAS5716_CONFA,  TAS5716_AUTO2),
+	regmap_reg_range(TAS5716_C1CFG,  TAS5716_STATUS),
+	regmap_reg_range(TAS5716_EQCFG,  TAS5716_EVOLRES),
+	regmap_reg_range(TAS5716_NSHAPE, TAS5716_MISC2),
+};
+
+static const struct regmap_range tas5716_volatile_regs_range[] = {
+	regmap_reg_range(TAS5716_CFADDR2, TAS5716_CFUD),
+	regmap_reg_range(TAS5716_STATUS,  TAS5716_STATUS),
+};
+
+static const struct regmap_access_table tas5716_write_regs = {
+	.yes_ranges =	tas5716_write_regs_range,
+	.n_yes_ranges =	ARRAY_SIZE(tas5716_write_regs_range),
+};
+
+static const struct regmap_access_table tas5716_read_regs = {
+	.yes_ranges =	tas5716_read_regs_range,
+	.n_yes_ranges =	ARRAY_SIZE(tas5716_read_regs_range),
+};
+
+static const struct regmap_access_table tas5716_volatile_regs = {
+	.yes_ranges =	tas5716_volatile_regs_range,
+	.n_yes_ranges =	ARRAY_SIZE(tas5716_volatile_regs_range),
+};
+
+/* regulator power supply names */
+static const char * const tas5716_supply_names[] = {
+	"vdd-dig",	/* digital supply, 3.3V */
+	"vdd-pll",	/* pll supply, 3.3V */
+	"vcc"		/* power amp supply, 5V - 26V */
+};
+
+/* codec private data */
+struct tas5716_priv {
+	struct regmap *regmap;
+	struct regulator_bulk_data supplies[ARRAY_SIZE(tas5716_supply_names)];
+	struct tas5716_platform_data *pdata;
+
+	unsigned int mclk;
+	unsigned int format;
+
+	u32 coef_shadow[TAS5716_COEF_COUNT];
+	int shutdown;
+
+	struct gpio_desc *gpiod_nreset;
+	struct gpio_desc *gpiod_power_down;
+
+	struct mutex coeff_lock;
+};
+
+static const DECLARE_TLV_DB_SCALE(mvol_tlv, -12750, 50, 1);
+static const DECLARE_TLV_DB_SCALE(chvol_tlv, -7950, 50, 1);
+static const DECLARE_TLV_DB_SCALE(tone_tlv, -1200, 200, 0);
+
+static const char * const tas5716_drc_ac[] = {
+	"Anti-Clipping", "Dynamic Range Compression"
+};
+static const char * const tas5716_auto_gc_mode[] = {
+	"User", "AC no clipping", "AC limited clipping (10%)",
+	"DRC nighttime listening mode"
+};
+static const char * const tas5716_auto_xo_mode[] = {
+	"User", "80Hz", "100Hz", "120Hz", "140Hz", "160Hz", "180Hz",
+	"200Hz", "220Hz", "240Hz", "260Hz", "280Hz", "300Hz", "320Hz",
+	"340Hz", "360Hz"
+};
+static const char * const tas5716_binary_output[] = {
+	"FFX 3-state output - normal operation", "Binary output"
+};
+static const char * const tas5716_limiter_select[] = {
+	"Limiter Disabled", "Limiter #1", "Limiter #2"
+};
+static const char * const tas5716_limiter_attack_rate[] = {
+	"3.1584", "2.7072", "2.2560", "1.8048", "1.3536", "0.9024",
+	"0.4512", "0.2256", "0.1504", "0.1123", "0.0902", "0.0752",
+	"0.0645", "0.0564", "0.0501", "0.0451"
+};
+static const char * const tas5716_limiter_release_rate[] = {
+	"0.5116", "0.1370", "0.0744", "0.0499", "0.0360", "0.0299",
+	"0.0264", "0.0208", "0.0198", "0.0172", "0.0147", "0.0137",
+	"0.0134", "0.0117", "0.0110", "0.0104"
+};
+static const char * const tas5716_noise_shaper_type[] = {
+	"Third order", "Fourth order"
+};
+
+static DECLARE_TLV_DB_RANGE(tas5716_limiter_ac_attack_tlv,
+	0, 7, TLV_DB_SCALE_ITEM(-1200, 200, 0),
+	8, 16, TLV_DB_SCALE_ITEM(300, 100, 0),
+);
+
+static DECLARE_TLV_DB_RANGE(tas5716_limiter_ac_release_tlv,
+	0, 0, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 0),
+	1, 1, TLV_DB_SCALE_ITEM(-2900, 0, 0),
+	2, 2, TLV_DB_SCALE_ITEM(-2000, 0, 0),
+	3, 8, TLV_DB_SCALE_ITEM(-1400, 200, 0),
+	8, 16, TLV_DB_SCALE_ITEM(-700, 100, 0),
+);
+
+static DECLARE_TLV_DB_RANGE(tas5716_limiter_drc_attack_tlv,
+	0, 7, TLV_DB_SCALE_ITEM(-3100, 200, 0),
+	8, 13, TLV_DB_SCALE_ITEM(-1600, 100, 0),
+	14, 16, TLV_DB_SCALE_ITEM(-1000, 300, 0),
+);
+
+static DECLARE_TLV_DB_RANGE(tas5716_limiter_drc_release_tlv,
+	0, 0, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 0),
+	1, 2, TLV_DB_SCALE_ITEM(-3800, 200, 0),
+	3, 4, TLV_DB_SCALE_ITEM(-3300, 200, 0),
+	5, 12, TLV_DB_SCALE_ITEM(-3000, 200, 0),
+	13, 16, TLV_DB_SCALE_ITEM(-1500, 300, 0),
+);
+
+static SOC_ENUM_SINGLE_DECL(tas5716_drc_ac_enum,
+			    TAS5716_CONFD, TAS5716_CONFD_DRC_SHIFT,
+			    tas5716_drc_ac);
+static SOC_ENUM_SINGLE_DECL(tas5716_noise_shaper_enum,
+			    TAS5716_CONFE, TAS5716_CONFE_NSBW_SHIFT,
+			    tas5716_noise_shaper_type);
+static SOC_ENUM_SINGLE_DECL(tas5716_auto_gc_enum,
+			    TAS5716_AUTO1, TAS5716_AUTO1_AMGC_SHIFT,
+			    tas5716_auto_gc_mode);
+static SOC_ENUM_SINGLE_DECL(tas5716_auto_xo_enum,
+			    TAS5716_AUTO2, TAS5716_AUTO2_XO_SHIFT,
+			    tas5716_auto_xo_mode);
+static SOC_ENUM_SINGLE_DECL(tas5716_binary_output_ch1_enum,
+			    TAS5716_C1CFG, TAS5716_CxCFG_BO_SHIFT,
+			    tas5716_binary_output);
+static SOC_ENUM_SINGLE_DECL(tas5716_binary_output_ch2_enum,
+			    TAS5716_C2CFG, TAS5716_CxCFG_BO_SHIFT,
+			    tas5716_binary_output);
+static SOC_ENUM_SINGLE_DECL(tas5716_binary_output_ch3_enum,
+			    TAS5716_C3CFG, TAS5716_CxCFG_BO_SHIFT,
+			    tas5716_binary_output);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter_ch1_enum,
+			    TAS5716_C1CFG, TAS5716_CxCFG_LS_SHIFT,
+			    tas5716_limiter_select);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter_ch2_enum,
+			    TAS5716_C2CFG, TAS5716_CxCFG_LS_SHIFT,
+			    tas5716_limiter_select);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter_ch3_enum,
+			    TAS5716_C3CFG, TAS5716_CxCFG_LS_SHIFT,
+			    tas5716_limiter_select);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter1_attack_rate_enum,
+			    TAS5716_L1AR, TAS5716_LxA_SHIFT,
+			    tas5716_limiter_attack_rate);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter2_attack_rate_enum,
+			    TAS5716_L2AR, TAS5716_LxA_SHIFT,
+			    tas5716_limiter_attack_rate);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter1_release_rate_enum,
+			    TAS5716_L1AR, TAS5716_LxR_SHIFT,
+			    tas5716_limiter_release_rate);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter2_release_rate_enum,
+			    TAS5716_L2AR, TAS5716_LxR_SHIFT,
+			    tas5716_limiter_release_rate);
+
+/*
+ * byte array controls for setting biquad, mixer, scaling coefficients;
+ * for biquads all five coefficients need to be set in one go,
+ * mixer and pre/postscale coefs can be set individually;
+ * each coef is 24bit, the bytes are ordered in the same way
+ * as given in the TAS5716 data sheet (big endian; b1, b2, a1, a2, b0)
+ */
+
+static int tas5716_coefficient_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+	int numcoef = kcontrol->private_value >> 16;
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	uinfo->count = 3 * numcoef;
+	return 0;
+}
+
+static int tas5716_coefficient_get(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	int numcoef = kcontrol->private_value >> 16;
+	int index = kcontrol->private_value & 0xffff;
+	unsigned int cfud, val;
+	int i, ret = 0;
+
+	mutex_lock(&tas5716->coeff_lock);
+
+	/* preserve reserved bits in TAS5716_CFUD */
+	regmap_read(tas5716->regmap, TAS5716_CFUD, &cfud);
+	cfud &= 0xf0;
+	/*
+	 * chip documentation does not say if the bits are self clearing,
+	 * so do it explicitly
+	 */
+	regmap_write(tas5716->regmap, TAS5716_CFUD, cfud);
+
+	regmap_write(tas5716->regmap, TAS5716_CFADDR2, index);
+	if (numcoef == 1) {
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud | 0x04);
+	} else if (numcoef == 5) {
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud | 0x08);
+	} else {
+		ret = -EINVAL;
+		goto exit_unlock;
+	}
+
+	for (i = 0; i < 3 * numcoef; i++) {
+		regmap_read(tas5716->regmap, TAS5716_B1CF1 + i, &val);
+		ucontrol->value.bytes.data[i] = val;
+	}
+
+exit_unlock:
+	mutex_unlock(&tas5716->coeff_lock);
+
+	return ret;
+}
+
+static int tas5716_coefficient_put(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	int numcoef = kcontrol->private_value >> 16;
+	int index = kcontrol->private_value & 0xffff;
+	unsigned int cfud;
+	int i;
+
+	/* preserve reserved bits in TAS5716_CFUD */
+	regmap_read(tas5716->regmap, TAS5716_CFUD, &cfud);
+	cfud &= 0xf0;
+	/*
+	 * chip documentation does not say if the bits are self clearing,
+	 * so do it explicitly
+	 */
+	regmap_write(tas5716->regmap, TAS5716_CFUD, cfud);
+
+	regmap_write(tas5716->regmap, TAS5716_CFADDR2, index);
+	for (i = 0; i < numcoef && (index + i < TAS5716_COEF_COUNT); i++)
+		tas5716->coef_shadow[index + i] =
+			  (ucontrol->value.bytes.data[3 * i] << 16)
+			| (ucontrol->value.bytes.data[3 * i + 1] << 8)
+			| (ucontrol->value.bytes.data[3 * i + 2]);
+	for (i = 0; i < 3 * numcoef; i++)
+		regmap_write(tas5716->regmap, TAS5716_B1CF1 + i,
+			     ucontrol->value.bytes.data[i]);
+	if (numcoef == 1)
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud | 0x01);
+	else if (numcoef == 5)
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud | 0x02);
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int tas5716_sync_coef_shadow(struct snd_soc_codec *codec)
+{
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	unsigned int cfud;
+	int i;
+
+	/* preserve reserved bits in TAS5716_CFUD */
+	regmap_read(tas5716->regmap, TAS5716_CFUD, &cfud);
+	cfud &= 0xf0;
+
+	for (i = 0; i < TAS5716_COEF_COUNT; i++) {
+		regmap_write(tas5716->regmap, TAS5716_CFADDR2, i);
+		regmap_write(tas5716->regmap, TAS5716_B1CF1,
+			     (tas5716->coef_shadow[i] >> 16) & 0xff);
+		regmap_write(tas5716->regmap, TAS5716_B1CF2,
+			     (tas5716->coef_shadow[i] >> 8) & 0xff);
+		regmap_write(tas5716->regmap, TAS5716_B1CF3,
+			     (tas5716->coef_shadow[i]) & 0xff);
+		/*
+		 * chip documentation does not say if the bits are
+		 * self-clearing, so do it explicitly
+		 */
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud);
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud | 0x01);
+	}
+	return 0;
+}
+
+static int tas5716_cache_sync(struct snd_soc_codec *codec)
+{
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	unsigned int mute;
+	int rc;
+
+	/* mute during register sync */
+	regmap_read(tas5716->regmap, TAS5716_CFUD, &mute);
+	regmap_write(tas5716->regmap, TAS5716_MMUTE, mute | TAS5716_MMUTE_MMUTE);
+	tas5716_sync_coef_shadow(codec);
+	rc = regcache_sync(tas5716->regmap);
+	regmap_write(tas5716->regmap, TAS5716_MMUTE, mute);
+	return rc;
+}
+
+#define SINGLE_COEF(xname, index) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = tas5716_coefficient_info, \
+	.get = tas5716_coefficient_get,\
+	.put = tas5716_coefficient_put, \
+	.private_value = index | (1 << 16) }
+
+#define BIQUAD_COEFS(xname, index) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = tas5716_coefficient_info, \
+	.get = tas5716_coefficient_get,\
+	.put = tas5716_coefficient_put, \
+	.private_value = index | (5 << 16) }
+
+static const struct snd_kcontrol_new tas5716_snd_controls[] = {
+SOC_SINGLE_TLV("Master Volume", TAS5716_MVOL, 0, 0xff, 1, mvol_tlv),
+/* VOL */
+SOC_SINGLE_TLV("Ch1 Volume", TAS5716_C1VOL, 0, 0xff, 1, chvol_tlv),
+SOC_SINGLE_TLV("Ch2 Volume", TAS5716_C2VOL, 0, 0xff, 1, chvol_tlv),
+SOC_SINGLE_TLV("Ch3 Volume", TAS5716_C3VOL, 0, 0xff, 1, chvol_tlv),
+/* CONFD */
+SOC_SINGLE("High Pass Filter Bypass Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_HPB_SHIFT, 1, 1),
+SOC_SINGLE("De-emphasis Filter Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_DEMP_SHIFT, 1, 0),
+SOC_SINGLE("DSP Bypass Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_DSPB_SHIFT, 1, 0),
+SOC_SINGLE("Post-scale Link Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_PSL_SHIFT, 1, 0),
+SOC_SINGLE("Biquad Coefficient Link Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_BQL_SHIFT, 1, 0),
+SOC_ENUM("Compressor/Limiter Switch", tas5716_drc_ac_enum),
+SOC_ENUM("Noise Shaper Bandwidth", tas5716_noise_shaper_enum),
+SOC_SINGLE("Zero-detect Mute Enable Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_ZDE_SHIFT, 1, 0),
+SOC_SINGLE("Submix Mode Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_SME_SHIFT, 1, 0),
+/* CONFE */
+SOC_SINGLE("Zero Cross Switch", TAS5716_CONFE, TAS5716_CONFE_ZCE_SHIFT, 1, 0),
+SOC_SINGLE("Soft Ramp Switch", TAS5716_CONFE, TAS5716_CONFE_SVE_SHIFT, 1, 0),
+/* MUTE */
+SOC_SINGLE("Master Switch", TAS5716_MMUTE, TAS5716_MMUTE_MMUTE_SHIFT, 1, 1),
+SOC_SINGLE("Ch1 Switch", TAS5716_MMUTE, TAS5716_MMUTE_C1M_SHIFT, 1, 1),
+SOC_SINGLE("Ch2 Switch", TAS5716_MMUTE, TAS5716_MMUTE_C2M_SHIFT, 1, 1),
+SOC_SINGLE("Ch3 Switch", TAS5716_MMUTE, TAS5716_MMUTE_C3M_SHIFT, 1, 1),
+/* AUTOx */
+SOC_ENUM("Automode GC", tas5716_auto_gc_enum),
+SOC_ENUM("Automode XO", tas5716_auto_xo_enum),
+/* CxCFG */
+SOC_SINGLE("Ch1 Tone Control Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_TCB_SHIFT, 1, 0),
+SOC_SINGLE("Ch2 Tone Control Bypass Switch",
+	   TAS5716_C2CFG, TAS5716_CxCFG_TCB_SHIFT, 1, 0),
+SOC_SINGLE("Ch1 EQ Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_EQBP_SHIFT, 1, 0),
+SOC_SINGLE("Ch2 EQ Bypass Switch",
+	   TAS5716_C2CFG, TAS5716_CxCFG_EQBP_SHIFT, 1, 0),
+SOC_SINGLE("Ch1 Master Volume Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_VBP_SHIFT, 1, 0),
+SOC_SINGLE("Ch2 Master Volume Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_VBP_SHIFT, 1, 0),
+SOC_SINGLE("Ch3 Master Volume Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_VBP_SHIFT, 1, 0),
+SOC_ENUM("Ch1 Binary Output Select", tas5716_binary_output_ch1_enum),
+SOC_ENUM("Ch2 Binary Output Select", tas5716_binary_output_ch2_enum),
+SOC_ENUM("Ch3 Binary Output Select", tas5716_binary_output_ch3_enum),
+SOC_ENUM("Ch1 Limiter Select", tas5716_limiter_ch1_enum),
+SOC_ENUM("Ch2 Limiter Select", tas5716_limiter_ch2_enum),
+SOC_ENUM("Ch3 Limiter Select", tas5716_limiter_ch3_enum),
+/* TONE */
+SOC_SINGLE_RANGE_TLV("Bass Tone Control Volume",
+		     TAS5716_TONE, TAS5716_TONE_BTC_SHIFT, 1, 13, 0, tone_tlv),
+SOC_SINGLE_RANGE_TLV("Treble Tone Control Volume",
+		     TAS5716_TONE, TAS5716_TONE_TTC_SHIFT, 1, 13, 0, tone_tlv),
+SOC_ENUM("Limiter1 Attack Rate (dB/ms)", tas5716_limiter1_attack_rate_enum),
+SOC_ENUM("Limiter2 Attack Rate (dB/ms)", tas5716_limiter2_attack_rate_enum),
+SOC_ENUM("Limiter1 Release Rate (dB/ms)", tas5716_limiter1_release_rate_enum),
+SOC_ENUM("Limiter2 Release Rate (dB/ms)", tas5716_limiter2_release_rate_enum),
+
+/*
+ * depending on mode, the attack/release thresholds have
+ * two different enum definitions; provide both
+ */
+SOC_SINGLE_TLV("Limiter1 Attack Threshold (AC Mode)",
+	       TAS5716_L1ATRT, TAS5716_LxA_SHIFT,
+	       16, 0, tas5716_limiter_ac_attack_tlv),
+SOC_SINGLE_TLV("Limiter2 Attack Threshold (AC Mode)",
+	       TAS5716_L2ATRT, TAS5716_LxA_SHIFT,
+	       16, 0, tas5716_limiter_ac_attack_tlv),
+SOC_SINGLE_TLV("Limiter1 Release Threshold (AC Mode)",
+	       TAS5716_L1ATRT, TAS5716_LxR_SHIFT,
+	       16, 0, tas5716_limiter_ac_release_tlv),
+SOC_SINGLE_TLV("Limiter2 Release Threshold (AC Mode)",
+	       TAS5716_L2ATRT, TAS5716_LxR_SHIFT,
+	       16, 0, tas5716_limiter_ac_release_tlv),
+SOC_SINGLE_TLV("Limiter1 Attack Threshold (DRC Mode)",
+	       TAS5716_L1ATRT, TAS5716_LxA_SHIFT,
+	       16, 0, tas5716_limiter_drc_attack_tlv),
+SOC_SINGLE_TLV("Limiter2 Attack Threshold (DRC Mode)",
+	       TAS5716_L2ATRT, TAS5716_LxA_SHIFT,
+	       16, 0, tas5716_limiter_drc_attack_tlv),
+SOC_SINGLE_TLV("Limiter1 Release Threshold (DRC Mode)",
+	       TAS5716_L1ATRT, TAS5716_LxR_SHIFT,
+	       16, 0, tas5716_limiter_drc_release_tlv),
+SOC_SINGLE_TLV("Limiter2 Release Threshold (DRC Mode)",
+	       TAS5716_L2ATRT, TAS5716_LxR_SHIFT,
+	       16, 0, tas5716_limiter_drc_release_tlv),
+
+BIQUAD_COEFS("Ch1 - Biquad 1", 0),
+BIQUAD_COEFS("Ch1 - Biquad 2", 5),
+BIQUAD_COEFS("Ch1 - Biquad 3", 10),
+BIQUAD_COEFS("Ch1 - Biquad 4", 15),
+BIQUAD_COEFS("Ch2 - Biquad 1", 20),
+BIQUAD_COEFS("Ch2 - Biquad 2", 25),
+BIQUAD_COEFS("Ch2 - Biquad 3", 30),
+BIQUAD_COEFS("Ch2 - Biquad 4", 35),
+BIQUAD_COEFS("High-pass", 40),
+BIQUAD_COEFS("Low-pass", 45),
+SINGLE_COEF("Ch1 - Prescale", 50),
+SINGLE_COEF("Ch2 - Prescale", 51),
+SINGLE_COEF("Ch1 - Postscale", 52),
+SINGLE_COEF("Ch2 - Postscale", 53),
+SINGLE_COEF("Ch3 - Postscale", 54),
+SINGLE_COEF("Thermal warning - Postscale", 55),
+SINGLE_COEF("Ch1 - Mix 1", 56),
+SINGLE_COEF("Ch1 - Mix 2", 57),
+SINGLE_COEF("Ch2 - Mix 1", 58),
+SINGLE_COEF("Ch2 - Mix 2", 59),
+SINGLE_COEF("Ch3 - Mix 1", 60),
+SINGLE_COEF("Ch3 - Mix 2", 61),
+};
+
+static const struct snd_soc_dapm_widget tas5716_dapm_widgets[] = {
+SND_SOC_DAPM_DAC("DAC", NULL, SND_SOC_NOPM, 0, 0),
+SND_SOC_DAPM_OUTPUT("LEFT"),
+SND_SOC_DAPM_OUTPUT("RIGHT"),
+SND_SOC_DAPM_OUTPUT("SUB"),
+};
+
+static const struct snd_soc_dapm_route tas5716_dapm_routes[] = {
+	{ "LEFT", NULL, "DAC" },
+	{ "RIGHT", NULL, "DAC" },
+	{ "SUB", NULL, "DAC" },
+	{ "DAC", NULL, "Playback" },
+};
+
+/* MCLK interpolation ratio per fs */
+static struct {
+	int fs;
+	int ir;
+} interpolation_ratios[] = {
+	{ 32000, 0 },
+	{ 44100, 0 },
+	{ 48000, 0 },
+	{ 88200, 1 },
+	{ 96000, 1 },
+	{ 176400, 2 },
+	{ 192000, 2 },
+};
+
+/* MCLK to fs clock ratios */
+static int mcs_ratio_table[3][6] = {
+	{ 768, 512, 384, 256, 128, 576 },
+	{ 384, 256, 192, 128,  64,   0 },
+	{ 192, 128,  96,  64,  32,   0 },
+};
+
+/**
+ * tas5716_set_dai_sysclk - configure MCLK
+ * @codec_dai: the codec DAI
+ * @clk_id: the clock ID (ignored)
+ * @freq: the MCLK input frequency
+ * @dir: the clock direction (ignored)
+ *
+ * The value of MCLK is used to determine which sample rates are supported
+ * by the TAS5716, based on the mcs_ratio_table.
+ *
+ * This function must be called by the machine driver's 'startup' function,
+ * otherwise the list of supported sample rates will not be available in
+ * time for ALSA.
+ */
+static int tas5716_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				 int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(codec->dev, "mclk=%u\n", freq);
+	tas5716->mclk = freq;
+
+	return 0;
+}
+
+/**
+ * tas5716_set_dai_fmt - configure the codec for the selected audio format
+ * @codec_dai: the codec DAI
+ * @fmt: a SND_SOC_DAIFMT_x value indicating the data format
+ *
+ * This function takes a bitmask of SND_SOC_DAIFMT_x bits and programs the
+ * codec accordingly.
+ */
+static int tas5716_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			      unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	unsigned int confb = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+	case SND_SOC_DAIFMT_RIGHT_J:
+	case SND_SOC_DAIFMT_LEFT_J:
+		tas5716->format = fmt & SND_SOC_DAIFMT_FORMAT_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		confb |= TAS5716_CONFB_C2IM;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		confb |= TAS5716_CONFB_C1IM;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return regmap_update_bits(tas5716->regmap, TAS5716_CONFB,
+				  TAS5716_CONFB_C1IM | TAS5716_CONFB_C2IM, confb);
+}
+
+/**
+ * tas5716_hw_params - program the TAS5716 with the given hardware parameters.
+ * @substream: the audio stream
+ * @params: the hardware parameters to set
+ * @dai: the SOC DAI (ignored)
+ *
+ * This function programs the hardware with the values provided.
+ * Specifically, the sample rate and the data format.
+ */
+static int tas5716_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	int i, mcs = -EINVAL, ir = -EINVAL;
+	unsigned int confa, confb;
+	unsigned int rate, ratio;
+	int ret;
+
+	if (!tas5716->mclk) {
+		dev_err(codec->dev,
+			"tas5716->mclk is unset. Unable to determine ratio\n");
+		return -EIO;
+	}
+
+	rate = params_rate(params);
+	ratio = tas5716->mclk / rate;
+	dev_dbg(codec->dev, "rate: %u, ratio: %u\n", rate, ratio);
+
+	for (i = 0; i < ARRAY_SIZE(interpolation_ratios); i++) {
+		if (interpolation_ratios[i].fs == rate) {
+			ir = interpolation_ratios[i].ir;
+			break;
+		}
+	}
+
+	if (ir < 0) {
+		dev_err(codec->dev, "Unsupported samplerate: %u\n", rate);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < 6; i++) {
+		if (mcs_ratio_table[ir][i] == ratio) {
+			mcs = i;
+			break;
+		}
+	}
+
+	if (mcs < 0) {
+		dev_err(codec->dev, "Unresolvable ratio: %u\n", ratio);
+		return -EINVAL;
+	}
+
+	confa = (ir << TAS5716_CONFA_IR_SHIFT) |
+		(mcs << TAS5716_CONFA_MCS_SHIFT);
+	confb = 0;
+
+	switch (params_width(params)) {
+	case 24:
+		dev_dbg(codec->dev, "24bit\n");
+		/* fall through */
+	case 32:
+		dev_dbg(codec->dev, "24bit or 32bit\n");
+		switch (tas5716->format) {
+		case SND_SOC_DAIFMT_I2S:
+			confb |= 0x0;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			confb |= 0x1;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			confb |= 0x2;
+			break;
+		}
+
+		break;
+	case 20:
+		dev_dbg(codec->dev, "20bit\n");
+		switch (tas5716->format) {
+		case SND_SOC_DAIFMT_I2S:
+			confb |= 0x4;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			confb |= 0x5;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			confb |= 0x6;
+			break;
+		}
+
+		break;
+	case 18:
+		dev_dbg(codec->dev, "18bit\n");
+		switch (tas5716->format) {
+		case SND_SOC_DAIFMT_I2S:
+			confb |= 0x8;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			confb |= 0x9;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			confb |= 0xa;
+			break;
+		}
+
+		break;
+	case 16:
+		dev_dbg(codec->dev, "16bit\n");
+		switch (tas5716->format) {
+		case SND_SOC_DAIFMT_I2S:
+			confb |= 0x0;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			confb |= 0xd;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			confb |= 0xe;
+			break;
+		}
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = regmap_update_bits(tas5716->regmap, TAS5716_CONFA,
+				 TAS5716_CONFA_MCS_MASK | TAS5716_CONFA_IR_MASK,
+				 confa);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_update_bits(tas5716->regmap, TAS5716_CONFB,
+				 TAS5716_CONFB_SAI_MASK | TAS5716_CONFB_SAIFB,
+				 confb);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int tas5716_startup_sequence(struct tas5716_priv *tas5716)
+{
+	if (tas5716->gpiod_power_down)
+		gpiod_set_value(tas5716->gpiod_power_down, 1);
+
+	if (tas5716->gpiod_nreset) {
+		gpiod_set_value(tas5716->gpiod_nreset, 0);
+		mdelay(1);
+		gpiod_set_value(tas5716->gpiod_nreset, 1);
+		mdelay(1);
+	}
+
+	return 0;
+}
+
+/**
+ * tas5716_set_bias_level - DAPM callback
+ * @codec: the codec device
+ * @level: DAPM power level
+ *
+ * This is called by ALSA to put the codec into low power mode
+ * or to wake it up.  If the codec is powered off completely
+ * all registers must be restored after power on.
+ */
+static int tas5716_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	dev_dbg(codec->dev, "level = %d\n", level);
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+		/* Full power on */
+		regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+				   TAS5716_CONFF_PWDN | TAS5716_CONFF_EAPD,
+				   TAS5716_CONFF_PWDN | TAS5716_CONFF_EAPD);
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
+			ret = regulator_bulk_enable(
+				ARRAY_SIZE(tas5716->supplies),
+				tas5716->supplies);
+			if (ret < 0) {
+				dev_err(codec->dev,
+					"Failed to enable supplies: %d\n",
+					ret);
+				return ret;
+			}
+			tas5716_startup_sequence(tas5716);
+			tas5716_cache_sync(codec);
+		}
+
+		/* Power down */
+		regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+				   TAS5716_CONFF_PWDN | TAS5716_CONFF_EAPD,
+				   0);
+
+		break;
+
+	case SND_SOC_BIAS_OFF:
+		/* The chip runs through the power down sequence for us */
+		regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+				   TAS5716_CONFF_PWDN | TAS5716_CONFF_EAPD, 0);
+
+		/* power down: low */
+		if (tas5716->gpiod_power_down)
+			gpiod_set_value(tas5716->gpiod_power_down, 0);
+
+		if (tas5716->gpiod_nreset)
+			gpiod_set_value(tas5716->gpiod_nreset, 0);
+
+		regulator_bulk_disable(ARRAY_SIZE(tas5716->supplies),
+				       tas5716->supplies);
+		break;
+	}
+	codec->dapm.bias_level = level;
+	return 0;
+}
+
+static const struct snd_soc_dai_ops tas5716_dai_ops = {
+	.hw_params	= tas5716_hw_params,
+	.set_sysclk	= tas5716_set_dai_sysclk,
+	.set_fmt	= tas5716_set_dai_fmt,
+};
+
+static struct snd_soc_dai_driver tas5716_dai = {
+	.name = "tas5716-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = TAS5716_RATES,
+		.formats = TAS5716_FORMATS,
+	},
+	.ops = &tas5716_dai_ops,
+};
+
+#ifdef CONFIG_PM
+static int tas5716_suspend(struct snd_soc_codec *codec)
+{
+	tas5716_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int tas5716_resume(struct snd_soc_codec *codec)
+{
+	tas5716_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	return 0;
+}
+#else
+#define tas5716_suspend NULL
+#define tas5716_resume NULL
+#endif
+
+static int tas5716_probe(struct snd_soc_codec *codec)
+{
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	struct tas5716_platform_data *pdata = tas5716->pdata;
+	int i, ret = 0, thermal = 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(tas5716->supplies),
+				    tas5716->supplies);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to enable supplies: %d\n", ret);
+		return ret;
+	}
+
+	ret = tas5716_startup_sequence(tas5716);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to startup device\n");
+		return ret;
+	}
+
+	/* CONFA */
+	if (!pdata->thermal_warning_recovery)
+		thermal |= TAS5716_CONFA_TWAB;
+	if (!pdata->thermal_warning_adjustment)
+		thermal |= TAS5716_CONFA_TWRB;
+	if (!pdata->fault_detect_recovery)
+		thermal |= TAS5716_CONFA_FDRB;
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFA,
+			   TAS5716_CONFA_TWAB | TAS5716_CONFA_TWRB |
+			   TAS5716_CONFA_FDRB,
+			   thermal);
+
+	/* CONFC */
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFC,
+			   TAS5716_CONFC_OM_MASK,
+			   pdata->ffx_power_output_mode
+				<< TAS5716_CONFC_OM_SHIFT);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFC,
+			   TAS5716_CONFC_CSZ_MASK,
+			   pdata->drop_compensation_ns
+				<< TAS5716_CONFC_CSZ_SHIFT);
+	regmap_update_bits(tas5716->regmap,
+			   TAS5716_CONFC,
+			   TAS5716_CONFC_OCRB,
+			   pdata->oc_warning_adjustment ?
+				TAS5716_CONFC_OCRB : 0);
+
+	/* CONFE */
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_MPCV,
+			   pdata->max_power_use_mpcc ?
+				TAS5716_CONFE_MPCV : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_MPC,
+			   pdata->max_power_correction ?
+				TAS5716_CONFE_MPC : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_AME,
+			   pdata->am_reduction_mode ?
+				TAS5716_CONFE_AME : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_PWMS,
+			   pdata->odd_pwm_speed_mode ?
+				TAS5716_CONFE_PWMS : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_DCCV,
+			   pdata->distortion_compensation ?
+				TAS5716_CONFE_DCCV : 0);
+	/*  CONFF */
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+			   TAS5716_CONFF_IDE,
+			   pdata->invalid_input_detect_mute ?
+				TAS5716_CONFF_IDE : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+			   TAS5716_CONFF_OCFG_MASK,
+			   pdata->output_conf
+				<< TAS5716_CONFF_OCFG_SHIFT);
+
+	/* channel to output mapping */
+	regmap_update_bits(tas5716->regmap, TAS5716_C1CFG,
+			   TAS5716_CxCFG_OM_MASK,
+			   pdata->ch1_output_mapping
+				<< TAS5716_CxCFG_OM_SHIFT);
+	regmap_update_bits(tas5716->regmap, TAS5716_C2CFG,
+			   TAS5716_CxCFG_OM_MASK,
+			   pdata->ch2_output_mapping
+				<< TAS5716_CxCFG_OM_SHIFT);
+	regmap_update_bits(tas5716->regmap, TAS5716_C3CFG,
+			   TAS5716_CxCFG_OM_MASK,
+			   pdata->ch3_output_mapping
+				<< TAS5716_CxCFG_OM_SHIFT);
+
+	/* miscellaneous registers */
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC1,
+			   TAS5716_MISC1_CPWMEN,
+			   pdata->activate_mute_output ?
+				TAS5716_MISC1_CPWMEN : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC1,
+			   TAS5716_MISC1_BRIDGOFF,
+			   pdata->bridge_immediate_off ?
+				TAS5716_MISC1_BRIDGOFF : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC1,
+			   TAS5716_MISC1_NSHHPEN,
+			   pdata->noise_shape_dc_cut ?
+				TAS5716_MISC1_NSHHPEN : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC1,
+			   TAS5716_MISC1_RPDNEN,
+			   pdata->powerdown_master_vol ?
+				TAS5716_MISC1_RPDNEN: 0);
+
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC2,
+			   TAS5716_MISC2_PNDLSL_MASK,
+			   pdata->powerdown_delay_divider
+				<< TAS5716_MISC2_PNDLSL_SHIFT);
+
+	/* initialize coefficient shadow RAM with reset values */
+	for (i = 4; i <= 49; i += 5)
+		tas5716->coef_shadow[i] = 0x400000;
+	for (i = 50; i <= 54; i++)
+		tas5716->coef_shadow[i] = 0x7fffff;
+	tas5716->coef_shadow[55] = 0x5a9df7;
+	tas5716->coef_shadow[56] = 0x7fffff;
+	tas5716->coef_shadow[59] = 0x7fffff;
+	tas5716->coef_shadow[60] = 0x400000;
+	tas5716->coef_shadow[61] = 0x400000;
+
+	tas5716_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	/* Bias level configuration will have done an extra enable */
+	regulator_bulk_disable(ARRAY_SIZE(tas5716->supplies), tas5716->supplies);
+
+	return 0;
+}
+
+static int tas5716_remove(struct snd_soc_codec *codec)
+{
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+
+	tas5716_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	regulator_bulk_disable(ARRAY_SIZE(tas5716->supplies), tas5716->supplies);
+
+	return 0;
+}
+
+static const struct snd_soc_codec_driver tas5716_codec = {
+	.probe =		tas5716_probe,
+	.remove =		tas5716_remove,
+	.suspend =		tas5716_suspend,
+	.resume =		tas5716_resume,
+	.set_bias_level =	tas5716_set_bias_level,
+	.controls =		tas5716_snd_controls,
+	.num_controls =		ARRAY_SIZE(tas5716_snd_controls),
+	.dapm_widgets =		tas5716_dapm_widgets,
+	.num_dapm_widgets =	ARRAY_SIZE(tas5716_dapm_widgets),
+	.dapm_routes =		tas5716_dapm_routes,
+	.num_dapm_routes =	ARRAY_SIZE(tas5716_dapm_routes),
+};
+
+static const struct regmap_config tas5716_regmap = {
+	.reg_bits =		8,
+	.val_bits =		8,
+	.max_register =		TAS5716_MISC2,
+	.reg_defaults =		tas5716_regs,
+	.num_reg_defaults =	ARRAY_SIZE(tas5716_regs),
+	.cache_type =		REGCACHE_RBTREE,
+	.wr_table =		&tas5716_write_regs,
+	.rd_table =		&tas5716_read_regs,
+	.volatile_table =	&tas5716_volatile_regs,
+};
+
+#ifdef CONFIG_OF
+static const struct of_device_id tas5716_dt_ids[] = {
+	{ .compatible = "ti,tas5716", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, tas5716_dt_ids);
+
+static const char * const tas5716_ffx_modes[] = {
+	[TAS5716_FFX_PM_DROP_COMP]		= "drop-compensation",
+	[TAS5716_FFX_PM_TAPERED_COMP]		= "tapered-compensation",
+	[TAS5716_FFX_PM_FULL_POWER]		= "full-power-mode",
+	[TAS5716_FFX_PM_VARIABLE_DROP_COMP]	= "variable-drop-compensation",
+};
+
+static int tas5716_probe_dt(struct device *dev, struct tas5716_priv *tas5716)
+{
+	struct device_node *np = dev->of_node;
+	struct tas5716_platform_data *pdata;
+	const char *ffx_power_mode;
+	u16 tmp;
+	u8 tmp8;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	of_property_read_u8(np, "ti,output-conf",
+			    &pdata->output_conf);
+	of_property_read_u8(np, "ti,ch1-output-mapping",
+			    &pdata->ch1_output_mapping);
+	of_property_read_u8(np, "ti,ch2-output-mapping",
+			    &pdata->ch2_output_mapping);
+	of_property_read_u8(np, "ti,ch3-output-mapping",
+			    &pdata->ch3_output_mapping);
+
+	if (of_get_property(np, "ti,thermal-warning-recovery", NULL))
+		pdata->thermal_warning_recovery = 1;
+	if (of_get_property(np, "ti,thermal-warning-adjustment", NULL))
+		pdata->thermal_warning_adjustment = 1;
+	if (of_get_property(np, "ti,fault-detect-recovery", NULL))
+		pdata->fault_detect_recovery = 1;
+
+	pdata->ffx_power_output_mode = TAS5716_FFX_PM_VARIABLE_DROP_COMP;
+	if (!of_property_read_string(np, "ti,ffx-power-output-mode",
+				     &ffx_power_mode)) {
+		int i, mode = -EINVAL;
+
+		for (i = 0; i < ARRAY_SIZE(tas5716_ffx_modes); i++)
+			if (!strcasecmp(ffx_power_mode, tas5716_ffx_modes[i]))
+				mode = i;
+
+		if (mode < 0)
+			dev_warn(dev, "Unsupported ffx output mode: %s\n",
+				 ffx_power_mode);
+		else
+			pdata->ffx_power_output_mode = mode;
+	}
+
+	tmp = 140;
+	of_property_read_u16(np, "ti,drop-compensation-ns", &tmp);
+	pdata->drop_compensation_ns = clamp_t(u16, tmp, 0, 300) / 20;
+
+	if (of_get_property(np, "ti,overcurrent-warning-adjustment", NULL))
+		pdata->oc_warning_adjustment = 1;
+
+	/* CONFE */
+	if (of_get_property(np, "ti,max-power-use-mpcc", NULL))
+		pdata->max_power_use_mpcc = 1;
+
+	if (of_get_property(np, "ti,max-power-correction", NULL))
+		pdata->max_power_correction = 1;
+
+	if (of_get_property(np, "ti,am-reduction-mode", NULL))
+		pdata->am_reduction_mode = 1;
+
+	if (of_get_property(np, "ti,odd-pwm-speed-mode", NULL))
+		pdata->odd_pwm_speed_mode = 1;
+
+	if (of_get_property(np, "ti,distortion-compensation", NULL))
+		pdata->distortion_compensation = 1;
+
+	/* CONFF */
+	if (of_get_property(np, "ti,invalid-input-detect-mute", NULL))
+		pdata->invalid_input_detect_mute = 1;
+
+	/* MISC */
+	if (of_get_property(np, "ti,activate-mute-output", NULL))
+		pdata->activate_mute_output = 1;
+
+	if (of_get_property(np, "ti,bridge-immediate-off", NULL))
+		pdata->bridge_immediate_off = 1;
+
+	if (of_get_property(np, "ti,noise-shape-dc-cut", NULL))
+		pdata->noise_shape_dc_cut = 1;
+
+	if (of_get_property(np, "ti,powerdown-master-volume", NULL))
+		pdata->powerdown_master_vol = 1;
+
+	if (!of_property_read_u8(np, "ti,powerdown-delay-divider", &tmp8)) {
+		if (is_power_of_2(tmp8) && tmp8 >= 1 && tmp8 <= 128)
+			pdata->powerdown_delay_divider = ilog2(tmp8);
+		else
+			dev_warn(dev, "Unsupported powerdown delay divider %d\n",
+				 tmp8);
+	}
+
+	tas5716->pdata = pdata;
+
+	return 0;
+}
+#endif
+
+static int tas5716_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct device *dev = &i2c->dev;
+	struct tas5716_priv *tas5716;
+	int ret, i;
+
+	printk("JDS - tas5716_i2c_probe\n");
+	tas5716 = devm_kzalloc(dev, sizeof(struct tas5716_priv), GFP_KERNEL);
+	if (!tas5716)
+		return -ENOMEM;
+
+	mutex_init(&tas5716->coeff_lock);
+	tas5716->pdata = dev_get_platdata(dev);
+
+#ifdef CONFIG_OF
+	if (dev->of_node) {
+		ret = tas5716_probe_dt(dev, tas5716);
+		if (ret < 0)
+			return ret;
+	}
+#endif
+
+	printk("JDS - tas5716_i2c_probe a\n");
+	/* GPIOs */
+	tas5716->gpiod_nreset = devm_gpiod_get(dev, "reset");
+	if (IS_ERR(tas5716->gpiod_nreset)) {
+		ret = PTR_ERR(tas5716->gpiod_nreset);
+		if (ret != -ENOENT && ret != -ENOSYS)
+			return ret;
+
+		tas5716->gpiod_nreset = NULL;
+	} else {
+		gpiod_direction_output(tas5716->gpiod_nreset, 0);
+	}
+
+	printk("JDS - tas5716_i2c_probe b\n");
+	tas5716->gpiod_power_down = devm_gpiod_get(dev, "power-down");
+	if (IS_ERR(tas5716->gpiod_power_down)) {
+		ret = PTR_ERR(tas5716->gpiod_power_down);
+		if (ret != -ENOENT && ret != -ENOSYS)
+			return ret;
+
+		tas5716->gpiod_power_down = NULL;
+	} else {
+		gpiod_direction_output(tas5716->gpiod_power_down, 0);
+	}
+
+	/* regulators */
+	for (i = 0; i < ARRAY_SIZE(tas5716->supplies); i++)
+		tas5716->supplies[i].supply = tas5716_supply_names[i];
+
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(tas5716->supplies),
+				      tas5716->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to request supplies: %d\n", ret);
+		return ret;
+	}
+
+	printk("JDS - tas5716_i2c_probe c\n");
+	tas5716->regmap = devm_regmap_init_i2c(i2c, &tas5716_regmap);
+	if (IS_ERR(tas5716->regmap)) {
+		ret = PTR_ERR(tas5716->regmap);
+		dev_err(dev, "Failed to init regmap: %d\n", ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(i2c, tas5716);
+
+	printk("JDS - tas5716_i2c_probe d\n");
+	ret = snd_soc_register_codec(dev, &tas5716_codec, &tas5716_dai, 1);
+	if (ret < 0)
+		dev_err(dev, "Failed to register codec (%d)\n", ret);
+
+	printk("JDS - tas5716_i2c_probe e\n");
+	return ret;
+}
+
+static int tas5716_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+	return 0;
+}
+
+static const struct i2c_device_id tas5716_i2c_id[] = {
+	{ "tas5716", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, tas5716_i2c_id);
+
+static struct i2c_driver tas5716_i2c_driver = {
+	.driver = {
+		.name = "tas5716",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(tas5716_dt_ids),
+	},
+	.probe =    tas5716_i2c_probe,
+	.remove =   tas5716_i2c_remove,
+	.id_table = tas5716_i2c_id,
+};
+
+module_i2c_driver(tas5716_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC TAS5716 driver");
+MODULE_AUTHOR("Sven Brandau <info@brandau.biz>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/tas5716.h b/sound/soc/codecs/tas5716.h
new file mode 100644
index 0000000..c90dd50
--- /dev/null
+++ b/sound/soc/codecs/tas5716.h
@@ -0,0 +1,238 @@
+/*
+ * Codec driver for ST TAS5716 2.1-channel high-efficiency digital audio system
+ *
+ * Copyright: 2011 Raumfeld GmbH
+ * Author: Sven Brandau <info@brandau.biz>
+ *
+ * based on code from:
+ *      Raumfeld GmbH
+ *        Johannes Stezenbach <js@sig21.net>
+ *	Wolfson Microelectronics PLC.
+ *	  Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifndef _ASOC_TAS_5716_H
+#define _ASOC_TAS_5716_H
+
+/* STA50 register addresses */
+
+#define TAS5716_REGISTER_COUNT	0x4D
+#define TAS5716_COEF_COUNT 62
+
+#define TAS5716_CONFA	0x00
+#define TAS5716_CONFB    0x01
+#define TAS5716_CONFC    0x02
+#define TAS5716_CONFD    0x03
+#define TAS5716_CONFE    0x04
+#define TAS5716_CONFF    0x05
+#define TAS5716_MMUTE    0x06
+#define TAS5716_MVOL     0x07
+#define TAS5716_C1VOL    0x08
+#define TAS5716_C2VOL    0x09
+#define TAS5716_C3VOL    0x0a
+#define TAS5716_AUTO1    0x0b
+#define TAS5716_AUTO2    0x0c
+#define TAS5716_AUTO3    0x0d
+#define TAS5716_C1CFG    0x0e
+#define TAS5716_C2CFG    0x0f
+#define TAS5716_C3CFG    0x10
+#define TAS5716_TONE     0x11
+#define TAS5716_L1AR     0x12
+#define TAS5716_L1ATRT   0x13
+#define TAS5716_L2AR     0x14
+#define TAS5716_L2ATRT   0x15
+#define TAS5716_CFADDR2  0x16
+#define TAS5716_B1CF1    0x17
+#define TAS5716_B1CF2    0x18
+#define TAS5716_B1CF3    0x19
+#define TAS5716_B2CF1    0x1a
+#define TAS5716_B2CF2    0x1b
+#define TAS5716_B2CF3    0x1c
+#define TAS5716_A1CF1    0x1d
+#define TAS5716_A1CF2    0x1e
+#define TAS5716_A1CF3    0x1f
+#define TAS5716_A2CF1    0x20
+#define TAS5716_A2CF2    0x21
+#define TAS5716_A2CF3    0x22
+#define TAS5716_B0CF1    0x23
+#define TAS5716_B0CF2    0x24
+#define TAS5716_B0CF3    0x25
+#define TAS5716_CFUD     0x26
+#define TAS5716_MPCC1    0x27
+#define TAS5716_MPCC2    0x28
+#define TAS5716_DCC1     0x29
+#define TAS5716_DCC2     0x2a
+#define TAS5716_FDRC1    0x2b
+#define TAS5716_FDRC2    0x2c
+#define TAS5716_STATUS   0x2d
+/* reserved: 0x2d - 0x30 */
+#define TAS5716_EQCFG    0x31
+#define TAS5716_EATH1    0x32
+#define TAS5716_ERTH1    0x33
+#define TAS5716_EATH2    0x34
+#define TAS5716_ERTH2    0x35
+#define TAS5716_CONFX    0x36
+#define TAS5716_SVCA     0x37
+#define TAS5716_SVCB     0x38
+#define TAS5716_RMS0A    0x39
+#define TAS5716_RMS0B    0x3a
+#define TAS5716_RMS0C    0x3b
+#define TAS5716_RMS1A    0x3c
+#define TAS5716_RMS1B    0x3d
+#define TAS5716_RMS1C    0x3e
+#define TAS5716_EVOLRES  0x3f
+/* reserved: 0x40 - 0x47 */
+#define TAS5716_NSHAPE   0x48
+#define TAS5716_CTXB4B1  0x49
+#define TAS5716_CTXB7B5  0x4a
+#define TAS5716_MISC1    0x4b
+#define TAS5716_MISC2    0x4c
+
+/* 0x00 CONFA */
+#define TAS5716_CONFA_MCS_MASK	0x03
+#define TAS5716_CONFA_MCS_SHIFT	0
+#define TAS5716_CONFA_IR_MASK	0x18
+#define TAS5716_CONFA_IR_SHIFT	3
+#define TAS5716_CONFA_TWRB	BIT(5)
+#define TAS5716_CONFA_TWAB	BIT(6)
+#define TAS5716_CONFA_FDRB	BIT(7)
+
+/* 0x01 CONFB */
+#define TAS5716_CONFB_SAI_MASK	0x0f
+#define TAS5716_CONFB_SAI_SHIFT	0
+#define TAS5716_CONFB_SAIFB	BIT(4)
+#define TAS5716_CONFB_DSCKE	BIT(5)
+#define TAS5716_CONFB_C1IM	BIT(6)
+#define TAS5716_CONFB_C2IM	BIT(7)
+
+/* 0x02 CONFC */
+#define TAS5716_CONFC_OM_MASK	0x03
+#define TAS5716_CONFC_OM_SHIFT	0
+#define TAS5716_CONFC_CSZ_MASK	0x3c
+#define TAS5716_CONFC_CSZ_SHIFT	2
+#define TAS5716_CONFC_OCRB	BIT(7)
+
+/* 0x03 CONFD */
+#define TAS5716_CONFD_HPB_SHIFT	0
+#define TAS5716_CONFD_DEMP_SHIFT	1
+#define TAS5716_CONFD_DSPB_SHIFT	2
+#define TAS5716_CONFD_PSL_SHIFT	3
+#define TAS5716_CONFD_BQL_SHIFT	4
+#define TAS5716_CONFD_DRC_SHIFT	5
+#define TAS5716_CONFD_ZDE_SHIFT	6
+#define TAS5716_CONFD_SME_SHIFT	7
+
+/* 0x04 CONFE */
+#define TAS5716_CONFE_MPCV	BIT(0)
+#define TAS5716_CONFE_MPCV_SHIFT	0
+#define TAS5716_CONFE_MPC	BIT(1)
+#define TAS5716_CONFE_MPC_SHIFT	1
+#define TAS5716_CONFE_NSBW	BIT(2)
+#define TAS5716_CONFE_NSBW_SHIFT	2
+#define TAS5716_CONFE_AME	BIT(3)
+#define TAS5716_CONFE_AME_SHIFT	3
+#define TAS5716_CONFE_PWMS	BIT(4)
+#define TAS5716_CONFE_PWMS_SHIFT	4
+#define TAS5716_CONFE_DCCV	BIT(5)
+#define TAS5716_CONFE_DCCV_SHIFT	5
+#define TAS5716_CONFE_ZCE	BIT(6)
+#define TAS5716_CONFE_ZCE_SHIFT	6
+#define TAS5716_CONFE_SVE	BIT(7)
+#define TAS5716_CONFE_SVE_SHIFT	7
+
+/* 0x05 CONFF */
+#define TAS5716_CONFF_OCFG_MASK	0x03
+#define TAS5716_CONFF_OCFG_SHIFT	0
+#define TAS5716_CONFF_IDE	BIT(2)
+#define TAS5716_CONFF_BCLE	BIT(3)
+#define TAS5716_CONFF_LDTE	BIT(4)
+#define TAS5716_CONFF_ECLE	BIT(5)
+#define TAS5716_CONFF_PWDN	BIT(6)
+#define TAS5716_CONFF_EAPD	BIT(7)
+
+/* 0x06 MMUTE */
+#define TAS5716_MMUTE_MMUTE		0x01
+#define TAS5716_MMUTE_MMUTE_SHIFT	0
+#define TAS5716_MMUTE_C1M		0x02
+#define TAS5716_MMUTE_C1M_SHIFT		1
+#define TAS5716_MMUTE_C2M		0x04
+#define TAS5716_MMUTE_C2M_SHIFT		2
+#define TAS5716_MMUTE_C3M		0x08
+#define TAS5716_MMUTE_C3M_SHIFT		3
+#define TAS5716_MMUTE_LOC_MASK		0xC0
+#define TAS5716_MMUTE_LOC_SHIFT		6
+
+/* 0x0b AUTO1 */
+#define TAS5716_AUTO1_AMGC_MASK	0x30
+#define TAS5716_AUTO1_AMGC_SHIFT	4
+
+/* 0x0c AUTO2 */
+#define TAS5716_AUTO2_AMAME	0x01
+#define TAS5716_AUTO2_AMAM_MASK	0x0e
+#define TAS5716_AUTO2_AMAM_SHIFT	1
+#define TAS5716_AUTO2_XO_MASK	0xf0
+#define TAS5716_AUTO2_XO_SHIFT	4
+
+/* 0x0d AUTO3 */
+#define TAS5716_AUTO3_PEQ_MASK	0x1f
+#define TAS5716_AUTO3_PEQ_SHIFT	0
+
+/* 0x0e 0x0f 0x10 CxCFG */
+#define TAS5716_CxCFG_TCB_SHIFT	0
+#define TAS5716_CxCFG_EQBP_SHIFT	1
+#define TAS5716_CxCFG_VBP_SHIFT	2
+#define TAS5716_CxCFG_BO_SHIFT	3
+#define TAS5716_CxCFG_LS_SHIFT	4
+#define TAS5716_CxCFG_OM_MASK	0xc0
+#define TAS5716_CxCFG_OM_SHIFT	6
+
+/* 0x11 TONE */
+#define TAS5716_TONE_BTC_SHIFT	0
+#define TAS5716_TONE_TTC_SHIFT	4
+
+/* 0x12 0x13 0x14 0x15 limiter attack/release */
+#define TAS5716_LxA_SHIFT	0
+#define TAS5716_LxR_SHIFT	4
+
+/* 0x26 CFUD */
+#define TAS5716_CFUD_W1		0x01
+#define TAS5716_CFUD_WA		0x02
+#define TAS5716_CFUD_R1		0x04
+#define TAS5716_CFUD_RA		0x08
+
+
+/* biquad filter coefficient table offsets */
+#define TAS5716_C1_BQ_BASE	0
+#define TAS5716_C2_BQ_BASE	20
+#define TAS5716_CH_BQ_NUM	4
+#define TAS5716_BQ_NUM_COEF	5
+#define TAS5716_XO_HP_BQ_BASE	40
+#define TAS5716_XO_LP_BQ_BASE	45
+#define TAS5716_C1_PRESCALE	50
+#define TAS5716_C2_PRESCALE	51
+#define TAS5716_C1_POSTSCALE	52
+#define TAS5716_C2_POSTSCALE	53
+#define TAS5716_C3_POSTSCALE	54
+#define TAS5716_TW_POSTSCALE	55
+#define TAS5716_C1_MIX1		56
+#define TAS5716_C1_MIX2		57
+#define TAS5716_C2_MIX1		58
+#define TAS5716_C2_MIX2		59
+#define TAS5716_C3_MIX1		60
+#define TAS5716_C3_MIX2		61
+
+/* miscellaneous register 1 */
+#define TAS5716_MISC1_CPWMEN	BIT(2)
+#define TAS5716_MISC1_BRIDGOFF	BIT(5)
+#define TAS5716_MISC1_NSHHPEN	BIT(6)
+#define TAS5716_MISC1_RPDNEN	BIT(7)
+
+/* miscellaneous register 2 */
+#define TAS5716_MISC2_PNDLSL_MASK	0x1c
+#define TAS5716_MISC2_PNDLSL_SHIFT	2
+
+#endif /* _ASOC_TAS_5716_H */
diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
index 79511ae..8403b20 100644
--- a/sound/soc/sunxi/Kconfig
+++ b/sound/soc/sunxi/Kconfig
@@ -7,4 +7,11 @@ config SND_SUNXI_SOC_CODEC
 	select REGMAP_MMIO
 	default y
 
+config SND_SUNXI_SOC_I2S
+	tristate "Sunxi I2S support"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	default y
+
 endmenu
+
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
index b8950d3..d87b4c1 100644
--- a/sound/soc/sunxi/Makefile
+++ b/sound/soc/sunxi/Makefile
@@ -1,2 +1,3 @@
 obj-$(CONFIG_SND_SUNXI_SOC_CODEC) += sunxi-codec.o
+obj-$(CONFIG_SND_SUNXI_SOC_I2S) += sunxi-i2s.o
 
diff --git a/sound/soc/sunxi/sunxi-i2s.c b/sound/soc/sunxi/sunxi-i2s.c
new file mode 100644
index 0000000..3b3873a
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-i2s.c
@@ -0,0 +1,667 @@
+/*
+ * Copyright 2014 Emilio López <emilio@elopez.com.ar>
+ * Copyright 2014 Jon Smirl <jonsmirl@gmail.com>
+ *
+ * Based on the Allwinner SDK driver, released under the GPL.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/clk.h>
+#include <linux/regmap.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+
+/* Codec register offsets and bit fields */
+#define SUNXI_DAC_DPC		(0x00)
+#define EN_DA				(31)
+#define DAC_VERSION			(23) /* For CODEC OLD VERSION */
+#define DVOL				(12)
+#define SUNXI_DAC_FIFOC		(0x04)
+#define DAC_FS				(29)
+#define FIR_VERSION			(28)
+#define SEND_LASAT			(26)
+#define TX_FIFO_MODE			(24)
+#define DAC_DRQ_CLR_CNT			(21)
+#define TX_TRIG_LEVEL			(8)
+#define DAC_MONO_EN			(6)
+#define TX_SAMPLE_BITS			(5)
+#define DAC_DRQ_EN			(4)
+#define DAC_FIFO_FLUSH			(0)
+#define SUNXI_DAC_FIFOS		(0x08)
+#define SUNXI_DAC_TXDATA	(0x0c)
+#define SUNXI_DAC_ACTL		(0x10)
+#define DACAENR				(31)
+#define DACAENL				(30)
+#define MIXEN				(29)
+#define DACPAS				(8)
+#define MIXPAS				(7)
+#define PAMUTE				(6)
+#define PAVOL				(0)
+#define SUNXI_DAC_TUNE		(0x14)
+#define SUNXI_DAC_DEBUG		(0x18)
+#define SUNXI_ADC_FIFOC		(0x1c)
+#define EN_AD				(28)
+#define RX_FIFO_MODE			(24)
+#define RX_TRIG_LEVEL			(8)
+#define ADC_MONO_EN			(7)
+#define RX_SAMPLE_BITS			(6)
+#define ADC_DRQ_EN			(4)
+#define ADC_FIFO_FLUSH			(0)
+#define SUNXI_ADC_FIFOS		(0x20)
+#define SUNXI_ADC_RXDATA	(0x24)
+#define SUNXI_ADC_ACTL		(0x28)
+#define ADCREN				(31)
+#define ADCLEN				(30)
+#define PREG1EN				(29)
+#define PREG2EN				(28)
+#define VMICEN				(27)
+#define ADCG				(20)
+#define ADCIS				(17)
+#define PA_EN				(4)
+#define DDE				(3)
+#define SUNXI_ADC_DEBUG		(0x2c)
+#define SUNXI_DAC_TXCNT		(0x30)
+#define SUNXI_ADC_RXCNT		(0x34)
+#define SUNXI_AC_SYS_VERI	(0x38)
+#define SUNXI_AC_MIC_PHONE_CAL	(0x3c)
+
+
+#define DAIFMT_16BITS             (16)
+#define DAIFMT_20BITS             (20)
+
+#define DAIFMT_BS_MASK            (~(1<<16)) /* FIFO big small mode mask */
+#define DAIFMT_BITS_MASK          (~(1<<5))  /* FIFO Bits select mask, not used yet */
+#define SAMPLE_RATE_MASK          (~(7<<29)) /* Sample Rate slect mask*/
+
+#define DAC_CHANNEL		  (6)
+
+enum sunxi_device_id {SUN4A, SUN4I, SUN5I, SUN7I};
+
+struct sunxi_priv {
+	struct regmap *regmap;
+	int irq;
+	struct clk *clk_apb, *clk_pll2, *clk_module;
+
+	enum sunxi_device_id id;
+
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+};
+
+static int i2s_play_start(struct sunxi_priv *priv)
+{
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+#endif
+
+	/* flush TX FIFO */
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_FIFO_FLUSH, 0x1 << DAC_FIFO_FLUSH);
+
+	/* enable DAC DRQ */
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_DRQ_EN, 0x1 << DAC_DRQ_EN);
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PAMUTE, 0x1 << PAMUTE);
+
+	return 0;
+}
+
+static int i2s_play_stop(struct sunxi_priv *priv)
+{
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+#endif
+
+	/* mute PA */
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PAMUTE, 0x0 << PAMUTE);
+	mdelay(5);
+
+	/* disable DAC DRQ */
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_DRQ_EN, 0x0 << DAC_DRQ_EN);
+
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAENL, 0x0 << DACAENL);
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAENR, 0x0 << DACAENR);
+
+	return 0;
+}
+
+static int i2s_capture_start(struct sunxi_priv *priv)
+{
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+#endif
+
+	/* enable ADC DRQ */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DRQ_EN, 0x1 << ADC_DRQ_EN);
+
+	return 0;
+}
+
+static int i2s_capture_stop(struct sunxi_priv *priv)
+{
+	/* disable ADC DRQ */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DRQ_EN, 0x0 << ADC_DRQ_EN);
+
+	/* enable mic1 PA */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << PREG1EN, 0x0 << PREG1EN);
+
+	/* enable VMIC */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << VMICEN, 0x0 << VMICEN);
+	if (priv->id == SUN7I) {
+		/* FIXME - undocumented */
+		regmap_update_bits(priv->regmap, SUNXI_DAC_TUNE, 0x3 << 8, 0x0 << 8);
+	}
+
+	/* enable ADC digital */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << EN_AD, 0x0 << EN_AD);
+
+	/* set RX FIFO mode */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << RX_FIFO_MODE, 0x0 << RX_FIFO_MODE);
+
+	/* flush RX FIFO */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_FIFO_FLUSH, 0x0 << ADC_FIFO_FLUSH);
+
+	/* enable adc1 analog */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << ADCLEN, 0x0 << ADCLEN);
+
+	return 0;
+}
+
+static int sunxi_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			i2s_capture_start(priv);
+		else
+			i2s_play_start(priv);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			i2s_capture_stop(priv);
+		else
+			i2s_play_stop(priv);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sunxi_i2s_prepare(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1 << EN_DA, 0x1 << EN_DA);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_FIFO_FLUSH, 0x1 << DAC_FIFO_FLUSH);
+		/* set TX FIFO send DRQ level */
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x3f << TX_TRIG_LEVEL, 0xf << TX_TRIG_LEVEL);
+		if (substream->runtime->rate > 32000) {
+			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << FIR_VERSION, 0x0 << FIR_VERSION);
+		} else {
+			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << FIR_VERSION, 0x1 << FIR_VERSION);
+		}
+		/* set TX FIFO MODE - 0 works for both 16 and 24 bits */
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << TX_FIFO_MODE, 0x0 << TX_FIFO_MODE);
+		/* send last sample when DAC FIFO under run */
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << SEND_LASAT, 0x0 << SEND_LASAT);
+		/* enable dac analog */
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAENL, 0x1 << DACAENL);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAENR, 0x1 << DACAENR);
+		/* enable DAC to PA */
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACPAS, 0x1 << DACPAS);
+	} else {
+		/* enable mic1 PA */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << PREG1EN, 0x1 << PREG1EN);
+		/* mic1 gain 32dB */  /* FIXME - makes no sense */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << 25, 0x1 << 25);
+		/* enable VMIC */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << VMICEN, 0x1 << VMICEN);
+
+		if (priv->id == SUN7I) {
+			/* boost up record effect */
+			regmap_update_bits(priv->regmap, SUNXI_DAC_TUNE, 0x3 << 8, 0x1 << 8);
+		}
+
+		/* enable ADC digital */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << EN_AD, 0x1 << EN_AD);
+		/* set RX FIFO mode */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << RX_FIFO_MODE, 0x1 << RX_FIFO_MODE);
+		/* flush RX FIFO */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_FIFO_FLUSH, 0x1 << ADC_FIFO_FLUSH);
+		/* set RX FIFO rec drq level */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0xf << RX_TRIG_LEVEL, 0x7 << RX_TRIG_LEVEL);
+		/* enable adc1 analog */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << ADCLEN, 0x3 << ADCLEN);
+	}
+
+	return 0;
+}
+
+static int sunxi_i2s_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+	int is_mono = !!(params_channels(params) == 1);
+	int is_24bit = !!(hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS)->min == 32);
+	unsigned int rate = params_rate(params);
+	unsigned int hwrate;
+
+	switch (rate) {
+	case 176400:
+	case 88200:
+	case 44100:
+	case 33075:
+	case 22050:
+	case 14700:
+	case 11025:
+	case 7350:
+	default:
+		clk_set_rate(priv->clk_pll2, 22579200);
+		clk_set_rate(priv->clk_module, 22579200);
+		break;
+	case 192000:
+	case 96000:
+	case 48000:
+	case 32000:
+	case 24000:
+	case 16000:
+	case 12000:
+	case 8000:
+		clk_set_rate(priv->clk_pll2, 24576000);
+		clk_set_rate(priv->clk_module, 24576000);
+		break;
+	}
+
+	switch (rate) {
+	case 192000:
+	case 176400:
+		hwrate = 6;
+		break;
+	case 96000:
+	case 88200:
+		hwrate = 7;
+		break;
+	default:
+	case 48000:
+	case 44100:
+		hwrate = 0;
+		break;
+	case 32000:
+	case 33075:
+		hwrate = 1;
+		break;
+	case 24000:
+	case 22050:
+		hwrate = 2;
+		break;
+	case 16000:
+	case 14700:
+		hwrate = 3;
+		break;
+	case 12000:
+	case 11025:
+		hwrate = 4;
+		break;
+	case 8000:
+	case 7350:
+		hwrate = 5;
+		break;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 7 << DAC_FS, hwrate << DAC_FS);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << DAC_MONO_EN, is_mono << DAC_MONO_EN);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << TX_SAMPLE_BITS, is_24bit << TX_SAMPLE_BITS);
+		if (is_24bit)
+			priv->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		else
+			priv->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	} else  {
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 7 << 29, hwrate << 29);
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 1 << ADC_MONO_EN, is_mono << ADC_MONO_EN);
+	}
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new sun7i_dac_ctls[] = {
+	/*SUNXI_DAC_ACTL = 0x10,PAVOL*/
+	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0),
+	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0),
+	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0),
+	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
+	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+	SOC_SINGLE("MIC output volume", SUNXI_DAC_ACTL, 20, 7, 0),
+	/*	FM Input to output mixer Gain Control
+	* 	From -4.5db to 6db,1.5db/step,default is 0db
+	*	-4.5db:0x0,-3.0db:0x1,-1.5db:0x2,0db:0x3
+	*	1.5db:0x4,3.0db:0x5,4.5db:0x6,6db:0x7
+	*/
+	SOC_SINGLE("Fm output Volume", SUNXI_DAC_ACTL, 23, 7, 0),
+	/*	Line-in gain stage to output mixer Gain Control
+	*	0:-1.5db,1:0db
+	*/
+	SOC_SINGLE("Line output Volume", SUNXI_DAC_ACTL, 26, 1, 0),
+
+	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0),
+	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0),
+	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0),
+	SOC_SINGLE("Linein Pre-AMP", SUNXI_ADC_ACTL, 13, 7, 0),
+	SOC_SINGLE("LINEIN APM Volume", SUNXI_AC_MIC_PHONE_CAL, 13, 0x7, 0),
+	/* ADC Input Gain Control, capture volume
+	* 000:-4.5db,001:-3db,010:-1.5db,011:0db,100:1.5db,101:3db,110:4.5db,111:6db
+	*/
+	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0),
+	/*
+	*	MIC2 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
+	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
+	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0),
+	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0),
+	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0),
+	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
+	SOC_SINGLE("Mic2 gain Volume", SUNXI_AC_MIC_PHONE_CAL, 26, 7, 0),
+	/*
+	*	MIC1 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	SOC_SINGLE("Mic1 gain Volume", SUNXI_AC_MIC_PHONE_CAL, 29, 3, 0),
+};
+
+static int sunxi_i2s_dai_probe(struct snd_soc_dai *dai)
+{
+	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	snd_soc_dai_init_dma_data(dai, &priv->playback_dma_data, &priv->capture_dma_data);
+
+	return 0;
+}
+
+static int sunxi_i2s_startup(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	return clk_prepare_enable(priv->clk_module);
+}
+
+static void sunxi_i2s_shutdown(struct snd_pcm_substream *substream,
+				 struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	clk_disable_unprepare(priv->clk_module);
+}
+
+
+static int i2s_init(struct sunxi_priv *priv)
+{
+	/* enable DAC digital */
+	regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 1 << EN_DA, 1 << EN_DA);
+
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << FIR_VERSION, 1 << FIR_VERSION);
+
+	/* set digital volume to maximum */
+	if (priv->id == SUN4A)
+		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x3F << DVOL, 0 << DVOL);
+
+	/* PA mute */
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 1 << PAMUTE, 0 << PAMUTE);
+
+	/* enable PA */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 1 << PA_EN, 1 << PA_EN);
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 3 << DAC_DRQ_CLR_CNT, 3 << DAC_DRQ_CLR_CNT);
+
+	/* set volume */
+	if (priv->id == SUN4A)
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x3f << PAVOL, 1 << PAVOL);
+	else
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x3f << PAVOL, 0x30 << PAVOL);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_i2s_dai_ops = {
+	.startup = sunxi_i2s_startup,
+	.shutdown = sunxi_i2s_shutdown,
+	.trigger = sunxi_i2s_trigger,
+	.hw_params = sunxi_i2s_hw_params,
+	.prepare = sunxi_i2s_prepare,
+};
+
+static struct snd_soc_dai_driver sunxi_i2s_dai = {
+	.probe = sunxi_i2s_dai_probe,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.formats = (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE),
+
+		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_11025 |\
+			 SNDRV_PCM_RATE_22050| SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\
+			 SNDRV_PCM_RATE_48000 |SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000 |\
+			 SNDRV_PCM_RATE_KNOT),
+		.rate_min = 8000,
+		.rate_max = 192000,
+	},
+	.ops = &sunxi_i2s_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_i2s_component = {
+	.name = "sunxi-i2s",
+};
+
+static const struct regmap_config sunxi_i2s_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_AC_MIC_PHONE_CAL,
+};
+
+static const struct snd_soc_dapm_widget i2s_dapm_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("Mic Bias"),
+	SND_SOC_DAPM_OUTPUT("HP_OUT"),
+	SND_SOC_DAPM_INPUT("MIC_IN"),
+	SND_SOC_DAPM_INPUT("LINE_IN"),
+};
+
+static const struct of_device_id sunxi_i2s_of_match[] = {
+	{ .compatible = "allwinner,sun4i-a10a-i2s", .data = (void *)SUN4A},
+	{ .compatible = "allwinner,sun4i-a10-i2s", .data = (void *)SUN4I},
+	{ .compatible = "allwinner,sun5i-a13-i2s", .data = (void *)SUN5I},
+	{ .compatible = "allwinner,sun7i-a20-i2s", .data = (void *)SUN7I},
+	{}
+};
+MODULE_DEVICE_TABLE(of, sunxi_i2s_of_match);
+
+static int sunxi_i2s_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct sunxi_priv *priv;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	of_id = of_match_device(sunxi_i2s_of_match, dev);
+	if (!of_id)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->id = (int)of_id->data;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	priv->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					     &sunxi_i2s_regmap_config);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	priv->irq = irq_of_parse_and_map(np, 0);
+	if (!priv->irq) {
+		dev_err(dev, "no irq for node %s\n", np->full_name);
+		return -ENXIO;
+	}
+
+	/* Get the clocks from the DT */
+	priv->clk_apb = devm_clk_get(dev, "apb");
+	if (IS_ERR(priv->clk_apb)) {
+		dev_err(dev, "failed to get apb clock\n");
+		return PTR_ERR(priv->clk_apb);
+	}
+	priv->clk_pll2 = devm_clk_get(dev, "pll2");
+	if (IS_ERR(priv->clk_pll2)) {
+		dev_err(dev, "failed to get pll2 clock\n");
+		return PTR_ERR(priv->clk_pll2);
+	}
+	priv->clk_module = devm_clk_get(dev, "i2s");
+	if (IS_ERR(priv->clk_module)) {
+		dev_err(dev, "failed to get i2s clock\n");
+		return PTR_ERR(priv->clk_module);
+	}
+
+	/* Enable PLL2 on a basic rate */
+	ret = clk_set_rate(priv->clk_pll2, 24576000);
+	if (ret) {
+		dev_err(dev, "failed to set i2s base clock rate\n");
+		return ret;
+	}
+	if (clk_prepare_enable(priv->clk_pll2)) {
+		dev_err(dev, "failed to enable pll2 clock\n");
+		return -EINVAL;
+	}
+
+	/* Enable the bus clock */
+	if (clk_prepare_enable(priv->clk_apb)) {
+		dev_err(dev, "failed to enable apb clock\n");
+		clk_disable_unprepare(priv->clk_pll2);
+		return -EINVAL;
+	}
+
+	/* DMA configuration for TX FIFO */
+	priv->playback_dma_data.addr = res->start + SUNXI_DAC_TXDATA;
+	priv->playback_dma_data.maxburst = 4;
+	priv->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	/* DMA configuration for RX FIFO */
+	priv->capture_dma_data.addr = res->start + SUNXI_ADC_RXDATA;
+	priv->capture_dma_data.maxburst = 4;
+	priv->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_i2s_component, &sunxi_i2s_dai, 1);
+	if (ret)
+		goto err_clk_disable;
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret)
+		goto err_clk_disable;
+
+	i2s_init(priv);
+
+	return 0;
+
+err_clk_disable:
+	clk_disable_unprepare(priv->clk_apb);
+	clk_disable_unprepare(priv->clk_pll2);
+	return ret;
+}
+
+static int sunxi_i2s_remove(struct platform_device *pdev)
+{
+	struct sunxi_priv *priv = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(priv->clk_apb);
+	clk_disable_unprepare(priv->clk_pll2);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_i2s_driver = {
+	.driver = {
+		.name = "sunxi-i2s",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_i2s_of_match,
+	},
+	.probe = sunxi_i2s_probe,
+	.remove = sunxi_i2s_remove,
+};
+module_platform_driver(sunxi_i2s_driver);
+
+MODULE_DESCRIPTION("sunxi i2s ASoC driver");
+MODULE_AUTHOR("Emilio López <emilio@elopez.com.ar>");
+MODULE_AUTHOR("Jon Smirl <jonsmirl@gmail.com>");
+MODULE_LICENSE("GPL");
