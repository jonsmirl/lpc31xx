Bottom: d6b6821caf97a60fad45a27cf1cb4be567fa05eb
Top:    fd28ac0163f4f331a0e41db3bd280c27b79af2f1
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-08-05 14:17:17 -0400

TAS5716 support for Tyler


---

diff --git a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
index a6c1a3c..6c0d638 100644
--- a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
+++ b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
@@ -106,6 +106,16 @@
 			status = "okay";
 		};
 
+		iis0: iis@01c22000 {
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2s0_pins_a>;
+			status = "okay";
+		};
+
+		codec: codec@01c22c00 {
+			status = "okay";
+		};
+
 		uart0: serial@01c28000 {
 			pinctrl-names = "default";
 			pinctrl-0 = <&uart0_pins_a>;
@@ -132,6 +142,24 @@
 			pinctrl-names = "default";
 			pinctrl-0 = <&i2c1_pins_a>;
 			status = "okay";
+
+			tas5716: tas5716@36 {
+				compatible = "ti,tas5716";
+				reg = <0x36>;
+				#sound-dai-cells = <0>;
+
+				power-down = <&pio 6 1 0>;
+				reset = <&pio 6 3 0>;
+				mute = <&pio 6 5 0>;
+				/*ti,hpsel = <&pio 0 0 0>;*/
+			};
+
+			sgtl5000: sgtl5000@a {
+				compatible = "fsl,sgtl5000";
+				reg = <0x0a>;
+				clocks = <&iis0>;
+				#sound-dai-cells = <0>;
+			};
 		};
 
 		i2c2: i2c@01c2b400 {
@@ -153,6 +181,21 @@
 		};
 	};
 
+	sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <256>;
+
+		simple-audio-card,cpu {
+			sound-dai = <&iis0>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&sgtl5000>;
+		};
+	};
+
+
 	leds {
 		compatible = "gpio-leds";
 		pinctrl-names = "default";
diff --git a/arch/arm/boot/dts/sun7i-a20.dtsi b/arch/arm/boot/dts/sun7i-a20.dtsi
index 3820bb2..ec9adfa 100644
--- a/arch/arm/boot/dts/sun7i-a20.dtsi
+++ b/arch/arm/boot/dts/sun7i-a20.dtsi
@@ -725,6 +725,13 @@
 				allwinner,pull = <0>;
 			};
 
+			i2s0_pins_a: i2s0@0 {
+				allwinner,pins = "PB5", "PB6","PB7", "PB8","PB9", "PB10","PB11", "PB12";
+				allwinner,function = "i2s0";
+				allwinner,drive = <0>;
+				allwinner,pull = <0>;
+			};
+
 			emac_pins_a: emac0@0 {
 				allwinner,pins = "PA0", "PA1", "PA2",
 						"PA3", "PA4", "PA5", "PA6",
@@ -875,6 +882,65 @@
 			status = "disabled";
 		};
 
+		iis0: iis@01c22000 {
+			#clock-cells = <0>;
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun7i-a20-iis";
+			reg = <0x01C22000 0x40>;
+			interrupts = <0 16 4>;
+			clocks = <&apb0_gates 3>, <&i2s0_clk>;
+			clock-names = "apb", "iis";
+			clock-output-names = "mclk0";
+			dmas = <&dma 0 3>, <&dma 0 3>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		iis1: iis@01c22400 {
+			#clock-cells = <0>;
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun7i-a20-iis";
+			reg = <0x01C22400 0x40>;
+			interrupts = <0 87 4>;
+			clocks = <&apb0_gates 4>, <&i2s1_clk>;
+			clock-names = "apb", "iis";
+			clock-output-names = "mclk1";
+			dmas = <&dma 0 4>, <&dma 0 4>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		iis2: iis@01c24400 {
+			#clock-cells = <0>;
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun7i-a20-iis";
+			reg = <0x01C24400 0x40>;
+			interrupts = <0 90 4>;
+			clocks = <&apb0_gates 8>, <&i2s2_clk>;
+			clock-names = "apb", "iis";
+			clock-output-names = "mclk2";
+			dmas = <&dma 0 6>, <&dma 0 6>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		codec: codec@01c22c00 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun7i-a20-codec";
+			reg = <0x01c22c00 0x40>;
+			interrupts = <0 30 4>;
+			clocks = <&pll2 0>, <&apb0_gates 0>, <&codec_clk>;
+			clock-names = "pll", "apb", "codec";
+			dmas = <&dma 0 19>, <&dma 0 19>;
+			dma-names = "rx", "tx";
+			routing =
+				"MIC_IN", "Microphone Jack",
+				"Microphone Jack", "Mic Bias",
+				"LINE_IN", "Line In Jack",
+				"Headphone Jack", "HP_OUT";
+			status = "disabled";
+		};
+
 		sid: eeprom@01c23800 {
 			compatible = "allwinner,sun7i-a20-sid";
 			reg = <0x01c23800 0x200>;
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 0060b31..8f08e4b 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -52,6 +52,7 @@ source "sound/soc/s6000/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/sirf/Kconfig"
 source "sound/soc/spear/Kconfig"
+source "sound/soc/sunxi/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/txx9/Kconfig"
 source "sound/soc/ux500/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 5f1df02..50c7ab3 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -29,6 +29,7 @@ obj-$(CONFIG_SND_SOC)	+= s6000/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= sirf/
 obj-$(CONFIG_SND_SOC)	+= spear/
+obj-$(CONFIG_SND_SOC)	+= sunxi/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= txx9/
 obj-$(CONFIG_SND_SOC)	+= ux500/
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 0b9571c..94a6bc8 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -92,6 +92,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_STA529 if I2C
 	select SND_SOC_STAC9766 if SND_SOC_AC97_BUS
 	select SND_SOC_TAS5086 if I2C
+	select SND_SOC_TAS5716 if I2C
 	select SND_SOC_TLV320AIC23_I2C if I2C
 	select SND_SOC_TLV320AIC23_SPI if SPI_MASTER
 	select SND_SOC_TLV320AIC26 if SPI_MASTER
@@ -525,6 +526,11 @@ config SND_SOC_TAS5086
 	tristate "Texas Instruments TAS5086 speaker amplifier"
 	depends on I2C
 
+config SND_SOC_TAS5716
+	tristate "Texas Instruments TAS5716 speaker amplifier"
+	select REGMAP_I2C
+	depends on I2C
+
 config SND_SOC_TLV320AIC23
 	tristate
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 1bd6e1c..dc18e5d 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -93,6 +93,7 @@ snd-soc-sta350-objs := sta350.o
 snd-soc-sta529-objs := sta529.o
 snd-soc-stac9766-objs := stac9766.o
 snd-soc-tas5086-objs := tas5086.o
+snd-soc-tas5716-objs := tas5716.o
 snd-soc-tlv320aic23-objs := tlv320aic23.o
 snd-soc-tlv320aic23-i2c-objs := tlv320aic23-i2c.o
 snd-soc-tlv320aic23-spi-objs := tlv320aic23-spi.o
@@ -256,6 +257,7 @@ obj-$(CONFIG_SND_SOC_STA350)   += snd-soc-sta350.o
 obj-$(CONFIG_SND_SOC_STA529)   += snd-soc-sta529.o
 obj-$(CONFIG_SND_SOC_STAC9766)	+= snd-soc-stac9766.o
 obj-$(CONFIG_SND_SOC_TAS5086)	+= snd-soc-tas5086.o
+obj-$(CONFIG_SND_SOC_TAS5716)	+= snd-soc-tas5716.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23)	+= snd-soc-tlv320aic23.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23_I2C)	+= snd-soc-tlv320aic23-i2c.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23_SPI)	+= snd-soc-tlv320aic23-spi.o
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index 3d39f0b..07a46b0 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -1443,6 +1443,8 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 	if (!sgtl5000)
 		return -ENOMEM;
 
+	printk("JDS - sgtl5000_i2c_probe\n");
+
 	sgtl5000->regmap = devm_regmap_init_i2c(client, &sgtl5000_regmap);
 	if (IS_ERR(sgtl5000->regmap)) {
 		ret = PTR_ERR(sgtl5000->regmap);
@@ -1460,15 +1462,19 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 		return ret;
 	}
 
+	printk("JDS - sgtl5000_i2c_probe a\n");
 	ret = clk_prepare_enable(sgtl5000->mclk);
 	if (ret)
 		return ret;
+	printk("JDS - sgtl5000_i2c_probe chip id next\n");
 
 	/* read chip information */
 	ret = regmap_read(sgtl5000->regmap, SGTL5000_CHIP_ID, &reg);
+	printk("JDS - sgtl5000_i2c_probe chip id ret %d\n", ret);
 	if (ret)
 		goto disable_clk;
 
+	printk("JDS - sgtl5000_i2c_probe b\n");
 	if (((reg & SGTL5000_PARTID_MASK) >> SGTL5000_PARTID_SHIFT) !=
 	    SGTL5000_PARTID_PART_ID) {
 		dev_err(&client->dev,
@@ -1477,12 +1483,14 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 		goto disable_clk;
 	}
 
+	printk("JDS - sgtl5000_i2c_probe c\n");
 	rev = (reg & SGTL5000_REVID_MASK) >> SGTL5000_REVID_SHIFT;
 	dev_info(&client->dev, "sgtl5000 revision 0x%x\n", rev);
 	sgtl5000->revision = rev;
 
 	i2c_set_clientdata(client, sgtl5000);
 
+	printk("JDS - sgtl5000_i2c_probe d\n");
 	/* Ensure sgtl5000 will start with sane register values */
 	ret = sgtl5000_fill_defaults(sgtl5000);
 	if (ret)
@@ -1493,6 +1501,7 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 	if (ret)
 		goto disable_clk;
 
+	printk("JDS - sgtl5000_i2c_probe finished\n");
 	return 0;
 
 disable_clk:
diff --git a/sound/soc/codecs/tas5716.c b/sound/soc/codecs/tas5716.c
new file mode 100644
index 0000000..3e52bc6
--- /dev/null
+++ b/sound/soc/codecs/tas5716.c
@@ -0,0 +1,1368 @@
+/*
+ * Codec driver for TI TAS5716 2.1-channel high-efficiency digital audio system
+ *
+ * Copyright: 2014 Raumfeld GmbH
+ * Author: Sven Brandau <info@brandau.biz>
+ *
+ * based on code from:
+ *	Raumfeld GmbH
+ *	  Johannes Stezenbach <js@sig21.net>
+ *	Wolfson Microelectronics PLC.
+ *	  Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *	Freescale Semiconductor, Inc.
+ *	  Timur Tabi <timur@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ":%s:%d: " fmt, __func__, __LINE__
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/gpio/consumer.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include "tas5716.h"
+
+#define TAS5716_RATES (SNDRV_PCM_RATE_32000 | \
+		      SNDRV_PCM_RATE_44100 | \
+		      SNDRV_PCM_RATE_48000 | \
+		      SNDRV_PCM_RATE_88200 | \
+		      SNDRV_PCM_RATE_96000 | \
+		      SNDRV_PCM_RATE_176400 | \
+		      SNDRV_PCM_RATE_192000)
+
+#define TAS5716_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE  | SNDRV_PCM_FMTBIT_S16_BE  | \
+	 SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S18_3BE | \
+	 SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S20_3BE | \
+	 SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_3BE | \
+	 SNDRV_PCM_FMTBIT_S24_LE  | SNDRV_PCM_FMTBIT_S24_BE  | \
+	 SNDRV_PCM_FMTBIT_S32_LE  | SNDRV_PCM_FMTBIT_S32_BE)
+
+/* Power-up register defaults */
+static const struct reg_default tas5716_regs[] = {
+	{  0x0, 0x6c },
+	{  0x1, 0x28 },
+	{  0x2, 0x00 },
+	{  0x3, 0xA0 },
+	{  0x4, 0x05 },
+	{  0x5, 0x40 },
+	{  0x6, 0x00 },
+	{  0x7, 0xff },
+	{  0x8, 0x30 },
+	{  0x9, 0x30 },
+	{  0xa, 0x30 },
+	{  0xb, 0x30 },
+	{  0xc, 0x30 },
+	{  0xd, 0x30 },
+	{  0xe, 0x91 },
+	{ 0x10, 0x02 },
+	{ 0x11, 0x4c },
+	{ 0x12, 0x34 },
+	{ 0x13, 0x1c },
+	{ 0x14, 0x64 },
+	{ 0x15, 0xb0 },
+	{ 0x16, 0x90 },
+	{ 0x19, 0x30 },
+	{ 0x1a, 0x0a },
+	{ 0x1b, 0x82 },
+	{ 0x1c, 0x02 },
+	{ 0x20, 0x008977A },
+	{ 0x21, 0x0004203 },
+	{ 0x22, 0x00 },
+	{ 0x25, 0x01021345 },
+	{ 0x26, 0x00800000 },
+	{ 0x28, 0x00800000 },
+	{ 0x40, 0xFDA21490 },
+	{ 0x41, 0x03842109 },
+	{ 0x42, 0x00084210 },
+	{ 0x43, 0xFDA21490 },
+	{ 0x44, 0x03842109 },
+	{ 0x45, 0x00084210 },
+	{ 0x46, 0x00 },
+	{ 0x50, 0x00 },
+};
+
+static const struct regmap_range tas5716_write_regs_range[] = {
+	regmap_reg_range(TAS5716_SYS_CTRL1,  TAS5716_BKND_ERR),
+	regmap_reg_range(TAS5716_INPUT_MUX,  TAS5716_AM_TUNED_FREQ),
+	regmap_reg_range(TAS5716_PWM_MUX,  TAS5716_SCALE),
+	regmap_reg_range(TAS5716_DRC1_T, TAS5716_BANK_UPDATE),
+};
+
+static const struct regmap_range tas5716_read_regs_range[] = {
+	regmap_reg_range(TAS5716_SYS_CTRL1,  TAS5716_BKND_ERR),
+	regmap_reg_range(TAS5716_INPUT_MUX,  TAS5716_AM_TUNED_FREQ),
+	regmap_reg_range(TAS5716_PWM_MUX,  TAS5716_SCALE),
+	regmap_reg_range(TAS5716_DRC1_T, TAS5716_BANK_UPDATE),
+};
+
+static const struct regmap_range tas5716_volatile_regs_range[] = {
+	regmap_reg_range(TAS5716_CLOCK_CTRL, TAS5716_ERROR),
+	regmap_reg_range(TAS5716_OSC_TRIM,  TAS5716_OSC_TRIM),
+};
+
+static const struct regmap_access_table tas5716_write_regs = {
+	.yes_ranges =	tas5716_write_regs_range,
+	.n_yes_ranges =	ARRAY_SIZE(tas5716_write_regs_range),
+};
+
+static const struct regmap_access_table tas5716_read_regs = {
+	.yes_ranges =	tas5716_read_regs_range,
+	.n_yes_ranges =	ARRAY_SIZE(tas5716_read_regs_range),
+};
+
+static const struct regmap_access_table tas5716_volatile_regs = {
+	.yes_ranges =	tas5716_volatile_regs_range,
+	.n_yes_ranges =	ARRAY_SIZE(tas5716_volatile_regs_range),
+};
+
+/* regulator power supply names */
+static const char * const tas5716_supply_names[] = {
+	"vdd",		/* digital supply, 3.3V */
+	"vcc"		/* power amp supply, 5V - 26V */
+};
+
+/* codec private data */
+struct tas5716_priv {
+	struct regmap *regmap;
+	struct regulator_bulk_data supplies[ARRAY_SIZE(tas5716_supply_names)];
+
+	unsigned int mclk;
+	unsigned int format;
+
+	int shutdown;
+
+	int gpio_nreset;
+	int gpio_power_down;
+	int gpio_mute;
+	int gpio_hpsel;
+
+	struct mutex coeff_lock;
+
+	u8 system_control_1;
+	u8 system_control_2;
+	u8 soft_mute;
+	u8 volume_configuration;
+	u8 modulation_limit;
+	u8 ic_delay_ch1;
+	u8 ic_delay_ch2;
+	u8 ic_delay_ch3;
+	u8 ic_delay_ch4;
+	u8 ic_delay_ch5;
+	u8 ic_delay_ch6;
+	u8 offset;
+	u8 pwm_shutdown_group;
+	u8 start_stop_period;
+	u8 backend_error;
+	u32 input_mux;
+	u32 ch6_input_mux;
+	u32 am_tuned_frequency;
+	u32 pwm_mux;
+	u32 drc_control;
+	u32 bank_update;
+};
+
+static const DECLARE_TLV_DB_SCALE(vol_tlv, -10000, 48, 1);
+
+
+static const DECLARE_TLV_DB_SCALE(chvol_tlv, -7950, 50, 1);
+static const DECLARE_TLV_DB_SCALE(tone_tlv, -1200, 200, 0);
+
+static const char * const tas5716_drc_ac[] = {
+	"Anti-Clipping", "Dynamic Range Compression"
+};
+static const char * const tas5716_auto_gc_mode[] = {
+	"User", "AC no clipping", "AC limited clipping (10%)",
+	"DRC nighttime listening mode"
+};
+static const char * const tas5716_auto_xo_mode[] = {
+	"User", "80Hz", "100Hz", "120Hz", "140Hz", "160Hz", "180Hz",
+	"200Hz", "220Hz", "240Hz", "260Hz", "280Hz", "300Hz", "320Hz",
+	"340Hz", "360Hz"
+};
+static const char * const tas5716_binary_output[] = {
+	"FFX 3-state output - normal operation", "Binary output"
+};
+static const char * const tas5716_limiter_select[] = {
+	"Limiter Disabled", "Limiter #1", "Limiter #2"
+};
+static const char * const tas5716_limiter_attack_rate[] = {
+	"3.1584", "2.7072", "2.2560", "1.8048", "1.3536", "0.9024",
+	"0.4512", "0.2256", "0.1504", "0.1123", "0.0902", "0.0752",
+	"0.0645", "0.0564", "0.0501", "0.0451"
+};
+static const char * const tas5716_limiter_release_rate[] = {
+	"0.5116", "0.1370", "0.0744", "0.0499", "0.0360", "0.0299",
+	"0.0264", "0.0208", "0.0198", "0.0172", "0.0147", "0.0137",
+	"0.0134", "0.0117", "0.0110", "0.0104"
+};
+static const char * const tas5716_noise_shaper_type[] = {
+	"Third order", "Fourth order"
+};
+#ifdef jds
+static DECLARE_TLV_DB_RANGE(tas5716_limiter_ac_attack_tlv,
+	0, 7, TLV_DB_SCALE_ITEM(-1200, 200, 0),
+	8, 16, TLV_DB_SCALE_ITEM(300, 100, 0),
+);
+
+static DECLARE_TLV_DB_RANGE(tas5716_limiter_ac_release_tlv,
+	0, 0, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 0),
+	1, 1, TLV_DB_SCALE_ITEM(-2900, 0, 0),
+	2, 2, TLV_DB_SCALE_ITEM(-2000, 0, 0),
+	3, 8, TLV_DB_SCALE_ITEM(-1400, 200, 0),
+	8, 16, TLV_DB_SCALE_ITEM(-700, 100, 0),
+);
+
+static DECLARE_TLV_DB_RANGE(tas5716_limiter_drc_attack_tlv,
+	0, 7, TLV_DB_SCALE_ITEM(-3100, 200, 0),
+	8, 13, TLV_DB_SCALE_ITEM(-1600, 100, 0),
+	14, 16, TLV_DB_SCALE_ITEM(-1000, 300, 0),
+);
+
+static DECLARE_TLV_DB_RANGE(tas5716_limiter_drc_release_tlv,
+	0, 0, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 0),
+	1, 2, TLV_DB_SCALE_ITEM(-3800, 200, 0),
+	3, 4, TLV_DB_SCALE_ITEM(-3300, 200, 0),
+	5, 12, TLV_DB_SCALE_ITEM(-3000, 200, 0),
+	13, 16, TLV_DB_SCALE_ITEM(-1500, 300, 0),
+);
+
+static SOC_ENUM_SINGLE_DECL(tas5716_drc_ac_enum,
+			    TAS5716_CONFD, TAS5716_CONFD_DRC_SHIFT,
+			    tas5716_drc_ac);
+static SOC_ENUM_SINGLE_DECL(tas5716_noise_shaper_enum,
+			    TAS5716_CONFE, TAS5716_CONFE_NSBW_SHIFT,
+			    tas5716_noise_shaper_type);
+static SOC_ENUM_SINGLE_DECL(tas5716_auto_gc_enum,
+			    TAS5716_AUTO1, TAS5716_AUTO1_AMGC_SHIFT,
+			    tas5716_auto_gc_mode);
+static SOC_ENUM_SINGLE_DECL(tas5716_auto_xo_enum,
+			    TAS5716_AUTO2, TAS5716_AUTO2_XO_SHIFT,
+			    tas5716_auto_xo_mode);
+static SOC_ENUM_SINGLE_DECL(tas5716_binary_output_ch1_enum,
+			    TAS5716_C1CFG, TAS5716_CxCFG_BO_SHIFT,
+			    tas5716_binary_output);
+static SOC_ENUM_SINGLE_DECL(tas5716_binary_output_ch2_enum,
+			    TAS5716_C2CFG, TAS5716_CxCFG_BO_SHIFT,
+			    tas5716_binary_output);
+static SOC_ENUM_SINGLE_DECL(tas5716_binary_output_ch3_enum,
+			    TAS5716_C3CFG, TAS5716_CxCFG_BO_SHIFT,
+			    tas5716_binary_output);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter_ch1_enum,
+			    TAS5716_C1CFG, TAS5716_CxCFG_LS_SHIFT,
+			    tas5716_limiter_select);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter_ch2_enum,
+			    TAS5716_C2CFG, TAS5716_CxCFG_LS_SHIFT,
+			    tas5716_limiter_select);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter_ch3_enum,
+			    TAS5716_C3CFG, TAS5716_CxCFG_LS_SHIFT,
+			    tas5716_limiter_select);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter1_attack_rate_enum,
+			    TAS5716_L1AR, TAS5716_LxA_SHIFT,
+			    tas5716_limiter_attack_rate);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter2_attack_rate_enum,
+			    TAS5716_L2AR, TAS5716_LxA_SHIFT,
+			    tas5716_limiter_attack_rate);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter1_release_rate_enum,
+			    TAS5716_L1AR, TAS5716_LxR_SHIFT,
+			    tas5716_limiter_release_rate);
+static SOC_ENUM_SINGLE_DECL(tas5716_limiter2_release_rate_enum,
+			    TAS5716_L2AR, TAS5716_LxR_SHIFT,
+			    tas5716_limiter_release_rate);
+#endif
+
+/* Byte lengths of the variable length registers in the TAS5716 */
+static int tas5716_register_size(int reg) {
+	switch (reg) {
+	case 0 ... 0x1f:
+		return 1;
+	case 0x20 ... 0x22:
+		return 2;
+	case 0x23 ... 0x24:
+		return 20;
+	case 0x25 ... 0x26:
+		return 4;
+	case 0x27:
+		return 1;
+	case 0x28:
+		return 4;
+	case 0x29 ... 0x38:
+		return 20;
+	case 0x39:
+		return 4;
+	case 0x3a ... 0x3f:
+		return 8;
+	case 0x40 ... 0x50:
+		return 4;
+	case 0x51:
+		return 8;
+	case 0x52:
+		return 12;
+	case 0x53 ... 0xFF:
+		return 4;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int tas5716_reg_write(void *context, unsigned int reg, unsigned int value)
+{
+	struct i2c_client *client = context;
+	unsigned int i;
+	int size;
+	uint8_t buf[5];
+	int ret;
+
+	size = tas5716_register_size(reg);
+	if (size < 0)
+		return size;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+
+	for (i = size + 1; i >= 2; --i) {
+		buf[i] = value;
+		value >>= 8;
+	}
+
+	ret = i2c_master_send(client, buf, size + 2);
+	if (ret == size + 2)
+		return 0;
+	else if (ret < 0)
+		return ret;
+	else
+		return -EIO;
+}
+
+static int tas5716_reg_read(void *context, unsigned int reg, unsigned int *value)
+{
+	int ret;
+	unsigned int i;
+	int size;
+	uint8_t send_buf[2], recv_buf[3];
+	struct i2c_client *client = context;
+	struct i2c_msg msgs[2];
+
+	size = tas5716_register_size(reg);
+	if (size < 0)
+		return size;
+
+	send_buf[0] = reg >> 8;
+	send_buf[1] = reg & 0xff;
+
+	msgs[0].addr = client->addr;
+	msgs[0].len = sizeof(send_buf);
+	msgs[0].buf = send_buf;
+	msgs[0].flags = 0;
+
+	msgs[1].addr = client->addr;
+	msgs[1].len = size;
+	msgs[1].buf = recv_buf;
+	msgs[1].flags = I2C_M_RD;
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret < 0)
+		return ret;
+	else if (ret != ARRAY_SIZE(msgs))
+		return -EIO;
+
+	*value = 0;
+
+	for (i = 0; i < size; i++)
+		*value |= recv_buf[i] << (i * 8);
+
+	return 0;
+}
+
+
+/*
+ * byte array controls for setting biquad, mixer, scaling coefficients;
+ * for biquads all five coefficients need to be set in one go,
+ * mixer and pre/postscale coefs can be set individually;
+ * each coef is 24bit, the bytes are ordered in the same way
+ * as given in the TAS5716 data sheet (big endian; b1, b2, a1, a2, b0)
+ */
+
+static int tas5716_coefficient_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+	int numcoef = kcontrol->private_value >> 16;
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	uinfo->count = numcoef;
+	return 0;
+}
+
+static int tas5716_coefficient_get(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+#ifdef jds
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	int numcoef = kcontrol->private_value >> 16;
+	int index = kcontrol->private_value & 0xffff;
+	unsigned int cfud, val;
+	int i, ret = 0;
+
+	mutex_lock(&tas5716->coeff_lock);
+	/* preserve reserved bits in TAS5716_CFUD */
+	regmap_read(tas5716->regmap, TAS5716_CFUD, &cfud);
+	cfud &= 0xf0;
+	/*
+	 * chip documentation does not say if the bits are self clearing,
+	 * so do it explicitly
+	 */
+	regmap_write(tas5716->regmap, TAS5716_CFUD, cfud);
+
+	regmap_write(tas5716->regmap, TAS5716_CFADDR2, index);
+	if (numcoef == 1) {
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud | 0x04);
+	} else if (numcoef == 5) {
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud | 0x08);
+	} else {
+		ret = -EINVAL;
+		goto exit_unlock;
+	}
+
+	for (i = 0; i < 3 * numcoef; i++) {
+		regmap_read(tas5716->regmap, TAS5716_B1CF1 + i, &val);
+		ucontrol->value.bytes.data[i] = val;
+	}
+exit_unlock:
+	mutex_unlock(&tas5716->coeff_lock);
+
+	return ret;
+#endif
+	return 0;
+}
+
+static int tas5716_coefficient_put(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+#ifdef jds
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	int numcoef = kcontrol->private_value >> 16;
+	int index = kcontrol->private_value & 0xffff;
+	unsigned int cfud;
+	int i;
+
+	/* preserve reserved bits in TAS5716_CFUD */
+	regmap_read(tas5716->regmap, TAS5716_CFUD, &cfud);
+	cfud &= 0xf0;
+	/*
+	 * chip documentation does not say if the bits are self clearing,
+	 * so do it explicitly
+	 */
+	regmap_write(tas5716->regmap, TAS5716_CFUD, cfud);
+
+	regmap_write(tas5716->regmap, TAS5716_CFADDR2, index);
+	for (i = 0; i < 3 * numcoef; i++)
+		regmap_write(tas5716->regmap, TAS5716_B1CF1 + i,
+			     ucontrol->value.bytes.data[i]);
+	if (numcoef == 1)
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud | 0x01);
+	else if (numcoef == 5)
+		regmap_write(tas5716->regmap, TAS5716_CFUD, cfud | 0x02);
+	else
+		return -EINVAL;
+#endif
+	return 0;
+}
+
+static int tas5716_cache_sync(struct snd_soc_codec *codec)
+{
+#ifdef jds
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	unsigned int mute;
+	int rc;
+
+	/* mute during register sync */
+	regmap_read(tas5716->regmap, TAS5716_CFUD, &mute);
+	regmap_write(tas5716->regmap, TAS5716_MMUTE, mute | TAS5716_MMUTE_MMUTE);
+	rc = regcache_sync(tas5716->regmap);
+	regmap_write(tas5716->regmap, TAS5716_MMUTE, mute);
+
+	return rc;
+#endif
+	return 0;
+}
+
+#define COEFS_8(xname, index) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = tas5716_coefficient_info, \
+	.get = tas5716_coefficient_get,\
+	.put = tas5716_coefficient_put, \
+	.private_value = index | (8 << 16) }
+
+#define COEFS_12(xname, index) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = tas5716_coefficient_info, \
+	.get = tas5716_coefficient_get,\
+	.put = tas5716_coefficient_put, \
+	.private_value = index | (12 << 16) }
+
+#define COEFS_20(xname, index) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = tas5716_coefficient_info, \
+	.get = tas5716_coefficient_get,\
+	.put = tas5716_coefficient_put, \
+	.private_value = index | (20 << 16) }
+
+static const struct snd_kcontrol_new tas5716_snd_controls[] = {
+SOC_SINGLE_TLV("Master Volume", TAS5716_MASTER_VOLUME, 0, 0xff, 1, vol_tlv),
+SOC_SINGLE_TLV("Channel 1 Volume", TAS5716_CH1_VOLUME, 0, 0xff, 1, vol_tlv),
+SOC_SINGLE_TLV("Channel 2 Volume", TAS5716_CH2_VOLUME, 0, 0xff, 1, vol_tlv),
+SOC_SINGLE_TLV("Channel 3 Volume", TAS5716_CH3_VOLUME, 0, 0xff, 1, vol_tlv),
+SOC_SINGLE_TLV("Channel 4 Volume", TAS5716_CH4_VOLUME, 0, 0xff, 1, vol_tlv),
+SOC_SINGLE_TLV("HP Volume", TAS5716_HP_VOLUME, 0, 0xff, 1, vol_tlv),
+SOC_SINGLE_TLV("Channel 5 Volume", TAS5716_CH6_VOLUME, 0, 0xff, 1, vol_tlv),
+
+
+
+#ifdef JDS
+SOC_SINGLE_TLV("Master Volume", TAS5716_MVOL, 0, 0xff, 1, mvol_tlv),
+/* VOL */
+SOC_SINGLE_TLV("Ch1 Volume", TAS5716_C1VOL, 0, 0xff, 1, chvol_tlv),
+SOC_SINGLE_TLV("Ch2 Volume", TAS5716_C2VOL, 0, 0xff, 1, chvol_tlv),
+SOC_SINGLE_TLV("Ch3 Volume", TAS5716_C3VOL, 0, 0xff, 1, chvol_tlv),
+/* CONFD */
+SOC_SINGLE("High Pass Filter Bypass Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_HPB_SHIFT, 1, 1),
+SOC_SINGLE("De-emphasis Filter Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_DEMP_SHIFT, 1, 0),
+SOC_SINGLE("DSP Bypass Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_DSPB_SHIFT, 1, 0),
+SOC_SINGLE("Post-scale Link Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_PSL_SHIFT, 1, 0),
+SOC_SINGLE("Biquad Coefficient Link Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_BQL_SHIFT, 1, 0),
+SOC_ENUM("Compressor/Limiter Switch", tas5716_drc_ac_enum),
+SOC_ENUM("Noise Shaper Bandwidth", tas5716_noise_shaper_enum),
+SOC_SINGLE("Zero-detect Mute Enable Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_ZDE_SHIFT, 1, 0),
+SOC_SINGLE("Submix Mode Switch",
+	   TAS5716_CONFD, TAS5716_CONFD_SME_SHIFT, 1, 0),
+/* CONFE */
+SOC_SINGLE("Zero Cross Switch", TAS5716_CONFE, TAS5716_CONFE_ZCE_SHIFT, 1, 0),
+SOC_SINGLE("Soft Ramp Switch", TAS5716_CONFE, TAS5716_CONFE_SVE_SHIFT, 1, 0),
+/* MUTE */
+SOC_SINGLE("Master Switch", TAS5716_MMUTE, TAS5716_MMUTE_MMUTE_SHIFT, 1, 1),
+SOC_SINGLE("Ch1 Switch", TAS5716_MMUTE, TAS5716_MMUTE_C1M_SHIFT, 1, 1),
+SOC_SINGLE("Ch2 Switch", TAS5716_MMUTE, TAS5716_MMUTE_C2M_SHIFT, 1, 1),
+SOC_SINGLE("Ch3 Switch", TAS5716_MMUTE, TAS5716_MMUTE_C3M_SHIFT, 1, 1),
+/* AUTOx */
+SOC_ENUM("Automode GC", tas5716_auto_gc_enum),
+SOC_ENUM("Automode XO", tas5716_auto_xo_enum),
+/* CxCFG */
+SOC_SINGLE("Ch1 Tone Control Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_TCB_SHIFT, 1, 0),
+SOC_SINGLE("Ch2 Tone Control Bypass Switch",
+	   TAS5716_C2CFG, TAS5716_CxCFG_TCB_SHIFT, 1, 0),
+SOC_SINGLE("Ch1 EQ Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_EQBP_SHIFT, 1, 0),
+SOC_SINGLE("Ch2 EQ Bypass Switch",
+	   TAS5716_C2CFG, TAS5716_CxCFG_EQBP_SHIFT, 1, 0),
+SOC_SINGLE("Ch1 Master Volume Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_VBP_SHIFT, 1, 0),
+SOC_SINGLE("Ch2 Master Volume Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_VBP_SHIFT, 1, 0),
+SOC_SINGLE("Ch3 Master Volume Bypass Switch",
+	   TAS5716_C1CFG, TAS5716_CxCFG_VBP_SHIFT, 1, 0),
+SOC_ENUM("Ch1 Binary Output Select", tas5716_binary_output_ch1_enum),
+SOC_ENUM("Ch2 Binary Output Select", tas5716_binary_output_ch2_enum),
+SOC_ENUM("Ch3 Binary Output Select", tas5716_binary_output_ch3_enum),
+SOC_ENUM("Ch1 Limiter Select", tas5716_limiter_ch1_enum),
+SOC_ENUM("Ch2 Limiter Select", tas5716_limiter_ch2_enum),
+SOC_ENUM("Ch3 Limiter Select", tas5716_limiter_ch3_enum),
+/* TONE */
+SOC_SINGLE_RANGE_TLV("Bass Tone Control Volume",
+		     TAS5716_TONE, TAS5716_TONE_BTC_SHIFT, 1, 13, 0, tone_tlv),
+SOC_SINGLE_RANGE_TLV("Treble Tone Control Volume",
+		     TAS5716_TONE, TAS5716_TONE_TTC_SHIFT, 1, 13, 0, tone_tlv),
+SOC_ENUM("Limiter1 Attack Rate (dB/ms)", tas5716_limiter1_attack_rate_enum),
+SOC_ENUM("Limiter2 Attack Rate (dB/ms)", tas5716_limiter2_attack_rate_enum),
+SOC_ENUM("Limiter1 Release Rate (dB/ms)", tas5716_limiter1_release_rate_enum),
+SOC_ENUM("Limiter2 Release Rate (dB/ms)", tas5716_limiter2_release_rate_enum),
+
+/*
+ * depending on mode, the attack/release thresholds have
+ * two different enum definitions; provide both
+ */
+SOC_SINGLE_TLV("Limiter1 Attack Threshold (AC Mode)",
+	       TAS5716_L1ATRT, TAS5716_LxA_SHIFT,
+	       16, 0, tas5716_limiter_ac_attack_tlv),
+SOC_SINGLE_TLV("Limiter2 Attack Threshold (AC Mode)",
+	       TAS5716_L2ATRT, TAS5716_LxA_SHIFT,
+	       16, 0, tas5716_limiter_ac_attack_tlv),
+SOC_SINGLE_TLV("Limiter1 Release Threshold (AC Mode)",
+	       TAS5716_L1ATRT, TAS5716_LxR_SHIFT,
+	       16, 0, tas5716_limiter_ac_release_tlv),
+SOC_SINGLE_TLV("Limiter2 Release Threshold (AC Mode)",
+	       TAS5716_L2ATRT, TAS5716_LxR_SHIFT,
+	       16, 0, tas5716_limiter_ac_release_tlv),
+SOC_SINGLE_TLV("Limiter1 Attack Threshold (DRC Mode)",
+	       TAS5716_L1ATRT, TAS5716_LxA_SHIFT,
+	       16, 0, tas5716_limiter_drc_attack_tlv),
+SOC_SINGLE_TLV("Limiter2 Attack Threshold (DRC Mode)",
+	       TAS5716_L2ATRT, TAS5716_LxA_SHIFT,
+	       16, 0, tas5716_limiter_drc_attack_tlv),
+SOC_SINGLE_TLV("Limiter1 Release Threshold (DRC Mode)",
+	       TAS5716_L1ATRT, TAS5716_LxR_SHIFT,
+	       16, 0, tas5716_limiter_drc_release_tlv),
+SOC_SINGLE_TLV("Limiter2 Release Threshold (DRC Mode)",
+	       TAS5716_L2ATRT, TAS5716_LxR_SHIFT,
+	       16, 0, tas5716_limiter_drc_release_tlv),
+#endif
+
+COEFS_20("ch6_bq[2] (loudness BQ)", 0x23),
+COEFS_20("ch6_bq[3] (post volume BQ)", 0x24),
+COEFS_20("ch1_bq[0]", 0x29),
+COEFS_20("ch1_bq[1]", 0x2a),
+COEFS_20("ch1_bq[2]", 0x2b),
+COEFS_20("ch1_bq[3]", 0x2c),
+COEFS_20("ch1_bq[4]", 0x2d),
+COEFS_20("ch1_bq[5]", 0x2e),
+COEFS_20("ch1_bq[6]", 0x2f),
+COEFS_20("ch2_bq[0]", 0x30),
+COEFS_20("ch2_bq[1]", 0x31),
+COEFS_20("ch2_bq[2]", 0x32),
+COEFS_20("ch2_bq[3]", 0x33),
+COEFS_20("ch2_bq[4]", 0x34),
+COEFS_20("ch2_bq[5]", 0x35),
+COEFS_20("ch2_bq[6]", 0x36),
+COEFS_20("ch6_bq[0]", 0x37),
+COEFS_20("ch6_bq[1]", 0x38),
+
+COEFS_8("DRC1 ae", 0x3a),
+COEFS_8("DRC1 aa", 0x3b),
+COEFS_8("DRC1 ad", 0x3c),
+COEFS_8("DRC1 ae", 0x3d),
+COEFS_8("DRC2 aa", 0x3e),
+COEFS_8("DRC2 ad", 0x3f),
+
+COEFS_8("V1OM", 0x51),
+COEFS_12("V2OM", 0x52),
+};
+
+static const struct snd_soc_dapm_widget tas5716_dapm_widgets[] = {
+SND_SOC_DAPM_DAC("DAC", NULL, SND_SOC_NOPM, 0, 0),
+SND_SOC_DAPM_OUTPUT("LEFT"),
+SND_SOC_DAPM_OUTPUT("RIGHT"),
+SND_SOC_DAPM_OUTPUT("SUB"),
+};
+
+static const struct snd_soc_dapm_route tas5716_dapm_routes[] = {
+	{ "LEFT", NULL, "DAC" },
+	{ "RIGHT", NULL, "DAC" },
+	{ "SUB", NULL, "DAC" },
+	{ "DAC", NULL, "Playback" },
+};
+
+/* MCLK interpolation ratio per fs */
+static struct {
+	int fs;
+	int ir;
+} interpolation_ratios[] = {
+	{ 32000, 0 },
+	{ 44100, 0 },
+	{ 48000, 0 },
+	{ 88200, 1 },
+	{ 96000, 1 },
+	{ 176400, 2 },
+	{ 192000, 2 },
+};
+
+/* MCLK to fs clock ratios */
+static int mcs_ratio_table[3][6] = {
+	{ 768, 512, 384, 256, 128, 576 },
+	{ 384, 256, 192, 128,  64,   0 },
+	{ 192, 128,  96,  64,  32,   0 },
+};
+
+/**
+ * tas5716_set_dai_sysclk - configure MCLK
+ * @codec_dai: the codec DAI
+ * @clk_id: the clock ID (ignored)
+ * @freq: the MCLK input frequency
+ * @dir: the clock direction (ignored)
+ *
+ * The value of MCLK is used to determine which sample rates are supported
+ * by the TAS5716, based on the mcs_ratio_table.
+ *
+ * This function must be called by the machine driver's 'startup' function,
+ * otherwise the list of supported sample rates will not be available in
+ * time for ALSA.
+ */
+static int tas5716_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				 int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(codec->dev, "mclk=%u\n", freq);
+	tas5716->mclk = freq;
+
+	return 0;
+}
+
+/**
+ * tas5716_set_dai_fmt - configure the codec for the selected audio format
+ * @codec_dai: the codec DAI
+ * @fmt: a SND_SOC_DAIFMT_x value indicating the data format
+ *
+ * This function takes a bitmask of SND_SOC_DAIFMT_x bits and programs the
+ * codec accordingly.
+ */
+static int tas5716_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			      unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+//	unsigned int confb = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+	case SND_SOC_DAIFMT_RIGHT_J:
+	case SND_SOC_DAIFMT_LEFT_J:
+		tas5716->format = fmt & SND_SOC_DAIFMT_FORMAT_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+//		confb |= TAS5716_CONFB_C2IM;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+//		confb |= TAS5716_CONFB_C1IM;
+		break;
+	default:
+		return -EINVAL;
+	}
+#ifdef jds
+	return regmap_update_bits(tas5716->regmap, TAS5716_CONFB,
+				  TAS5716_CONFB_C1IM | TAS5716_CONFB_C2IM, confb);
+#endif
+	return 0;
+}
+
+/**
+ * tas5716_hw_params - program the TAS5716 with the given hardware parameters.
+ * @substream: the audio stream
+ * @params: the hardware parameters to set
+ * @dai: the SOC DAI (ignored)
+ *
+ * This function programs the hardware with the values provided.
+ * Specifically, the sample rate and the data format.
+ */
+static int tas5716_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	int i, mcs = -EINVAL, ir = -EINVAL;
+//	unsigned int confa;
+	unsigned int confb;
+	unsigned int rate, ratio;
+//	int ret;
+
+	if (!tas5716->mclk) {
+		dev_err(codec->dev,
+			"tas5716->mclk is unset. Unable to determine ratio\n");
+		return -EIO;
+	}
+
+	rate = params_rate(params);
+	ratio = tas5716->mclk / rate;
+	dev_dbg(codec->dev, "rate: %u, ratio: %u\n", rate, ratio);
+
+	for (i = 0; i < ARRAY_SIZE(interpolation_ratios); i++) {
+		if (interpolation_ratios[i].fs == rate) {
+			ir = interpolation_ratios[i].ir;
+			break;
+		}
+	}
+
+	if (ir < 0) {
+		dev_err(codec->dev, "Unsupported samplerate: %u\n", rate);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < 6; i++) {
+		if (mcs_ratio_table[ir][i] == ratio) {
+			mcs = i;
+			break;
+		}
+	}
+
+	if (mcs < 0) {
+		dev_err(codec->dev, "Unresolvable ratio: %u\n", ratio);
+		return -EINVAL;
+	}
+
+//	confa = (ir << TAS5716_CONFA_IR_SHIFT) |
+//		(mcs << TAS5716_CONFA_MCS_SHIFT);
+	confb = 0;
+
+	switch (params_width(params)) {
+	case 24:
+		dev_dbg(codec->dev, "24bit\n");
+		/* fall through */
+	case 32:
+		dev_dbg(codec->dev, "24bit or 32bit\n");
+		switch (tas5716->format) {
+		case SND_SOC_DAIFMT_I2S:
+			confb |= 0x0;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			confb |= 0x1;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			confb |= 0x2;
+			break;
+		}
+
+		break;
+	case 20:
+		dev_dbg(codec->dev, "20bit\n");
+		switch (tas5716->format) {
+		case SND_SOC_DAIFMT_I2S:
+			confb |= 0x4;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			confb |= 0x5;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			confb |= 0x6;
+			break;
+		}
+
+		break;
+	case 18:
+		dev_dbg(codec->dev, "18bit\n");
+		switch (tas5716->format) {
+		case SND_SOC_DAIFMT_I2S:
+			confb |= 0x8;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			confb |= 0x9;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			confb |= 0xa;
+			break;
+		}
+
+		break;
+	case 16:
+		dev_dbg(codec->dev, "16bit\n");
+		switch (tas5716->format) {
+		case SND_SOC_DAIFMT_I2S:
+			confb |= 0x0;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			confb |= 0xd;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			confb |= 0xe;
+			break;
+		}
+
+		break;
+	default:
+		return -EINVAL;
+	}
+#ifdef jds
+	ret = regmap_update_bits(tas5716->regmap, TAS5716_CONFA,
+				 TAS5716_CONFA_MCS_MASK | TAS5716_CONFA_IR_MASK,
+				 confa);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_update_bits(tas5716->regmap, TAS5716_CONFB,
+				 TAS5716_CONFB_SAI_MASK | TAS5716_CONFB_SAIFB,
+				 confb);
+	if (ret < 0)
+		return ret;
+#endif
+	return 0;
+}
+
+static int tas5716_startup_sequence(struct tas5716_priv *tas5716)
+{
+	if (tas5716->gpio_power_down)
+		gpio_set_value(tas5716->gpio_power_down, 1);
+
+	if (tas5716->gpio_nreset) {
+		gpio_set_value(tas5716->gpio_nreset, 0);
+		mdelay(1);
+		gpio_set_value(tas5716->gpio_nreset, 1);
+		mdelay(1);
+	}
+
+	return 0;
+}
+
+/**
+ * tas5716_set_bias_level - DAPM callback
+ * @codec: the codec device
+ * @level: DAPM power level
+ *
+ * This is called by ALSA to put the codec into low power mode
+ * or to wake it up.  If the codec is powered off completely
+ * all registers must be restored after power on.
+ */
+static int tas5716_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	dev_dbg(codec->dev, "level = %d\n", level);
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+		/* Full power on */
+#ifdef jds
+		regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+				   TAS5716_CONFF_PWDN | TAS5716_CONFF_EAPD,
+				   TAS5716_CONFF_PWDN | TAS5716_CONFF_EAPD);
+#endif
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
+			ret = regulator_bulk_enable(
+				ARRAY_SIZE(tas5716->supplies),
+				tas5716->supplies);
+			if (ret < 0) {
+				dev_err(codec->dev,
+					"Failed to enable supplies: %d\n",
+					ret);
+				return ret;
+			}
+			tas5716_startup_sequence(tas5716);
+			tas5716_cache_sync(codec);
+		}
+
+		/* Power down */
+#ifdef JDS
+		regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+				   TAS5716_CONFF_PWDN | TAS5716_CONFF_EAPD,
+				   0);
+#endif
+
+		break;
+
+	case SND_SOC_BIAS_OFF:
+		/* The chip runs through the power down sequence for us */
+#ifdef JDS
+		regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+				   TAS5716_CONFF_PWDN | TAS5716_CONFF_EAPD, 0);
+#endif
+
+		/* power down: low */
+		if (tas5716->gpio_power_down)
+			gpio_set_value(tas5716->gpio_power_down, 0);
+
+		if (tas5716->gpio_nreset)
+			gpio_set_value(tas5716->gpio_nreset, 0);
+
+		regulator_bulk_disable(ARRAY_SIZE(tas5716->supplies),
+				       tas5716->supplies);
+		break;
+	}
+	codec->dapm.bias_level = level;
+	return 0;
+}
+
+static const struct snd_soc_dai_ops tas5716_dai_ops = {
+	.hw_params	= tas5716_hw_params,
+	.set_sysclk	= tas5716_set_dai_sysclk,
+	.set_fmt	= tas5716_set_dai_fmt,
+};
+
+static struct snd_soc_dai_driver tas5716_dai = {
+	.name = "tas5716-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = TAS5716_RATES,
+		.formats = TAS5716_FORMATS,
+	},
+	.ops = &tas5716_dai_ops,
+};
+
+#ifdef CONFIG_PM
+static int tas5716_suspend(struct snd_soc_codec *codec)
+{
+	tas5716_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int tas5716_resume(struct snd_soc_codec *codec)
+{
+	tas5716_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	return 0;
+}
+#else
+#define tas5716_suspend NULL
+#define tas5716_resume NULL
+#endif
+
+static int tas5716_probe(struct snd_soc_codec *codec)
+{
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+	int ret = 0;
+//	int thermal = 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(tas5716->supplies),
+				    tas5716->supplies);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to enable supplies: %d\n", ret);
+		return ret;
+	}
+
+	ret = tas5716_startup_sequence(tas5716);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to startup device\n");
+		return ret;
+	}
+#ifdef jds
+	/* CONFA */
+	if (!tas5716->thermal_warning_recovery)
+		thermal |= TAS5716_CONFA_TWAB;
+	if (!tas5716->thermal_warning_adjustment)
+		thermal |= TAS5716_CONFA_TWRB;
+	if (!tas5716->fault_detect_recovery)
+		thermal |= TAS5716_CONFA_FDRB;
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFA,
+			   TAS5716_CONFA_TWAB | TAS5716_CONFA_TWRB |
+			   TAS5716_CONFA_FDRB,
+			   thermal);
+
+	/* CONFC */
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFC,
+			   TAS5716_CONFC_OM_MASK,
+			   tas5716->ffx_power_output_mode
+				<< TAS5716_CONFC_OM_SHIFT);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFC,
+			   TAS5716_CONFC_CSZ_MASK,
+			   tas5716->drop_compensation_ns
+				<< TAS5716_CONFC_CSZ_SHIFT);
+	regmap_update_bits(tas5716->regmap,
+			   TAS5716_CONFC,
+			   TAS5716_CONFC_OCRB,
+			   tas5716->oc_warning_adjustment ?
+				TAS5716_CONFC_OCRB : 0);
+
+	/* CONFE */
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_MPCV,
+			   tas5716->max_power_use_mpcc ?
+				TAS5716_CONFE_MPCV : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_MPC,
+			   tas5716->max_power_correction ?
+				TAS5716_CONFE_MPC : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_AME,
+			   tas5716->am_reduction_mode ?
+				TAS5716_CONFE_AME : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_PWMS,
+			   tas5716->odd_pwm_speed_mode ?
+				TAS5716_CONFE_PWMS : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFE,
+			   TAS5716_CONFE_DCCV,
+			   tas5716->distortion_compensation ?
+				TAS5716_CONFE_DCCV : 0);
+	/*  CONFF */
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+			   TAS5716_CONFF_IDE,
+			   tas5716->invalid_input_detect_mute ?
+				TAS5716_CONFF_IDE : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_CONFF,
+			   TAS5716_CONFF_OCFG_MASK,
+			   tas5716->output_conf
+				<< TAS5716_CONFF_OCFG_SHIFT);
+
+	/* channel to output mapping */
+	regmap_update_bits(tas5716->regmap, TAS5716_C1CFG,
+			   TAS5716_CxCFG_OM_MASK,
+			   tas5716->ch1_output_mapping
+				<< TAS5716_CxCFG_OM_SHIFT);
+	regmap_update_bits(tas5716->regmap, TAS5716_C2CFG,
+			   TAS5716_CxCFG_OM_MASK,
+			   tas5716->ch2_output_mapping
+				<< TAS5716_CxCFG_OM_SHIFT);
+	regmap_update_bits(tas5716->regmap, TAS5716_C3CFG,
+			   TAS5716_CxCFG_OM_MASK,
+			   tas5716->ch3_output_mapping
+				<< TAS5716_CxCFG_OM_SHIFT);
+
+	/* miscellaneous registers */
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC1,
+			   TAS5716_MISC1_CPWMEN,
+			   tas5716->activate_mute_output ?
+				TAS5716_MISC1_CPWMEN : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC1,
+			   TAS5716_MISC1_BRIDGOFF,
+			   tas5716->bridge_immediate_off ?
+				TAS5716_MISC1_BRIDGOFF : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC1,
+			   TAS5716_MISC1_NSHHPEN,
+			   tas5716->noise_shape_dc_cut ?
+				TAS5716_MISC1_NSHHPEN : 0);
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC1,
+			   TAS5716_MISC1_RPDNEN,
+			   tas5716->powerdown_master_vol ?
+				TAS5716_MISC1_RPDNEN: 0);
+
+	regmap_update_bits(tas5716->regmap, TAS5716_MISC2,
+			   TAS5716_MISC2_PNDLSL_MASK,
+			   tas5716->powerdown_delay_divider
+				<< TAS5716_MISC2_PNDLSL_SHIFT);
+#endif
+	tas5716_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	/* Bias level configuration will have done an extra enable */
+	regulator_bulk_disable(ARRAY_SIZE(tas5716->supplies), tas5716->supplies);
+
+	return 0;
+}
+
+static int tas5716_remove(struct snd_soc_codec *codec)
+{
+	struct tas5716_priv *tas5716 = snd_soc_codec_get_drvdata(codec);
+
+	tas5716_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	regulator_bulk_disable(ARRAY_SIZE(tas5716->supplies), tas5716->supplies);
+
+	return 0;
+}
+
+static const struct snd_soc_codec_driver tas5716_codec = {
+	.probe =		tas5716_probe,
+	.remove =		tas5716_remove,
+	.suspend =		tas5716_suspend,
+	.resume =		tas5716_resume,
+	.set_bias_level =	tas5716_set_bias_level,
+	.controls =		tas5716_snd_controls,
+	.num_controls =		ARRAY_SIZE(tas5716_snd_controls),
+	.dapm_widgets =		tas5716_dapm_widgets,
+	.num_dapm_widgets =	ARRAY_SIZE(tas5716_dapm_widgets),
+	.dapm_routes =		tas5716_dapm_routes,
+	.num_dapm_routes =	ARRAY_SIZE(tas5716_dapm_routes),
+};
+
+static const struct regmap_config tas5716_regmap = {
+	.reg_bits =		8,
+	.val_bits =		32,
+	.max_register =		TAS5716_V2OM,
+	.reg_defaults =		tas5716_regs,
+	.num_reg_defaults =	ARRAY_SIZE(tas5716_regs),
+	.cache_type =		REGCACHE_RBTREE,
+	.volatile_table =	&tas5716_volatile_regs,
+	.wr_table =		&tas5716_write_regs,
+	.rd_table =		&tas5716_read_regs,
+	.reg_write =		tas5716_reg_write,
+	.reg_read =		tas5716_reg_read,
+};
+
+static const struct of_device_id tas5716_dt_ids[] = {
+	{ .compatible = "ti,tas5716", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, tas5716_dt_ids);
+
+#ifdef jds
+static const char * const tas5716_ffx_modes[] = {
+	[TAS5716_FFX_PM_DROP_COMP]		= "drop-compensation",
+	[TAS5716_FFX_PM_TAPERED_COMP]		= "tapered-compensation",
+	[TAS5716_FFX_PM_FULL_POWER]		= "full-power-mode",
+	[TAS5716_FFX_PM_VARIABLE_DROP_COMP]	= "variable-drop-compensation",
+};
+#endif
+
+static int tas5716_probe_dt(struct device *dev, struct tas5716_priv *tas5716)
+{
+	struct device_node *np = dev->of_node;
+
+	of_property_read_u8(np, "ti,system-control-1", &tas5716->system_control_1);
+	of_property_read_u8(np, "ti,system-control-2", &tas5716->system_control_2);
+	of_property_read_u8(np, "ti,soft-mute", &tas5716->soft_mute);
+	of_property_read_u8(np, "ti,volume-configuration", &tas5716->volume_configuration);
+	of_property_read_u8(np, "ti,modulation-limit", &tas5716->modulation_limit);
+	of_property_read_u8(np, "ti,ic-delay-ch1", &tas5716->ic_delay_ch1);
+	of_property_read_u8(np, "ti,ic-delay-ch2", &tas5716->ic_delay_ch2);
+	of_property_read_u8(np, "ti,ic-delay-ch3", &tas5716->ic_delay_ch3);
+	of_property_read_u8(np, "ti,ic-delay-ch4", &tas5716->ic_delay_ch4);
+	of_property_read_u8(np, "ti,ic-delay-ch5", &tas5716->ic_delay_ch5);
+	of_property_read_u8(np, "ti,ic-delay-ch6", &tas5716->ic_delay_ch6);
+	of_property_read_u8(np, "ti,offset", &tas5716->offset);
+	of_property_read_u8(np, "ti,pwm-shutdown-group", &tas5716->pwm_shutdown_group);
+	of_property_read_u8(np, "ti,start-stop-period", &tas5716->start_stop_period);
+	of_property_read_u8(np, "ti,backend-error", &tas5716->backend_error);
+	of_property_read_u32(np, "ti,input-mux", &tas5716->input_mux);
+	of_property_read_u32(np, "ti,ch6-input-mux", &tas5716->ch6_input_mux);
+	of_property_read_u32(np, "ti,am-tuned-frequency", &tas5716->am_tuned_frequency);
+	of_property_read_u32(np, "ti,pwm-mux", &tas5716->pwm_mux);
+	of_property_read_u32(np, "ti,drc-control", &tas5716->drc_control);
+	of_property_read_u32(np, "ti,bank-update", &tas5716->bank_update);
+
+	return 0;
+}
+
+
+static int tas5716_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	enum of_gpio_flags flags;
+	struct device *dev = &i2c->dev;
+	struct device_node *np = dev->of_node;
+	struct tas5716_priv *tas5716;
+	int ret, i;
+
+	printk("JDS - tas5716_i2c_probe\n");
+	tas5716 = devm_kzalloc(dev, sizeof(struct tas5716_priv), GFP_KERNEL);
+	if (!tas5716)
+		return -ENOMEM;
+
+	mutex_init(&tas5716->coeff_lock);
+
+	ret = tas5716_probe_dt(dev, tas5716);
+	if (ret < 0)
+		return ret;
+
+	printk("JDS - tas5716_i2c_probe a\n");
+
+	/* GPIOs */
+	tas5716->gpio_nreset = of_get_named_gpio_flags(np, "reset", 0, &flags);
+	if (gpio_is_valid(tas5716->gpio_nreset)) {
+		ret = devm_gpio_request_one(dev, tas5716->gpio_nreset,
+			     flags & OF_GPIO_ACTIVE_LOW ?
+				GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH,
+			     "tas5716:reset");
+		if (ret < 0)
+			return ret;
+	}
+
+	tas5716->gpio_power_down = of_get_named_gpio_flags(np, "power-down", 0, &flags);
+	if (gpio_is_valid(tas5716->gpio_power_down)) {
+		ret = devm_gpio_request_one(dev, tas5716->gpio_power_down,
+			     flags & OF_GPIO_ACTIVE_LOW ?
+				GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH,
+			     "tas5716:power-down");
+		if (ret < 0)
+			return ret;
+	}
+
+	tas5716->gpio_mute = of_get_named_gpio_flags(np, "mute", 0, &flags);
+	if (gpio_is_valid(tas5716->gpio_mute)) {
+		ret = devm_gpio_request_one(dev, tas5716->gpio_mute,
+			     flags & OF_GPIO_ACTIVE_LOW ?
+				GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH,
+			     "tas5716:mute");
+		if (ret < 0)
+			return ret;
+	}
+
+	tas5716->gpio_hpsel = of_get_named_gpio_flags(np, "ti,hpsel", 0, &flags);
+	if (gpio_is_valid(tas5716->gpio_hpsel)) {
+		ret = devm_gpio_request_one(dev, tas5716->gpio_hpsel,
+			     flags & OF_GPIO_ACTIVE_LOW ?
+				GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH,
+			     "tas5716:ti,hpsel");
+		if (ret < 0)
+			return ret;
+	}
+
+	/* regulators */
+	for (i = 0; i < ARRAY_SIZE(tas5716->supplies); i++)
+		tas5716->supplies[i].supply = tas5716_supply_names[i];
+
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(tas5716->supplies),
+				      tas5716->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to request supplies: %d\n", ret);
+		return ret;
+	}
+
+	printk("JDS - tas5716_i2c_probe c\n");
+	tas5716->regmap = devm_regmap_init_i2c(i2c, &tas5716_regmap);
+	if (IS_ERR(tas5716->regmap)) {
+		ret = PTR_ERR(tas5716->regmap);
+		dev_err(dev, "Failed to init regmap: %d\n", ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(i2c, tas5716);
+
+	printk("JDS - tas5716_i2c_probe d\n");
+	ret = snd_soc_register_codec(dev, &tas5716_codec, &tas5716_dai, 1);
+	if (ret < 0)
+		dev_err(dev, "Failed to register codec (%d)\n", ret);
+
+	printk("JDS - tas5716_i2c_probe e\n");
+	return ret;
+}
+
+static int tas5716_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+	return 0;
+}
+
+static const struct i2c_device_id tas5716_i2c_id[] = {
+	{ "tas5716", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, tas5716_i2c_id);
+
+static struct i2c_driver tas5716_i2c_driver = {
+	.driver = {
+		.name = "tas5716",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(tas5716_dt_ids),
+	},
+	.probe =    tas5716_i2c_probe,
+	.remove =   tas5716_i2c_remove,
+	.id_table = tas5716_i2c_id,
+};
+
+module_i2c_driver(tas5716_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC TAS5716 driver");
+MODULE_AUTHOR("Jon Smirl <jonsmirl@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/tas5716.h b/sound/soc/codecs/tas5716.h
new file mode 100644
index 0000000..7588860
--- /dev/null
+++ b/sound/soc/codecs/tas5716.h
@@ -0,0 +1,398 @@
+/*
+ * Codec driver for TI TAS5716 2.1-channel high-efficiency digital audio system
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifndef _ASOC_TAS_5716_H
+#define _ASOC_TAS_5716_H
+
+/* TAS5716 register addresses */
+
+#define TAS5716_CLOCK_CTRL	0x00 	// Clock control register
+#define TAS5716_DEVICE_ID	0x01 	// Device ID register
+#define TAS5716_ERROR		0x02	// Error status register
+#define TAS5716_SYS_CTRL1	0x03	// System control 1 register
+#define TAS5716_FORMAT		0x04 	// Serial-data interface register
+#define TAS5716_SYS_CTRL2	0x05	// System-control 2 register
+#define TAS5716_SOFT_MUTE	0x06	// Soft-mute register
+#define TAS5716_MASTER_VOLUME	0x07	// Master volume
+#define TAS5716_CH1_VOLUME	0x08	// Channel 1 volume
+#define TAS5716_CH2_VOLUME	0x08	// Channel 2 volume
+#define TAS5716_CH3_VOLUME	0x08	// Channel 3 volume
+#define TAS5716_CH4_VOLUME	0x08	// Channel 4 volume
+#define TAS5716_HP_VOLUME	0x0C	// HP volume
+#define TAS5716_CH6_VOLUME	0x0D	// Channel-6 volume
+#define TAS5716_VOLUME_CONFIG	0x0E 	// Volume configuration
+
+#define TAS5716_MOD_LIMIT0	0x10	// Modulation-limit register
+#define TAS5716_IC_DELAY_CH1	0x11 	// IC delay channel 1
+#define TAS5716_IC_DELAY_CH2	0x12 	// IC delay channel 2
+#define TAS5716_IC_DELAY_CH3	0x13 	// IC delay channel 3
+#define TAS5716_IC_DELAY_CH4	0x14 	// IC delay channel 4
+#define TAS5716_IC_DELAY_CH5	0x15 	// IC delay channel 5
+#define TAS5716_IC_DELAY_CH6	0x16 	// IC delay channel 6
+#define TAS5716_OFFSET		0x17	// Offset register
+
+#define TAS5716_PWM_SHUTDOWN	0x19	// PWM shutdown group
+#define TAS5716_START_STOP	0x1A	// Start/stop period
+#define TAS5716_OSC_TRIM	0x1B	// Oscillator trim
+#define TAS5716_BKND_ERR	0x1C	// BKND_ERR
+
+#define TAS5716_INPUT_MUX	0x20	// Input MUX register
+#define TAS5716_CH6_INPUT_MUX2	0x21	// Ch-6 input mux-2 register
+#define TAS5716_AM_TUNED_FREQ	0x22	// AM tuned frequency
+
+#define TAS5716_CH6_BQ_2	0x23	// ch6_bq[2] (loudness BQ)
+#define TAS5716_CH6_BQ_3	0x24	// ch6_bq[3] (post volume)
+#define TAS5716_PWM_MUX		0x25	// PWM MUX register
+#define TAS5716_1_G		0x26	// 1/G register
+#define TAS5716_SCALE		0x28	// Scale register
+#define TAS5716_CH1_BQ_0	0x29	// ch1_bq[0]
+#define TAS5716_CH1_BQ_1	0x2A	// ch1_bq[1]
+#define TAS5716_CH1_BQ_2	0x2B	// ch1_bq[2]
+#define TAS5716_CH1_BQ_3	0x2C	// ch1_bq[3]
+#define TAS5716_CH1_BQ_4	0x2D	// ch1_bq[4]
+#define TAS5716_CH1_BQ_5	0x2E	// ch1_bq[5]
+#define TAS5716_CH1_BQ_6	0x2F	// ch1_bq[6]
+#define TAS5716_CH2_BQ_0	0x30	// ch2_bq[0]
+#define TAS5716_CH2_BQ_1	0x31	// ch2_bq[1]
+#define TAS5716_CH2_BQ_2	0x32	// ch2_bq[2]
+#define TAS5716_CH2_BQ_3	0x33	// ch2_bq[3]
+#define TAS5716_CH2_BQ_4	0x34	// ch2_bq[4]
+#define TAS5716_CH2_BQ_5	0x35	// ch2_bq[5]
+#define TAS5716_CH2_BQ_6	0x36	// ch2_bq[6]
+#define TAS5716_CH6_BQ_0	0x37	// ch6_bq[0]
+#define TAS5716_CH6_BQ_1	0x38	// ch6_bq[1]
+
+#define TAS5716_DRC1_AE		0x3A	// DRC1 ae
+#define TAS5716_DRC1_AA		0x3B	// DRC1 aa
+#define TAS5716_DRC1_AD		0x3C	// DRC1 ad
+#define TAS5716_DRC2_AE		0x3F	// DRC2 ae
+#define TAS5716_DRC2_AA		0x3E	// DRC2 aa
+#define TAS5716_DRC2_AD		0x3F	// DRC2 ad
+#define TAS5716_DRC1_T		0x40	// DRC1-T
+#define TAS5716_DRC1_K		0x41	// DRC1-K
+#define TAS5716_DRC1_O		0x42	// DRC1-O
+#define TAS5716_DRC2_T		0x43	// DRC2-T
+#define TAS5716_DRC2_K		0x44	// DRC2-K
+#define TAS5716_DRC2_O		0x45	// DRC2-O
+#define TAS5716_DRC_CONTROL	0x46	// DRC control
+
+#define TAS5716_BANK_UPDATE	0x50	// Bank update command
+#define TAS5716_V1OM		0x51	// V1OM3[31:0] V1OM1[31:0]
+#define TAS5716_V2OM		0x52	// V2OM6[31:0] V2OM4[31:0] V2OM2[31:0]
+
+/* TAS5716_CLOCK_CONTROL	0x00 	Clock control register */
+
+#define TAS5716_CLOCK_CTRL_FS_MASK	(7<<5)
+#define TAS5716_CLOCK_CTRL_32K		(0<<5)
+#define TAS5716_CLOCK_CTRL_38K		(1<<5)
+#define TAS5716_CLOCK_CTRL_441K		(2<<5)
+#define TAS5716_CLOCK_CTRL_48K		(3<<5)
+#define TAS5716_CLOCK_CTRL_882K		(4<<5)
+#define TAS5716_CLOCK_CTRL_96K		(5<<5)
+#define TAS5716_CLOCK_CTRL_176K		(6<<5)
+#define TAS5716_CLOCK_CTRL_192K		(7<<5)
+#define TAS5716_CLOCK_CTRL_FS_SHIFT	5
+#define TAS5716_CLOCK_CTRL_FS_WIDTH	3
+#define TAS5716_CLOCK_CTRL_MCLK_MASK	(7<<2)
+#define TAS5716_CLOCK_CTRL_64FS		(0<<2)
+#define TAS5716_CLOCK_CTRL_128FS	(1<<2)
+#define TAS5716_CLOCK_CTRL_192FS	(2<<2)
+#define TAS5716_CLOCK_CTRL_256FS	(3<<2)
+#define TAS5716_CLOCK_CTRL_384FS	(4<<2)
+#define TAS5716_CLOCK_CTRL_512FS	(5<<2)
+#define TAS5716_CLOCK_CTRL_MCLK_SHIFT	2
+#define TAS5716_CLOCK_CTRL_MCLK_WIDTH	3
+#define TAS5716_CLOCK_CTRL_SCLK64	(0<<1)
+#define TAS5716_CLOCK_CTRL_SCLK48	(1<<1)
+#define TAS5716_CLOCK_CTRL_SCLK_MASK	(1<<1)
+#define TAS5716_CLOCK_CTRL_SCLK_SHIFT	1
+#define TAS5716_CLOCK_CTRL_SCLK_WIDTH	1
+#define TAS5716_CLOCK_CTRL_VALID	(1<<0)
+#define TAS5716_CLOCK_CTRL_VALID_MASK	(1<<0)
+#define TAS5716_CLOCK_CTRL_VALID_SHIFT	0
+#define TAS5716_CLOCK_CTRL_VALID_WIDTH	1
+
+/* TAS5716_DEVICE_ID		0x01 	Device ID register */
+
+/* TAS5716_ERROR_STATUS		0x02	Error status register */
+
+#define TAS5716_ERROR_MCLK		(1<<7)
+#define TAS5716_ERROR_MCLK_MASK		(1<<7)
+#define TAS5716_ERROR_MCLK_SHIFT	7
+#define TAS5716_ERROR_MCLK_WIDTH	1
+#define TAS5716_ERROR_PLL		(1<<6)
+#define TAS5716_ERROR_PLL_MASK		(1<<6)
+#define TAS5716_ERROR_PLL_SHIFT		6
+#define TAS5716_ERROR_PLL_WIDTH		1
+#define TAS5716_ERROR_SCLK		(1<<5)
+#define TAS5716_ERROR_SCLK_MASK		(1<<5)
+#define TAS5716_ERROR_SCLK_SHIFT	5
+#define TAS5716_ERROR_SCLK_WIDTH	1
+#define TAS5716_ERROR_LRCLK		(1<<4)
+#define TAS5716_ERROR_LRCLK_MASK	(1<<4)
+#define TAS5716_ERROR_LRCLK_SHIFT	4
+#define TAS5716_ERROR_LRCLK_WIDTH	1
+#define TAS5716_ERROR_SLIP		(1<<3)
+#define TAS5716_ERROR_SLIP_MASK		(1<<3)
+#define TAS5716_ERROR_SLIP_SHIFT	3
+#define TAS5716_ERROR_SLIP_WIDTH	1
+#define TAS5716_ERROR_NONE		0
+
+/* TAS5716_SYS_CTRL1		0x03	System control 1 register */
+
+#define TAS5716_SYS_CTRL1_PWM_PASS	(1<<7)
+#define TAS5716_SYS_CTRL1_PWM_MASK	(1<<7)
+#define TAS5716_SYS_CTRL1_PWM_SHIFT	7
+#define TAS5716_SYS_CTRL1_PWM_WIDTH	1
+#define TAS5716_SYS_CTRL1_HARD_UNMUTE	(1<<5)
+#define TAS5716_SYS_CTRL1_SOFT_UNMUTE	(0<<5)
+#define TAS5716_SYS_CTRL1_UNMUTE_MASK	(1<<5)
+#define TAS5716_SYS_CTRL1_UNMUTE_SHIFT	5
+#define TAS5716_SYS_CTRL1_UNMUTE_WIDTH	1
+#define TAS5716_SYS_CTRL1_AUTOCLK_OFF	(1<<3)
+#define TAS5716_SYS_CTRL1_AUTOCLK_ON	(0<<3)
+#define TAS5716_SYS_CTRL1_AUTOCLK_MASK	(1<<3)
+#define TAS5716_SYS_CTRL1_AUTOCLK_SHIFT	3
+#define TAS5716_SYS_CTRL1_AUTOCLK_WIDTH	1
+#define TAS5716_SYS_CTRL1_SOFTSTART	(1<<2)
+#define TAS5716_SYS_CTRL1_SOFT_MASK	(1<<2)
+#define TAS5716_SYS_CTRL1_SOFT_SHIFT	2
+#define TAS5716_SYS_CTRL1_SOFT_WIDTH	1
+#define TAS5716_SYS_CTRL1_DEEMP_MASK	(3<<0)
+#define TAS5716_SYS_CTRL1_DEEMP_NONE	(0<<0)
+#define TAS5716_SYS_CTRL1_DEEMP_441	(2<<0)
+#define TAS5716_SYS_CTRL1_DEEMP_48	(3<<0)
+#define TAS5716_SYS_CTRL1_DEEMP_SHIFT	0
+#define TAS5716_SYS_CTRL1_DEEMP_WIDTH	2
+
+/* TAS5716_FORMAT		0x04 	Serial-data interface register */
+
+#define TAS5716_FORMAT_RJ_16		0
+#define TAS5716_FORMAT_RJ_20		1
+#define TAS5716_FORMAT_RJ_24		2
+#define TAS5716_FORMAT_I2S_16		3
+#define TAS5716_FORMAT_I2S_20		4
+#define TAS5716_FORMAT_I2S_24		5
+#define TAS5716_FORMAT_LJ_16		6
+#define TAS5716_FORMAT_LJ_20		7
+#define TAS5716_FORMAT_LJ_24		8
+#define TAS5716_FORMAT_RJ_18		0xA
+#define TAS5716_FORMAT_I2S_16_32FS	0x13
+#define TAS5716_FORMAT_LJ_16_32FS	0x16
+
+/* TAS5716_SYS_CTRL2		0x05	System-control 2 register */
+
+#define TAS5716_SYS_CTRL2_SHUT_MASK	(3<<5)
+#define TAS5716_SYS_CTRL2_SHUTDOWN	(3<<5)
+#define TAS5716_SYS_CTRL2_START_SDG	(0<<5)
+#define TAS5716_SYS_CTRL2_START_ALL	(1<<5)
+#define TAS5716_SYS_CTRL2_SHUT_SHIFT	5
+#define TAS5716_SYS_CTRL2_SHUT_WIDTH	2
+#define TAS5716_SYS_CTRL2_HPVOL		(1<<3)
+#define TAS5716_SYS_CTRL2_CHVOL		(0<<3)
+#define TAS5716_SYS_CTRL2_HPVOL_MASK	(1<<3)
+#define TAS5716_SYS_CTRL2_HPVOL_SHIFT	3
+#define TAS5716_SYS_CTRL2_HPVOL_WIDTH	1
+#define TAS5716_SYS_CTRL2_SPK_MASK	(3<<1)
+#define TAS5716_SYS_CTRL2_HPSEL		(0<<1)
+#define TAS5716_SYS_CTRL2_HPMODE	(1<<1)
+#define TAS5716_SYS_CTRL2_LINEOUT	(2<<1)
+#define TAS5716_SYS_CTRL2_SPK_SHIFT	1
+#define TAS5716_SYS_CTRL2_SPK_WIDTH	2
+
+/* TAS5716_SOFT_MUTE		0x06	Soft-mute register */
+
+#define TAS5716_SM_CH1			(1<<0)
+#define TAS5716_SM_CH1_MASK		(1<<0)
+#define TAS5716_SM_CH1_SHIFT		0
+#define TAS5716_SM_CH1_WIDTH		1
+#define TAS5716_SM_CH2			(1<<1)
+#define TAS5716_SM_CH2_MASK		(1<<1)
+#define TAS5716_SM_CH2_SHIFT		1
+#define TAS5716_SM_CH2_WIDTH		1
+#define TAS5716_SM_CH3			(1<<2)
+#define TAS5716_SM_CH3_MASK		(1<<2)
+#define TAS5716_SM_CH3_SHIFT		2
+#define TAS5716_SM_CH3_WIDTH		1
+#define TAS5716_SM_CH4			(1<<3)
+#define TAS5716_SM_CH4_MASK		(1<<3)
+#define TAS5716_SM_CH4_SHIFT		3
+#define TAS5716_SM_CH4_WIDTH		1
+#define TAS5716_SM_CH6			(1<<5)
+#define TAS5716_SM_CH6_MASK		(1<<5)
+#define TAS5716_SM_CH6_SHIFT		5
+#define TAS5716_SM_CH6_WIDTH		1
+#define TAS5716_SM_UNMUTE_ALL		0
+
+/* TAS5716_MASTER_VOLUME	0x07	Master volume */
+/* TAS5716_CH1_VOLUME		0x08	Channel 1 volume */
+/* TAS5716_CH2_VOLUME		0x08	Channel 2 volume */
+/* TAS5716_CH3_VOLUME		0x08	Channel 3 volume */
+/* TAS5716_CH4_VOLUME		0x08	Channel 4 volume */
+/* TAS5716_HP_VOLUME		0x0C	HP volume */
+/* TAS5716_CH6_VOLUME		0x0D	Channel-6 volume */
+
+/* TAS5716_VOLUME_CONFIG	0x0E 	Volume configuration */
+
+#define TAS5716_VOLCONF_BIQUAD		(1<<6)
+#define TAS5716_VOLCONF_BIQUAD_MASK	(1<<6)
+#define TAS5716_VOLCONF_BIQUAD_SHIFT	6
+#define TAS5716_VOLCONF_BIQUAD_WIDTH	1
+#define TAS5716_VOLCONF_SLEW_MASK	(3<<0)
+#define TAS5716_VOLCONF_SLEW512		(0<<0)
+#define TAS5716_VOLCONF_SLEW1024	(1<<0)
+#define TAS5716_VOLCONF_SLEW2048	(2<<0)
+#define TAS5716_VOLCONF_SLEW256		(3<<0)
+#define TAS5716_VOLCONF_SLEW_SHIFT	0
+#define TAS5716_VOLCONF_SLEW_WIDTH	2
+
+/* TAS5716_MOD_LIMIT0		0x10	Modulation-limit register */
+/* TAS5716_IC_DELAY_CH1		0x11 	IC delay channel 1 */
+/* TAS5716_IC_DELAY_CH2		0x12 	IC delay channel 2 */
+/* TAS5716_IC_DELAY_CH3		0x13 	IC delay channel 3 */
+/* TAS5716_IC_DELAY_CH4		0x14 	IC delay channel 4 */
+/* TAS5716_IC_DELAY_CH5		0x15 	IC delay channel 5 */
+/* TAS5716_IC_DELAY_CH6		0x16 	IC delay channel 6 */
+/* TAS5716_OFFSET		0x17	Offset register */
+
+/* TAS5716_PWM_SHUTDOWN		0x19	PWM shutdown group */
+
+#define TAS5716_SDG_CH6			(1 << 5)
+#define TAS5716_SDG_CH5			(1 << 4)
+#define TAS5716_SDG_CH4			(1 << 3)
+#define TAS5716_SDG_CH3			(1 << 2)
+#define TAS5716_SDG_CH2			(1 << 1)
+#define TAS5716_SDG_CH1			(1 << 0)
+
+/* TAS5716_START_STOP		0x1A	Start/stop period */
+
+#define TAS5716_SS_BTL			(1<<7)
+#define TAS5716_SS_SE			(0<<7)
+#define TAS5716_SS_LOAD_MASK		(1<<7)
+#define TAS5716_SS_LOAD_SHIFT		6
+#define TAS5716_SS_LOAD_WIDTH		1
+#define TAS5716_SS_DUTY_MASK		(0x1F<<0)
+#define TAS5716_SS_DUTY_SHIFT		0
+#define TAS5716_SS_DUTY_WIDTH		5
+
+/* TAS5716_OSC_TRIM		0x1B	Oscillator trim */
+/* Write data 0x00 to register 0x1B (enable factory trim). */
+
+#define TAS5716_OSC_DONE		(1<<7)
+#define TAS5716_OSC_DONE_MASK		(1<<7)
+#define TAS5716_OSC_DONE_SHIFT		7
+#define TAS5716_OSC_DONE_WIDTH		1
+#define TAS5716_OSC_NOTRIM		(1<<1)
+#define TAS5716_OSC_NOTRIM_MASK		(1<<1)
+#define TAS5716_OSC_NOTRIM_SHIFT	1
+#define TAS5716_OSC_NOTRIM_WIDTH	1
+
+/* TAS5716_BKND_ERR		0x1C	BKND_ERR */
+
+/* TAS5716_INPUT_MUX		0x20	Input MUX register */
+#define TAS5716_MUX_AD(ch)		0
+#define TAS5716_MUX_BD(ch)		(8<<((6-ch)*4)))
+#define TAS5716_MUX_IN1L(ch)		(0<<((6-ch)*4)))
+#define TAS5716_MUX_IN1R(ch)		(1<<((6-ch)*4)))
+#define TAS5716_MUX_IN2L(ch)		(2<<((6-ch)*4)))
+#define TAS5716_MUX_IN2R(ch)		(3<<((6-ch)*4)))
+#define TAS5716_MUX_BTL(ch)		(7<<((6-ch)*4)))
+
+/* TAS5716_CH6_INPUT_MUX2	0x21	Ch-6 input mux-2 register */
+
+#define TAS5716_MUX2_6_TO_6		(0<<8)
+#define TAS5716_MUX2_6_BASS		(1<<8)
+#define TAS5716_MUX2_LR_DIV_2		(2<<8)
+#define TAS5716_MUX2_MASK		(3<<8)
+#define TAS5716_MUX2_SHIFT		8
+#define TAS5716_MUX2_WIDTH		2
+
+/* TAS5716_AM_TUNED_FREQ	0x22	AM tuned frequency */
+
+#define TAS5716_AM_MODE			(1<<20)
+#define TAS5716_AM_MODE_MASK		(1<<20)
+#define TAS5716_AM_MODE_SHIFT		20
+#define TAS5716_AM_MODE_WIDTH		1
+#define TAS5716_AM_SEQ_MASK		(3<<18)
+#define TAS5716_AM_SEQ_SHIFT		18
+#define TAS5716_AM_SEQ_WIDTH		1
+#define TAS5716_AM_IF			(1<<17)
+#define TAS5716_AM_IF_MASK		(1<<17)
+#define TAS5716_AM_IF_SHIFT		17
+#define TAS5716_AM_IF_WIDTH		1
+#define TAS5716_AM_BCD			(1<<16)
+#define TAS5716_AM_BCD_MASK		(1<<16)
+#define TAS5716_AM_BCD_SHIFT		16
+#define TAS5716_AM_BCD_WIDTH		1
+#define TAS5716_AM_FREQ_MASK		(0xFFFF<<0)
+#define TAS5716_AM_FREQ_SHIFT		0
+#define TAS5716_AM_FREQ_WIDTH		16
+
+/* TAS5716_PWM_MUX		0x25	PWM MUX register */
+#define TAS5716_PWM_MUX_HPL(ch)		((ch-1)<<28)
+#define TAS5716_PWM_MUX_HPR(ch)		((ch-1)<<24)
+#define TAS5716_PWM_MUX_OUTA(ch)	((ch-1)<<20)
+#define TAS5716_PWM_MUX_OUTB(ch)	((ch-1)<<16)
+#define TAS5716_PWM_MUX_OUTC(ch)	((ch-1)<<12)
+#define TAS5716_PWM_MUX_OUTD(ch)	((ch-1)<<8)
+#define TAS5716_PWM_MUX_SUBM(ch)	((ch-1)<<4)
+#define TAS5716_PWM_MUX_SUBP(ch)	((ch-1)<<0)
+
+/* TAS5716_1_G			0x26	1/G register */
+/* TAS5716_SCALE		0x28	Scale register */
+/* TAS5716_CH1_BQ_0		0x29	ch1_bq[0] */
+/* TAS5716_CH1_BQ_1		0x2A	ch1_bq[1] */
+/* TAS5716_CH1_BQ_2		0x2B	ch1_bq[2] */
+/* TAS5716_CH1_BQ_3		0x2C	ch1_bq[3] */
+/* TAS5716_CH1_BQ_4		0x2D	ch1_bq[4] */
+/* TAS5716_CH1_BQ_5		0x2E	ch1_bq[5] */
+/* TAS5716_CH1_BQ_6		0x2F	ch1_bq[6] */
+/* TAS5716_CH2_BQ_0		0x30	ch2_bq[0] */
+/* TAS5716_CH2_BQ_1		0x31	ch2_bq[1] */
+/* TAS5716_CH2_BQ_2		0x32	ch2_bq[2] */
+/* TAS5716_CH2_BQ_3		0x33	ch2_bq[3] */
+/* TAS5716_CH2_BQ_4		0x34	ch2_bq[4] */
+/* TAS5716_CH2_BQ_5		0x35	ch2_bq[5] */
+/* TAS5716_CH2_BQ_6		0x36	ch2_bq[6] */
+/* TAS5716_CH6_BQ_0		0x37	ch6_bq[0] */
+/* TAS5716_CH6_BQ_1		0x38	ch6_bq[1] */
+
+/* TAS5716_DRC1_AE		0x3A	DRC1 ae */
+/* TAS5716_DRC1_AA		0x3B	DRC1 aa */
+/* TAS5716_DRC1_AD		0x3C	DRC1 ad */
+/* TAS5716_DRC2_AE		0x3F	DRC2 ae */
+/* TAS5716_DRC2_AA		0x3E	DRC2 aa */
+/* TAS5716_DRC2_AD		0x3F	DRC2 ad */
+/* TAS5716_DRC1_T		0x40	DRC1-T */
+/* TAS5716_DRC1_K		0x41	DRC1-K */
+/* TAS5716_DRC1_O		0x42	DRC1-O */
+/* TAS5716_DRC2_T		0x43	DRC2-T */
+/* TAS5716_DRC2_K		0x44	DRC2-K */
+/* TAS5716_DRC2_O		0x45	DRC2-O */
+/* TAS5716_DRC_CONTROL		0x46	DRC control */
+
+#define TAS5716_DRC_CTRL_DRC1_CH4	(1 << 3)
+#define TAS5716_DRC_CTRL_DRC1_CH3	(1 << 2)
+#define TAS5716_DRC_CTRL_DRC2_SUB	(1 << 1)
+#define TAS5716_DRC_CTRL_DRC2_SAT	(1 << 0)
+
+/* TAS5716_BANK_UPDATE		0x50	Bank update command */
+
+#define TAS5716_BANK_EQ_HEAD		(1 << 7)
+#define TAS5716_BANK_DRC_HEAD		(1 << 6)
+#define TAS5716_BANK_SW_MASK		(3 << 0)
+#define TAS5716_BANK_SW_NONE		(0 << 0)
+#define TAS5716_BANK_SW_BANK1		(1 << 0)
+#define TAS5716_BANK_SW_BANK2		(2 << 0)
+#define TAS5716_BANK_SW_BANK3		(3 << 0)
+#define TAS5716_BANK_SW_AUTO		(4 << 0)
+
+/* TAS5716_V1OM			0x51	V1OM3[31:0] V1OM1[31:0] */
+/* TAS5716_V2OM			0x52	V2OM6[31:0] V2OM4[31:0] V2OM2[31:0] */
+
+#endif /* _ASOC_TAS_5716_H */
diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
new file mode 100644
index 0000000..777d0e0
--- /dev/null
+++ b/sound/soc/sunxi/Kconfig
@@ -0,0 +1,16 @@
+menu "SoC Audio support for Allwinner SoCs"
+        depends on ARCH_SUNXI
+
+config SND_SUNXI_SOC_CODEC
+	tristate "APB on-chip sun4i/sun5i/sun7i CODEC"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	default y
+
+config SND_SUNXI_SOC_I2S
+	tristate "sun4i/sun5i/sun7i I2S"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	default y
+
+endmenu
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
new file mode 100644
index 0000000..d87b4c1
--- /dev/null
+++ b/sound/soc/sunxi/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_SND_SUNXI_SOC_CODEC) += sunxi-codec.o
+obj-$(CONFIG_SND_SUNXI_SOC_I2S) += sunxi-i2s.o
+
diff --git a/sound/soc/sunxi/i2s/Kconfig b/sound/soc/sunxi/i2s/Kconfig
new file mode 100644
index 0000000..a6dff42
--- /dev/null
+++ b/sound/soc/sunxi/i2s/Kconfig
@@ -0,0 +1,7 @@
+config SND_SUNXI_SOC_I2S_INTERFACE
+	tristate "SoC i2s interface for the AllWinner sun4i and sun5i chips"
+	default m
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the SUNXI AC97, I2S or PCM interface. You will also need
+	  to select the audio interfaces to support below.
diff --git a/sound/soc/sunxi/i2s/Makefile b/sound/soc/sunxi/i2s/Makefile
new file mode 100644
index 0000000..15d9287
--- /dev/null
+++ b/sound/soc/sunxi/i2s/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_SND_SUNXI_SOC_I2S_INTERFACE) += i2s.o
+obj-$(CONFIG_SND_SUNXI_SOC_I2S_INTERFACE) += dma.o
+obj-$(CONFIG_SND_SUNXI_SOC_I2S_INTERFACE) += codec.o
+obj-$(CONFIG_SND_SUNXI_SOC_I2S_INTERFACE) += card.o
+
diff --git a/sound/soc/sunxi/i2s/card.c b/sound/soc/sunxi/i2s/card.c
new file mode 100644
index 0000000..7c1a3d4
--- /dev/null
+++ b/sound/soc/sunxi/i2s/card.c
@@ -0,0 +1,318 @@
+/*
+ * sound\soc\sunxi\i2s\sunxi_sndi2s.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <plat/sys_config.h>
+#include <linux/io.h>
+
+#include "sunxi-i2s.h"
+#include "sunxi-i2sdma.h"
+
+#include "sndi2s.h"
+
+static struct clk *xtal;
+static int clk_users;
+static DEFINE_MUTEX(clk_lock);
+
+#ifdef ENFORCE_RATES
+static struct snd_pcm_hw_constraint_list hw_constraints_rates = {
+	.count	= ARRAY_SIZE(rates),
+	.list	= rates,
+	.mask	= 0,
+};
+#endif
+
+static int sunxi_sndi2s_startup(struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+	#ifdef ENFORCE_RATES
+		struct snd_pcm_runtime *runtime = substream->runtime;;
+	#endif
+
+	if (!ret) {
+	#ifdef ENFORCE_RATES
+		ret = snd_pcm_hw_constraint_list(runtime, 0,
+						 SNDRV_PCM_HW_PARAM_RATE,
+						 &hw_constraints_rates);
+		if (ret < 0)
+			return ret;
+	#endif
+	}
+	return ret;
+}
+
+static void sunxi_sndi2s_shutdown(struct snd_pcm_substream *substream)
+{
+	mutex_lock(&clk_lock);
+	clk_users -= 1;
+	if (clk_users == 0) {
+		clk_put(xtal);
+		xtal = NULL;
+
+	}
+	mutex_unlock(&clk_lock);
+}
+
+typedef struct __MCLK_SET_INF
+{
+    __u32       samp_rate;      // sample rate
+    __u16       mult_fs;        // multiply of smaple rate
+
+    __u8        clk_div;        // mpll division
+    __u8        mpll;           // select mpll, 0 - 24.576 Mhz, 1 - 22.5792 Mhz
+
+} __mclk_set_inf;
+
+
+typedef struct __BCLK_SET_INF
+{
+    __u8        bitpersamp;     // bits per sample
+    __u8        clk_div;        // clock division
+    __u16       mult_fs;        // multiplay of sample rate
+
+} __bclk_set_inf;
+
+
+static __bclk_set_inf BCLK_INF[] =
+{
+    // 16bits per sample
+    {16,  4, 128}, {16,  6, 192}, {16,  8, 256},
+    {16, 12, 384}, {16, 16, 512},
+
+    //24 bits per sample
+    {24,  4, 192}, {24,  8, 384}, {24, 16, 768},
+
+    //32 bits per sample
+    {32,  2, 128}, {32,  4, 256}, {32,  6, 384},
+    {32,  8, 512}, {32, 12, 768},
+
+    //end flag
+    {0xff, 0, 0},
+};
+
+static __mclk_set_inf  MCLK_INF[] =
+{
+    // 8k bitrate
+    {  8000, 128, 24, 0}, {  8000, 192, 16, 0}, {  8000, 256, 12, 0},
+    {  8000, 384,  8, 0}, {  8000, 512,  6, 0}, {  8000, 768,  4, 0},
+
+    // 16k bitrate
+    { 16000, 128, 12, 0}, { 16000, 192,  8, 0}, { 16000, 256,  6, 0},
+    { 16000, 384,  4, 0}, { 16000, 768,  2, 0},
+
+    // 32k bitrate
+    { 32000, 128,  6, 0}, { 32000, 192,  4, 0}, { 32000, 384,  2, 0},
+    { 32000, 768,  1, 0},
+
+    // 64k bitrate
+    { 64000, 192,  2, 0}, { 64000, 384,  1, 0},
+
+    //128k bitrate
+    {128000, 192,  1, 0},
+
+    // 12k bitrate
+    { 12000, 128, 16, 0}, { 12000, 256, 8, 0}, { 12000, 512, 4, 0},
+
+    // 24k bitrate
+    { 24000, 128,  8, 0}, { 24000, 256, 4, 0}, { 24000, 512, 2, 0},
+
+    // 48K bitrate
+    { 48000, 128,  4, 0}, { 48000, 256,  2, 0}, { 48000, 512, 1, 0},
+
+    // 96k bitrate
+    { 96000, 128 , 2, 0}, { 96000, 256,  1, 0},
+
+    //192k bitrate
+    {192000, 128,  1, 0},
+
+    //11.025k bitrate
+    { 11025, 128, 16, 1}, { 11205, 256,  8, 1}, { 11205, 512,  4, 1},
+
+    //22.05k bitrate
+    { 22050, 128,  8, 1}, { 22050, 256,  4, 1},
+    { 22050, 512,  2, 1},
+
+    //44.1k bitrate
+    { 44100, 128,  4, 1}, { 44100, 256,  2, 1}, { 44100, 512,  1, 1},
+
+    //88.2k bitrate
+    { 88200, 128,  2, 1}, { 88200, 256,  1, 1},
+
+    //176.4k bitrate
+    {176400, 128, 1, 1},
+
+    //end flag 0xffffffff
+    {0xffffffff, 0, 0, 0},
+};
+
+static s32 get_clock_divder(u32 sample_rate, u32 sample_width, u32 * mclk_div, u32* mpll, u32* bclk_div, u32* mult_fs)
+{
+	u32 i, j, ret = -EINVAL;
+
+	for(i=0; i< 100; i++) {
+		 if((MCLK_INF[i].samp_rate == sample_rate) &&
+		 	((MCLK_INF[i].mult_fs == 256) || (MCLK_INF[i].mult_fs == 128))) {
+			  for(j=0; j<ARRAY_SIZE(BCLK_INF); j++) {
+					if((BCLK_INF[j].bitpersamp == sample_width) &&
+						(BCLK_INF[j].mult_fs == MCLK_INF[i].mult_fs)) {
+						 //set mclk and bclk division
+						 *mclk_div = MCLK_INF[i].clk_div;
+						 *mpll = MCLK_INF[i].mpll;
+						 *bclk_div = BCLK_INF[j].clk_div;
+						 *mult_fs = MCLK_INF[i].mult_fs;
+						 ret = 0;
+						 break;
+					}
+			  }
+		 }
+		 else if(MCLK_INF[i].samp_rate == 0xffffffff)
+		 	break;
+	}
+
+	return ret;
+}
+
+static int sunxi_sndi2s_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int ret = 0;
+	unsigned long rate = params_rate(params);
+	u32 mclk_div=0, mpll=0, bclk_div=0, mult_fs=0;
+
+	get_clock_divder(rate, 32, &mclk_div, &mpll, &bclk_div, &mult_fs);
+
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0 , mpll, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0 , mpll, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, SUNXI_DIV_MCLK, mclk_div);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, SUNXI_DIV_BCLK, bclk_div);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(codec_dai, 0, mult_fs);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_sndi2s_ops = {
+	.startup 		= sunxi_sndi2s_startup,
+	.shutdown 		= sunxi_sndi2s_shutdown,
+	.hw_params 		= sunxi_sndi2s_hw_params,
+};
+
+static struct snd_soc_dai_link sunxi_sndi2s_dai_link = {
+	.name 			= "I2S",
+	.stream_name 	= "SUNXI-I2S",
+	.cpu_dai_name 	= "sunxi-i2s.0",
+	.codec_dai_name = "sndi2s",
+	.platform_name 	= "sunxi-i2s-pcm-audio.0",
+	.codec_name 	= "sunxi-i2s-codec.0",
+	.ops 			= &sunxi_sndi2s_ops,
+};
+
+static struct snd_soc_card snd_soc_sunxi_sndi2s = {
+	.name = "sunxi-sndi2s",
+	.owner = THIS_MODULE,
+	.dai_link = &sunxi_sndi2s_dai_link,
+	.num_links = 1,
+};
+
+static int __devinit sunxi_sndi2s_probe(struct platform_device *pdev)
+{
+	snd_soc_sunxi_sndi2s.dev = &pdev->dev;
+	return snd_soc_register_card(&snd_soc_sunxi_sndi2s);
+}
+
+static int __devexit sunxi_sndi2s_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_card(&snd_soc_sunxi_sndi2s);
+	return 0;
+}
+
+static struct platform_device sunxi_sndi2s_device = {
+	.name = "sunxi-sndi2s",
+};
+
+static struct platform_driver sunxi_sndi2s_driver = {
+	.probe = sunxi_sndi2s_probe,
+	.remove = __devexit_p(sunxi_sndi2s_remove),
+	.driver = {
+		.name = "sunxi-sndi2s",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init sunxi_sndi2s_init(void)
+{
+	int ret, i2s_used = 0;
+
+	ret = script_parser_fetch("i2s_para", "i2s_used", &i2s_used, 1);
+	if (ret != 0 || !i2s_used)
+		return -ENODEV;
+
+	ret = platform_device_register(&sunxi_sndi2s_device);
+	if (ret < 0)
+		return ret;
+
+	ret = platform_driver_register(&sunxi_sndi2s_driver);
+	if (ret < 0) {
+		platform_device_unregister(&sunxi_sndi2s_device);
+		return ret;
+	}
+	return 0;
+}
+
+static void __exit sunxi_sndi2s_exit(void)
+{
+	platform_driver_unregister(&sunxi_sndi2s_driver);
+	platform_device_unregister(&sunxi_sndi2s_device);
+}
+
+module_init(sunxi_sndi2s_init);
+module_exit(sunxi_sndi2s_exit);
+
+MODULE_AUTHOR("ALL WINNER");
+MODULE_DESCRIPTION("SUNXI_sndi2s ALSA SoC audio driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/i2s/card.h b/sound/soc/sunxi/i2s/card.h
new file mode 100644
index 0000000..47f0961
--- /dev/null
+++ b/sound/soc/sunxi/i2s/card.h
@@ -0,0 +1,25 @@
+/*
+ * sound\soc\sunxi\i2s\sunxi_sndi2s.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef SUNXI_SNDI2S_H_
+#define SUNXI_SNDI2S_H_
+
+struct sunxi_sndi2s_platform_data {
+	int iis_bclk;
+	int iis_ws;
+	int iis_data;
+	void (*power)(int);
+	int model;
+}
+#endif
diff --git a/sound/soc/sunxi/i2s/codec.c b/sound/soc/sunxi/i2s/codec.c
new file mode 100644
index 0000000..68bad02
--- /dev/null
+++ b/sound/soc/sunxi/i2s/codec.c
@@ -0,0 +1,206 @@
+/*
+ * sound\soc\sunxi\i2s\sndi2s.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <plat/sys_config.h>
+#include <linux/io.h>
+
+#include "sndi2s.h"
+
+struct sndi2s_priv {
+	int sysclk;
+	int dai_fmt;
+
+	struct snd_pcm_substream *master_substream;
+	struct snd_pcm_substream *slave_substream;
+};
+
+static int i2s_used = 0;
+#define sndi2s_RATES  (SNDRV_PCM_RATE_8000_192000|SNDRV_PCM_RATE_KNOT)
+#define sndi2s_FORMATS (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE | \
+		                     SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S20_3LE)
+
+hdmi_audio_t hdmi_parameter;
+
+static int sndi2s_mute(struct snd_soc_dai *dai, int mute)
+{
+	return 0;
+}
+
+static int sndi2s_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void sndi2s_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+
+}
+
+static int sndi2s_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params,
+	struct snd_soc_dai *dai)
+{
+	hdmi_parameter.sample_rate = params_rate(params);
+
+	return 0;
+}
+
+static int sndi2s_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int sndi2s_set_dai_clkdiv(struct snd_soc_dai *codec_dai, int div_id, int div)
+{
+
+	hdmi_parameter.fs_between = div;
+
+	return 0;
+}
+
+static int sndi2s_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			       unsigned int fmt)
+{
+	return 0;
+}
+
+struct snd_soc_dai_ops sndi2s_dai_ops = {
+	.startup = sndi2s_startup,
+	.shutdown = sndi2s_shutdown,
+	.hw_params = sndi2s_hw_params,
+	.digital_mute = sndi2s_mute,
+	.set_sysclk = sndi2s_set_dai_sysclk,
+	.set_clkdiv = sndi2s_set_dai_clkdiv,
+	.set_fmt = sndi2s_set_dai_fmt,
+};
+
+struct snd_soc_dai_driver sndi2s_dai = {
+	.name = "sndi2s",
+	/* playback capabilities */
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = sndi2s_RATES,
+		.formats = sndi2s_FORMATS,
+	},
+	/* pcm operations */
+	.ops = &sndi2s_dai_ops,
+	.symmetric_rates = 1,
+};
+EXPORT_SYMBOL(sndi2s_dai);
+
+static int sndi2s_soc_probe(struct snd_soc_codec *codec)
+{
+	struct sndi2s_priv *sndi2s;
+
+	sndi2s = kzalloc(sizeof(struct sndi2s_priv), GFP_KERNEL);
+	if(sndi2s == NULL){
+		return -ENOMEM;
+	}
+	snd_soc_codec_set_drvdata(codec, sndi2s);
+
+	return 0;
+}
+
+/* power down chip */
+static int sndi2s_soc_remove(struct snd_soc_codec *codec)
+{
+	struct sndhdmi_priv *sndi2s = snd_soc_codec_get_drvdata(codec);
+
+	kfree(sndi2s);
+
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_sndi2s = {
+	.probe 	=	sndi2s_soc_probe,
+	.remove =   sndi2s_soc_remove,
+};
+
+static int __devinit sndi2s_codec_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_sndi2s, &sndi2s_dai, 1);
+}
+
+static int __devexit sndi2s_codec_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+/*data relating*/
+static struct platform_device sndi2s_codec_device = {
+	.name = "sunxi-i2s-codec",
+};
+
+/*method relating*/
+static struct platform_driver sndi2s_codec_driver = {
+	.driver = {
+		.name = "sunxi-i2s-codec",
+		.owner = THIS_MODULE,
+	},
+	.probe = sndi2s_codec_probe,
+	.remove = __devexit_p(sndi2s_codec_remove),
+};
+
+static int __init sndi2s_codec_init(void)
+{
+	int err = 0;
+	int ret = 0;
+
+	ret = script_parser_fetch("i2s_para","i2s_used", &i2s_used, sizeof(int));
+	if (ret) {
+        printk("[I2S]sndi2s_init fetch i2s using configuration failed\n");
+    }
+
+	if (i2s_used) {
+		if((err = platform_device_register(&sndi2s_codec_device)) < 0)
+			return err;
+
+		if ((err = platform_driver_register(&sndi2s_codec_driver)) < 0)
+			return err;
+	} else {
+       printk("[I2S]sndi2s cannot find any using configuration for controllers, return directly!\n");
+       return 0;
+    }
+
+	return 0;
+}
+module_init(sndi2s_codec_init);
+
+static void __exit sndi2s_codec_exit(void)
+{
+	if (i2s_used) {
+		i2s_used = 0;
+		platform_driver_unregister(&sndi2s_codec_driver);
+	}
+}
+module_exit(sndi2s_codec_exit);
+
+MODULE_DESCRIPTION("SNDI2S ALSA soc codec driver");
+MODULE_AUTHOR("Zoltan Devai, Christian Pellegrin <chripell@evolware.org>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-i2s-codec");
diff --git a/sound/soc/sunxi/i2s/codec.h b/sound/soc/sunxi/i2s/codec.h
new file mode 100644
index 0000000..e5b95c8
--- /dev/null
+++ b/sound/soc/sunxi/i2s/codec.h
@@ -0,0 +1,58 @@
+/*
+ * sound\soc\sunxi\i2s\sndi2s.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef SNDI2S_H_
+#define SNDI2S_H_
+
+typedef struct hdmi_audio
+{
+	__u8    hw_intf;        /* 0:iis  1:spdif 2:pcm */
+	__u16	fs_between;     /* fs */
+	__u32   sample_rate;    /*sample rate*/
+	__u8    clk_edge;       /* 0:*/
+	__u8    ch0_en;         /* 1 */
+	__u8    ch1_en;         /* 0 */
+	__u8 	ch2_en;         /* 0 */
+	__u8 	ch3_en;         /* 0 */
+	__u8	word_length;    /* 32 */
+	__u8    shift_ctl;      /* 0 */
+	__u8    dir_ctl;        /* 0 */
+	__u8    ws_pol;
+	__u8    just_pol;
+}hdmi_audio_t;
+
+
+typedef struct
+{
+    __s32 (*hdmi_audio_enable)(__u8 mode, __u8 channel);
+    __s32 (*hdmi_set_audio_para)(hdmi_audio_t * audio_para);
+}__audio_hdmi_func;
+
+
+/*define display driver command*/
+typedef enum tag_HDMI_CMD
+{
+    /* command cache on/off                         */
+		HDMI_CMD_SET_VIDEO_MOD,
+		HDMI_CMD_GET_VIDEO_MOD,
+		HDMI_CMD_SET_AUDIO_PARA,
+		HDMI_CMD_AUDIO_RESET_NOTIFY,            /*iis reset finish notify    */
+		HDMI_CMD_CLOSE,                         /*iis reset finish notify    */
+		HDMI_CMD_MOD_SUPPORT,                   /*hdmi*/
+		HDMI_CMD_AUDIO_ENABLE,
+		HDMI_CMD_GET_HPD_STATUS,
+}__hdmi_cmd_t;
+
+#endif
diff --git a/sound/soc/sunxi/i2s/dma.c b/sound/soc/sunxi/i2s/dma.c
new file mode 100644
index 0000000..488ef4d
--- /dev/null
+++ b/sound/soc/sunxi/i2s/dma.c
@@ -0,0 +1,450 @@
+/*
+ * sound\soc\sunxi\i2s\sunxi-i2sdma.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <plat/dma_compat.h>
+
+#include "sunxi-i2s.h"
+#include "sunxi-i2sdma.h"
+
+static volatile unsigned int dmasrc = 0;
+static volatile unsigned int dmadst = 0;
+
+static const struct snd_pcm_hardware sunxi_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				      SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+				      SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+	.rates			= SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+	.rate_min		= 8000,
+	.rate_max		= 192000,
+	.channels_min		= 1,
+	.channels_max		= 2,
+	.buffer_bytes_max	= 128*1024,    /* value must be (2^n)Kbyte size */
+	.period_bytes_min	= 1024*4,//1024*4,
+	.period_bytes_max	= 1024*32,//1024*32,
+	.periods_min		= 4,//4,
+	.periods_max		= 8,//8,
+	.fifo_size		= 128,//32,
+};
+
+struct sunxi_runtime_data {
+	spinlock_t lock;
+	int state;
+	unsigned int dma_loaded;
+	unsigned int dma_limit;
+	unsigned int dma_period;
+	dma_addr_t dma_start;
+	dma_addr_t dma_pos;
+	dma_addr_t dma_end;
+	struct sunxi_dma_params *params;
+};
+
+static void sunxi_pcm_enqueue(struct snd_pcm_substream *substream)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+	dma_addr_t pos = prtd->dma_pos;
+	unsigned int limit;
+	int ret;
+
+	unsigned long len = prtd->dma_period;
+  	limit = prtd->dma_limit;
+  	while(prtd->dma_loaded < limit) {
+		if((pos + len) > prtd->dma_end) {
+			len  = prtd->dma_end - pos;
+		}
+
+		ret = sunxi_dma_enqueue(prtd->params, pos,  len, 0);
+		if(ret == 0) {
+			prtd->dma_loaded++;
+			pos += prtd->dma_period;
+			if(pos >= prtd->dma_end)
+				pos = prtd->dma_start;
+		}else {
+			break;
+		}
+
+	}
+	prtd->dma_pos = pos;
+}
+
+static void sunxi_audio_buffdone(struct sunxi_dma_params *dma, void *dev_id)
+{
+	struct sunxi_runtime_data *prtd;
+	struct snd_pcm_substream *substream = dev_id;
+
+	prtd = substream->runtime->private_data;
+	if (substream) {
+		snd_pcm_period_elapsed(substream);
+	}
+
+	spin_lock(&prtd->lock);
+	{
+		prtd->dma_loaded--;
+		sunxi_pcm_enqueue(substream);
+	}
+	spin_unlock(&prtd->lock);
+}
+
+static int sunxi_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	unsigned long totbytes = params_buffer_bytes(params);
+	struct sunxi_dma_params *dma =
+			snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	int ret = 0;
+	if (!dma)
+		return 0;
+
+	if (prtd->params == NULL) {
+		prtd->params = dma;
+		ret = sunxi_dma_request(prtd->params, 0);
+		if (ret < 0) {
+				return ret;
+		}
+	}
+
+	if (sunxi_dma_set_callback(prtd->params, sunxi_audio_buffdone,
+							    substream) != 0) {
+		sunxi_dma_release(prtd->params);
+		prtd->params = NULL;
+		return -EINVAL;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	runtime->dma_bytes = totbytes;
+
+	spin_lock_irq(&prtd->lock);
+	prtd->dma_loaded = 0;
+	prtd->dma_limit = runtime->hw.periods_min;
+	prtd->dma_period = params_period_bytes(params);
+	prtd->dma_start = runtime->dma_addr;
+	prtd->dma_pos = prtd->dma_start;
+	prtd->dma_end = prtd->dma_start + totbytes;
+	spin_unlock_irq(&prtd->lock);
+	return 0;
+}
+
+static int sunxi_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+
+	if (prtd->params)
+		sunxi_dma_flush(prtd->params);
+
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	if (prtd->params) {
+		sunxi_dma_stop(prtd->params);
+		sunxi_dma_release(prtd->params);
+		prtd->params = NULL;
+	}
+
+	return 0;
+}
+
+static int sunxi_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	if (!prtd->params)
+		return 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+		struct dma_hw_conf codec_dma_conf;
+		codec_dma_conf.drqsrc_type  = DRQ_TYPE_SDRAM;
+		codec_dma_conf.drqdst_type  = DRQ_TYPE_IIS;
+		codec_dma_conf.xfer_type    = DMAXFER_D_BHALF_S_BHALF;
+		codec_dma_conf.address_type = DMAADDRT_D_FIX_S_INC;
+		codec_dma_conf.dir          = SW_DMA_WDEV;
+		codec_dma_conf.reload       = 0;
+		codec_dma_conf.hf_irq       = SW_DMA_IRQ_FULL;
+		codec_dma_conf.from         = prtd->dma_start;
+		codec_dma_conf.to           = prtd->params->dma_addr;
+#else
+		dma_config_t codec_dma_conf;
+		memset(&codec_dma_conf, 0, sizeof(codec_dma_conf));
+		codec_dma_conf.xfer_type.src_data_width	= DATA_WIDTH_16BIT;
+		codec_dma_conf.xfer_type.src_bst_len	= DATA_BRST_1;	
+		codec_dma_conf.xfer_type.dst_data_width	= DATA_WIDTH_16BIT;
+		codec_dma_conf.xfer_type.dst_bst_len	= DATA_BRST_1;
+		codec_dma_conf.address_type.src_addr_mode = NDMA_ADDR_INCREMENT;
+		codec_dma_conf.address_type.dst_addr_mode = NDMA_ADDR_NOCHANGE;
+		codec_dma_conf.src_drq_type		= N_SRC_SDRAM;
+		codec_dma_conf.dst_drq_type		= N_DST_IIS0_TX;
+		codec_dma_conf.bconti_mode		= false;
+		codec_dma_conf.irq_spt			= CHAN_IRQ_FD;
+#endif
+		ret = sunxi_dma_config(prtd->params, &codec_dma_conf, 0);
+	}
+
+	/* flush the DMA channel */
+	prtd->dma_loaded = 0;
+	if (sunxi_dma_flush(prtd->params) == 0)
+		prtd->dma_pos = prtd->dma_start;
+
+	/* enqueue dma buffers */
+	sunxi_pcm_enqueue(substream);
+
+	return ret;
+}
+
+static int sunxi_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+	int ret ;
+	spin_lock(&prtd->lock);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		printk("[IIS] dma trigger start\n");
+		printk("[IIS] 0x01c22400+0x24 = %#x, line= %d\n", readl(0xf1c22400+0x24), __LINE__);
+		sunxi_dma_start(prtd->params);
+		break;
+
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+        printk("[IIS] dma trigger stop\n");
+		sunxi_dma_stop(prtd->params);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&prtd->lock);
+	return 0;
+}
+
+static snd_pcm_uframes_t sunxi_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd = runtime->private_data;
+	unsigned long res = 0;
+	snd_pcm_uframes_t offset = 0;
+
+	spin_lock(&prtd->lock);
+	sunxi_dma_getcurposition(prtd->params,
+				 (dma_addr_t*)&dmasrc, (dma_addr_t*)&dmadst);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		res = dmadst - prtd->dma_start;
+	else
+	{
+		offset = bytes_to_frames(runtime, dmasrc + prtd->dma_period - runtime->dma_addr);
+	}
+	spin_unlock(&prtd->lock);
+
+	if(offset >= runtime->buffer_size)
+		offset = 0;
+		return offset;
+}
+
+static int sunxi_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd;
+
+	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	snd_soc_set_runtime_hwparams(substream, &sunxi_pcm_hardware);
+
+	prtd = kzalloc(sizeof(struct sunxi_runtime_data), GFP_KERNEL);
+	if (prtd == NULL)
+		return -ENOMEM;
+
+	spin_lock_init(&prtd->lock);
+
+	runtime->private_data = prtd;
+	return 0;
+}
+
+static int sunxi_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd = runtime->private_data;
+
+	kfree(prtd);
+
+	return 0;
+}
+
+static int sunxi_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+static struct snd_pcm_ops sunxi_pcm_ops = {
+	.open			= sunxi_pcm_open,
+	.close			= sunxi_pcm_close,
+	.ioctl			= snd_pcm_lib_ioctl,
+	.hw_params		= sunxi_pcm_hw_params,
+	.hw_free		= sunxi_pcm_hw_free,
+	.prepare		= sunxi_pcm_prepare,
+	.trigger		= sunxi_pcm_trigger,
+	.pointer		= sunxi_pcm_pointer,
+	.mmap			= sunxi_pcm_mmap,
+};
+
+static int sunxi_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = sunxi_pcm_hardware.buffer_bytes_max;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+	return 0;
+}
+
+static void sunxi_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+static u64 sunxi_pcm_mask = DMA_BIT_MASK(32);
+
+static int sunxi_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_pcm *pcm = rtd->pcm;
+	int ret = 0;
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &sunxi_pcm_mask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+ out:
+	return ret;
+}
+
+static struct snd_soc_platform_driver sunxi_soc_platform = {
+	.ops		= &sunxi_pcm_ops,
+	.pcm_new	= sunxi_pcm_new,
+	.pcm_free	= sunxi_pcm_free_dma_buffers,
+};
+
+static int __devinit sunxi_i2s_pcm_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_platform(&pdev->dev, &sunxi_soc_platform);
+}
+
+static int __devexit sunxi_i2s_pcm_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+/*data relating*/
+static struct platform_device sunxi_i2s_pcm_device = {
+	.name = "sunxi-i2s-pcm-audio",
+};
+
+/*method relating*/
+static struct platform_driver sunxi_i2s_pcm_driver = {
+	.probe = sunxi_i2s_pcm_probe,
+	.remove = __devexit_p(sunxi_i2s_pcm_remove),
+	.driver = {
+		.name = "sunxi-i2s-pcm-audio",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init sunxi_soc_platform_i2s_init(void)
+{
+	int err = 0;
+	if((err = platform_device_register(&sunxi_i2s_pcm_device)) < 0)
+		return err;
+
+	if ((err = platform_driver_register(&sunxi_i2s_pcm_driver)) < 0)
+		return err;
+	return 0;
+}
+module_init(sunxi_soc_platform_i2s_init);
+
+static void __exit sunxi_soc_platform_i2s_exit(void)
+{
+	return platform_driver_unregister(&sunxi_i2s_pcm_driver);
+}
+module_exit(sunxi_soc_platform_i2s_exit);
+
+MODULE_AUTHOR("All winner");
+MODULE_DESCRIPTION("SUNXI PCM DMA module");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/sunxi/i2s/dma.h b/sound/soc/sunxi/i2s/dma.h
new file mode 100644
index 0000000..50418a58
--- /dev/null
+++ b/sound/soc/sunxi/i2s/dma.h
@@ -0,0 +1,35 @@
+/*
+ * sound\soc\sunxi\i2s\sunxi-i2sdma.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+
+#ifndef SUNXI_PCM_H_
+#define SUNXI_PCM_H_
+
+#define ST_RUNNING    (1<<0)
+#define ST_OPENED     (1<<1)
+
+#define SUNXI_DAI_I2S			1
+
+enum sunxi_dma_buffresult {
+	SUNXI_RES_OK,
+	SUNXI_RES_ERR,
+	SUNXI_RES_ABORT
+};
+
+/* platform data */
+extern struct snd_soc_platform sunxi_soc_platform_i2s;
+extern struct sunxi_i2s_info sunxi_iis;
+
+#endif //SUNXI_PCM_H_
diff --git a/sound/soc/sunxi/i2s/i2s.c b/sound/soc/sunxi/i2s/i2s.c
new file mode 100644
index 0000000..a677ccc
--- /dev/null
+++ b/sound/soc/sunxi/i2s/i2s.c
@@ -0,0 +1,711 @@
+/*
+ * sound\soc\sunxi\i2s\sunxi-i2s.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/jiffies.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <mach/clock.h>
+#include <plat/system.h>
+#include <plat/sys_config.h>
+
+#include <mach/hardware.h>
+#include <asm/dma.h>
+#include <plat/dma_compat.h>
+
+#include "sunxi-i2sdma.h"
+#include "sunxi-i2s.h"
+
+static int regsave[8];
+static int i2s_used = 0;
+
+static struct sunxi_dma_params sunxi_i2s_pcm_stereo_out = {
+	.client.name	=	"I2S PCM Stereo out",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel	=	DMACH_NIIS,
+#endif
+	.dma_addr 	=	SUNXI_IISBASE + SUNXI_IISTXFIFO,
+};
+
+static struct sunxi_dma_params sunxi_i2s_pcm_stereo_in = {
+	.client.name	=	"I2S PCM Stereo in",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel	=	DMACH_NIIS,
+#endif
+	.dma_addr 	=	SUNXI_IISBASE + SUNXI_IISRXFIFO,
+};
+
+
+ struct sunxi_i2s_info sunxi_iis;
+static u32 i2s_handle = 0;
+ static struct clk *i2s_apbclk, *i2s_pll2clk, *i2s_pllx8, *i2s_moduleclk;
+
+void sunxi_snd_txctrl_i2s(struct snd_pcm_substream *substream, int on)
+{
+	u32 reg_val;
+
+	reg_val = readl(sunxi_iis.regs + SUNXI_TXCHSEL);
+	reg_val &= ~0x7;
+	reg_val |= SUNXI_TXCHSEL_CHNUM(substream->runtime->channels);
+	writel(reg_val, sunxi_iis.regs + SUNXI_TXCHSEL);
+
+	reg_val = readl(sunxi_iis.regs + SUNXI_TXCHMAP);
+	reg_val = 0;
+	if (sunxi_is_sun4i()) {
+		if(substream->runtime->channels == 1) {
+			reg_val = 0x76543200;
+		} else {
+			reg_val = 0x76543210;
+		}
+	} else {
+		if(substream->runtime->channels == 1) {
+			reg_val = 0x00000000;
+		} else {
+			reg_val = 0x00000010;
+		}
+	}
+	writel(reg_val, sunxi_iis.regs + SUNXI_TXCHMAP);
+
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	if (sunxi_is_sun4i()) {
+		reg_val &= ~SUNXI_IISCTL_SDO3EN;
+		reg_val &= ~SUNXI_IISCTL_SDO2EN;
+		reg_val &= ~SUNXI_IISCTL_SDO1EN;
+		reg_val &= ~SUNXI_IISCTL_SDO0EN;
+		switch(substream->runtime->channels) {
+			case 1:
+			case 2:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+				break;
+			case 3:
+			case 4:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+				reg_val |= SUNXI_IISCTL_SDO1EN;
+				break;
+			case 5:
+			case 6:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+				reg_val |= SUNXI_IISCTL_SDO1EN;
+				reg_val |= SUNXI_IISCTL_SDO2EN;
+				break;
+			case 7:
+			case 8:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+				reg_val |= SUNXI_IISCTL_SDO1EN;
+				reg_val |= SUNXI_IISCTL_SDO2EN;
+				reg_val |= SUNXI_IISCTL_SDO3EN;
+				break;
+			default:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+		}
+	} else {
+		reg_val |= SUNXI_IISCTL_SDO0EN;
+	}
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	//flush TX FIFO
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISFCTL);
+	reg_val |= SUNXI_IISFCTL_FTX;
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISFCTL);
+
+	//clear TX counter
+	writel(0, sunxi_iis.regs + SUNXI_IISTXCNT);
+
+	if (on) {
+		/* IIS TX ENABLE */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val |= SUNXI_IISCTL_TXEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+		/* enable DMA DRQ mode for play */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISINT);
+		reg_val |= SUNXI_IISINT_TXDRQEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISINT);
+
+		//Global Enable Digital Audio Interface
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val |= SUNXI_IISCTL_GEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	} else {
+		/* IIS TX DISABLE */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val &= ~SUNXI_IISCTL_TXEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+		/* DISBALE dma DRQ mode */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISINT);
+		reg_val &= ~SUNXI_IISINT_TXDRQEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISINT);
+
+		//Global disable Digital Audio Interface
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val &= ~SUNXI_IISCTL_GEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+	}
+}
+
+void sunxi_snd_rxctrl_i2s(int on)
+{
+	u32 reg_val;
+
+	//flush RX FIFO
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISFCTL);
+	reg_val |= SUNXI_IISFCTL_FRX;
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISFCTL);
+
+	//clear RX counter
+	writel(0, sunxi_iis.regs + SUNXI_IISRXCNT);
+
+	if (on) {
+		/* IIS RX ENABLE */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val |= SUNXI_IISCTL_RXEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+		/* enable DMA DRQ mode for record */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISINT);
+		reg_val |= SUNXI_IISINT_RXDRQEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISINT);
+
+		//Global Enable Digital Audio Interface
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val |= SUNXI_IISCTL_GEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	} else {
+		/* IIS RX DISABLE */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val &= ~SUNXI_IISCTL_RXEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+		/* DISBALE dma DRQ mode */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISINT);
+		reg_val &= ~SUNXI_IISINT_RXDRQEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISINT);
+
+		//Global disable Digital Audio Interface
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val &= ~SUNXI_IISCTL_GEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+	}
+}
+
+static inline int sunxi_snd_is_clkmaster(void)
+{
+	return ((readl(sunxi_iis.regs + SUNXI_IISCTL) & SUNXI_IISCTL_MS) ? 0 : 1);
+}
+
+static int sunxi_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	u32 reg_val;
+	u32 reg_val1;
+
+	//SDO ON
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	if (sunxi_is_sun4i()) {
+		reg_val |= (SUNXI_IISCTL_SDO0EN | SUNXI_IISCTL_SDO1EN |
+			    SUNXI_IISCTL_SDO2EN | SUNXI_IISCTL_SDO3EN);
+	} else {
+		reg_val |= SUNXI_IISCTL_SDO0EN;
+	}
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	/* master or slave selection */
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	switch(fmt & SND_SOC_DAIFMT_MASTER_MASK){
+		case SND_SOC_DAIFMT_CBM_CFM:   /* codec clk & frm master */
+			reg_val |= SUNXI_IISCTL_MS;
+			break;
+		case SND_SOC_DAIFMT_CBS_CFS:   /* codec clk & frm slave */
+			reg_val &= ~SUNXI_IISCTL_MS;
+			break;
+		default:
+			return -EINVAL;
+	}
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	/* pcm or i2s mode selection */
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	reg_val1 = readl(sunxi_iis.regs + SUNXI_IISFAT0);
+	reg_val1 &= ~SUNXI_IISFAT0_FMT_RVD;
+	switch(fmt & SND_SOC_DAIFMT_FORMAT_MASK){
+		case SND_SOC_DAIFMT_I2S:        /* I2S mode */
+			reg_val &= ~SUNXI_IISCTL_PCM;
+			reg_val1 |= SUNXI_IISFAT0_FMT_I2S;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:    /* Right Justified mode */
+			reg_val &= ~SUNXI_IISCTL_PCM;
+			reg_val1 |= SUNXI_IISFAT0_FMT_RGT;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:     /* Left Justified mode */
+			reg_val &= ~SUNXI_IISCTL_PCM;
+			reg_val1 |= SUNXI_IISFAT0_FMT_LFT;
+			break;
+		case SND_SOC_DAIFMT_DSP_A:      /* L data msb after FRM LRC */
+			reg_val |= SUNXI_IISCTL_PCM;
+			reg_val1 &= ~SUNXI_IISFAT0_LRCP;
+			break;
+		case SND_SOC_DAIFMT_DSP_B:      /* L data msb during FRM LRC */
+			reg_val |= SUNXI_IISCTL_PCM;
+			reg_val1 |= SUNXI_IISFAT0_LRCP;
+			break;
+		default:
+			return -EINVAL;
+	}
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+	writel(reg_val1, sunxi_iis.regs + SUNXI_IISFAT0);
+
+	/* DAI signal inversions */
+	reg_val1 = readl(sunxi_iis.regs + SUNXI_IISFAT0);
+	switch(fmt & SND_SOC_DAIFMT_INV_MASK){
+		case SND_SOC_DAIFMT_NB_NF:     /* normal bit clock + frame */
+			reg_val1 &= ~SUNXI_IISFAT0_LRCP;
+			reg_val1 &= ~SUNXI_IISFAT0_BCP;
+			break;
+		case SND_SOC_DAIFMT_NB_IF:     /* normal bclk + inv frm */
+			reg_val1 |= SUNXI_IISFAT0_LRCP;
+			reg_val1 &= ~SUNXI_IISFAT0_BCP;
+			break;
+		case SND_SOC_DAIFMT_IB_NF:     /* invert bclk + nor frm */
+			reg_val1 &= ~SUNXI_IISFAT0_LRCP;
+			reg_val1 |= SUNXI_IISFAT0_BCP;
+			break;
+		case SND_SOC_DAIFMT_IB_IF:     /* invert bclk + frm */
+			reg_val1 |= SUNXI_IISFAT0_LRCP;
+			reg_val1 |= SUNXI_IISFAT0_BCP;
+			break;
+	}
+	writel(reg_val1, sunxi_iis.regs + SUNXI_IISFAT0);
+
+	/* word select size */
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISFAT0);
+	reg_val &= ~SUNXI_IISFAT0_WSS_32BCLK;
+	if(sunxi_iis.ws_size == 16)
+		reg_val |= SUNXI_IISFAT0_WSS_16BCLK;
+	else if(sunxi_iis.ws_size == 20)
+		reg_val |= SUNXI_IISFAT0_WSS_20BCLK;
+	else if(sunxi_iis.ws_size == 24)
+		reg_val |= SUNXI_IISFAT0_WSS_24BCLK;
+	else
+		reg_val |= SUNXI_IISFAT0_WSS_32BCLK;
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISFAT0);
+
+	/* PCM REGISTER setup */
+	reg_val = sunxi_iis.pcm_txtype&0x3;
+	reg_val |= sunxi_iis.pcm_rxtype<<2;
+
+	if(!sunxi_iis.pcm_sync_type)
+		reg_val |= SUNXI_IISFAT1_SSYNC;							//short sync
+	if(sunxi_iis.pcm_sw == 16)
+		reg_val |= SUNXI_IISFAT1_SW;
+
+	reg_val |=((sunxi_iis.pcm_start_slot - 1)&0x3)<<6;		//start slot index
+
+	reg_val |= sunxi_iis.pcm_lsb_first<<9;			//MSB or LSB first
+
+	if(sunxi_iis.pcm_sync_period == 256)
+		reg_val |= 0x4<<12;
+	else if (sunxi_iis.pcm_sync_period == 128)
+		reg_val |= 0x3<<12;
+	else if (sunxi_iis.pcm_sync_period == 64)
+		reg_val |= 0x2<<12;
+	else if (sunxi_iis.pcm_sync_period == 32)
+		reg_val |= 0x1<<12;
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISFAT1);
+
+	/* set FIFO control register */
+	reg_val = 0 & 0x3;
+	reg_val |= (1 & 0x1)<<2;
+	reg_val |= SUNXI_IISFCTL_RXTL(0xf);				//RX FIFO trigger level
+	reg_val |= SUNXI_IISFCTL_TXTL(0x40);				//TX FIFO empty trigger level
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISFCTL);
+	return 0;
+}
+
+static int sunxi_i2s_hw_params(struct snd_pcm_substream *substream, 
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct sunxi_dma_params *dma_data;
+
+	/* play or record */
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_data = &sunxi_i2s_pcm_stereo_out;
+	else
+		dma_data = &sunxi_i2s_pcm_stereo_in;
+
+	snd_soc_dai_set_dma_data(rtd->cpu_dai, substream, dma_data);
+	return 0;
+}
+
+static int sunxi_i2s_trigger(struct snd_pcm_substream *substream,
+                              int cmd, struct snd_soc_dai *dai)
+{
+	int ret = 0;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct sunxi_dma_params *dma_data =
+					snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+				sunxi_snd_rxctrl_i2s(1);
+			} else {
+				sunxi_snd_txctrl_i2s(substream, 1);
+			}
+			sunxi_dma_started(dma_data);
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+				sunxi_snd_rxctrl_i2s(0);
+			} else {
+			  sunxi_snd_txctrl_i2s(substream, 0);
+			}
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+
+	return ret;
+}
+
+//freq:   1: 22.5792MHz   0: 24.576MHz
+static int sunxi_i2s_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id,
+                                 unsigned int freq, int dir)
+{
+	if (!freq) {
+		clk_set_rate(i2s_pll2clk, 24576000);
+	} else {
+		clk_set_rate(i2s_pll2clk, 22579200);
+	}
+
+	return 0;
+}
+
+static int sunxi_i2s_set_clkdiv(struct snd_soc_dai *cpu_dai, int div_id, int div)
+{
+	u32 reg;
+	switch (div_id) {
+		case SUNXI_DIV_MCLK:
+			if(div <= 8)
+				div  = (div >>1);
+			else if(div  == 12)
+				div  = 0x5;
+			else if(div  == 16)
+				div  = 0x6;
+			else if(div == 24)
+				div = 0x7;
+			else if(div == 32)
+				div = 0x8;
+			else if(div == 48)
+				div = 0x9;
+			else if(div == 64)
+				div = 0xa;
+			reg = (readl(sunxi_iis.regs + SUNXI_IISCLKD) & ~SUNXI_IISCLKD_MCLK_MASK) | (div << SUNXI_IISCLKD_MCLK_OFFS);
+			writel(reg, sunxi_iis.regs + SUNXI_IISCLKD);
+			break;
+		case SUNXI_DIV_BCLK:
+			if(div <= 8)
+				div = (div>>1) - 1;
+			else if(div == 12)
+				div = 0x4;
+			else if(div == 16)
+				div = 0x5;
+			else if(div == 32)
+				div = 0x6;
+			else if(div == 64)
+				div = 0x7;
+			reg = (readl(sunxi_iis.regs + SUNXI_IISCLKD) & ~SUNXI_IISCLKD_BCLK_MASK) | (div <<SUNXI_IISCLKD_BCLK_OFFS);
+			writel(reg, sunxi_iis.regs + SUNXI_IISCLKD);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	//diable MCLK output when high samplerate
+	reg = readl(sunxi_iis.regs + SUNXI_IISCLKD);
+	if (!(reg & 0xF)) {
+		reg &= ~SUNXI_IISCLKD_MCLKOEN;
+		writel(reg, sunxi_iis.regs + SUNXI_IISCLKD);
+	} else {
+		reg |= SUNXI_IISCLKD_MCLKOEN;
+		writel(reg, sunxi_iis.regs + SUNXI_IISCLKD);
+	}
+
+	return 0;
+}
+
+static int sunxi_i2s_dai_probe(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+static int sunxi_i2s_dai_remove(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void iisregsave(void)
+{
+	regsave[0] = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	regsave[1] = readl(sunxi_iis.regs + SUNXI_IISFAT0);
+	regsave[2] = readl(sunxi_iis.regs + SUNXI_IISFAT1);
+	regsave[3] = readl(sunxi_iis.regs + SUNXI_IISFCTL) | (0x3<<24);
+	regsave[4] = readl(sunxi_iis.regs + SUNXI_IISINT);
+	regsave[5] = readl(sunxi_iis.regs + SUNXI_IISCLKD);
+	regsave[6] = readl(sunxi_iis.regs + SUNXI_TXCHSEL);
+	regsave[7] = readl(sunxi_iis.regs + SUNXI_TXCHMAP);
+}
+
+static void iisregrestore(void)
+{
+	writel(regsave[0], sunxi_iis.regs + SUNXI_IISCTL);
+	writel(regsave[1], sunxi_iis.regs + SUNXI_IISFAT0);
+	writel(regsave[2], sunxi_iis.regs + SUNXI_IISFAT1);
+	writel(regsave[3], sunxi_iis.regs + SUNXI_IISFCTL);
+	writel(regsave[4], sunxi_iis.regs + SUNXI_IISINT);
+	writel(regsave[5], sunxi_iis.regs + SUNXI_IISCLKD);
+	writel(regsave[6], sunxi_iis.regs + SUNXI_TXCHSEL);
+	writel(regsave[7], sunxi_iis.regs + SUNXI_TXCHMAP);
+}
+
+static int sunxi_i2s_suspend(struct snd_soc_dai *cpu_dai)
+{
+	u32 reg_val;
+	printk("[IIS]Entered %s\n", __func__);
+
+	//Global Enable Digital Audio Interface
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	reg_val &= ~SUNXI_IISCTL_GEN;
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	iisregsave();
+
+	//release the module clock
+	clk_disable(i2s_moduleclk);
+
+	clk_disable(i2s_apbclk);
+
+	//printk("[IIS]PLL2 0x01c20008 = %#x\n", *(volatile int*)0xF1C20008);
+	printk("[IIS]SPECIAL CLK 0x01c20068 = %#x, line= %d\n", *(volatile int*)0xF1C20068, __LINE__);
+	printk("[IIS]SPECIAL CLK 0x01c200B8 = %#x, line = %d\n", *(volatile int*)0xF1C200B8, __LINE__);
+
+	return 0;
+}
+static int sunxi_i2s_resume(struct snd_soc_dai *cpu_dai)
+{
+	u32 reg_val;
+	printk("[IIS]Entered %s\n", __func__);
+
+	//release the module clock
+	clk_enable(i2s_apbclk);
+
+	//release the module clock
+	clk_enable(i2s_moduleclk);
+
+	iisregrestore();
+
+	//Global Enable Digital Audio Interface
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	reg_val |= SUNXI_IISCTL_GEN;
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	//printk("[IIS]PLL2 0x01c20008 = %#x\n", *(volatile int*)0xF1C20008);
+	printk("[IIS]SPECIAL CLK 0x01c20068 = %#x, line= %d\n", *(volatile int*)0xF1C20068, __LINE__);
+	printk("[IIS]SPECIAL CLK 0x01c200B8 = %#x, line = %d\n", *(volatile int*)0xF1C200B8, __LINE__);
+
+	return 0;
+}
+
+#define SUNXI_I2S_RATES (SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT)
+static struct snd_soc_dai_ops sunxi_iis_dai_ops = {
+	.trigger 	= sunxi_i2s_trigger,
+	.hw_params 	= sunxi_i2s_hw_params,
+	.set_fmt 	= sunxi_i2s_set_fmt,
+	.set_clkdiv = sunxi_i2s_set_clkdiv,
+	.set_sysclk = sunxi_i2s_set_sysclk,
+};
+
+static struct snd_soc_dai_driver sunxi_iis_dai = {
+	.probe 		= sunxi_i2s_dai_probe,
+	.suspend 	= sunxi_i2s_suspend,
+	.resume 	= sunxi_i2s_resume,
+	.remove 	= sunxi_i2s_dai_remove,
+	.playback 	= {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.capture 	= {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.symmetric_rates = 1,
+	.ops 		= &sunxi_iis_dai_ops,
+};
+
+static int __devinit sunxi_i2s_dev_probe(struct platform_device *pdev)
+{
+	int reg_val = 0;
+	int ret;
+
+	sunxi_iis.regs = ioremap(SUNXI_IISBASE, 0x100);
+	if (sunxi_iis.regs == NULL)
+		return -ENXIO;
+
+	//i2s apbclk
+	i2s_apbclk = clk_get(NULL, "apb_i2s");
+	if(-1 == clk_enable(i2s_apbclk)){
+		printk("i2s_apbclk failed! line = %d\n", __LINE__);
+		goto out;
+	}
+
+	i2s_pllx8 = clk_get(NULL, "audio_pllx8");
+
+	//i2s pll2clk
+	i2s_pll2clk = clk_get(NULL, "audio_pll");
+
+	//i2s module clk
+	i2s_moduleclk = clk_get(NULL, "i2s");
+
+	if(clk_set_parent(i2s_moduleclk, i2s_pll2clk)){
+		printk("try to set parent of i2s_moduleclk to i2s_pll2ck failed! line = %d\n",__LINE__);
+		goto out1;
+	}
+
+	if(clk_set_rate(i2s_moduleclk, 24576000/8)){
+		printk("set i2s_moduleclk clock freq to 24576000 failed! line = %d\n", __LINE__);
+		goto out1;
+	}
+
+	if(-1 == clk_enable(i2s_moduleclk)){
+		printk("open i2s_moduleclk failed! line = %d\n", __LINE__);
+		goto out1;
+	}
+
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	reg_val |= SUNXI_IISCTL_GEN;
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	iounmap(sunxi_iis.ioregs);
+	ret = snd_soc_register_dai(&pdev->dev, &sunxi_iis_dai);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register DAI\n");
+		goto out2;
+	}
+
+	goto out;
+	out2:
+		clk_disable(i2s_moduleclk);
+	out1:
+		clk_disable(i2s_apbclk);
+	out:
+	return 0;
+}
+
+static int __devexit sunxi_i2s_dev_remove(struct platform_device *pdev)
+{
+	if(i2s_used) {
+		i2s_used = 0;
+		//release the module clock
+		clk_disable(i2s_moduleclk);
+
+		//release pllx8clk
+		clk_put(i2s_pllx8);
+
+		//release pll2clk
+		clk_put(i2s_pll2clk);
+
+		//release apbclk
+		clk_put(i2s_apbclk);
+
+		gpio_release(i2s_handle, 2);
+		snd_soc_unregister_dai(&pdev->dev);
+		platform_set_drvdata(pdev, NULL);
+	}
+	return 0;
+}
+
+/*data relating*/
+static struct platform_device sunxi_i2s_device = {
+	.name = "sunxi-i2s",
+};
+
+/*method relating*/
+static struct platform_driver sunxi_i2s_driver = {
+	.probe = sunxi_i2s_dev_probe,
+	.remove = __devexit_p(sunxi_i2s_dev_remove),
+	.driver = {
+		.name = "sunxi-i2s",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init sunxi_i2s_init(void)
+{
+	int err = 0;
+	int ret;
+
+	ret = script_parser_fetch("i2s_para","i2s_used", &i2s_used, sizeof(int));
+	if (ret) {
+        printk("[I2S]sunxi_i2s_init fetch i2s using configuration failed\n");
+    }
+
+ 	if (i2s_used) {
+		i2s_handle = gpio_request_ex("i2s_para", NULL);
+
+		if((err = platform_device_register(&sunxi_i2s_device)) < 0)
+			return err;
+
+		if ((err = platform_driver_register(&sunxi_i2s_driver)) < 0)
+			return err;
+	} else {
+        printk("[I2S]sunxi-i2s cannot find any using configuration for controllers, return directly!\n");
+        return 0;
+    }
+	return 0;
+}
+module_init(sunxi_i2s_init);
+
+static void __exit sunxi_i2s_exit(void)
+{
+	platform_driver_unregister(&sunxi_i2s_driver);
+}
+module_exit(sunxi_i2s_exit);
+
+/* Module information */
+MODULE_AUTHOR("ALLWINNER");
+MODULE_DESCRIPTION("sunxi I2S SoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-i2s");
+
diff --git a/sound/soc/sunxi/i2s/i2s.h b/sound/soc/sunxi/i2s/i2s.h
new file mode 100644
index 0000000..f12d6d5
--- /dev/null
+++ b/sound/soc/sunxi/i2s/i2s.h
@@ -0,0 +1,304 @@
+/*
+ * sound\soc\sunxi\i2s\sunxi-i2s.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef SUNXI_I2S_H_
+#define SUNXI_I2S_H_
+
+/*------------------------------------------------------------*/
+/* REGISTER definition */
+
+/* IIS REGISTER */
+#define SUNXI_IISBASE 		(0x01C22400)
+
+#define SUNXI_IISCTL 	  (0x00)
+	#define SUNXI_IISCTL_SDO3EN		(1<<11)
+	#define SUNXI_IISCTL_SDO2EN		(1<<10)
+	#define SUNXI_IISCTL_SDO1EN		(1<<9)
+	#define SUNXI_IISCTL_SDO0EN		(1<<8)
+	#define SUNXI_IISCTL_ASS			(1<<6)
+	#define SUNXI_IISCTL_MS			(1<<5)
+	#define SUNXI_IISCTL_PCM			(1<<4)
+	#define SUNXI_IISCTL_LOOP			(1<<3)
+	#define SUNXI_IISCTL_TXEN			(1<<2)
+	#define SUNXI_IISCTL_RXEN			(1<<1)
+	#define SUNXI_IISCTL_GEN			(1<<0)
+
+#define SUNXI_IISFAT0 		(0x04)
+	#define SUNXI_IISFAT0_LRCP					(1<<7)
+	#define SUNXI_IISFAT0_BCP					(1<<6)
+	#define SUNXI_IISFAT0_SR_RVD				(3<<4)
+	#define SUNXI_IISFAT0_SR_16BIT				(0<<4)
+	#define	SUNXI_IISFAT0_SR_20BIT				(1<<4)
+	#define SUNXI_IISFAT0_SR_24BIT				(2<<4)
+	#define SUNXI_IISFAT0_WSS_16BCLK			(0<<2)
+	#define SUNXI_IISFAT0_WSS_20BCLK			(1<<2)
+	#define SUNXI_IISFAT0_WSS_24BCLK			(2<<2)
+	#define SUNXI_IISFAT0_WSS_32BCLK			(3<<2)
+	#define SUNXI_IISFAT0_FMT_I2S				(0<<0)
+	#define SUNXI_IISFAT0_FMT_LFT				(1<<0)
+	#define SUNXI_IISFAT0_FMT_RGT				(2<<0)
+	#define SUNXI_IISFAT0_FMT_RVD				(3<<0)
+
+#define SUNXI_IISFAT1		(0x08)
+	#define SUNXI_IISFAT1_SYNCLEN_16BCLK		(0<<12)
+	#define SUNXI_IISFAT1_SYNCLEN_32BCLK		(1<<12)
+	#define SUNXI_IISFAT1_SYNCLEN_64BCLK		(2<<12)
+	#define SUNXI_IISFAT1_SYNCLEN_128BCLK		(3<<12)
+	#define SUNXI_IISFAT1_SYNCLEN_256BCLK		(4<<12)
+	#define SUNXI_IISFAT1_SYNCOUTEN			(1<<11)
+	#define SUNXI_IISFAT1_OUTMUTE 				(1<<10)
+	#define SUNXI_IISFAT1_MLS		 			(1<<9)
+	#define SUNXI_IISFAT1_SEXT		 			(1<<8)
+	#define SUNXI_IISFAT1_SI_1ST				(0<<6)
+	#define SUNXI_IISFAT1_SI_2ND			 	(1<<6)
+	#define SUNXI_IISFAT1_SI_3RD			 	(2<<6)
+	#define SUNXI_IISFAT1_SI_4TH			 	(3<<6)
+	#define SUNXI_IISFAT1_SW			 		(1<<5)
+	#define SUNXI_IISFAT1_SSYNC	 			(1<<4)
+	#define SUNXI_IISFAT1_RXPDM_16PCM			(0<<2)
+	#define SUNXI_IISFAT1_RXPDM_8PCM			(1<<2)
+	#define SUNXI_IISFAT1_RXPDM_8ULAW			(2<<2)
+	#define SUNXI_IISFAT1_RXPDM_8ALAW  		(3<<2)
+	#define SUNXI_IISFAT1_TXPDM_16PCM			(0<<0)
+	#define SUNXI_IISFAT1_TXPDM_8PCM			(1<<0)
+	#define SUNXI_IISFAT1_TXPDM_8ULAW			(2<<0)
+	#define SUNXI_IISFAT1_TXPDM_8ALAW  		(3<<0)
+
+#define SUNXI_IISTXFIFO 	(0x0C)
+
+#define SUNXI_IISRXFIFO 	(0x10)
+
+#define SUNXI_IISFCTL  	(0x14)
+	#define SUNXI_IISFCTL_FIFOSRC			(1<<31)
+	#define SUNXI_IISFCTL_FTX				(1<<25)
+	#define SUNXI_IISFCTL_FRX				(1<<24)
+	#define SUNXI_IISFCTL_TXTL(v)			((v)<<12)
+	#define SUNXI_IISFCTL_RXTL(v)  		((v)<<4)
+	#define SUNXI_IISFCTL_TXIM_MOD0		(0<<2)
+	#define SUNXI_IISFCTL_TXIM_MOD1		(1<<2)
+	#define SUNXI_IISFCTL_RXOM_MOD0		(0<<0)
+	#define SUNXI_IISFCTL_RXOM_MOD1		(1<<0)
+	#define SUNXI_IISFCTL_RXOM_MOD2		(2<<0)
+	#define SUNXI_IISFCTL_RXOM_MOD3		(3<<0)
+
+#define SUNXI_IISFSTA   	(0x18)
+	#define SUNXI_IISFSTA_TXE				(1<<28)
+	#define SUNXI_IISFSTA_TXECNT(v)		((v)<<16)
+	#define SUNXI_IISFSTA_RXA				(1<<8)
+	#define SUNXI_IISFSTA_RXACNT(v)		((v)<<0)
+
+#define SUNXI_IISINT    	(0x1C)
+	#define SUNXI_IISINT_TXDRQEN				(1<<7)
+	#define SUNXI_IISINT_TXUIEN				(1<<6)
+	#define SUNXI_IISINT_TXOIEN				(1<<5)
+	#define SUNXI_IISINT_TXEIEN				(1<<4)
+	#define SUNXI_IISINT_RXDRQEN				(1<<2)
+	#define SUNXI_IISINT_RXOIEN				(1<<1)
+	#define SUNXI_IISINT_RXAIEN				(1<<0)
+
+#define SUNXI_IISISTA   	(0x20)
+	#define SUNXI_IISISTA_TXUISTA			(1<<6)
+	#define SUNXI_IISISTA_TXOISTA			(1<<5)
+	#define SUNXI_IISISTA_TXEISTA			(1<<4)
+	#define SUNXI_IISISTA_RXOISTA			(1<<1)
+	#define SUNXI_IISISTA_RXAISTA			(1<<0)
+
+#define SUNXI_IISCLKD   	(0x24)
+	#define SUNXI_IISCLKD_MCLKOEN			(1<<7)
+	#define SUNXI_IISCLKD_BCLKDIV_2		(0<<4)
+	#define SUNXI_IISCLKD_BCLKDIV_4		(1<<4)
+	#define SUNXI_IISCLKD_BCLKDIV_6		(2<<4)
+	#define SUNXI_IISCLKD_BCLKDIV_8		(3<<4)
+	#define SUNXI_IISCLKD_BCLKDIV_12		(4<<4)
+	#define SUNXI_IISCLKD_BCLKDIV_16		(5<<4)
+	#define SUNXI_IISCLKD_BCLKDIV_32		(6<<4)
+	#define SUNXI_IISCLKD_BCLKDIV_64		(7<<4)
+	#define SUNXI_IISCLKD_MCLKDIV_1		(0<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_2		(1<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_4		(2<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_6		(3<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_8		(4<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_12		(5<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_16		(6<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_24		(7<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_32		(8<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_48		(9<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_64		(10<<0)
+
+#define SUNXI_IISTXCNT  	(0x28)
+
+#define SUNXI_IISRXCNT  	(0x2C)
+
+#define SUNXI_TXCHSEL		(0x30)
+	#define SUNXI_TXCHSEL_CHNUM(v)			(((v)-1)<<0)
+
+#define SUNXI_TXCHMAP		(0x34)
+	#define SUNXI_TXCHMAP_CH7(v)			(((v)-1)<<28)
+	#define SUNXI_TXCHMAP_CH6(v)			(((v)-1)<<24)
+	#define SUNXI_TXCHMAP_CH5(v)			(((v)-1)<<20)
+	#define SUNXI_TXCHMAP_CH4(v)			(((v)-1)<<16)
+	#define SUNXI_TXCHMAP_CH3(v)			(((v)-1)<<12)
+	#define SUNXI_TXCHMAP_CH2(v)			(((v)-1)<<8)
+	#define SUNXI_TXCHMAP_CH1(v)			(((v)-1)<<4)
+	#define SUNXI_TXCHMAP_CH0(v)			(((v)-1)<<0)
+
+#define SUNXI_RXCHSEL		(0x38)
+	#define SUNXI_RXCHSEL_CHNUM(v)			(((v)-1)<<0)
+
+#define SUNXI_RXCHMAP		(0x3C)
+	#define SUNXI_RXCHMAP_CH3(v)			(((v)-1)<<12)
+	#define SUNXI_RXCHMAP_CH2(v)			(((v)-1)<<8)
+	#define SUNXI_RXCHMAP_CH1(v)			(((v)-1)<<4)
+	#define SUNXI_RXCHMAP_CH0(v)			(((v)-1)<<0)
+
+
+/* DMA REGISTER */
+#define SUNXI_DMABASE	(0x01C02000)
+
+#define SUNXI_DMAIRQEN						(0x0)
+	#define SUNXI_DMAIRQEN_NDMA_FULLEN(v)				(1<<((v)*2+1))
+	#define SUNXI_DMAIRQEN_NDMA_HALFEN(v)				(1<<((v)*2))
+
+#define SUNXI_DMAIRQPENDING	 		(0x4)
+	#define SUNXI_DMAIRQPENGDING_NDMA_FULLPEND(v)		(1<<((v)*2+1))
+	#define SUNXI_DMAIRQPENGDING_NDMA_HALFPEND(v)		(1<<((v)*2))
+
+#define SUNXI_NDMACFG(v)				((v)*0x20+0x100)
+	#define SUNXI_NDMACFG_DMALOAD					(1<<31)
+	#define SUNXI_NDMACFG_BUSY						(1<<30)
+	#define SUNXI_NDMACFG_CONTINUOUS				(1<<29)
+	#define SUNXI_NDMACFG_WAIT(v)					(((v)-1)<<26)   //wait clock = 2^n  example: 8 clocks = 2^3
+	#define SUNXI_NDMACFG_DSTDATAWIDTH_8BIT		(0<<24)
+	#define SUNXI_NDMACFG_DSTDATAWIDTH_16BIT		(1<<24)
+	#define SUNXI_NDMACFG_DSTDATAWIDTH_32BIT		(2<<24)
+	#define SUNXI_NDMACFG_DSTDATAWIDTH_RVD			(3<<24)
+	#define SUNXI_NDMACFG_DSTBURST4				(1<<23)
+	#define SUNXI_NDMACFG_DSTADDRTYPE_INC			(0<<21)
+	#define SUNXI_NDMACFG_DSTADDRTYPE_CON 			(1<<21)
+	#define SUNXI_NDMACFG_DSTTYPE_IRTX				(0x0<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SPDIFTX			(0x1<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_IISTX			(0x2<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_AC97TX			(0x3<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SPI0TX 			(0x4<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SPI1TX			(0x5<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SPI2TX			(0x6<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART0TX			(0x8<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART1TX			(0x9<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART2TX			(0xA<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART3TX			(0xB<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_AUDIODA			(0xC<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_NFC				(0xF<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SRAM				(0x10<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_DRAM				(0x11<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART4TX			(0x12<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART5TX          (0x13<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART6TX			(0x14<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART7TX			(0x15<<16)
+	#define SUNXI_NDMACFG_SRCDATAWIDTH_8BIT		(0<<8)
+	#define SUNXI_NDMACFG_SRCDATAWIDTH_16BIT		(1<<8)
+	#define SUNXI_NDMACFG_SRCDATAWIDTH_32BIT		(2<<8)
+	#define SUNXI_NDMACFG_SRCDATAWIDTH_RVD			(3<<8)
+	#define SUNXI_NDMACFG_SRCBURST4				(1<<7)
+	#define SUNXI_NDMACFG_SRCADDRTYPE_INC			(0<<5)
+	#define SUNXI_NDMACFG_SRCADDRTYPE_CON 			(1<<5)
+	#define SUNXI_NDMACFG_SRCTYPE_IRRX				(0x0<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SPDIFRX			(0x1<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_IISRX			(0x2<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_AC97RX			(0x3<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SPI0RX 			(0x4<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SPI1RX			(0x5<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SPI2RX			(0x6<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART0RX			(0x8<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART1RX			(0x9<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART2RX			(0xA<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART3RX			(0xB<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_AUDIOAD			(0xC<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_TPAD				(0xD<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_NFC				(0xF<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SRAM				(0x10<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_DRAM				(0x11<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART4RX			(0x12<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART5RX			(0x13<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART6RX			(0x14<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART7RX			(0x15<<0)
+
+#define SUNXI_NDMASRCADDR(v)				((v)*0x20 + 0x100 + 4)
+
+#define SUNXI_NDMADSTADDR(v)				((v)*0x20 + 0x100 + 8)
+
+#define SUNXI_NDMACNT(v)				((v)*0x20 + 0x100 + 0xC)
+
+
+/* CCM REGISTER */
+#define SUNXI_CCMBASE    (0x01C20000)
+
+#define SUNXI_CCM_AUDIO_HOSC_PLL_REG   (0x08)
+	#define SUNXI_CCM_AUDIO_HOSC_PLL_REG_AUDIOEN		(1<<31)
+	#define SUNXI_CCM_AUDIO_HOSC_PLL_REG_FRE225792MHZ	(0<<27)
+	#define SUNXI_CCM_AUDIO_HOSC_PLL_REG_FRE24576MHZ	(1<<27)
+
+#define SUNXI_CCM_APB_GATE_REG    		 (0x68)
+	#define SUNXI_CCM_APB_GATE_REG_IISGATE				(1<<3)
+
+#define SUNXI_CCM_AUDIO_CLK_REG				(0xb8)
+	#define SUNXI_CCM_AUDIO_CLK_REG_IISSPECIALGATE		(1<<31)
+	#define SUNXI_CCM_AUDIO_CLK_REG_DIV(v)					((v)<<16)
+/*------------------------------------------------------------*/
+
+/*------------------------------------------------------------*/
+/* Clock dividers */
+#define SUNXI_DIV_MCLK	0
+#define SUNXI_DIV_BCLK	1
+
+#define SUNXI_IISCLKD_MCLK_MASK   0x0f
+#define SUNXI_IISCLKD_MCLK_OFFS   0
+#define SUNXI_IISCLKD_BCLK_MASK   0x070
+#define SUNXI_IISCLKD_BCLK_OFFS   4
+#define SUNXI_IISCLKD_MCLKEN_OFFS 7
+
+unsigned int sunxi_i2s_get_clockrate(void);
+extern struct sunxi_i2s_info sunxi_i2s;
+//extern struct snd_soc_dai sunxi_iis_dai;
+
+extern void sunxi_snd_txctrl_i2s(struct snd_pcm_substream *substream, int on);
+extern void sunxi_snd_rxctrl_i2s(int on);
+
+struct sunxi_i2s_info {
+	void __iomem   *regs;    /* IIS BASE */
+	void __iomem   *ccmregs;  //CCM BASE
+	void __iomem   *ioregs;   //IO BASE
+
+	u32 slave;					//0: master, 1: slave
+	u32 mono;					//0: stereo, 1: mono
+	u32 samp_fs;				//audio sample rate (unit in kHz)
+	u32 samp_res;			//16 bits, 20 bits , 24 bits, 32 bits)
+	u32 samp_format;		//audio sample format (0: standard I2S, 1: left-justified, 2: right-justified, 3: pcm)
+	u32 ws_size;				//16 BCLK, 20 BCLK, 24 BCLK, 32 BCLK)
+	u32 mclk_rate;			//mclk frequency divide by fs (128fs, 192fs, 256fs, 384fs, 512fs, 768fs)
+	u32 lrc_pol;				//LRC clock polarity (0: normal ,1: inverted)
+	u32 bclk_pol;			//BCLK polarity (0: normal, 1: inverted)
+	u32 pcm_txtype;		//PCM transmitter type (0: 16-bits linear mode, 1: 8-bits linear mode, 2: u-law, 3: A-law)
+	u32 pcm_rxtype;		//PCM receiver type  (0: 16-bits linear mode, 1: 8-bits linear mode, 2: u-law, 3: A-law)
+	u32 pcm_sw;				//PCM slot width (8: 8 bits, 16: 16 bits)
+	u32 pcm_sync_period;//PCM sync period (16/32/64/128/256)
+	u32 pcm_sync_type;	//PCM sync symbol size (0: short sync, 1: long sync)
+	u32 pcm_start_slot;//PCM start slot index (1--4)
+	u32 pcm_lsb_first;	//0: MSB first, 1: LSB first
+	u32 pcm_ch_num;		//PCM channel number (1: one channel, 2: two channel)
+
+};
+
+extern struct sunxi_i2s_info sunxi_i2s;
+#endif
diff --git a/sound/soc/sunxi/sunxi-codec.c b/sound/soc/sunxi/sunxi-codec.c
new file mode 100644
index 0000000..7bf2275
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-codec.c
@@ -0,0 +1,714 @@
+/*
+ * Copyright 2014 Emilio Lpez <emilio@elopez.com.ar>
+ * Copyright 2014 Jon Smirl <jonsmirl@gmail.com>
+ *
+ * Based on the Allwinner SDK driver, released under the GPL.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/clk.h>
+#include <linux/regmap.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+
+/* Codec register offsets and bit fields */
+#define SUNXI_DAC_DPC		(0x00)
+#define EN_DA				(31)
+#define DAC_VERSION			(23) /* For CODEC OLD VERSION */
+#define DVOL				(12)
+#define SUNXI_DAC_FIFOC		(0x04)
+#define DAC_FS				(29)
+#define FIR_VERSION			(28)
+#define SEND_LASAT			(26)
+#define TX_FIFO_MODE			(24)
+#define DAC_DRQ_CLR_CNT			(21)
+#define TX_TRIG_LEVEL			(8)
+#define DAC_MONO_EN			(6)
+#define TX_SAMPLE_BITS			(5)
+#define DAC_DRQ_EN			(4)
+#define DAC_FIFO_FLUSH			(0)
+#define SUNXI_DAC_FIFOS		(0x08)
+#define SUNXI_DAC_TXDATA	(0x0c)
+#define SUNXI_DAC_ACTL		(0x10)
+#define DACAENR				(31)
+#define DACAENL				(30)
+#define MIXEN				(29)
+#define DACPAS				(8)
+#define MIXPAS				(7)
+#define PA_MUTE				(6)
+#define PAVOL				(0)
+#define SUNXI_DAC_TUNE		(0x14)
+#define SUNXI_DAC_DEBUG		(0x18)
+#define SUNXI_ADC_FIFOC		(0x1c)
+#define EN_AD				(28)
+#define RX_FIFO_MODE			(24)
+#define RX_TRIG_LEVEL			(8)
+#define ADC_MONO_EN			(7)
+#define RX_SAMPLE_BITS			(6)
+#define ADC_DRQ_EN			(4)
+#define ADC_FIFO_FLUSH			(0)
+#define SUNXI_ADC_FIFOS		(0x20)
+#define SUNXI_ADC_RXDATA	(0x24)
+#define SUNXI_ADC_ACTL		(0x28)
+#define ADCREN				(31)
+#define ADCLEN				(30)
+#define PREG1EN				(29)
+#define PREG2EN				(28)
+#define VMICEN				(27)
+#define ADCG				(20)
+#define ADCIS				(17)
+#define PA_EN				(4)
+#define DDE				(3)
+#define SUNXI_ADC_DEBUG		(0x2c)
+#define SUNXI_DAC_TXCNT		(0x30)
+#define SUNXI_ADC_RXCNT		(0x34)
+#define SUNXI_AC_SYS_VERI	(0x38)
+#define SUNXI_AC_MIC_PHONE_CAL	(0x3c)
+
+/* Supported SoC families - used for quirks */
+enum sunxi_soc_family {
+	SUN4IA,	/* A10 SoC - revision A */
+	SUN4I,	/* A10 SoC - later revisions */
+	SUN5I,	/* A10S/A13 SoCs */
+	SUN7I,	/* A20 SoC */
+};
+
+struct sunxi_priv {
+	struct regmap *regmap;
+	struct clk *clk_apb, *clk_pll2, *clk_module;
+
+	enum sunxi_soc_family revision;
+
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+};
+
+static int codec_play_start(struct sunxi_priv *priv)
+{
+	/* FIXME: drive PA gpio high */
+
+	/* flush TX FIFO */
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_FIFO_FLUSH, 0x1 << DAC_FIFO_FLUSH);
+
+	/* enable DAC DRQ */
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_DRQ_EN, 0x1 << DAC_DRQ_EN);
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x1 << PA_MUTE);
+
+	return 0;
+}
+
+static int codec_play_stop(struct sunxi_priv *priv)
+{
+	/* FIXME: drive PA gpio low */
+
+	/* mute PA */
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
+	mdelay(5);
+
+	/* disable DAC DRQ */
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_DRQ_EN, 0x0 << DAC_DRQ_EN);
+
+	/* mute PA */
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAENL, 0x0 << DACAENL);
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAENR, 0x0 << DACAENR);
+
+	return 0;
+}
+
+static int codec_capture_start(struct sunxi_priv *priv)
+{
+	/* FIXME: drive PA gpio high */
+
+	/* enable ADC DRQ */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DRQ_EN, 0x1 << ADC_DRQ_EN);
+
+	return 0;
+}
+
+static int codec_capture_stop(struct sunxi_priv *priv)
+{
+	/* disable ADC DRQ */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DRQ_EN, 0x0 << ADC_DRQ_EN);
+
+	/* enable mic1 PA */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << PREG1EN, 0x0 << PREG1EN);
+
+	/* enable VMIC */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << VMICEN, 0x0 << VMICEN);
+	if (priv->revision == SUN7I) {
+		/* FIXME - undocumented */
+		regmap_update_bits(priv->regmap, SUNXI_DAC_TUNE, 0x3 << 8, 0x0 << 8);
+	}
+
+	/* enable ADC digital */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << EN_AD, 0x0 << EN_AD);
+
+	/* set RX FIFO mode */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << RX_FIFO_MODE, 0x0 << RX_FIFO_MODE);
+
+	/* flush RX FIFO */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_FIFO_FLUSH, 0x0 << ADC_FIFO_FLUSH);
+
+	/* enable adc1 analog */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << ADCLEN, 0x0 << ADCLEN);
+
+	return 0;
+}
+
+static int sunxi_codec_trigger(struct snd_pcm_substream *substream, int cmd,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			codec_capture_start(priv);
+		else
+			codec_play_start(priv);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			codec_capture_stop(priv);
+		else
+			codec_play_stop(priv);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_prepare(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1 << EN_DA, 0x1 << EN_DA);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_FIFO_FLUSH, 0x1 << DAC_FIFO_FLUSH);
+		/* set TX FIFO send DRQ level */
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x3f << TX_TRIG_LEVEL, 0xf << TX_TRIG_LEVEL);
+		if (substream->runtime->rate > 32000) {
+			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << FIR_VERSION, 0x0 << FIR_VERSION);
+		} else {
+			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << FIR_VERSION, 0x1 << FIR_VERSION);
+		}
+		/* set TX FIFO MODE - 0 works for both 16 and 24 bits */
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << TX_FIFO_MODE, 0x0 << TX_FIFO_MODE);
+		/* send last sample when DAC FIFO under run */
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << SEND_LASAT, 0x0 << SEND_LASAT);
+		/* enable dac analog */
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAENL, 0x1 << DACAENL);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAENR, 0x1 << DACAENR);
+		/* enable DAC to PA */
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACPAS, 0x1 << DACPAS);
+	} else {
+		/* enable mic1 PA */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << PREG1EN, 0x1 << PREG1EN);
+		/* mic1 gain 32dB */  /* FIXME - makes no sense */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << 25, 0x1 << 25);
+		/* enable VMIC */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << VMICEN, 0x1 << VMICEN);
+
+		if (priv->revision == SUN7I) {
+			/* boost up record effect */
+			regmap_update_bits(priv->regmap, SUNXI_DAC_TUNE, 0x3 << 8, 0x1 << 8);
+		}
+
+		/* enable ADC digital */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << EN_AD, 0x1 << EN_AD);
+		/* set RX FIFO mode */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << RX_FIFO_MODE, 0x1 << RX_FIFO_MODE);
+		/* flush RX FIFO */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_FIFO_FLUSH, 0x1 << ADC_FIFO_FLUSH);
+		/* set RX FIFO rec drq level */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0xf << RX_TRIG_LEVEL, 0x7 << RX_TRIG_LEVEL);
+		/* enable adc1 analog */
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << ADCLEN, 0x3 << ADCLEN);
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+	int is_mono = !!(params_channels(params) == 1);
+	int is_24bit = !!(hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS)->min == 32);
+	unsigned int rate = params_rate(params);
+	unsigned int hwrate;
+
+	switch (rate) {
+	case 176400:
+	case 88200:
+	case 44100:
+	case 33075:
+	case 22050:
+	case 14700:
+	case 11025:
+	case 7350:
+	default:
+		clk_set_rate(priv->clk_pll2, 22579200);
+		clk_set_rate(priv->clk_module, 22579200);
+		break;
+	case 192000:
+	case 96000:
+	case 48000:
+	case 32000:
+	case 24000:
+	case 16000:
+	case 12000:
+	case 8000:
+		clk_set_rate(priv->clk_pll2, 24576000);
+		clk_set_rate(priv->clk_module, 24576000);
+		break;
+	}
+
+	switch (rate) {
+	case 192000:
+	case 176400:
+		hwrate = 6;
+		break;
+	case 96000:
+	case 88200:
+		hwrate = 7;
+		break;
+	default:
+	case 48000:
+	case 44100:
+		hwrate = 0;
+		break;
+	case 32000:
+	case 33075:
+		hwrate = 1;
+		break;
+	case 24000:
+	case 22050:
+		hwrate = 2;
+		break;
+	case 16000:
+	case 14700:
+		hwrate = 3;
+		break;
+	case 12000:
+	case 11025:
+		hwrate = 4;
+		break;
+	case 8000:
+	case 7350:
+		hwrate = 5;
+		break;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 7 << DAC_FS, hwrate << DAC_FS);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << DAC_MONO_EN, is_mono << DAC_MONO_EN);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << TX_SAMPLE_BITS, is_24bit << TX_SAMPLE_BITS);
+		if (is_24bit)
+			priv->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		else
+			priv->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	} else  {
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 7 << DAC_FS, hwrate << DAC_FS);
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 1 << ADC_MONO_EN, is_mono << ADC_MONO_EN);
+	}
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new sun7i_dac_ctls[] = {
+	/*SUNXI_DAC_ACTL = 0x10,PAVOL*/
+	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0),
+	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), /* Global output switch */
+	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), /* FM left switch */
+	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), /* FM right switch */
+	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), /* Line left switch */
+	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), /* Line right switch */
+	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0),
+	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0),
+	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
+	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), /* from bit 9 to bit 12. Microphone input mute */
+	SOC_SINGLE("MIC output volume", SUNXI_DAC_ACTL, 20, 7, 0),
+	/*	FM Input to output mixer Gain Control
+	* 	From -4.5db to 6db,1.5db/step,default is 0db
+	*	-4.5db:0x0,-3.0db:0x1,-1.5db:0x2,0db:0x3
+	*	1.5db:0x4,3.0db:0x5,4.5db:0x6,6db:0x7
+	*/
+	SOC_SINGLE("Fm output Volume", SUNXI_DAC_ACTL, 23, 7, 0),
+	/*	Line-in gain stage to output mixer Gain Control
+	*	0:-1.5db,1:0db
+	*/
+	SOC_SINGLE("Line output Volume", SUNXI_DAC_ACTL, 26, 1, 0),
+
+	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0),
+	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0),
+	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0),
+	SOC_SINGLE("Linein Pre-AMP", SUNXI_ADC_ACTL, 13, 7, 0),
+	SOC_SINGLE("LINEIN APM Volume", SUNXI_AC_MIC_PHONE_CAL, 13, 0x7, 0),
+	/* ADC Input Gain Control, capture volume
+	* 000:-4.5db,001:-3db,010:-1.5db,011:0db,100:1.5db,101:3db,110:4.5db,111:6db
+	*/
+	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0),
+	/*
+	*	MIC2 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), /* Microphone left volume */
+	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), /* Microphone right volume */
+	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0),
+	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0),
+	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0),
+	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), /* ADC input mute */
+	SOC_SINGLE("Mic2 gain Volume", SUNXI_AC_MIC_PHONE_CAL, 26, 7, 0),
+	/*
+	*	MIC1 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	SOC_SINGLE("Mic1 gain Volume", SUNXI_AC_MIC_PHONE_CAL, 29, 3, 0),
+};
+
+static int sunxi_codec_dai_probe(struct snd_soc_dai *dai)
+{
+	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	snd_soc_dai_init_dma_data(dai, &priv->playback_dma_data, &priv->capture_dma_data);
+
+	return 0;
+}
+
+static int sunxi_codec_startup(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	return clk_prepare_enable(priv->clk_module);
+}
+
+static void sunxi_codec_shutdown(struct snd_pcm_substream *substream,
+				 struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	clk_disable_unprepare(priv->clk_module);
+}
+
+
+static int codec_init(struct sunxi_priv *priv)
+{
+	/* enable DAC digital */
+	regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 1 << EN_DA, 1 << EN_DA);
+
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << FIR_VERSION, 1 << FIR_VERSION);
+
+	/* set digital volume to maximum */
+	if (priv->revision == SUN4IA)
+		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x3F << DVOL, 0 << DVOL);
+
+	/* PA mute */
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 1 << PA_MUTE, 0 << PA_MUTE);
+
+	/* enable PA */
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 1 << PA_EN, 1 << PA_EN);
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 3 << DAC_DRQ_CLR_CNT, 3 << DAC_DRQ_CLR_CNT);
+
+	/* set volume */
+	if (priv->revision == SUN4IA)
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x3f << PAVOL, 1 << PAVOL);
+	else
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x3f << PAVOL, 0x3b << PAVOL);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_codec_dai_ops = {
+	.startup = sunxi_codec_startup,
+	.shutdown = sunxi_codec_shutdown,
+	.trigger = sunxi_codec_trigger,
+	.hw_params = sunxi_codec_hw_params,
+	.prepare = sunxi_codec_prepare,
+};
+
+static struct snd_soc_dai_driver sunxi_codec_dai = {
+	.probe = sunxi_codec_dai_probe,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rate_min = 8000,
+		.rate_max = 192000,
+		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_11025 |\
+			 SNDRV_PCM_RATE_22050| SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\
+			 SNDRV_PCM_RATE_48000 |SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000 |\
+			 SNDRV_PCM_RATE_KNOT),
+		.formats = (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE),
+	},
+	.ops = &sunxi_codec_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_codec_component = {
+	.name = "sunxi-codec",
+};
+
+static const struct regmap_config sunxi_codec_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_AC_MIC_PHONE_CAL,
+};
+
+static const struct snd_soc_dapm_widget codec_dapm_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("Mic Bias"),
+	SND_SOC_DAPM_OUTPUT("HP_OUT"),
+	SND_SOC_DAPM_INPUT("MIC_IN"),
+	SND_SOC_DAPM_INPUT("LINE_IN"),
+};
+
+static struct snd_soc_dai_link cdc_dai = {
+	.name = "cdc",
+	.stream_name = "CDC PCM",
+	.codec_dai_name = "sunxi-codec-dai",
+	.cpu_dai_name = "1c22c00.codec",
+	.codec_name = "1c22c00.codec",
+	.platform_name = "1c22c00.codec",
+	//.init = tegra_wm8903_init,
+	//.ops = &tegra_wm8903_ops,
+	.dai_fmt = SND_SOC_DAIFMT_I2S,
+};
+
+static struct snd_soc_card snd_soc_sunxi_codec = {
+	.name = "sunxi-codec",
+	.owner = THIS_MODULE,
+	.dai_link = &cdc_dai,
+	.num_links = 1,
+};
+
+static struct snd_soc_codec_driver dummy_codec = {
+	.controls = sun7i_dac_ctls,
+	.num_controls = ARRAY_SIZE(sun7i_dac_ctls),
+	.dapm_widgets = codec_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(codec_dapm_widgets),
+};
+
+#define SUNXI_RATES	SNDRV_PCM_RATE_8000_192000
+#define SUNXI_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_driver dummy_dai = {
+	.name = "sunxi-codec-dai",
+	.playback = {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= SUNXI_RATES,
+		.formats	= SUNXI_FORMATS,
+	},
+	.capture = {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates 		= SUNXI_RATES,
+		.formats 	= SUNXI_FORMATS,
+	 },
+};
+
+static const struct of_device_id sunxi_codec_of_match[] = {
+	{ .compatible = "allwinner,sun4i-a10a-codec", .data = (void *)SUN4IA},
+	{ .compatible = "allwinner,sun4i-a10-codec", .data = (void *)SUN4I},
+	{ .compatible = "allwinner,sun5i-a13-codec", .data = (void *)SUN5I},
+	{ .compatible = "allwinner,sun7i-a20-codec", .data = (void *)SUN7I},
+	{}
+};
+MODULE_DEVICE_TABLE(of, sunxi_codec_of_match);
+
+static int sunxi_codec_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_card *card = &snd_soc_sunxi_codec;
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct sunxi_priv *priv;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	of_id = of_match_device(sunxi_codec_of_match, dev);
+	if (!of_id)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	card->dev = &pdev->dev;
+	platform_set_drvdata(pdev, card);
+	snd_soc_card_set_drvdata(card, priv);
+
+	priv->revision = (enum sunxi_soc_family)of_id->data;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	priv->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					     &sunxi_codec_regmap_config);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	/* Get the clocks from the DT */
+	priv->clk_apb = devm_clk_get(dev, "apb");
+	if (IS_ERR(priv->clk_apb)) {
+		dev_err(dev, "failed to get apb clock\n");
+		return PTR_ERR(priv->clk_apb);
+	}
+	priv->clk_pll2 = devm_clk_get(dev, "pll");
+	if (IS_ERR(priv->clk_pll2)) {
+		dev_err(dev, "failed to get pll2 clock\n");
+		return PTR_ERR(priv->clk_pll2);
+	}
+	priv->clk_module = devm_clk_get(dev, "codec");
+	if (IS_ERR(priv->clk_module)) {
+		dev_err(dev, "failed to get codec clock\n");
+		return PTR_ERR(priv->clk_module);
+	}
+
+	/* Enable PLL2 on a basic rate */
+	ret = clk_set_rate(priv->clk_pll2, 24576000);
+	if (ret) {
+		dev_err(dev, "failed to set codec base clock rate\n");
+		return ret;
+	}
+	if (clk_prepare_enable(priv->clk_pll2)) {
+		dev_err(dev, "failed to enable pll2 clock\n");
+		return -EINVAL;
+	}
+
+	/* Enable the bus clock */
+	if (clk_prepare_enable(priv->clk_apb)) {
+		dev_err(dev, "failed to enable apb clock\n");
+		clk_disable_unprepare(priv->clk_pll2);
+		return -EINVAL;
+	}
+
+	/* DMA configuration for TX FIFO */
+	priv->playback_dma_data.addr = res->start + SUNXI_DAC_TXDATA;
+	priv->playback_dma_data.maxburst = 4;
+	priv->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	/* DMA configuration for RX FIFO */
+	priv->capture_dma_data.addr = res->start + SUNXI_ADC_RXDATA;
+	priv->capture_dma_data.maxburst = 4;
+	priv->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	ret = snd_soc_register_codec(&pdev->dev, &dummy_codec, &dummy_dai, 1);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_codec_component, &sunxi_codec_dai, 1);
+	if (ret)
+		goto err_clk_disable;
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret)
+		goto err_clk_disable;
+
+	codec_init(priv);
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+		goto err_fini_utils;
+	}
+
+	ret = snd_soc_of_parse_audio_routing(card, "routing");
+	if (ret)
+		goto err;
+
+	return 0;
+
+err_fini_utils:
+err:
+err_clk_disable:
+	clk_disable_unprepare(priv->clk_apb);
+	clk_disable_unprepare(priv->clk_pll2);
+	return ret;
+}
+
+static int sunxi_codec_remove(struct platform_device *pdev)
+{
+	struct sunxi_priv *priv = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(priv->clk_apb);
+	clk_disable_unprepare(priv->clk_pll2);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_codec_driver = {
+	.driver = {
+		.name = "sunxi-codec",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_codec_of_match,
+	},
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_remove,
+};
+module_platform_driver(sunxi_codec_driver);
+
+MODULE_DESCRIPTION("sunxi codec ASoC driver");
+MODULE_AUTHOR("Emilio Lpez <emilio@elopez.com.ar>");
+MODULE_AUTHOR("Jon Smirl <jonsmirl@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-i2s.c b/sound/soc/sunxi/sunxi-i2s.c
new file mode 100644
index 0000000..4982b8b
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-i2s.c
@@ -0,0 +1,709 @@
+/*
+ * Copyright 2014 Emilio Lpez <emilio@elopez.com.ar>
+ * Copyright 2014 Jon Smirl <jonsmirl@gmail.com>
+ *
+ * Based on the Allwinner SDK driver, released under the GPL.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/regmap.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "sunxi-i2s.h"
+
+void sunxi_snd_txctrl_i2s(struct sunxi_priv *priv, struct snd_pcm_substream *substream, int on)
+{
+	u32 reg_val;
+
+	regmap_update_bits(priv->regmap, SUNXI_I2S_TXCHSEL, SUNXI_I2STXCHSEL_CHNUM_MASK, 
+				(substream->runtime->channels - 1) << SUNXI_I2STXCHSEL_CHNUM_SHIFT);
+
+	regmap_raw_read(priv->regmap, SUNXI_I2S_TXCHMAP, &reg_val, sizeof(reg_val));
+	reg_val = 0;
+	if (priv->revision == SUN4I) {
+		if(substream->runtime->channels == 1) {
+			reg_val = 0x76543200;
+		} else {
+			reg_val = 0x76543210;
+		}
+	} else {
+		if(substream->runtime->channels == 1) {
+			reg_val = 0x00000000;
+		} else {
+			reg_val = 0x00000010;
+		}
+	}
+	regmap_write(priv->regmap, SUNXI_I2S_TXCHMAP, reg_val);
+
+	regmap_read(priv->regmap, SUNXI_I2S_CTL, &reg_val);
+	if (priv->revision == SUN4I) {
+		reg_val &= ~SUNXI_I2SCTL_SDOEN_ALL;
+		switch(substream->runtime->channels) {
+			case 1:
+			case 2:
+				reg_val |= SUNXI_I2SCTL_SDO0EN;
+				break;
+			case 3:
+			case 4:
+				reg_val |= SUNXI_I2SCTL_SDO0EN;
+				reg_val |= SUNXI_I2SCTL_SDO1EN;
+				break;
+			case 5:
+			case 6:
+				reg_val |= SUNXI_I2SCTL_SDO0EN;
+				reg_val |= SUNXI_I2SCTL_SDO1EN;
+				reg_val |= SUNXI_I2SCTL_SDO2EN;
+				break;
+			case 7:
+			case 8:
+				reg_val |= SUNXI_I2SCTL_SDO0EN;
+				reg_val |= SUNXI_I2SCTL_SDO1EN;
+				reg_val |= SUNXI_I2SCTL_SDO2EN;
+				reg_val |= SUNXI_I2SCTL_SDO3EN;
+				break;
+			default:
+				reg_val |= SUNXI_I2SCTL_SDO0EN;
+		}
+	} else {
+		reg_val |= SUNXI_I2SCTL_SDO0EN;
+	}
+	regmap_write(priv->regmap, SUNXI_I2S_CTL, reg_val);
+
+	//flush TX FIFO
+	regmap_update_bits(priv->regmap, SUNXI_I2S_FCTL, SUNXI_I2SFCTL_FTX_MASK, SUNXI_I2SFCTL_FTX);
+
+	//clear TX counter
+	regmap_write(priv->regmap, SUNXI_I2S_TXCNT, 0);
+
+	if (on) {
+		/* IIS TX ENABLE */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_TXEN_MASK, SUNXI_I2SCTL_TXEN);
+
+		/* enable DMA DRQ mode for play */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_INT, SUNXI_I2SINT_TXDRQEN_MASK, SUNXI_I2SINT_TXDRQEN);
+
+		//Global Enable Digital Audio Interface
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_GEN_MASK, SUNXI_I2SCTL_GEN);
+
+	} else {
+		/* IIS TX DISABLE */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_TXEN_MASK, 0);
+
+		/* DISBALE dma DRQ mode */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_INT, SUNXI_I2SINT_TXDRQEN_MASK, 0);
+
+		//Global disable Digital Audio Interface
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_GEN_MASK, 0);
+	}
+}
+
+void sunxi_snd_rxctrl_i2s(struct sunxi_priv *priv, int on)
+{
+	//flush RX FIFO
+	regmap_update_bits(priv->regmap, SUNXI_I2S_FCTL, SUNXI_I2SFCTL_FRX_MASK, SUNXI_I2SFCTL_FRX);
+
+	//clear RX counter
+	regmap_write(priv->regmap, SUNXI_I2S_RXCNT, 0);
+
+	if (on) {
+		/* IIS RX ENABLE */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_RXEN_MASK, SUNXI_I2SCTL_RXEN);
+
+		/* enable DMA DRQ mode for record */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_INT, SUNXI_I2SINT_RXDRQEN_MASK, SUNXI_I2SINT_RXDRQEN);
+
+		//Global Enable Digital Audio Interface
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_GEN_MASK, SUNXI_I2SCTL_GEN);
+
+	} else {
+		/* IIS RX DISABLE */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_RXEN_MASK, 0);
+
+		/* DISBALE dma DRQ mode */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_INT, SUNXI_I2SINT_RXDRQEN_MASK, 0);
+
+		//Global disable Digital Audio Interface
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_GEN_MASK, 0);
+	}
+}
+
+static inline int sunxi_snd_is_clkmaster(struct sunxi_priv *priv)
+{
+	u32 reg_val;
+
+	regmap_read(priv->regmap, SUNXI_I2S_CTL, &reg_val);
+	return ((reg_val & SUNXI_I2SCTL_MS_MASK) ? 0 : 1);
+}
+
+static int sunxi_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 reg_val;
+
+	//SDO ON
+	if (priv->revision == SUN4I) {
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_SDOEN_ALL, SUNXI_I2SCTL_SDOEN_ALL);
+	} else {
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_SDO0EN_MASK, SUNXI_I2SCTL_SDO0EN);
+	}
+
+
+	/* master or slave selection */
+	switch(fmt & SND_SOC_DAIFMT_MASTER_MASK){
+	case SND_SOC_DAIFMT_CBM_CFM:   /* codec clk & frm master */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_MS_MASK, SUNXI_I2SCTL_MS);
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:   /* codec clk & frm slave */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_MS_MASK, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* pcm or i2s mode selection */
+	switch(fmt & SND_SOC_DAIFMT_FORMAT_MASK){
+	case SND_SOC_DAIFMT_I2S:        /* I2S mode */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_PCM_MASK, SUNXI_I2SCTL_PCM);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_FMT_MASK, SUNXI_I2SFAT0_FMT_I2S);
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:    /* Right Justified mode */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_PCM_MASK, 0);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_FMT_MASK, SUNXI_I2SFAT0_FMT_RGT);
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:     /* Left Justified mode */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_PCM_MASK, 0);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_FMT_MASK, SUNXI_I2SFAT0_FMT_LFT);
+		break;
+	case SND_SOC_DAIFMT_DSP_A:      /* L data msb after FRM LRC */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_PCM_MASK, SUNXI_I2SCTL_PCM);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_LRCP_MASK, 0);
+		break;
+	case SND_SOC_DAIFMT_DSP_B:      /* L data msb during FRM LRC */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_PCM_MASK, SUNXI_I2SCTL_PCM);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_LRCP_MASK, SUNXI_I2SFAT0_LRCP);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* DAI signal inversions */
+	switch(fmt & SND_SOC_DAIFMT_INV_MASK){
+	case SND_SOC_DAIFMT_NB_NF:     /* normal bit clock + frame */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_LRCP_MASK, 0);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_BCP_MASK, 0);
+		break;
+	case SND_SOC_DAIFMT_NB_IF:     /* normal bclk + inv frm */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_LRCP_MASK, SUNXI_I2SFAT0_LRCP);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_BCP_MASK, 0);
+		break;
+	case SND_SOC_DAIFMT_IB_NF:     /* invert bclk + nor frm */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_LRCP_MASK, 0);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_BCP_MASK, SUNXI_I2SFAT0_BCP);
+		break;
+	case SND_SOC_DAIFMT_IB_IF:     /* invert bclk + frm */
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_LRCP_MASK, SUNXI_I2SFAT0_LRCP);
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_BCP_MASK, SUNXI_I2SFAT0_BCP);
+		break;
+	}
+
+	/* word select size */
+	if(priv->ws_size == 16)
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_WSS_MASK, SUNXI_I2SFAT0_WSS_16BCLK);
+	else if(priv->ws_size == 20)
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_WSS_MASK, SUNXI_I2SFAT0_WSS_20BCLK);
+	else if(priv->ws_size == 24)
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_WSS_MASK, SUNXI_I2SFAT0_WSS_24BCLK);
+	else
+		regmap_update_bits(priv->regmap, SUNXI_I2S_FAT0, SUNXI_I2SFAT0_WSS_MASK, SUNXI_I2SFAT0_WSS_32BCLK);
+
+	/* PCM REGISTER setup */
+	reg_val = priv->pcm_txtype & 0x3;
+	reg_val |= priv->pcm_rxtype << 2;
+
+	if(!priv->pcm_sync_type)
+		reg_val |= SUNXI_I2SFAT1_SSYNC;				// short sync
+	if(priv->pcm_sw == 16)
+		reg_val |= SUNXI_I2SFAT1_SW;
+
+	reg_val |= ((priv->pcm_start_slot - 1) << SUNXI_I2SFAT1_SI_SHIFT) & SUNXI_I2SFAT1_SI_MASK; // start slot index
+
+	reg_val |= priv->pcm_lsb_first << SUNXI_I2SFAT1_MLS_SHIFT;	// MSB or LSB first
+
+	if(priv->pcm_sync_period == 256)
+		reg_val |= SUNXI_I2SFAT1_SYNCLEN_256BCLK;
+	else if (priv->pcm_sync_period == 128)
+		reg_val |= SUNXI_I2SFAT1_SYNCLEN_128BCLK;
+	else if (priv->pcm_sync_period == 64)
+		reg_val |= SUNXI_I2SFAT1_SYNCLEN_64BCLK;
+	else if (priv->pcm_sync_period == 32)
+		reg_val |= SUNXI_I2SFAT1_SYNCLEN_32BCLK;
+	regmap_write(priv->regmap, SUNXI_I2S_FAT1, reg_val);
+
+	/* set FIFO control register */
+	reg_val = SUNXI_I2SFCTL_RXOM_MOD0;
+	reg_val |= SUNXI_I2SFCTL_TXIM_MOD1;
+	reg_val |= SUNXI_I2SFCTL_RXTL(0xf);				//RX FIFO trigger level
+	reg_val |= SUNXI_I2SFCTL_TXTL(0x40);				//TX FIFO empty trigger level
+	regmap_write(priv->regmap, SUNXI_I2S_FCTL, reg_val);
+	return 0;
+}
+
+static int sunxi_i2s_hw_params(struct snd_pcm_substream *substream, 
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *cpu_dai)
+{
+	return 0;
+}
+
+static int sunxi_i2s_trigger(struct snd_pcm_substream *substream,
+                              int cmd, struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret = 0;
+
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+				sunxi_snd_rxctrl_i2s(priv, 1);
+			} else {
+				sunxi_snd_txctrl_i2s(priv, substream, 1);
+			}
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+				sunxi_snd_rxctrl_i2s(priv, 0);
+			} else {
+				sunxi_snd_txctrl_i2s(priv, substream, 0);
+			}
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+
+	return ret;
+}
+
+//freq:   1: 22.5792MHz   0: 24.576MHz
+static int sunxi_i2s_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id, unsigned int freq, int dir)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	if (!freq) {
+		clk_set_rate(priv->clk_iis, 24576000);
+	} else {
+		clk_set_rate(priv->clk_iis, 22579200);
+	}
+
+	return 0;
+}
+
+static int sunxi_i2s_set_clkdiv(struct snd_soc_dai *cpu_dai, int div_id, int div)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 reg;
+
+	switch (div_id) {
+	case SUNXI_DIV_MCLK:
+		if (div >= 64)
+			div = SUNXI_I2SCLKD_MCLKDIV_64;
+		else if (div >= 48)
+			div = SUNXI_I2SCLKD_MCLKDIV_48;
+		else if (div >= 32)
+			div = SUNXI_I2SCLKD_MCLKDIV_32;
+		else if (div >= 24)
+			div = SUNXI_I2SCLKD_MCLKDIV_24;
+		else if (div >= 16)
+			div  = SUNXI_I2SCLKD_MCLKDIV_16;
+		else if (div >= 12)
+			div  = SUNXI_I2SCLKD_MCLKDIV_12;
+		else if (div >= 8)
+			div  = SUNXI_I2SCLKD_MCLKDIV_8;
+		else if (div >= 6)
+			div  = SUNXI_I2SCLKD_MCLKDIV_6;
+		else if (div >= 4)
+			div  = SUNXI_I2SCLKD_MCLKDIV_4;
+		else 
+			div  = SUNXI_I2SCLKD_MCLKDIV_2;
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CLKD, SUNXI_I2SCLKD_MCLKDIV_MASK, div);
+		break;
+	case SUNXI_DIV_BCLK:
+		if (div >= 64)
+			div = SUNXI_I2SCLKD_BCLKDIV_64;
+		else if (div >= 32)
+			div = SUNXI_I2SCLKD_BCLKDIV_32;
+		else if (div >= 16)
+			div  = SUNXI_I2SCLKD_BCLKDIV_16;
+		else if (div >= 8)
+			div  = SUNXI_I2SCLKD_BCLKDIV_8;
+		else if (div >= 6)
+			div  = SUNXI_I2SCLKD_BCLKDIV_6;
+		else if (div >= 4)
+			div  = SUNXI_I2SCLKD_BCLKDIV_4;
+		else 
+			div  = SUNXI_I2SCLKD_BCLKDIV_2;
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CLKD, SUNXI_I2SCLKD_BCLKDIV_MASK, div);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	//diable MCLK output when high samplerate
+	regmap_read(priv->regmap, SUNXI_I2S_CLKD, &reg);
+	if (!(reg & SUNXI_I2SCLKD_MCLKDIV_MASK)) {
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CLKD, SUNXI_I2SCLKD_MCLKOEN_MASK, 0);
+	} else {
+		regmap_update_bits(priv->regmap, SUNXI_I2S_CLKD, SUNXI_I2SCLKD_MCLKOEN_MASK, SUNXI_I2SCLKD_MCLKOEN);
+	}
+	return 0;
+}
+
+static int sunxi_i2s_dai_probe(struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	snd_soc_dai_init_dma_data(cpu_dai, &priv->playback_dma_data, &priv->capture_dma_data);
+
+	return 0;
+}
+
+static int sunxi_i2s_dai_remove(struct snd_soc_dai *cpu_dai)
+{
+	return 0;
+}
+
+
+static int sunxi_i2s_mclk_prepare(struct clk_hw *hw)
+{
+	struct sunxi_priv *priv =
+		container_of(hw, struct sunxi_priv, mclk_div.hw);
+
+	priv->mode = IIS_MASTER;
+	regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_GEN_MASK, SUNXI_I2SCTL_GEN);
+	regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_TXEN_MASK, SUNXI_I2SCTL_TXEN);
+	regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_RXEN_MASK, SUNXI_I2SCTL_RXEN);
+	regmap_update_bits(priv->regmap, SUNXI_I2S_CLKD, SUNXI_I2SCLKD_MCLKDIV_MASK, SUNXI_I2SCLKD_MCLKDIV_8);
+	regmap_update_bits(priv->regmap, SUNXI_I2S_CLKD, SUNXI_I2SCLKD_MCLKOEN_MASK, SUNXI_I2SCLKD_MCLKOEN);
+	mdelay(10);
+	printk("JDS - sunxi_i2s_mclk_prepare done\n");
+	return 0;
+}
+
+static struct clk_ops sunxi_i2s_clk_divider_ops = {
+};
+
+static int sunxi_i2s_mclk_init(struct platform_device *pdev, struct sunxi_priv *priv)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct clk_init_data init;
+	const char *clk_name = NULL;
+	const char *clk_parent = __clk_get_name(priv->clk_iis);
+	int ret;
+	int flags = 0;
+
+	of_property_read_string(np, "clock-output-names", &clk_name);
+
+	sunxi_i2s_clk_divider_ops = clk_divider_ops;
+	sunxi_i2s_clk_divider_ops.prepare = sunxi_i2s_mclk_prepare;
+
+	init.name = clk_name;
+	init.ops = &sunxi_i2s_clk_divider_ops;
+	init.flags = flags | CLK_IS_BASIC;
+	init.parent_names = &clk_parent;
+	init.num_parents = 1;
+
+	/* struct clk_divider assignments */
+	priv->mclk_div.reg = priv->base + SUNXI_I2S_CLKD;
+	priv->mclk_div.shift = SUNXI_I2SCLKD_MCLKDIV_SHIFT;
+	priv->mclk_div.width = SUNXI_I2SCLKD_MCLKDIV_WIDTH;
+	priv->mclk_div.flags = 0;
+	priv->mclk_div.lock = NULL;
+	priv->mclk_div.hw.init = &init;
+	priv->mclk_div.table = NULL;
+
+	/* register the clock */
+	priv->clk_mclk = clk_register(&pdev->dev, &priv->mclk_div.hw);
+
+	if (IS_ERR(priv->clk_mclk)) {
+		dev_err(&pdev->dev, "failed to register mclk: %ld\n", PTR_ERR(priv->clk_mclk));
+		return PTR_ERR(priv->clk_mclk);
+	}
+
+	ret = of_clk_add_provider(np, of_clk_src_simple_get, priv->clk_mclk);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static void iisregsave(void)
+{
+	/*regsave[0] = readl(priv->regs + SUNXI_I2S_CTL);
+	regsave[1] = readl(priv->regs + SUNXI_I2S_FAT0);
+	regsave[2] = readl(priv->regs + SUNXI_I2S_FAT1);
+	regsave[3] = readl(priv->regs + SUNXI_I2S_FCTL) | (0x3<<24);
+	regsave[4] = readl(priv->regs + SUNXI_I2S_INT);
+	regsave[5] = readl(priv->regs + SUNXI_I2S_CLKD);
+	regsave[6] = readl(priv->regs + SUNXI_TXCHSEL);
+	regsave[7] = readl(priv->regs + SUNXI_TXCHMAP);*/
+}
+
+static void iisregrestore(void)
+{
+	/*writel(regsave[0], priv->regs + SUNXI_I2S_CTL);
+	writel(regsave[1], priv->regs + SUNXI_I2S_FAT0);
+	writel(regsave[2], priv->regs + SUNXI_I2S_FAT1);
+	writel(regsave[3], priv->regs + SUNXI_I2S_FCTL);
+	writel(regsave[4], priv->regs + SUNXI_I2S_INT);
+	writel(regsave[5], priv->regs + SUNXI_I2S_CLKD);
+	writel(regsave[6], priv->regs + SUNXI_TXCHSEL);
+	writel(regsave[7], priv->regs + SUNXI_TXCHMAP);*/
+}
+
+static int sunxi_i2s_suspend(struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	printk("[IIS]Entered %s\n", __func__);
+
+	//Global Enable Digital Audio Interface
+	regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_GEN_MASK, 0);
+
+	iisregsave();
+
+	//release the module clock
+	clk_disable(priv->clk_iis);
+
+	clk_disable(priv->clk_apb);
+
+	//printk("[IIS]PLL2 0x01c20008 = %#x\n", *(volatile int*)0xF1C20008);
+	printk("[IIS]SPECIAL CLK 0x01c20068 = %#x, line= %d\n", *(volatile int*)0xF1C20068, __LINE__);
+	printk("[IIS]SPECIAL CLK 0x01c200B8 = %#x, line = %d\n", *(volatile int*)0xF1C200B8, __LINE__);
+
+	return 0;
+}
+static int sunxi_i2s_resume(struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	printk("[IIS]Entered %s\n", __func__);
+
+	//release the module clock
+	clk_enable(priv->clk_apb);
+
+	//release the module clock
+	clk_enable(priv->clk_iis);
+
+	iisregrestore();
+
+	//Global Enable Digital Audio Interface
+	regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_GEN_MASK, SUNXI_I2SCTL_GEN);
+
+	//printk("[IIS]PLL2 0x01c20008 = %#x\n", *(volatile int*)0xF1C20008);
+	printk("[IIS]SPECIAL CLK 0x01c20068 = %#x, line= %d\n", *(volatile int*)0xF1C20068, __LINE__);
+	printk("[IIS]SPECIAL CLK 0x01c200B8 = %#x, line = %d\n", *(volatile int*)0xF1C200B8, __LINE__);
+
+	return 0;
+}
+
+#define SUNXI_I2S_RATES (SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT)
+static struct snd_soc_dai_ops sunxi_i2s_dai_ops = {
+	.trigger 	= sunxi_i2s_trigger,
+	.hw_params 	= sunxi_i2s_hw_params,
+	.set_fmt 	= sunxi_i2s_set_fmt,
+	.set_clkdiv = sunxi_i2s_set_clkdiv,
+	.set_sysclk = sunxi_i2s_set_sysclk,
+};
+
+static struct snd_soc_dai_driver sunxi_i2s_dai = {
+	.probe 		= sunxi_i2s_dai_probe,
+	.suspend 	= sunxi_i2s_suspend,
+	.resume 	= sunxi_i2s_resume,
+	.remove 	= sunxi_i2s_dai_remove,
+	.playback 	= {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.capture 	= {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.symmetric_rates = 1,
+	.ops 		= &sunxi_i2s_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_i2s_component = {
+	.name = "sunxi-i2s",
+};
+
+static const struct regmap_config sunxi_i2s_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_I2S_RXCHMAP,
+};
+
+static const struct of_device_id sunxi_i2s_of_match[] = {
+	{ .compatible = "allwinner,sun4i-a10-iis", .data = (void *)SUN4I},
+	{ .compatible = "allwinner,sun5i-a13-iis", .data = (void *)SUN5I},
+	{ .compatible = "allwinner,sun7i-a20-iis", .data = (void *)SUN7I},
+	{}
+};
+MODULE_DEVICE_TABLE(of, sunxi_i2s_of_match);
+
+static int sunxi_i2s_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct sunxi_priv *priv;
+	struct resource *res;
+	int ret;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	printk("JDS: sunxi_i2s_probe\n");
+	of_id = of_match_device(sunxi_i2s_of_match, dev);
+	if (!of_id)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->revision = (enum sunxi_soc_family)of_id->data;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->base))
+		return PTR_ERR(priv->base);
+
+	priv->regmap = devm_regmap_init_mmio(&pdev->dev, priv->base,
+					     &sunxi_i2s_regmap_config);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	/* Get the clocks from the DT */
+	priv->clk_apb = devm_clk_get(dev, "apb");
+	if (IS_ERR(priv->clk_apb)) {
+		dev_err(dev, "failed to get apb clock\n");
+		return PTR_ERR(priv->clk_apb);
+	}
+	priv->clk_iis = devm_clk_get(dev, "iis");
+	if (IS_ERR(priv->clk_iis)) {
+		dev_err(dev, "failed to get iis clock\n");
+		return PTR_ERR(priv->clk_iis);
+	}
+
+	/* Enable iis on a basic rate */
+	ret = clk_set_rate(priv->clk_iis, 24576000);
+	if (ret) {
+		dev_err(dev, "failed to set i2s base clock rate\n");
+		return ret;
+	}
+	if (clk_prepare_enable(priv->clk_iis)) {
+		dev_err(dev, "failed to enable iis clock\n");
+		return -EINVAL;
+	}
+
+	/* Enable the bus clock */
+	if (clk_prepare_enable(priv->clk_apb)) {
+		dev_err(dev, "failed to enable apb clock\n");
+		clk_disable_unprepare(priv->clk_iis);
+		return -EINVAL;
+	}
+
+	/* DMA configuration for TX FIFO */
+	priv->playback_dma_data.addr = res->start + SUNXI_I2S_TXFIFO;
+	priv->playback_dma_data.maxburst = 4;
+	priv->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	/* DMA configuration for RX FIFO */
+	priv->capture_dma_data.addr = res->start + SUNXI_I2S_RXFIFO;
+	priv->capture_dma_data.maxburst = 4;
+	priv->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	ret = sunxi_i2s_mclk_init(pdev, priv);
+	if (ret)
+		goto err_clk_disable;
+
+	//FIXME
+	clk_prepare_enable(priv->clk_mclk);
+
+	dev_set_drvdata(&pdev->dev, priv);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_i2s_component, &sunxi_i2s_dai, 1);
+	if (ret)
+		goto err_clk_disable;
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret)
+		goto err_clk_disable;
+
+	printk("JDS: sunxi_i2s_probe finished\n");
+	return 0;
+
+err_clk_disable:
+	clk_disable_unprepare(priv->clk_apb);
+	clk_disable_unprepare(priv->clk_iis);
+	return ret;
+}
+
+static int sunxi_i2s_remove(struct platform_device *pdev)
+{
+	struct sunxi_priv *priv = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(priv->clk_apb);
+	clk_disable_unprepare(priv->clk_iis);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_i2s_driver = {
+	.driver = {
+		.name = "sunxi-i2s",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_i2s_of_match,
+	},
+	.probe = sunxi_i2s_probe,
+	.remove = sunxi_i2s_remove,
+};
+module_platform_driver(sunxi_i2s_driver);
+
+MODULE_DESCRIPTION("sunxi i2s ASoC driver");
+MODULE_AUTHOR("Jon Smirl <jonsmirl@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-i2s.h b/sound/soc/sunxi/sunxi-i2s.h
new file mode 100644
index 0000000..b857cc1
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-i2s.h
@@ -0,0 +1,440 @@
+/*
+ * sound\soc\sunxi\i2s\sunxi-i2s.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef SUNXI_I2S_H_
+#define SUNXI_I2S_H_
+
+/*------------------------------------------------------------*/
+/* REGISTER definitions */
+
+#define SUNXI_I2S_CTL		0x00 /* Digital Audio Control Register */
+#define SUNXI_I2S_FAT0		0x04 /* Digital Audio Format Register 0 */
+#define SUNXI_I2S_FAT1		0x08 /* Digital Audio Format Register 1 */
+#define SUNXI_I2S_TXFIFO	0x0C /* Digital Audio TX FIFO Register */
+#define SUNXI_I2S_RXFIFO	0x10 /* Digital Audio RX FIFO Register */
+#define SUNXI_I2S_FCTL		0x14 /* Digital Audio FIFO Control Register */
+#define SUNXI_I2S_FSTA		0x18 /* Digital Audio FIFO Status Register */
+#define SUNXI_I2S_INT		0x1C /* Digital Audio Interrupt Control Register */
+#define SUNXI_I2S_ISTA		0x20 /* Digital Audio Interrupt Status Register */
+#define SUNXI_I2S_CLKD		0x24 /* Digital Audio Clock Divide Register */
+#define SUNXI_I2S_RXCNT		0x28 /* Digital Audio RX Sample Counter Register */
+#define SUNXI_I2S_TXCNT		0x2C /* Digital Audio TX Sample Counter Register */
+#define SUNXI_I2S_TXCHSEL	0x30 /* Digital Audio TX Channel Select register */
+#define SUNXI_I2S_TXCHMAP	0x34 /* Digital Audio TX Channel Mapping Register */
+#define SUNXI_I2S_RXCHSEL	0x38 /* Digital Audio RX Channel Select register */
+#define SUNXI_I2S_RXCHMAP	0x3C /* Digital Audio RX Channel Mapping Register */
+
+
+/* SUNXI_I2S_CTL	0x00 	 Digital Audio Control Register */
+#define SUNXI_I2SCTL_SDO3EN		(1<<11)
+#define SUNXI_I2SCTL_SDO3EN_MASK	(1<<11)
+#define SUNXI_I2SCTL_SDO3EN_SHIFT	11
+#define SUNXI_I2SCTL_SDO3EN_WIDTH	1
+#define SUNXI_I2SCTL_SDO2EN		(1<<10)
+#define SUNXI_I2SCTL_SDO2EN_MASK	(1<<10)
+#define SUNXI_I2SCTL_SDO2EN_SHIFT	10
+#define SUNXI_I2SCTL_SDO2EN_WIDTH	1
+#define SUNXI_I2SCTL_SDO1EN		(1<<9)
+#define SUNXI_I2SCTL_SDO1EN_MASK	(1<<9)
+#define SUNXI_I2SCTL_SDO1EN_SHIFT	9
+#define SUNXI_I2SCTL_SDO1EN_WIDTH	1
+#define SUNXI_I2SCTL_SDO0EN		(1<<8)
+#define SUNXI_I2SCTL_SDO0EN_MASK	(1<<8)
+#define SUNXI_I2SCTL_SDO0EN_SHIFT	8
+#define SUNXI_I2SCTL_SDO0EN_WIDTH	1
+#define SUNXI_I2SCTL_SDOEN_ALL (SUNXI_I2SCTL_SDO3EN | SUNXI_I2SCTL_SDO2EN | SUNXI_I2SCTL_SDO1EN| SUNXI_I2SCTL_SDO0EN)
+
+#define SUNXI_I2SCTL_ASS		(1<<6)
+#define SUNXI_I2SCTL_ASS_MASK		(1<<6)
+#define SUNXI_I2SCTL_ASS_SHIFT		6
+#define SUNXI_I2SCTL_ASS_WIDTH		1
+#define SUNXI_I2SCTL_MS			(1<<5)
+#define SUNXI_I2SCTL_MS_MASK		(1<<5)
+#define SUNXI_I2SCTL_MS_SHIFT		5
+#define SUNXI_I2SCTL_MS_WIDTH		1
+#define SUNXI_I2SCTL_PCM		(1<<4)
+#define SUNXI_I2SCTL_PCM_MASK		(1<<4)
+#define SUNXI_I2SCTL_PCM_SHIFT		4
+#define SUNXI_I2SCTL_PCM_WIDTH		1
+#define SUNXI_I2SCTL_LOOP		(1<<3)
+#define SUNXI_I2SCTL_LOOP_MASK		(1<<3)
+#define SUNXI_I2SCTL_LOOP_SHIFT		3
+#define SUNXI_I2SCTL_LOOP_WIDTH		1
+#define SUNXI_I2SCTL_TXEN		(1<<2)
+#define SUNXI_I2SCTL_TXEN_MASK		(1<<2)
+#define SUNXI_I2SCTL_TXEN_SHIFT		2
+#define SUNXI_I2SCTL_TXEN_WIDTH		1
+#define SUNXI_I2SCTL_RXEN		(1<<1)
+#define SUNXI_I2SCTL_RXEN_MASK		(1<<1)
+#define SUNXI_I2SCTL_RXEN_SHIFT		1
+#define SUNXI_I2SCTL_RXEN_WIDTH		1
+#define SUNXI_I2SCTL_GEN		(1<<0)
+#define SUNXI_I2SCTL_GEN_MASK		(1<<0)
+#define SUNXI_I2SCTL_GEN_SHIFT		0
+#define SUNXI_I2SCTL_GEN_WIDTH		1
+
+/* SUNXI_I2S_FAT0	0x04 	 Digital Audio Format Register 0 */
+
+#define SUNXI_I2SFAT0_LRCP		(1<<7)
+#define SUNXI_I2SFAT0_LRCP_MASK		(1<<7)
+#define SUNXI_I2SFAT0_LRCP_SHIFT	7
+#define SUNXI_I2SFAT0_LRCP_WIDTH	1
+#define SUNXI_I2SFAT0_BCP		(1<<6)
+#define SUNXI_I2SFAT0_BCP_MASK		(1<<6)
+#define SUNXI_I2SFAT0_BCP_SHIFT		6
+#define SUNXI_I2SFAT0_BCP_WIDTH		1
+#define SUNXI_I2SFAT0_SR_MASK		(3<<4)
+#define SUNXI_I2SFAT0_SR_16BIT		(0<<4)
+#define	SUNXI_I2SFAT0_SR_20BIT		(1<<4)
+#define SUNXI_I2SFAT0_SR_24BIT		(2<<4)
+#define SUNXI_I2SFAT0_SR_SHIFT		4
+#define SUNXI_I2SFAT0_SR_WIDTH		2
+#define SUNXI_I2SFAT0_WSS_MASK		(3<<2)
+#define SUNXI_I2SFAT0_WSS_16BCLK	(0<<2)
+#define SUNXI_I2SFAT0_WSS_20BCLK	(1<<2)
+#define SUNXI_I2SFAT0_WSS_24BCLK	(2<<2)
+#define SUNXI_I2SFAT0_WSS_32BCLK	(3<<2)
+#define SUNXI_I2SFAT0_WSS_SHIFT		2
+#define SUNXI_I2SFAT0_WSS_WIDTH		2
+#define SUNXI_I2SFAT0_FMT_MASK		(3<<0)
+#define SUNXI_I2SFAT0_FMT_I2S		(0<<0)
+#define SUNXI_I2SFAT0_FMT_LFT		(1<<0)
+#define SUNXI_I2SFAT0_FMT_RGT		(2<<0)
+#define SUNXI_I2SFAT0_FMT_RVD		(3<<0)
+#define SUNXI_I2SFAT0_FMT_SHIFT		0
+#define SUNXI_I2SFAT0_FMT_WIDTH		2
+
+/* SUNXI_I2S_FAT1	0x08 	 Digital Audio Format Register 1 */
+
+#define SUNXI_I2SFAT1_SYNCLEN_MASK	(7<<12)
+#define SUNXI_I2SFAT1_SYNCLEN_16BCLK	(0<<12)
+#define SUNXI_I2SFAT1_SYNCLEN_32BCLK	(1<<12)
+#define SUNXI_I2SFAT1_SYNCLEN_64BCLK	(2<<12)
+#define SUNXI_I2SFAT1_SYNCLEN_128BCLK	(3<<12)
+#define SUNXI_I2SFAT1_SYNCLEN_256BCLK	(4<<12)
+#define SUNXI_I2SFAT1_SYNCLEN_SHIFT	12
+#define SUNXI_I2SFAT1_SYNCLEN_WIDTH	3
+#define SUNXI_I2SFAT1_SYNCOUTEN		(1<<11)
+#define SUNXI_I2SFAT1_SYNCOUTEN_MASK	(1<<11)
+#define SUNXI_I2SFAT1_SYNCOUTEN_SHIFT	11
+#define SUNXI_I2SFAT1_SYNCOUTEN_WIDTH	1
+#define SUNXI_I2SFAT1_OUTMUTE		(1<<10)
+#define SUNXI_I2SFAT1_OUTMUTE_MASK	(1<<10)
+#define SUNXI_I2SFAT1_OUTMUTE_SHIFT	10
+#define SUNXI_I2SFAT1_OUTMUTE_WIDTH	1
+#define SUNXI_I2SFAT1_MLS		(1<<9)
+#define SUNXI_I2SFAT1_MLS_MASK		(1<<9)
+#define SUNXI_I2SFAT1_MLS_SHIFT		9
+#define SUNXI_I2SFAT1_MLS_WIDTH		1
+#define SUNXI_I2SFAT1_SEXT		(1<<8)
+#define SUNXI_I2SFAT1_SEXT_MASK		(1<<8)
+#define SUNXI_I2SFAT1_SEXT_SHIFT	8
+#define SUNXI_I2SFAT1_SEXT_WIDTH	1
+#define SUNXI_I2SFAT1_SI_MASK		(3<<6)
+#define SUNXI_I2SFAT1_SI_1ST		(0<<6)
+#define SUNXI_I2SFAT1_SI_2ND		(1<<6)
+#define SUNXI_I2SFAT1_SI_3RD		(2<<6)
+#define SUNXI_I2SFAT1_SI_4TH		(3<<6)
+#define SUNXI_I2SFAT1_SI_SHIFT		6
+#define SUNXI_I2SFAT1_SI_WIDTH		2
+#define SUNXI_I2SFAT1_SW		(1<<5)
+#define SUNXI_I2SFAT1_SW_MASK		(1<<5)
+#define SUNXI_I2SFAT1_SW_SHIFT		5
+#define SUNXI_I2SFAT1_SW_WIDTH		1
+#define SUNXI_I2SFAT1_SSYNC		(1<<4)
+#define SUNXI_I2SFAT1_SSYNC_MASK	(1<<4)
+#define SUNXI_I2SFAT1_SSYNC_SHIFT	4
+#define SUNXI_I2SFAT1_SSYNC_WIDTH	1
+#define SUNXI_I2SFAT1_RXPDM_MASK	(3<<2)
+#define SUNXI_I2SFAT1_RXPDM_16PCM	(0<<2)
+#define SUNXI_I2SFAT1_RXPDM_8PCM	(1<<2)
+#define SUNXI_I2SFAT1_RXPDM_8ULAW	(2<<2)
+#define SUNXI_I2SFAT1_RXPDM_8ALAW  	(3<<2)
+#define SUNXI_I2SFAT1_RXPDM_SHIFT	2
+#define SUNXI_I2SFAT1_RXPDM_WIDTH	2
+#define SUNXI_I2SFAT1_TXPDM_MASK	(3<<0)
+#define SUNXI_I2SFAT1_TXPDM_16PCM	(0<<0)
+#define SUNXI_I2SFAT1_TXPDM_8PCM	(1<<0)
+#define SUNXI_I2SFAT1_TXPDM_8ULAW	(2<<0)
+#define SUNXI_I2SFAT1_TXPDM_8ALAW  	(3<<0)
+#define SUNXI_I2SFAT1_TXPDM_SHIFT	0
+#define SUNXI_I2SFAT1_TXPDM_WIDTH	2
+
+/* SUNXI_I2S_TXFIFO	0x0C 	 Digital Audio TX FIFO Register */
+
+/* SUNXI_I2S_RXFIFO	0x10 	 Digital Audio RX FIFO Register */
+
+/* SUNXI_I2S_FCTL	0x14 	 Digital Audio FIFO Control Register */
+
+#define SUNXI_I2SFCTL_FIFOSRC		(1<<31)
+#define SUNXI_I2SFCTL_FIFOSRC_MASK	(1<<31)
+#define SUNXI_I2SFCTL_FIFOSRC_SHIFT	31
+#define SUNXI_I2SFCTL_FIFOSRC_WIDTH	1
+#define SUNXI_I2SFCTL_FTX		(1<<25)
+#define SUNXI_I2SFCTL_FTX_MASK		(1<<25)
+#define SUNXI_I2SFCTL_FTX_SHIFT		25
+#define SUNXI_I2SFCTL_FTX_WIDTH		1
+#define SUNXI_I2SFCTL_FRX		(1<<24)
+#define SUNXI_I2SFCTL_FRX_MASK		(1<<24)
+#define SUNXI_I2SFCTL_FRX_SHIFT		24
+#define SUNXI_I2SFCTL_FRX_WIDTH		1
+#define SUNXI_I2SFCTL_TXTL(x) ((x << SUNXI_I2SFCTL_TXTL_SHIFT) & SUNXI_I2SFCTL_TXTL_MASK)
+#define SUNXI_I2SFCTL_TXTL_MASK		(0x3F<<12)
+#define SUNXI_I2SFCTL_TXTL_SHIFT	12
+#define SUNXI_I2SFCTL_TXTL_WIDTH	7
+#define SUNXI_I2SFCTL_RXTL(x) ((x << SUNXI_I2SFCTL_RXTL_SHIFT) & SUNXI_I2SFCTL_RXTL_MASK)
+#define SUNXI_I2SFCTL_RXTL_MASK		(0x3F<<4)
+#define SUNXI_I2SFCTL_RXTL_SHIFT	4
+#define SUNXI_I2SFCTL_RXTL_WIDTH	7
+#define SUNXI_I2SFCTL_TXIM_MASK		(1<<2)
+#define SUNXI_I2SFCTL_TXIM_MOD0		(0<<2)
+#define SUNXI_I2SFCTL_TXIM_MOD1		(1<<2)
+#define SUNXI_I2SFCTL_TXIM_SHIFT	2
+#define SUNXI_I2SFCTL_TXIM_WIDTH	1
+#define SUNXI_I2SFCTL_RXOM_MASK		(3<<0)
+#define SUNXI_I2SFCTL_RXOM_MOD0		(0<<0)
+#define SUNXI_I2SFCTL_RXOM_MOD1		(1<<0)
+#define SUNXI_I2SFCTL_RXOM_MOD2		(2<<0)
+#define SUNXI_I2SFCTL_RXOM_MOD3		(3<<0)
+#define SUNXI_I2SFCTL_RXOM_SHIFT	0
+#define SUNXI_I2SFCTL_RXOM_WIDTH	2
+
+/* SUNXI_I2S_FSTA	0x18 	 Digital Audio FIFO Status Register */
+
+#define SUNXI_I2SFSTA_TXE		(1<<28)
+#define SUNXI_I2SFSTA_TXE_MASK		(1<<28)
+#define SUNXI_I2SFSTA_TXE_SHIFT		28
+#define SUNXI_I2SFSTA_TXE_WIDTH		1
+#define SUNXI_I2SFSTA_TXECNT_MASK	(0xFF<<16)
+#define SUNXI_I2SFSTA_TXECNT_SHIFT	16
+#define SUNXI_I2SFSTA_TXECNT_WIDTH	8
+#define SUNXI_I2SFSTA_RXA		(1<<8)
+#define SUNXI_I2SFSTA_RXA_MASK		(1<<8)
+#define SUNXI_I2SFSTA_RXA_SHIFT		8
+#define SUNXI_I2SFSTA_RXA_WIDTH		1
+#define SUNXI_I2SFSTA_RXACNT_MASK	(0x3F<<0)
+#define SUNXI_I2SFSTA_RXACNT_SHIFT	0
+#define SUNXI_I2SFSTA_RXACNT_WIDTH	7
+
+/* SUNXI_I2S_INT	0x1C 	 Digital Audio Interrupt Control Register */
+
+#define SUNXI_I2SINT_TXDRQEN		(1<<7)
+#define SUNXI_I2SINT_TXDRQEN_MASK	(1<<7)
+#define SUNXI_I2SINT_TXDRQEN_SHIFT	7
+#define SUNXI_I2SINT_TXDRQEN_WIDTH	1
+#define SUNXI_I2SINT_TXUIEN		(1<<6)
+#define SUNXI_I2SINT_TXUIEN_MASK	(1<<6)
+#define SUNXI_I2SINT_TXUIEN_SHIFT	6
+#define SUNXI_I2SINT_TXUIEN_WIDTH	1
+#define SUNXI_I2SINT_TXOIEN		(1<<5)
+#define SUNXI_I2SINT_TXOIEN_MASK	(1<<5)
+#define SUNXI_I2SINT_TXOIEN_SHIFT	5
+#define SUNXI_I2SINT_TXOIEN_WIDTH	1
+#define SUNXI_I2SINT_TXEIEN		(1<<4)
+#define SUNXI_I2SINT_TXEIEN_MASK	(1<<4)
+#define SUNXI_I2SINT_TXEIEN_SHIFT	4
+#define SUNXI_I2SINT_TXEIEN_WIDTH	1
+#define SUNXI_I2SINT_RXDRQEN		(1<<3)
+#define SUNXI_I2SINT_RXDRQEN_MASK	(1<<3)
+#define SUNXI_I2SINT_RXDRQEN_SHIFT	3
+#define SUNXI_I2SINT_RXDRQEN_WIDTH	1
+#define SUNXI_I2SINT_RXUIEN		(1<<2)
+#define SUNXI_I2SINT_RXUIEN_MASK	(1<<2)
+#define SUNXI_I2SINT_RXUIEN_SHIFT	2
+#define SUNXI_I2SINT_RXUIEN_WIDTH	1
+#define SUNXI_I2SINT_RXOIEN		(1<<1)
+#define SUNXI_I2SINT_RXOIEN_MASK	(1<<1)
+#define SUNXI_I2SINT_RXOIEN_SHIFT	1
+#define SUNXI_I2SINT_RXOIEN_WIDTH	1
+#define SUNXI_I2SINT_RXAIEN		(1<<0)
+#define SUNXI_I2SINT_RXAIEN_MASK	(1<<0)
+#define SUNXI_I2SINT_RXAIEN_SHIFT	0
+#define SUNXI_I2SINT_RXAIEN_WIDTH	1
+
+/* SUNXI_I2S_ISTA	0x20 	 Digital Audio Interrupt Status Register */
+
+#define SUNXI_I2SSTA_TXUIEN		(1<<6)
+#define SUNXI_I2SSTA_TXUIEN_MASK	(1<<6)
+#define SUNXI_I2SSTA_TXUIEN_SHIFT	6
+#define SUNXI_I2SSTA_TXUIEN_WIDTH	1
+#define SUNXI_I2SSTA_TXOIEN		(1<<5)
+#define SUNXI_I2SSTA_TXOIEN_MASK	(1<<5)
+#define SUNXI_I2SSTA_TXOIEN_SHIFT	5
+#define SUNXI_I2SSTA_TXOIEN_WIDTH	1
+#define SUNXI_I2SSTA_TXEIEN		(1<<4)
+#define SUNXI_I2SSTA_TXEIEN_MASK	(1<<4)
+#define SUNXI_I2SSTA_TXEIEN_SHIFT	4
+#define SUNXI_I2SSTA_TXEIEN_WIDTH	1
+#define SUNXI_I2SSTA_RXUIEN		(1<<2)
+#define SUNXI_I2SSTA_RXUIEN_MASK	(1<<2)
+#define SUNXI_I2SSTA_RXUIEN_SHIFT	2
+#define SUNXI_I2SSTA_RXUIEN_WIDTH	1
+#define SUNXI_I2SSTA_RXOIEN		(1<<1)
+#define SUNXI_I2SSTA_RXOIEN_MASK	(1<<1)
+#define SUNXI_I2SSTA_RXOIEN_SHIFT	1
+#define SUNXI_I2SSTA_RXOIEN_WIDTH	1
+#define SUNXI_I2SSTA_RXAIEN		(1<<0)
+#define SUNXI_I2SSTA_RXAIEN_MASK	(1<<0)
+#define SUNXI_I2SSTA_RXAIEN_SHIFT	0
+#define SUNXI_I2SSTA_RXAIEN_WIDTH	1
+
+/* SUNXI_I2S_CLKD	0x24 	 Digital Audio Clock Divide Register */
+
+#define SUNXI_I2SCLKD_MCLKOEN		(1<<7)
+#define SUNXI_I2SCLKD_MCLKOEN_MASK	(1<<7)
+#define SUNXI_I2SCLKD_MCLKOEN_SHIFT	7
+#define SUNXI_I2SCLKD_MCLKOEN_WIDTH	1
+#define SUNXI_I2SCLKD_BCLKDIV_MASK	(7<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_2		(0<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_4		(1<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_6		(2<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_8		(3<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_12	(4<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_16	(5<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_32	(6<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_64	(7<<4)
+#define SUNXI_I2SCLKD_BCLKDIV_SHIFT	4
+#define SUNXI_I2SCLKD_BCLKDIV_WIDTH	3
+#define SUNXI_I2SCLKD_MCLKDIV_MASK	(0xF<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_1		(0<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_2		(1<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_4		(2<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_6		(3<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_8		(4<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_12	(5<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_16	(6<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_24	(7<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_32	(8<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_48	(9<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_64	(10<<0)
+#define SUNXI_I2SCLKD_MCLKDIV_SHIFT	0
+#define SUNXI_I2SCLKD_MCLKDIV_WIDTH	4
+
+/* SUNXI_I2S_RXCNT	0x28 	 Digital Audio RX Sample Counter Register */
+
+/* SUNXI_I2S_TXCNT	0x2C 	 Digital Audio TX Sample Counter Register */
+
+/* SUNXI_I2S_TXCHSEL	0x30 	 Digital Audio TX Channel Select register */
+
+#define SUNXI_I2STXCHSEL_CHNUM_MASK	(7<<0)
+#define SUNXI_I2STXCHSEL_CHNUM_SHIFT	0
+#define SUNXI_I2STXCHSEL_CHNUM_WIDTH	3
+
+/* SUNXI_I2S_TXCHMAP	0x34 	 Digital Audio TX Channel Mapping Register */
+
+#define SUNXI_I2STXCHMAP_CH7_MASK	(7<<28)
+#define SUNXI_I2STXCHMAP_CH7_SHIFT	28
+#define SUNXI_I2STXCHMAP_CH7_WIDTH	3
+#define SUNXI_I2STXCHMAP_CH6_MASK	(7<<24)
+#define SUNXI_I2STXCHMAP_CH6_SHIFT	24
+#define SUNXI_I2STXCHMAP_CH6_WIDTH	3
+#define SUNXI_I2STXCHMAP_CH5_MASK	(7<<20)
+#define SUNXI_I2STXCHMAP_CH5_SHIFT	20
+#define SUNXI_I2STXCHMAP_CH5_WIDTH	3
+#define SUNXI_I2STXCHMAP_CH4_MASK	(7<<16)
+#define SUNXI_I2STXCHMAP_CH4_SHIFT	16
+#define SUNXI_I2STXCHMAP_CH4_WIDTH	3
+#define SUNXI_I2STXCHMAP_CH3_MASK	(7<<12)
+#define SUNXI_I2STXCHMAP_CH3_SHIFT	12
+#define SUNXI_I2STXCHMAP_CH3_WIDTH	3
+#define SUNXI_I2STXCHMAP_CH2_MASK	(7<<8)
+#define SUNXI_I2STXCHMAP_CH2_SHIFT	8
+#define SUNXI_I2STXCHMAP_CH2_WIDTH	3
+#define SUNXI_I2STXCHMAP_CH1_MASK	(7<<4)
+#define SUNXI_I2STXCHMAP_CH1_SHIFT	4
+#define SUNXI_I2STXCHMAP_CH1_WIDTH	3
+#define SUNXI_I2STXCHMAP_CH0_MASK	(7<<0)
+#define SUNXI_I2STXCHMAP_CH0_SHIFT	0
+#define SUNXI_I2STXCHMAP_CH0_WIDTH	3
+
+/* SUNXI_I2S_RXCHSEL	0x38 	 Digital Audio RX Channel Select register */
+
+#define SUNXI_I2SRXCHSEL_CHNUM_MASK	(7<<0)
+#define SUNXI_I2SRXCHSEL_CHNUM_SHIFT	0
+#define SUNXI_I2SRXCHSEL_CHNUM_WIDTH	3
+
+/* SUNXI_I2S_RXCHMAP	0x3C 	 Digital Audio RX Channel Mapping Register */
+
+#define SUNXI_I2SRXCHMAP_CH3_MASK	(7<<12)
+#define SUNXI_I2SRXCHMAP_CH3_SHIFT	12
+#define SUNXI_I2SRXCHMAP_CH3_WIDTH	3
+#define SUNXI_I2SRXCHMAP_CH2_MASK	(7<<8)
+#define SUNXI_I2SRXCHMAP_CH2_SHIFT	8
+#define SUNXI_I2SRXCHMAP_CH2_WIDTH	3
+#define SUNXI_I2SRXCHMAP_CH1_MASK	(7<<4)
+#define SUNXI_I2SRXCHMAP_CH1_SHIFT	4
+#define SUNXI_I2SRXCHMAP_CH1_WIDTH	3
+#define SUNXI_I2SRXCHMAP_CH0_MASK	(7<<0)
+#define SUNXI_I2SRXCHMAP_CH0_SHIFT	0
+#define SUNXI_I2SRXCHMAP_CH0_WIDTH	3
+
+
+/*------------------------------------------------------------*/
+/* Clock dividers */
+#define SUNXI_DIV_MCLK	0
+#define SUNXI_DIV_BCLK	1
+
+#define SUNXI_I2SCLKD_MCLK_MASK   0x0f
+#define SUNXI_I2SCLKD_MCLK_OFFS   0
+#define SUNXI_I2SCLKD_BCLK_MASK   0x070
+#define SUNXI_I2SCLKD_BCLK_OFFS   4
+#define SUNXI_I2SCLKD_MCLKEN_OFFS 7
+
+/* Supported SoC families - used for quirks */
+enum sunxi_soc_family {
+	SUN4IA,	/* A10 SoC - revision A */
+	SUN4I,	/* A10 SoC - later revisions */
+	SUN5I,	/* A10S/A13 SoCs */
+	SUN7I,	/* A20 SoC */
+};
+
+enum sunxi_i2s_mode {
+	IIS_MASTER,
+	IIS_SLAVE,
+};	
+
+struct sunxi_priv {
+	struct regmap *regmap;
+	struct clk *clk_apb, *clk_iis, *clk_mclk;
+
+	enum sunxi_soc_family revision;
+
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+
+	u32 slave;		//0: master, 1: slave
+	u32 mono;		//0: stereo, 1: mono
+	u32 samp_fs;		//audio sample rate (unit in kHz)
+	u32 samp_res;		//16 bits, 20 bits , 24 bits, 32 bits)
+	u32 samp_format;	//audio sample format (0: standard I2S, 1: left-justified, 2: right-justified, 3: pcm)
+	u32 ws_size;		//16 BCLK, 20 BCLK, 24 BCLK, 32 BCLK)
+	u32 mclk_rate;		//mclk frequency divide by fs (128fs, 192fs, 256fs, 384fs, 512fs, 768fs)
+	u32 lrc_pol;		//LRC clock polarity (0: normal ,1: inverted)
+	u32 bclk_pol;		//BCLK polarity (0: normal, 1: inverted)
+	u32 pcm_txtype;		//PCM transmitter type (0: 16-bits linear mode, 1: 8-bits linear mode, 2: u-law, 3: A-law)
+	u32 pcm_rxtype;		//PCM receiver type  (0: 16-bits linear mode, 1: 8-bits linear mode, 2: u-law, 3: A-law)
+	u32 pcm_sw;		//PCM slot width (8: 8 bits, 16: 16 bits)
+	u32 pcm_sync_period;	//PCM sync period (16/32/64/128/256)
+	u32 pcm_sync_type;	//PCM sync symbol size (0: short sync, 1: long sync)
+	u32 pcm_start_slot;	//PCM start slot index (1--4)
+	u32 pcm_lsb_first;	//0: MSB first, 1: LSB first
+	u32 pcm_ch_num;		//PCM channel number (1: one channel, 2: two channel)
+
+	void __iomem *base;
+	struct clk_divider mclk_div;
+	enum sunxi_i2s_mode mode;
+};
+
+#endif
