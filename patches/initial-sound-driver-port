Bottom: d90793d567f477f784df988b4f53d0f7f49b6a8f
Top:    c0fd7a79b4f7ab41a7e949ccf0441a3667cd6ec2
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-06-24 08:33:34 -0400

Initial sound driver port

---

diff --git a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
index bed74a9..a347eff 100644
--- a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
+++ b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
@@ -137,6 +137,10 @@
 			status = "okay";
 		};
 
+		codec@1c22c00 {
+			status = "okay";
+		};
+
 		ir0: ir@01c21800 {
 			pinctrl-names = "default";
 			pinctrl-0 = <&ir0_pins_a>;
diff --git a/arch/arm/boot/dts/sun7i-a20.dtsi b/arch/arm/boot/dts/sun7i-a20.dtsi
index 263eb79..833ef7e 100644
--- a/arch/arm/boot/dts/sun7i-a20.dtsi
+++ b/arch/arm/boot/dts/sun7i-a20.dtsi
@@ -91,6 +91,14 @@
 			clock-output-names = "pll1";
 		};
 
+		pll2: clk@01c20008 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sun7i-a20-pll2-clk";
+			reg = <0x01c20008 0x4>;
+			clocks = <&osc24M>;
+			clock-output-names = "pll2";
+		};
+
 		pll4: clk@01c20018 {
 			#clock-cells = <0>;
 			compatible = "allwinner,sun7i-a20-pll4-clk";
@@ -327,6 +335,30 @@
 			clock-output-names = "ir1";
 		};
 
+		i2s0_clk: clk@01c200b8 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200b8 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s0";
+		};
+
+		ac97_clk: clk@01c200bc {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200bc 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "ac97";
+		};
+
+		spdif_clk: clk@01c200c0 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200c0 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "spdif";
+		};
+
 		usb_clk: clk@01c200cc {
 			#clock-cells = <1>;
 		        #reset-cells = <1>;
@@ -344,6 +376,30 @@
 			clock-output-names = "spi3";
 		};
 
+		i2s1_clk: clk@01c200d8 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200d8 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s1";
+		};
+
+		i2s2_clk: clk@01c200dc {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200dc 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s2";
+		};
+
+		codec_clk: clk@01c20140 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-codec-clk";
+			reg = <0x01c20140 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "codec";
+		};
+
 		mbus_clk: clk@01c2015c {
 			#clock-cells = <0>;
 			compatible = "allwinner,sun4i-a10-mod0-clk";
@@ -807,6 +863,77 @@
 			clocks = <&osc24M>;
 			#pwm-cells = <3>;
 		};
+		
+		spdif@01c21000 {
+			compatible = "allwinner,sun7i-a20-spdif";
+			reg = <0x01C21000 0x40>;
+			interrupts = <0 13 4>;
+			clocks = <&pll2>, <&apb0_gates 1>, <&spdif_clk>;
+			clock-names = "pll2", "apb", "spdif";
+			dmas = <&dma 0 2>, <&dma 0 2>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		ac97@01c21400 {
+			compatible = "allwinner,sun7i-a20-ac97";
+			reg = <0x01C21400 0x40>;
+			interrupts = <0 14 4>;
+			clocks = <&pll2>, <&apb0_gates 2>, <&ac97_clk>;
+			clock-names = "pll2", "apb", "ac97";
+			dmas = <&dma 0 5>, <&dma 0 5>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s0: i2s@01c22000 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C22000 0x40>;
+			interrupts = <0 16 4>;
+			clocks = <&pll2>, <&apb0_gates 3>, <&i2s0_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 3>, <&dma 0 3>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s1: i2s@01c22400 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C22400 0x40>;
+			interrupts = <0 87 4>;
+			clocks = <&pll2>, <&apb0_gates 4>, <&i2s1_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 4>, <&dma 0 4>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s2: i2s@01c24400 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C24400 0x40>;
+			interrupts = <0 90 4>;
+			clocks = <&pll2>, <&apb0_gates 8>, <&i2s2_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 6>, <&dma 0 6>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		codec: codec@01c22c00 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun7i-a20-codec";
+			reg = <0x01C22c00 0x40>;
+			interrupts = <0 30 4>;
+			clocks = <&pll2>, <&apb0_gates 0>, <&codec_clk>;
+			clock-names = "pll2", "apb", "codec";
+			dmas = <&dma 0 19>, <&dma 0 19>;
+			dma-names = "rx", "tx";
+			routing =
+				"MIC_IN", "Microphone Jack",
+				"Microphone Jack", "Mic Bias",
+				"LINE_IN", "Line In Jack",
+				"Headphone Jack", "HP_OUT";
+		};
 
 		ir0: ir@01c21800 {
 			compatible = "allwinner,sun7i-a20-ir";
@@ -851,8 +978,8 @@
 			reg-shift = <2>;
 			reg-io-width = <4>;
 			clocks = <&apb1_gates 16>;
-			dmas = <&dma 0 8>, <&dma 0 8>;
-			dma-names = "rx", "tx";
+			/*dmas = <&dma 0 8>, <&dma 0 8>;
+			dma-names = "rx", "tx"; */
 			status = "disabled";
 		};
 
diff --git a/cop b/cop
new file mode 100755
index 0000000..42d5878
--- /dev/null
+++ b/cop
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+
+make zImage uImage dtbs
+#cp /work/hans/sound/soc/sunxi/sunxi-codec.ko /work/root/lib/modules/3.15.0+/kernel/sound/soc/sunxi
+
diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 399cf4d..9e67ac5 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -62,11 +62,17 @@ static unsigned long clk_factors_recalc_rate(struct clk_hw *hw,
 		p = FACTOR_GET(config->pshift, config->pwidth, reg);
 
 	/* Calculate the rate */
-	if (config->n_from_one)
+	switch (config->rate_adjust) {
+	case N_FROM_ONE:
 		rate = (parent_rate * (n + 1) * (k + 1) >> p) / (m + 1);
-	else
+		break;
+	case PLL2_DIV:
+		rate = parent_rate * n / k / m;
+		break;
+	default:
 		rate = (parent_rate * n * (k + 1) >> p) / (m + 1);
-
+		break;
+	}
 	return rate;
 }
 
@@ -139,6 +145,7 @@ static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
 	reg = FACTOR_SET(config->pshift, config->pwidth, reg, p);
 
 	/* Apply them now */
+	printk("CLK - write reg %p value %x\n", factors->reg, reg);
 	writel(reg, factors->reg);
 
 	/* delay 500us so pll stabilizes */
diff --git a/drivers/clk/sunxi/clk-factors.h b/drivers/clk/sunxi/clk-factors.h
index 0484a48..2d63400 100644
--- a/drivers/clk/sunxi/clk-factors.h
+++ b/drivers/clk/sunxi/clk-factors.h
@@ -6,6 +6,8 @@
 
 #define SUNXI_FACTORS_NOT_APPLICABLE	(0)
 
+enum erate_adjust {NO_ADJUST = 0, N_FROM_ONE, PLL2_DIV};
+
 struct clk_factors_config {
 	u8 nshift;
 	u8 nwidth;
@@ -15,7 +17,7 @@ struct clk_factors_config {
 	u8 mwidth;
 	u8 pshift;
 	u8 pwidth;
-	u8 n_from_one;
+	enum erate_adjust rate_adjust;
 };
 
 struct clk_factors {
diff --git a/drivers/clk/sunxi/clk-sunxi.c b/drivers/clk/sunxi/clk-sunxi.c
index 1d16c0c..1e4c98d 100644
--- a/drivers/clk/sunxi/clk-sunxi.c
+++ b/drivers/clk/sunxi/clk-sunxi.c
@@ -212,6 +212,30 @@ static void sun8i_a23_get_pll1_factors(u32 *freq, u32 parent_rate,
 }
 
 /**
+ * sun7i_get_pll2_factors()
+ * parent_rate is always 24Mhz
+ */
+
+static void sun7i_get_pll2_factors(u32 *freq, u32 parent_rate,
+				   u8 *n, u8 *k, u8 *m, u8 *p)
+{
+	printk("JDS - sun7i_get_pll2_factors %d\n", *freq);
+	/* we were called to round the frequency, we can now return */
+	if (n == NULL)
+		return;
+	
+	if (*freq == 22579200) {
+		*n = 79;
+		*m = 21;  /* Pre */
+		*k = 4;   /* Post */
+	} else  {
+		*n = 86;
+		*m = 21;  /* Pre */
+		*k = 4;   /* Post */
+	}
+}
+
+/**
  * sun4i_get_pll5_factors() - calculates n, k factors for PLL5
  * PLL5 rate is calculated as follows
  * rate = parent_rate * n * (k + 1)
@@ -479,7 +503,17 @@ static struct clk_factors_config sun8i_a23_pll1_config = {
 	.mwidth = 2,
 	.pshift = 16,
 	.pwidth = 2,
-	.n_from_one = 1,
+	.rate_adjust = N_FROM_ONE,
+};
+
+static struct clk_factors_config sun7i_pll2_config = {
+	.nshift = 8,
+	.nwidth = 7,
+	.kshift = 26,
+	.kwidth = 4,
+	.mshift = 0,
+	.mwidth = 5,
+	.rate_adjust = PLL2_DIV,
 };
 
 static struct clk_factors_config sun4i_pll5_config = {
@@ -494,7 +528,7 @@ static struct clk_factors_config sun6i_a31_pll6_config = {
 	.nwidth = 5,
 	.kshift = 4,
 	.kwidth = 2,
-	.n_from_one = 1,
+	.rate_adjust = N_FROM_ONE,
 };
 
 static struct clk_factors_config sun4i_apb1_config = {
@@ -538,6 +572,12 @@ static const struct factors_data sun8i_a23_pll1_data __initconst = {
 	.getter = sun8i_a23_get_pll1_factors,
 };
 
+static const struct factors_data sun7i_a20_pll2_data __initconst = {
+	.enable = 31,
+	.table = &sun7i_pll2_config,
+	.getter = sun7i_get_pll2_factors,
+};
+
 static const struct factors_data sun7i_a20_pll4_data __initconst = {
 	.enable = 31,
 	.table = &sun4i_pll5_config,
@@ -945,6 +985,10 @@ static const struct gates_data sun6i_a31_usb_gates_data __initconst = {
 	.reset_mask = BIT(2) | BIT(1) | BIT(0),
 };
 
+static const struct gates_data sunxi_codec_data __initconst = {
+	.mask = {BIT(31)},
+};
+
 static void __init sunxi_gates_clk_setup(struct device_node *node,
 					 struct gates_data *data)
 {
@@ -975,17 +1019,19 @@ static void __init sunxi_gates_clk_setup(struct device_node *node,
 	for_each_set_bit(i, data->mask, SUNXI_GATES_MAX_SIZE) {
 		of_property_read_string_index(node, "clock-output-names",
 					      j, &clk_name);
-
 		clk_data->clks[i] = clk_register_gate(NULL, clk_name,
 						      clk_parent, 0,
 						      reg + 4 * (i/32), i % 32,
 						      0, &clk_lock);
 		WARN_ON(IS_ERR(clk_data->clks[i]));
 		clk_register_clkdev(clk_data->clks[i], clk_name, NULL);
-
 		j++;
 	}
 
+	/* if there is a single gate, copy it to entry[0] so there is no requirement for phandle arg */
+	if (j == 1)
+		clk_data->clks[0] = clk_data->clks[i];
+
 	/* Adjust to the real max */
 	clk_data->clk_num = i;
 
@@ -1195,12 +1241,12 @@ free_clkdata:
 }
 
 
-
 /* Matches for factors clocks */
 static const struct of_device_id clk_factors_match[] __initconst = {
 	{.compatible = "allwinner,sun4i-a10-pll1-clk", .data = &sun4i_pll1_data,},
 	{.compatible = "allwinner,sun6i-a31-pll1-clk", .data = &sun6i_a31_pll1_data,},
 	{.compatible = "allwinner,sun8i-a23-pll1-clk", .data = &sun8i_a23_pll1_data,},
+	{.compatible = "allwinner,sun7i-a20-pll2-clk", .data = &sun7i_a20_pll2_data,},
 	{.compatible = "allwinner,sun7i-a20-pll4-clk", .data = &sun7i_a20_pll4_data,},
 	{.compatible = "allwinner,sun4i-a10-apb1-clk", .data = &sun4i_apb1_data,},
 	{.compatible = "allwinner,sun4i-a10-mod0-clk", .data = &sun4i_mod0_data,},
@@ -1258,6 +1304,7 @@ static const struct of_device_id clk_gates_match[] __initconst = {
 	{.compatible = "allwinner,sun4i-a10-usb-clk", .data = &sun4i_a10_usb_gates_data,},
 	{.compatible = "allwinner,sun5i-a13-usb-clk", .data = &sun5i_a13_usb_gates_data,},
 	{.compatible = "allwinner,sun6i-a31-usb-clk", .data = &sun6i_a31_usb_gates_data,},
+	{.compatible = "allwinner,sunxi-codec-clk", .data = &sunxi_codec_data,},
 	{}
 };
 
diff --git a/drivers/dma/of-dma.c b/drivers/dma/of-dma.c
index e8fe9dc..4fb133c 100644
--- a/drivers/dma/of-dma.c
+++ b/drivers/dma/of-dma.c
@@ -159,6 +159,7 @@ struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
 		return ERR_PTR(-ENODEV);
 	}
 
+	printk("JDS = of_dma_request_slave_channel %s %s\n", name, np->full_name);
 	count = of_property_count_strings(np, "dma-names");
 	if (count < 0) {
 		pr_err("%s: dma-names property of node '%s' missing or empty\n",
diff --git a/drivers/dma/sun4i-dma.c b/drivers/dma/sun4i-dma.c
index 7b986bd..5c30ecd 100644
--- a/drivers/dma/sun4i-dma.c
+++ b/drivers/dma/sun4i-dma.c
@@ -327,6 +327,7 @@ static void release_pchan(struct sun4i_ddma_dev *priv,
 static void configure_pchan(struct sun4i_dma_pchan *pchan,
 			    struct sun4i_ddma_promise *d)
 {
+	printk("JDS - configure_pchan\n");
 	if (pchan->is_dedicated) {
 		/* Configure addresses and misc parameters */
 		writel_relaxed(d->src, pchan->base + DDMA_SRC_ADDR_REG);
@@ -456,6 +457,7 @@ generate_ndma_promise(struct dma_chan *chan, dma_addr_t src, dma_addr_t dest,
 	struct sun4i_ddma_promise *promise;
 	int ret;
 
+	printk("JDS - generate_ndma_promise\n");
 	promise = kzalloc(sizeof(*promise), GFP_NOWAIT);
 	if (!promise)
 		return NULL;
@@ -512,6 +514,7 @@ generate_ddma_promise(struct dma_chan *chan, dma_addr_t src, dma_addr_t dest,
 	struct sun4i_ddma_promise *promise;
 	int ret;
 
+	printk("JDS - generate_ddma_promise\n");
 	promise = kzalloc(sizeof(*promise), GFP_NOWAIT);
 	if (!promise)
 		return NULL;
@@ -603,6 +606,7 @@ sun4i_dma_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest,
 	struct sun4i_ddma_promise *promise;
 	struct sun4i_ddma_contract *contract;
 
+	printk("JDS - sun4i_dma_prep_dma_memcpy\n");
 	contract = generate_ddma_contract();
 	if (!contract)
 		return NULL;
@@ -637,6 +641,73 @@ sun4i_dma_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest,
 	return vchan_tx_prep(&vchan->vc, &contract->vd, flags);
 }
 
+static struct dma_async_tx_descriptor *sun4i_dma_prep_dma_cyclic(
+		struct dma_chan *chan, dma_addr_t buf, size_t len,
+		size_t period_len, enum dma_transfer_direction dir,
+		unsigned long flags, void *context) {
+	struct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);
+	struct dma_slave_config *sconfig = &vchan->cfg;
+	struct sun4i_ddma_promise *promise;
+	struct sun4i_ddma_contract *contract;
+	dma_addr_t src, dest;
+
+	printk("JDS - sun4i_dma_prep_dma_cyclic\n");
+	if (!is_slave_direction(dir)) {
+		dev_err(chan2dev(chan), "Invalid DMA direction\n");
+		return NULL;
+	}
+
+	contract = generate_ddma_contract();
+	if (!contract)
+		return NULL;
+
+	/* Figure out addresses */
+	if (dir == DMA_MEM_TO_DEV) {
+		src = buf;
+		dest = sconfig->dst_addr;
+	} else {
+		src = sconfig->src_addr;
+		dest = buf;
+	}
+
+	if (vchan->is_dedicated)
+		promise = generate_ddma_promise(chan, src, dest, len, sconfig);
+	else
+		promise = generate_ndma_promise(chan, src, dest, len, sconfig);
+
+	if (!promise) {
+		kfree(contract);
+		return NULL;
+	}
+
+	/* Figure out endpoints */
+	if (vchan->is_dedicated && dir == DMA_MEM_TO_DEV) {
+		promise->cfg |= DDMA_CFG_CONT_MODE | DDMA_CFG_SRC_DRQ_TYPE(DDMA_DRQ_TYPE_SDRAM) |
+			    DDMA_CFG_SRC_ADDR_MODE(DDMA_ADDR_MODE_LINEAR) |
+			    DDMA_CFG_DEST_DRQ_TYPE(vchan->endpoint) |
+			    DDMA_CFG_DEST_ADDR_MODE(DDMA_ADDR_MODE_IO);
+	} else if (!vchan->is_dedicated && dir == DMA_MEM_TO_DEV) {
+		promise->cfg |= NDMA_CFG_CONT_MODE | NDMA_CFG_SRC_DRQ_TYPE(NDMA_DRQ_TYPE_SDRAM) |
+			    NDMA_CFG_DEST_DRQ_TYPE(vchan->endpoint) |
+			    NDMA_CFG_DEST_FIXED_ADDR;
+	} else if (vchan->is_dedicated) {
+		promise->cfg |= DDMA_CFG_CONT_MODE | DDMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |
+			    DDMA_CFG_SRC_ADDR_MODE(DDMA_ADDR_MODE_IO) |
+			    DDMA_CFG_DEST_DRQ_TYPE(DDMA_DRQ_TYPE_SDRAM) |
+			    DDMA_CFG_DEST_ADDR_MODE(DDMA_ADDR_MODE_LINEAR);
+	} else {
+		promise->cfg |= NDMA_CFG_CONT_MODE | NDMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |
+			    NDMA_CFG_SRC_FIXED_ADDR |
+			    NDMA_CFG_DEST_DRQ_TYPE(NDMA_DRQ_TYPE_SDRAM);
+	}
+
+	/* Fill the contract with our only promise */
+	list_add_tail(&promise->list, &contract->demands);
+
+	/* And add it to the vchan */
+	return vchan_tx_prep(&vchan->vc, &contract->vd, flags);
+}
+
 static struct dma_async_tx_descriptor *
 sun4i_dma_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 			unsigned int sg_len, enum dma_transfer_direction dir,
@@ -651,6 +722,7 @@ sun4i_dma_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 	u32 endpoints, para;
 	int i;
 
+	printk("JDS - sun4i_dma_prep_slave_sg\n");
 	if (!sgl)
 		return NULL;
 
@@ -723,6 +795,7 @@ static void sun4i_ddma_terminate_all(struct sun4i_dma_vchan *vchan)
 	u32 n_busy = NDMA_CFG_LOADING;
 
 
+	printk("sun4i_ddma_terminate_all\n");
 	spin_lock_irqsave(&vchan->vc.lock, flags);
 	vchan_get_all_descriptors(&vchan->vc, &head);
 	spin_unlock_irqrestore(&vchan->vc.lock, flags);
@@ -751,6 +824,8 @@ static int sun4i_dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 	struct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);
 	int ret = 0;
 
+	printk("JDS - sun4i_dma_control cmd %d\n", cmd);
+
 	switch (cmd) {
 	case DMA_RESUME:
 	case DMA_PAUSE:
@@ -771,6 +846,7 @@ static int sun4i_dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 		break;
 	}
 
+	printk("JDS - sun4i_dma_control, %d\n", ret);
 	return ret;
 }
 
@@ -919,6 +995,19 @@ static void sun4i_ddma_tasklet(unsigned long data)
 		execute_vchan_pending(priv, &priv->vchans[i]);
 }
 
+static int sun4i_dma_device_slave_caps(struct dma_chan *dchan,
+				      struct dma_slave_caps *caps)
+{
+	caps->src_addr_widths = 32;
+	caps->dstn_addr_widths = 32;
+	caps->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);
+	caps->cmd_pause = true;
+	caps->cmd_terminate = true;
+	caps->residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;
+
+	return 0;
+}
+
 static int sun4i_dma_probe(struct platform_device *pdev)
 {
 	struct sun4i_ddma_dev *priv;
@@ -962,7 +1051,9 @@ static int sun4i_dma_probe(struct platform_device *pdev)
 	priv->slave.device_issue_pending	= sun4i_dma_issue_pending;
 	priv->slave.device_prep_slave_sg	= sun4i_dma_prep_slave_sg;
 	priv->slave.device_prep_dma_memcpy	= sun4i_dma_prep_dma_memcpy;
+	priv->slave.device_prep_dma_cyclic	= sun4i_dma_prep_dma_cyclic;
 	priv->slave.device_control		= sun4i_dma_control;
+	priv->slave.device_slave_caps 		= sun4i_dma_device_slave_caps;
 	priv->slave.chancnt			= DDMA_NR_MAX_VCHANS;
 
 	priv->slave.dev = &pdev->dev;
diff --git a/sound/core/pcm_dmaengine.c b/sound/core/pcm_dmaengine.c
index 76cbb9e..7878410 100644
--- a/sound/core/pcm_dmaengine.c
+++ b/sound/core/pcm_dmaengine.c
@@ -148,10 +148,12 @@ static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 	enum dma_transfer_direction direction;
 	unsigned long flags = DMA_CTRL_ACK;
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit\n");
 	direction = snd_pcm_substream_to_dma_direction(substream);
 
 	if (!substream->runtime->no_period_wakeup)
 		flags |= DMA_PREP_INTERRUPT;
+	printk("JDS - dmaengine_pcm_prepare_and_submit a\n");
 
 	prtd->pos = 0;
 	desc = dmaengine_prep_dma_cyclic(chan,
@@ -159,13 +161,16 @@ static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 		snd_pcm_lib_buffer_bytes(substream),
 		snd_pcm_lib_period_bytes(substream), direction, flags);
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit b\n");
 	if (!desc)
 		return -ENOMEM;
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit c\n");
 	desc->callback = dmaengine_pcm_dma_complete;
 	desc->callback_param = substream;
 	prtd->cookie = dmaengine_submit(desc);
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit d\n");
 	return 0;
 }
 
@@ -185,12 +190,17 @@ int snd_dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int ret;
 
+	printk("JDS = snd_dmaengine_pcm_trigger cmd %d prtd %p runtime %p\n", cmd, prtd, runtime);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
+	printk("JDS = snd_dmaengine_pcm_trigger a\n");
 		ret = dmaengine_pcm_prepare_and_submit(substream);
+	printk("JDS = snd_dmaengine_pcm_trigger b\n");
 		if (ret)
 			return ret;
+	printk("JDS = snd_dmaengine_pcm_trigger c\n");
 		dma_async_issue_pending(prtd->dma_chan);
+	printk("JDS = snd_dmaengine_pcm_trigger d\n");
 		break;
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
@@ -212,6 +222,7 @@ int snd_dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		return -EINVAL;
 	}
 
+	printk("JDS = snd_dmaengine_pcm_trigger f\n");
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_dmaengine_pcm_trigger);
@@ -295,6 +306,7 @@ int snd_dmaengine_pcm_open(struct snd_pcm_substream *substream,
 	struct dmaengine_pcm_runtime_data *prtd;
 	int ret;
 
+	printk("JDS - snd_dmaengine_pcm_open\n");
 	if (!chan)
 		return -ENXIO;
 
@@ -311,6 +323,7 @@ int snd_dmaengine_pcm_open(struct snd_pcm_substream *substream,
 
 	substream->runtime->private_data = prtd;
 
+	printk("JDS - snd_dmaengine_pcm_open ret\n");
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_dmaengine_pcm_open);
diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index ce83def..f6edad4 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2086,6 +2086,7 @@ static int pcm_sanity_check(struct snd_pcm_substream *substream)
 	if (PCM_RUNTIME_CHECK(substream))
 		return -ENXIO;
 	runtime = substream->runtime;
+	printk("pcm_sanity_check %p %p\n", substream->ops->copy, runtime->dma_area);
 	if (snd_BUG_ON(!substream->ops->copy && !runtime->dma_area))
 		return -EINVAL;
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
diff --git a/sound/core/pcm_memory.c b/sound/core/pcm_memory.c
index 54debc0..66186c5 100644
--- a/sound/core/pcm_memory.c
+++ b/sound/core/pcm_memory.c
@@ -409,6 +409,7 @@ int _snd_pcm_lib_alloc_vmalloc_buffer(struct snd_pcm_substream *substream,
 	if (PCM_RUNTIME_CHECK(substream))
 		return -EINVAL;
 	runtime = substream->runtime;
+	printk("CLK - _snd_pcm_lib_alloc_vmalloc_buffer substream %p runtime %p dma_area %p\n", substream, runtime, runtime->dma_area);
 	if (runtime->dma_area) {
 		if (runtime->dma_bytes >= size)
 			return 0; /* already large enough */
@@ -418,6 +419,7 @@ int _snd_pcm_lib_alloc_vmalloc_buffer(struct snd_pcm_substream *substream,
 	if (!runtime->dma_area)
 		return -ENOMEM;
 	runtime->dma_bytes = size;
+	printk("CLK - _snd_pcm_lib_alloc_vmalloc_buffer substream %p runtime %p dma_area %p\n", substream, runtime, runtime->dma_area);
 	return 1;
 }
 EXPORT_SYMBOL(_snd_pcm_lib_alloc_vmalloc_buffer);
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 0060b31..8f08e4b 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -52,6 +52,7 @@ source "sound/soc/s6000/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/sirf/Kconfig"
 source "sound/soc/spear/Kconfig"
+source "sound/soc/sunxi/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/txx9/Kconfig"
 source "sound/soc/ux500/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 5f1df02..50c7ab3 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -29,6 +29,7 @@ obj-$(CONFIG_SND_SOC)	+= s6000/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= sirf/
 obj-$(CONFIG_SND_SOC)	+= spear/
+obj-$(CONFIG_SND_SOC)	+= sunxi/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= txx9/
 obj-$(CONFIG_SND_SOC)	+= ux500/
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 051c006..dc3b7c1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -21,7 +21,7 @@
  *   o Add more codecs and platforms to ensure good API coverage.
  *   o Support TDM on PCM and I2S
  */
-
+#define DEBUG
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
@@ -4667,6 +4667,7 @@ int snd_soc_of_get_dai_name(struct device_node *of_node,
 	struct of_phandle_args args;
 	int ret;
 
+printk("JDS = snd_soc_of_get_dai_name\n");
 	ret = of_parse_phandle_with_args(of_node, "sound-dai",
 					 "#sound-dai-cells", 0, &args);
 	if (ret)
@@ -4674,11 +4675,13 @@ int snd_soc_of_get_dai_name(struct device_node *of_node,
 
 	ret = -EPROBE_DEFER;
 
+printk("JDS = snd_soc_of_get_dai_name a\n");
 	mutex_lock(&client_mutex);
 	list_for_each_entry(pos, &component_list, list) {
 		if (pos->dev->of_node != args.np)
 			continue;
 
+printk("JDS = snd_soc_of_get_dai_name b\n");
 		if (pos->driver->of_xlate_dai_name) {
 			ret = pos->driver->of_xlate_dai_name(pos, &args, dai_name);
 		} else {
@@ -4703,9 +4706,12 @@ int snd_soc_of_get_dai_name(struct device_node *of_node,
 
 			ret = 0;
 
+printk("JDS = snd_soc_of_get_dai_name c\n");
 			*dai_name = pos->dai_drv[id].name;
+printk("JDS = snd_soc_of_get_dai_name name %s\n", *dai_name);
 			if (!*dai_name)
 				*dai_name = pos->name;
+printk("JDS = snd_soc_of_get_dai_name d *s\n", *dai_name);
 		}
 
 		break;
@@ -4713,6 +4719,7 @@ int snd_soc_of_get_dai_name(struct device_node *of_node,
 	mutex_unlock(&client_mutex);
 
 	of_node_put(args.np);
+printk("JDS = snd_soc_of_get_dai_name e\n");
 
 	return ret;
 }
diff --git a/sound/soc/soc-generic-dmaengine-pcm.c b/sound/soc/soc-generic-dmaengine-pcm.c
index 5bace12..4ba2a2bc 100644
--- a/sound/soc/soc-generic-dmaengine-pcm.c
+++ b/sound/soc/soc-generic-dmaengine-pcm.c
@@ -65,15 +65,19 @@ int snd_dmaengine_pcm_prepare_slave_config(struct snd_pcm_substream *substream,
 	struct snd_dmaengine_dai_dma_data *dma_data;
 	int ret;
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config\n");
 	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config 1\n");
 	ret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);
 	if (ret)
 		return ret;
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config 2\n");
 	snd_dmaengine_pcm_set_config_from_dai_data(substream, dma_data,
 		slave_config);
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config 3\n");
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_dmaengine_pcm_prepare_slave_config);
@@ -90,6 +94,7 @@ static int dmaengine_pcm_hw_params(struct snd_pcm_substream *substream,
 	struct dma_slave_config slave_config;
 	int ret;
 
+	printk("JDS - dmaengine_pcm_hw_params pcm %p\n", pcm);
 	memset(&slave_config, 0, sizeof(slave_config));
 
 	if (!pcm->config)
@@ -107,6 +112,7 @@ static int dmaengine_pcm_hw_params(struct snd_pcm_substream *substream,
 			return ret;
 	}
 
+	printk("JDS - dmaengine_pcm_hw_params ret\n");
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
 }
 
@@ -121,12 +127,14 @@ static int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substrea
 	struct snd_pcm_hardware hw;
 	int ret;
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams pcm %p\n", pcm);
 	if (pcm->config && pcm->config->pcm_hardware)
 		return snd_soc_set_runtime_hwparams(substream,
 				pcm->config->pcm_hardware);
 
 	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams dma_data %p\n", dma_data);
 	memset(&hw, 0, sizeof(hw));
 	hw.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
 			SNDRV_PCM_INFO_INTERLEAVED;
@@ -137,6 +145,7 @@ static int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substrea
 	hw.buffer_bytes_max = SIZE_MAX;
 	hw.fifo_size = dma_data->fifo_size;
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams dma_data 2  %p\n", dma_data);
 	if (pcm->flags & SND_DMAENGINE_PCM_FLAG_NO_RESIDUE)
 		hw.info |= SNDRV_PCM_INFO_BATCH;
 
@@ -148,6 +157,7 @@ static int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substrea
 			hw.info |= SNDRV_PCM_INFO_BATCH;
 	}
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams dma_data 3 %p\n", dma_data);
 	return snd_soc_set_runtime_hwparams(substream, &hw);
 }
 
@@ -158,6 +168,7 @@ static int dmaengine_pcm_open(struct snd_pcm_substream *substream)
 	struct dma_chan *chan = pcm->chan[substream->stream];
 	int ret;
 
+	printk("JDS - dmaengine_pcm_open\n");
 	ret = dmaengine_pcm_set_runtime_hwparams(substream);
 	if (ret)
 		return ret;
@@ -178,6 +189,7 @@ static struct dma_chan *dmaengine_pcm_compat_request_channel(
 	struct snd_dmaengine_dai_dma_data *dma_data;
 	dma_filter_fn fn = NULL;
 
+	printk("JDS - dmaengine_pcm_compat_request_channel\n");
 	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
 	if ((pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX) && pcm->chan[0])
@@ -219,6 +231,7 @@ static int dmaengine_pcm_new(struct snd_soc_pcm_runtime *rtd)
 	unsigned int i;
 	int ret;
 
+	printk("JDS - dmaengine_pcm_new\n");
 	if (config && config->prealloc_buffer_size) {
 		prealloc_buffer_size = config->prealloc_buffer_size;
 		max_buffer_size = config->pcm_hardware->buffer_bytes_max;
@@ -283,11 +296,14 @@ static snd_pcm_uframes_t dmaengine_pcm_pointer(
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);
+	snd_pcm_uframes_t ret;
 
 	if (pcm->flags & SND_DMAENGINE_PCM_FLAG_NO_RESIDUE)
-		return snd_dmaengine_pcm_pointer_no_residue(substream);
+		ret = snd_dmaengine_pcm_pointer_no_residue(substream);
 	else
-		return snd_dmaengine_pcm_pointer(substream);
+		ret = snd_dmaengine_pcm_pointer(substream);
+	printk("dmaengine_pcm_pointer %x\n", ret);
+	return ret;
 }
 
 static const struct snd_pcm_ops dmaengine_pcm_ops = {
@@ -319,6 +335,7 @@ static int dmaengine_pcm_request_chan_of(struct dmaengine_pcm *pcm,
 	const char *name;
 	struct dma_chan *chan;
 
+	printk("JDS - dmaengine_pcm_request_chan_of\n");
 	if ((pcm->flags & (SND_DMAENGINE_PCM_FLAG_NO_DT |
 			   SND_DMAENGINE_PCM_FLAG_CUSTOM_CHANNEL_NAME)) ||
 	    !dev->of_node)
@@ -388,6 +405,7 @@ int snd_dmaengine_pcm_register(struct device *dev,
 	struct dmaengine_pcm *pcm;
 	int ret;
 
+	printk("JDS - snd_dmaengine_pcm_register\n");
 	pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
 	if (!pcm)
 		return -ENOMEM;
diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c
index a391de0..59a03a0 100644
--- a/sound/soc/soc-pcm.c
+++ b/sound/soc/soc-pcm.c
@@ -671,12 +671,14 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	int ret = 0;
 
+	printk("JDS - soc_pcm_hw_params\n");
 	mutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);
 
 	ret = soc_pcm_params_symmetry(substream, params);
 	if (ret)
 		goto out;
 
+	printk("JDS - soc_pcm_hw_params a\n");
 	if (rtd->dai_link->ops && rtd->dai_link->ops->hw_params) {
 		ret = rtd->dai_link->ops->hw_params(substream, params);
 		if (ret < 0) {
@@ -686,6 +688,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
+	printk("JDS - soc_pcm_hw_params b\n");
 	if (codec_dai->driver->ops && codec_dai->driver->ops->hw_params) {
 		ret = codec_dai->driver->ops->hw_params(substream, params, codec_dai);
 		if (ret < 0) {
@@ -695,6 +698,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
+	printk("JDS - soc_pcm_hw_params c\n");
 	if (cpu_dai->driver->ops && cpu_dai->driver->ops->hw_params) {
 		ret = cpu_dai->driver->ops->hw_params(substream, params, cpu_dai);
 		if (ret < 0) {
@@ -704,6 +708,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
+	printk("JDS - soc_pcm_hw_params d\n");
 	if (platform->driver->ops && platform->driver->ops->hw_params) {
 		ret = platform->driver->ops->hw_params(substream, params);
 		if (ret < 0) {
@@ -726,6 +731,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 
 out:
 	mutex_unlock(&rtd->pcm_mutex);
+	printk("JDS - soc_pcm_hw_params e\n");
 	return ret;
 
 platform_err:
diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
new file mode 100644
index 0000000..cb75a83
--- /dev/null
+++ b/sound/soc/sunxi/Kconfig
@@ -0,0 +1,5 @@
+config SND_SUNXI_SOC_CODEC
+	tristate "APB On-Chip sun4i and sun5i Codec"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	default y
+
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
new file mode 100644
index 0000000..b8950d3
--- /dev/null
+++ b/sound/soc/sunxi/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_SND_SUNXI_SOC_CODEC) += sunxi-codec.o
+
diff --git a/sound/soc/sunxi/codec_new.c b/sound/soc/sunxi/codec_new.c
new file mode 100644
index 0000000..4070bfe
--- /dev/null
+++ b/sound/soc/sunxi/codec_new.c
@@ -0,0 +1,687 @@
+/*
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/clk.h>
+#include <linux/regmap.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+
+//Codec Register
+#define SUNXI_DAC_DPC                (0x00)
+#define SUNXI_DAC_FIFOC              (0x04)
+#define SUNXI_DAC_FIFOS              (0x08)
+#define SUNXI_DAC_TXDATA             (0x0c)
+#define SUNXI_DAC_ACTL               (0x10)
+#define SUNXI_DAC_TUNE               (0x14)
+#define SUNXI_DAC_DEBUG              (0x18)
+#define SUNXI_ADC_FIFOC              (0x1c)
+#define SUNXI_ADC_FIFOS              (0x20)
+#define SUNXI_ADC_RXDATA             (0x24)
+#define SUNXI_ADC_ACTL               (0x28)
+#define SUNXI_ADC_DEBUG              (0x2c)
+#define SUNXI_DAC_TXCNT              (0x30)
+#define SUNXI_ADC_RXCNT              (0x34)
+#define SUNXI_BIAS_CRT               (0x38)
+#define SUNXI_MIC_CRT                (0x3c)
+#define SUNXI_CODEC_REGS_NUM         (13)
+
+#define DAIFMT_16BITS             (16)
+#define DAIFMT_20BITS             (20)
+
+#define DAIFMT_BS_MASK            (~(1<<16))  	//FIFO big small mode mask
+#define DAIFMT_BITS_MASK          (~(1<<5))		//FIFO Bits select mask,not used yet.
+#define SAMPLE_RATE_MASK          (~(7<<29))  	//Sample Rate slect mask
+
+#define DAC_EN                    (31)
+#define DIGITAL_VOL               (12)
+//For CODEC OLD VERSION
+#define DAC_VERSION               (23)
+
+#define DAC_CHANNEL		  (6)
+#define LAST_SE                   (26)
+#define TX_FIFO_MODE              (24)
+#define DRA_LEVEL                 (21)
+#define TX_TRI_LEVEL              (8)
+#define DAC_MODE                  (6)			//not used yet
+#define TASR                      (5)			//not used yet
+#define DAC_DRQ                   (4)
+#define DAC_FIFO_FLUSH            (0)
+
+#define VOLUME                    (0)
+#define PA_MUTE                   (6)
+#define MIXPAS                    (7)
+#define DACPAS                    (8)
+#define MIXEN                     (29)
+#define DACAEN_L                  (30)
+#define DACAEN_R                  (31)
+
+#define ADC_DIG_EN                (28)
+#define RX_FIFO_MODE              (24)
+#define RX_TRI_LEVEL              (8)
+#define ADC_MODE                  (7)
+#define RASR                      (6)
+#define ADC_DRQ                   (4)
+#define ADC_FIFO_FLUSH            (0)
+
+#define  ADC_LF_EN                (31)
+#define  ADC_RI_EN                (30)
+#define  ADC_EN                   (30)
+#define  MIC1_EN                  (29)
+#define  MIC2_EN                  (28)
+#define  VMIC_EN                  (27)
+#define  MIC_GAIN                 (25)
+#define  ADC_SELECT               (17)
+#define  PA_ENABLE                (4)
+#define  HP_DIRECT                (3)
+
+
+enum sunxi_device_id {SUN4A, SUN4I, SUN5I, SUN7I}; 
+
+struct sunxi_priv {
+	struct regmap *regmap;
+	int irq;
+	struct clk *clk_apb, *clk_pll2, *clk_module;
+
+	enum sunxi_device_id id;
+
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+};
+
+static int codec_play_start(struct sunxi_priv *priv)
+{
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+#endif
+	//flush TX FIFO
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_FIFO_FLUSH, 0x1 << DAC_FIFO_FLUSH);
+	//enable dac drq
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_DRQ, 0x1 << DAC_DRQ);
+	return 0;
+}
+
+static int codec_play_stop(struct sunxi_priv *priv)
+{
+	//pa mute
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+#endif
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
+	mdelay(5);
+	//disable dac drq
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_DRQ, 0x0 << DAC_DRQ);
+	//pa mute
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_L, 0x0 << DACAEN_L);
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_R, 0x0 << DACAEN_R);
+	return 0;
+}
+
+static int codec_capture_start(struct sunxi_priv *priv)
+{
+	//enable adc drq
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+#endif
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DRQ, 0x1 << ADC_DRQ);
+	return 0;
+}
+
+static int codec_capture_stop(struct sunxi_priv *priv)
+{
+	//disable adc drq
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DRQ, 0x0 << ADC_DRQ);
+	//enable mic1 pa
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << MIC1_EN, 0x0 << MIC1_EN);
+	//enable VMIC
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << VMIC_EN, 0x0 << VMIC_EN);
+	if (priv->id == SUN7I) {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_TUNE, 0x3 << 8, 0x0 << 8);
+	}
+	//enable adc digital
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DIG_EN, 0x0 << ADC_DIG_EN);
+	//set RX FIFO mode
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << RX_FIFO_MODE, 0x0 << RX_FIFO_MODE);
+	//flush RX FIFO
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_FIFO_FLUSH, 0x0 << ADC_FIFO_FLUSH);
+	//enable adc1 analog
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << ADC_EN, 0x0 << ADC_EN);
+	return 0;
+}
+
+static int sunxi_codec_trigger(struct snd_pcm_substream *substream, int cmd,
+	struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	printk("JDS - sunxi_codec_trigger cmd %d\n", cmd);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			codec_capture_start(priv);
+		else
+			codec_play_start(priv);
+		break;		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			codec_capture_stop(priv);
+		else
+			codec_play_stop(priv);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sunxi_codec_prepare(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	printk("JDS - sunxi_codec_prepare\n");
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1 << DAC_EN, 0x1 << DAC_EN);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_FIFO_FLUSH, 0x1 << DAC_FIFO_FLUSH);
+		//set TX FIFO send drq level
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0xf << TX_TRI_LEVEL, 0xf << TX_TRI_LEVEL);
+		if (substream->runtime->rate > 32000) {
+			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << 28, 0x0 << 28);
+		} else {
+			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << 28, 0x1 << 28);
+		}
+		//set TX FIFO MODE
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << TX_FIFO_MODE, 0x1 << TX_FIFO_MODE);
+		//send last sample when dac fifo under run
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << LAST_SE, 0x0 << LAST_SE);
+		//enable dac analog
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_L, 0x1 << DACAEN_L);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_R, 0x1 << DACAEN_R);
+		//enable dac to pa
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACPAS, 0x1 << DACPAS);
+	} else {
+		//enable mic1 pa
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << MIC1_EN, 0x1 << MIC1_EN);
+		//mic1 gain 32dB
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << 25, 0x1 << 25);
+		//enable VMIC
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << VMIC_EN, 0x1 << VMIC_EN);
+
+		if (priv->id == SUN7I) {
+			/* boost up record effect */
+			regmap_update_bits(priv->regmap, SUNXI_DAC_TUNE, 0x3 << 8, 0x1 << 8);
+		}
+
+		//enable adc digital
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DIG_EN, 0x1 << ADC_DIG_EN);
+		//set RX FIFO mode
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << RX_FIFO_MODE, 0x1 << RX_FIFO_MODE);
+		//flush RX FIFO
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_FIFO_FLUSH, 0x1 << ADC_FIFO_FLUSH);
+		//set RX FIFO rec drq level
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0xf << RX_TRI_LEVEL, 0x7 << RX_TRI_LEVEL);
+		//enable adc1 analog
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << ADC_EN, 0x3 << ADC_EN);
+	}
+	return 0;
+}
+
+static int sunxi_codec_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+	unsigned int rate = params_rate(params);
+
+	printk("CLK - sunxi_codec_hw_params substream %p runtime %p\n", substream, rtd);
+	switch (params_rate(params)) {
+	case 44100:
+	case 22050:
+	case 11025:
+	default:
+		clk_set_rate(priv->clk_pll2, 22579200);
+		clk_set_rate(priv->clk_module, 22579200);
+		break;
+	case 192000:
+	case 96000:
+	case 48000:
+	case 32000:
+	case 24000:
+	case 16000:
+	case 12000:
+	case 8000:
+		clk_set_rate(priv->clk_pll2, 24576000);
+		clk_set_rate(priv->clk_module, 24576000);
+		break;
+	}
+
+	switch (params_rate(params)) {
+	default:
+	case 44100:
+		rate = 0;
+		break;
+	case 22050:
+		rate = 2;
+		break;
+	case 11025:
+		rate = 4;
+		break;
+	case 192000:
+		rate = 6;
+		break;
+	case 96000:
+		rate = 7;
+		break;
+	case 48000:
+		rate = 0;
+		break;
+	case 32000:
+		rate = 1;
+		break;
+	case 24000:
+		rate = 2;
+		break;
+	case 16000:
+		rate = 3;
+		break;
+	case 12000:
+		rate = 4;
+		break;
+	case 8000:
+		rate = 5;
+		break;
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 7 << 29, rate << 29);
+		if (substream->runtime->channels == 1)
+			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << 6, 1 << 6);
+		else
+			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << 6, 0 << 6);
+	} else  {
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 7 << 29, rate << 29);
+		if (substream->runtime->channels == 1)
+			regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 1 << 7, 1 << 7);
+		else
+			regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 1 << 7, 0 << 7);
+	}
+	return 0;
+}
+
+static const struct snd_kcontrol_new sun7i_dac_ctls[] = {
+	/*SUNXI_DAC_ACTL = 0x10,PAVOL*/
+	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
+	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0), 
+	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+	SOC_SINGLE("MIC output volume", SUNXI_DAC_ACTL, 20, 7, 0),
+	/*	FM Input to output mixer Gain Control
+	* 	From -4.5db to 6db,1.5db/step,default is 0db
+	*	-4.5db:0x0,-3.0db:0x1,-1.5db:0x2,0db:0x3
+	*	1.5db:0x4,3.0db:0x5,4.5db:0x6,6db:0x7
+	*/
+	SOC_SINGLE("Fm output Volume", SUNXI_DAC_ACTL, 23, 7, 0),
+	/*	Line-in gain stage to output mixer Gain Control
+	*	0:-1.5db,1:0db
+	*/
+	SOC_SINGLE("Line output Volume", SUNXI_DAC_ACTL, 26, 1, 0),
+
+	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
+	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
+	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0), 
+	SOC_SINGLE("Linein Pre-AMP", SUNXI_ADC_ACTL, 13, 7, 0), 
+	SOC_SINGLE("LINEIN APM Volume", SUNXI_MIC_CRT, 13, 0x7, 0),
+	/* ADC Input Gain Control, capture volume
+	* 000:-4.5db,001:-3db,010:-1.5db,011:0db,100:1.5db,101:3db,110:4.5db,111:6db
+	*/
+	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0),
+	/*
+	*	MIC2 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
+	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
+	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
+	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
+	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
+	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
+	SOC_SINGLE("Mic2 gain Volume", SUNXI_MIC_CRT, 26, 7, 0),
+	/*
+	*	MIC1 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	SOC_SINGLE("Mic1 gain Volume", SUNXI_MIC_CRT, 29, 3, 0), 
+};
+
+
+static int sunxi_codec_dai_probe(struct snd_soc_dai *dai)
+{
+	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	printk("CLK - sunxi_codec_dai_probe %p\n", priv);
+	snd_soc_dai_init_dma_data(dai, &priv->playback_dma_data, &priv->capture_dma_data);
+
+	return 0;
+}
+
+static int sunxi_codec_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	int ret;
+	printk("JDS - CLK sunxi_codec_startup %p %p\n", codec, priv->clk_module);
+	ret = clk_prepare_enable(priv->clk_module);
+	if (ret)
+		return ret;
+
+	printk("JDS - sunxi_codec_startup - ok\n");
+	return 0;
+}
+
+static void sunxi_codec_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	printk("JDS - sunxi_codec_shutdown\n");
+	clk_disable_unprepare(priv->clk_module);
+}
+
+static const struct snd_soc_dai_ops sunxi_codec_dai_ops = {
+	.startup = sunxi_codec_startup,
+	.shutdown = sunxi_codec_shutdown,
+	.trigger = sunxi_codec_trigger,
+	.hw_params = sunxi_codec_hw_params,
+	.prepare = sunxi_codec_prepare,
+};
+
+static struct snd_soc_dai_driver sunxi_codec_dai = {
+	.probe = sunxi_codec_dai_probe,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+
+		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_11025 |\
+			 SNDRV_PCM_RATE_22050| SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\
+			 SNDRV_PCM_RATE_48000 |SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000 |\
+			 SNDRV_PCM_RATE_KNOT),
+		.rate_min = 8000,
+		.rate_max = 192000,
+	},
+	.ops = &sunxi_codec_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_codec_component = {
+	.name = "sunxi-codec",
+};
+
+static const struct regmap_config sunxi_codec_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_MIC_CRT,
+};
+
+static const struct snd_soc_dapm_widget codec_dapm_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("Mic Bias"),
+	SND_SOC_DAPM_OUTPUT("HP_OUT"),
+	SND_SOC_DAPM_INPUT("MIC_IN"),
+	SND_SOC_DAPM_INPUT("LINE_IN"),
+};
+
+static struct snd_soc_dai_link cdc_dai = {
+	.name = "cdc",
+	.stream_name = "CDC PCM",
+	.codec_dai_name = "sunxi-codec-dai",
+	.cpu_dai_name = "1c22c00.codec",
+	.codec_name = "1c22c00.codec",
+	//.init = tegra_wm8903_init,
+	//.ops = &tegra_wm8903_ops,
+	.dai_fmt = SND_SOC_DAIFMT_I2S,
+};
+
+static struct snd_soc_card snd_soc_sunxi_codec = {
+	.name = "sunxi-codec",
+	.owner = THIS_MODULE,
+	.dai_link = &cdc_dai,
+	.num_links = 1,
+
+	.fully_routed = true,
+};
+
+static struct snd_soc_codec_driver dummy_codec = {
+	.controls = sun7i_dac_ctls,
+	.num_controls = ARRAY_SIZE(sun7i_dac_ctls),
+	.dapm_widgets = codec_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(codec_dapm_widgets),
+};
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_192000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S8 | \
+			SNDRV_PCM_FMTBIT_U8 | \
+			SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_U16_LE | \
+			SNDRV_PCM_FMTBIT_S24_LE | \
+			SNDRV_PCM_FMTBIT_U24_LE | \
+			SNDRV_PCM_FMTBIT_S32_LE | \
+			SNDRV_PCM_FMTBIT_U32_LE | \
+			SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE)
+static struct snd_soc_dai_driver dummy_dai = {
+	.name = "sunxi-codec-dai",
+	.playback = {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+	.capture = {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates = STUB_RATES,
+		.formats = STUB_FORMATS,
+	 },
+};
+
+static const struct of_device_id sunxi_codec_of_match[] = {
+	{ .compatible = "allwinner,sun4i-a10a-codec", .data = (void *)SUN4A},
+	{ .compatible = "allwinner,sun4i-a10-codec", .data = (void *)SUN4I},
+	{ .compatible = "allwinner,sun5i-a13-codec", .data = (void *)SUN5I},
+	{ .compatible = "allwinner,sun7i-a20-codec", .data = (void *)SUN7I},
+	{}
+};
+MODULE_DEVICE_TABLE(of, sunxi_codec_of_match);
+
+static int sunxi_codec_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_card *card = &snd_soc_sunxi_codec;
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct sunxi_priv *priv;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	of_id = of_match_device(sunxi_codec_of_match, dev);
+	if (!of_id)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	card->dev = &pdev->dev;
+	platform_set_drvdata(pdev, card);
+	snd_soc_card_set_drvdata(card, priv);
+
+	priv->id = (int)of_id->data;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	priv->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					    &sunxi_codec_regmap_config);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	priv->irq = irq_of_parse_and_map(np, 0);
+	if (!priv->irq) {
+		dev_err(dev, "no irq for node %s\n", np->full_name);
+		return -ENXIO;
+	}
+
+	/* Clock */
+	priv->clk_apb = devm_clk_get(dev, "apb");
+	if (IS_ERR(priv->clk_apb)) {
+		dev_err(dev, "failed to get apb clock.\n");
+		return PTR_ERR(priv->clk_apb);
+	}
+	priv->clk_pll2 = devm_clk_get(dev, "pll2");
+	if (IS_ERR(priv->clk_pll2)) {
+		dev_err(dev, "failed to get pll2 clock.\n");
+		return PTR_ERR(priv->clk_pll2);
+	}
+	priv->clk_module = devm_clk_get(dev, "codec");
+	if (IS_ERR(priv->clk_module)) {
+		dev_err(dev, "failed to get codec clock.\n");
+		return PTR_ERR(priv->clk_module);
+	}
+	printk("CLK = card %p priv %p priv->clk_module %p\n", card, priv, priv->clk_module);
+
+	ret = clk_set_rate(priv->clk_pll2, 24576000);
+	if (ret) {
+		dev_err(dev, "set codec base clock rate failed!\n");
+		return ret;
+	}
+	if (clk_prepare_enable(priv->clk_pll2)) {
+		dev_err(dev, "try to enable clk_pll2 failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(priv->clk_apb)) {
+		dev_err(dev, "try to enable clk_apb failed\n");
+		return -EINVAL;
+	}
+
+	priv->playback_dma_data.addr = res->start + SUNXI_DAC_TXDATA;
+	priv->playback_dma_data.maxburst = 4;
+	priv->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	priv->capture_dma_data.addr = res->start + SUNXI_ADC_RXDATA;
+	priv->capture_dma_data.maxburst = 4;
+	priv->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	ret = snd_soc_register_codec(&pdev->dev, &dummy_codec, &dummy_dai, 1);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_codec_component, &sunxi_codec_dai, 1);
+	if (ret)
+		goto err_clk_disable;
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret)
+		goto err_clk_disable;
+
+	ret = snd_soc_of_parse_audio_routing(card, "routing");
+	if (ret)
+		goto err;
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+		goto err_fini_utils;
+	}
+
+	return 0;
+
+err_fini_utils:
+err:
+err_clk_disable:
+	clk_disable_unprepare(priv->clk_module);
+	clk_disable_unprepare(priv->clk_apb);
+	clk_disable_unprepare(priv->clk_pll2);
+	return ret;
+}
+
+static int sunxi_codec_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_priv *priv = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(priv->clk_module);
+	clk_disable_unprepare(priv->clk_apb);
+	clk_disable_unprepare(priv->clk_pll2);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_codec_driver = {
+	.driver = {
+		.name = "sunxi-codec",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_codec_of_match,
+	},
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_dev_remove,
+};
+module_platform_driver(sunxi_codec_driver);
+
+MODULE_ALIAS("platform:sunxi-codec");
+MODULE_DESCRIPTION("sunxi CODEC ALSA codec driver");
+MODULE_AUTHOR("software");
+MODULE_LICENSE("GPL v2");
+
diff --git a/sound/soc/sunxi/codec_old.c b/sound/soc/sunxi/codec_old.c
new file mode 100644
index 0000000..5143b42
--- /dev/null
+++ b/sound/soc/sunxi/codec_old.c
@@ -0,0 +1,752 @@
+/*
+ * ALSA SoC codec Out Audio Layer for spear processors
+ *
+ * Copyright (C) 2012 ST Microelectronics
+ * Vipin Kumar <vipin.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/regmap.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include "sunxi-codec.h"
+
+static void codec_resume_events(struct work_struct *work);
+struct workqueue_struct *resume_work_queue;
+static DECLARE_WORK(codec_resume_work, codec_resume_events);
+
+static void sunxi_configure(struct card_data *priv)
+{
+#ifdef JDS
+	writel(sunxi_RESET, priv->io_base + sunxi_SOFT_RST);
+	mdelay(1);
+	writel(readl(priv->io_base + sunxi_SOFT_RST) & ~sunxi_RESET,
+			priv->io_base + sunxi_SOFT_RST);
+
+	writel(sunxi_FDMA_TRIG_16 | sunxi_MEMFMT_16_16 |
+			sunxi_VALID_HW | sunxi_USER_HW |
+			sunxi_CHNLSTA_HW | sunxi_PARITY_HW,
+			priv->io_base + sunxi_CFG);
+
+	writel(0x7F, priv->io_base + sunxi_INT_STA_CLR);
+	writel(0x7F, priv->io_base + sunxi_INT_EN_CLR);
+#endif 
+}
+
+static int sunxi_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *cpu_dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	ret = clk_enable(priv->codec_moduleclk);
+	if (ret)
+		return ret;
+
+	priv->running = true;
+	sunxi_configure(priv);
+
+	return 0;
+}
+
+static void sunxi_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return;
+
+	clk_disable(priv->codec_moduleclk);
+	priv->running = false;
+}
+
+static void sunxi_clock(struct card_data *priv, u32 core_freq,
+		u32 rate)
+{
+#ifdef JDS
+	u32 divider, ctrl;
+	clk_set_rate(priv->clk, core_freq);
+	divider = DIV_ROUND_CLOSEST(clk_get_rate(priv->clk), (rate * 128));
+
+	ctrl = readl(priv->io_base + sunxi_CTRL);
+	ctrl &= ~codec_DIVIDER_MASK;
+	ctrl |= (divider << codec_DIVIDER_SHIFT) & codec_DIVIDER_MASK;
+	writel(ctrl, priv->io_base + sunxi_CTRL);
+#endif
+}
+
+static int sunxi_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params,
+		struct snd_soc_dai *dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	u32 rate, core_freq;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	rate = params_rate(params);
+
+	switch (rate) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64000:
+		/*
+		 * The clock is multiplied by 10 to bring it to feasible range
+		 * of frequencies for sscg
+		 */
+		core_freq = 64000 * 128 * 10;	/* 81.92 MHz */
+		break;
+	case 5512:
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		core_freq = 176400 * 128;	/* 22.5792 MHz */
+		break;
+	case 48000:
+	case 96000:
+	case 192000:
+	default:
+		core_freq = 192000 * 128;	/* 24.576 MHz */
+		break;
+	}
+
+	sunxi_clock(priv, core_freq, rate);
+	priv->saved_params.core_freq = core_freq;
+	priv->saved_params.rate = rate;
+
+	return 0;
+}
+
+static int sunxi_trigger(struct snd_pcm_substream *substream, int cmd,
+		struct snd_soc_dai *dai)
+{
+#ifdef JDS
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	u32 ctrl;
+#endif
+	int ret = 0;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+#ifdef JDS		
+			ctrl = readl(priv->io_base + sunxi_CTRL);
+			ctrl &= ~codec_OPMODE_MASK;
+			if (!priv->saved_params.mute)
+				ctrl |= codec_OPMODE_AUD_DATA |
+					codec_STATE_NORMAL;
+			else
+				ctrl |= codec_OPMODE_MUTE_PCM;
+			writel(ctrl, priv->io_base + sunxi_CTRL);
+#endif
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+#ifdef JDS		
+		ctrl = readl(priv->io_base + sunxi_CTRL);
+		ctrl &= ~codec_OPMODE_MASK;
+		ctrl |= codec_OPMODE_OFF;
+		writel(ctrl, priv->io_base + sunxi_CTRL);
+#endif
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sunxi_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+#ifdef JDS
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	u32 val;
+
+	priv->saved_params.mute = mute;
+	val = readl(priv->io_base + sunxi_CTRL);
+	val &= ~codec_OPMODE_MASK;
+
+	if (mute)
+		val |= codec_OPMODE_MUTE_PCM;
+	else {
+		if (priv->running)
+			val |= codec_OPMODE_AUD_DATA | codec_STATE_NORMAL;
+		else
+			val |= codec_OPMODE_OFF;
+	}
+
+	writel(val, priv->io_base + sunxi_CTRL);
+#endif
+	return 0;
+}
+
+static int codec_mute_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	ucontrol->value.integer.value[0] = priv->saved_params.mute;
+	return 0;
+}
+
+static int codec_mute_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	if (priv->saved_params.mute == ucontrol->value.integer.value[0])
+		return 0;
+
+	sunxi_digital_mute(cpu_dai, ucontrol->value.integer.value[0]);
+
+	return 1;
+}
+
+#ifdef JDS
+static void codec_resume_events(struct work_struct *work)
+{
+	printk("%s,%d\n", __func__, __LINE__);
+
+	if (priv->id == SUN7I) {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	else
+		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1, DAC_EN, 0x1);
+
+	msleep(20);
+	//enable PA
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x1);
+	msleep(550);
+	//enable dac analog
+
+	if (priv->id == SUN7I) {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x1);
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1, 8, 0x0);
+	} else {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x1);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x1);
+
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACPAS, 0x1);
+	}
+	if (gpio_pa_shutdown) {
+		msleep(50);
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+	}
+}
+#endif
+
+
+
+/**
+ *	codec_reset - reset the codec
+ * @codec	SoC Audio Codec
+ * Reset the codec, set the register of codec default value
+ * Return 0 for success
+ */
+static int codec_init(struct card_data *priv)
+{
+	//enable dac digital
+	regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1 << DAC_EN, 0x1 << DAC_EN);
+
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << 28, 0x1 << 28);
+	//set digital volume to maximum
+	if (priv->id == SUN4A)
+		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x6 << DIGITAL_VOL, 0x0 << DIGITAL_VOL);
+
+	//pa mute
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
+	//enable PA
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << PA_ENABLE, 0x1 << PA_ENABLE);
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x3 << DRA_LEVEL, 0x3 << DRA_LEVEL);
+	//set volume
+	if ((priv->id == SUN4A) || (priv->id == SUN4I)) {
+		int device_lr_change = 0;
+		if (priv->id == SUN4A)
+			regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x01 << VOLUME);
+		else 
+			regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x3b << VOLUME);
+#ifdef JDS
+		rc = script_parser_fetch("audio_para", "audio_lr_change", &device_lr_change, 1);
+		if (rc != SCRIPT_AUDIO_OK) {
+			pr_err("No audio_lr_change in fex audio_para\n");
+			return -1;
+		}
+#endif
+		if (device_lr_change)
+			regmap_update_bits(priv->regmap, SUNXI_DAC_DEBUG, 0x1 << DAC_CHANNEL, 0x1 << DAC_CHANNEL);
+	} else {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x3b << VOLUME);
+	}
+	return 0;
+}
+
+
+/*	对sunxi-codec.c各寄存器的各种设定，或读取。主要实现函数有三个.
+ * 	.info = snd_codec_info_volsw, .get = snd_codec_get_volsw,\.put = snd_codec_put_volsw,
+ * It should be noted that the only difference between sunxi and sun5i is the Master Playback Volume
+ */
+static const struct snd_kcontrol_new sun4i_dac[] = {
+	//FOR B C VERSION
+	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
+	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	SOC_SINGLE("Fm Volume", SUNXI_DAC_ACTL, 23, 7, 0), //Fm 音量
+	SOC_SINGLE("Line Volume", SUNXI_DAC_ACTL, 26, 1, 0), //Line音量
+	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
+	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+};
+
+static const struct snd_kcontrol_new sun4a_dac[] = {
+	//For A VERSION
+	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_DPC, 12, 0x3f, 0), //62 steps, 3e + 1 = 3f 主音量控制
+	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	SOC_SINGLE("Fm Volume", SUNXI_DAC_ACTL, 23, 7, 0), //Fm 音量
+	SOC_SINGLE("Line Volume", SUNXI_DAC_ACTL, 26, 1, 0), //Line音量
+	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
+	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+};
+
+static const struct snd_kcontrol_new sunxi_adc_controls[] = { 
+	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
+	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
+	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0),
+	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0), //录音音量
+	SOC_SINGLE("Line Capture Volume", SUNXI_ADC_ACTL, 13, 7, 0), 
+	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
+	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
+	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
+	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
+	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
+	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
+};
+
+static const struct snd_kcontrol_new sun7i_dac_ctls[] = {
+	/*SUNXI_DAC_ACTL = 0x10,PAVOL*/
+	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
+	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0), 
+	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+	SOC_SINGLE("MIC output volume", SUNXI_DAC_ACTL, 20, 7, 0),
+	/*	FM Input to output mixer Gain Control
+	* 	From -4.5db to 6db,1.5db/step,default is 0db
+	*	-4.5db:0x0,-3.0db:0x1,-1.5db:0x2,0db:0x3
+	*	1.5db:0x4,3.0db:0x5,4.5db:0x6,6db:0x7
+	*/
+	SOC_SINGLE("Fm output Volume", SUNXI_DAC_ACTL, 23, 7, 0),
+	/*	Line-in gain stage to output mixer Gain Control
+	*	0:-1.5db,1:0db
+	*/
+	SOC_SINGLE("Line output Volume", SUNXI_DAC_ACTL, 26, 1, 0),
+};
+
+static const struct snd_kcontrol_new sun7i_adc_ctls[] = { 
+	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
+	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
+	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0), 
+	SOC_SINGLE("Linein Pre-AMP", SUNXI_ADC_ACTL, 13, 7, 0), 
+	SOC_SINGLE("LINEIN APM Volume", SUNXI_MIC_CRT, 13, 0x7, 0),
+	/* ADC Input Gain Control, capture volume
+	* 000:-4.5db,001:-3db,010:-1.5db,011:0db,100:1.5db,101:3db,110:4.5db,111:6db
+	*/
+	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0),
+	/*
+	*	MIC2 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
+	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
+	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
+	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
+	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
+	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
+	SOC_SINGLE("Mic2 gain Volume", SUNXI_MIC_CRT, 26, 7, 0),
+	/*
+	*	MIC1 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	SOC_SINGLE("Mic1 gain Volume", SUNXI_MIC_CRT, 29, 3, 0), 
+};
+
+
+
+static int sunxi_soc_dai_probe(struct snd_soc_dai *dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	struct snd_dmaengine_dai_dma_data *playback_dma_data;
+	struct snd_dmaengine_dai_dma_data *capture_dma_data;
+
+	playback_dma_data = devm_kzalloc(dai->dev,
+					 sizeof(*playback_dma_data),
+					 GFP_KERNEL);
+	if (!playback_dma_data)
+		return -ENOMEM;
+
+	capture_dma_data = devm_kzalloc(dai->dev,
+					sizeof(*capture_dma_data),
+					GFP_KERNEL);
+	if (!capture_dma_data)
+		return -ENOMEM;
+
+	playback_dma_data->addr = priv->codec_phys + SUNXI_DAC_TXDATA;
+	capture_dma_data->addr = priv->codec_phys + SUNXI_ADC_RXDATA;
+
+	playback_dma_data->maxburst = 4;
+	capture_dma_data->maxburst = 4;
+
+	playback_dma_data->addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	playback_dma_data->addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	snd_soc_dai_init_dma_data(dai, playback_dma_data, capture_dma_data);
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_dai_ops = {
+	.digital_mute	= sunxi_digital_mute,
+	.startup	= sunxi_startup,
+	.shutdown	= sunxi_shutdown,
+	.trigger	= sunxi_trigger,
+	.hw_params	= sunxi_hw_params,
+};
+
+static struct snd_soc_dai_driver sunxi_dai = {
+	.name		= "cat",
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+				 SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | \
+				 SNDRV_PCM_RATE_192000),
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.probe = sunxi_soc_dai_probe,
+	.ops = &sunxi_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_component = {
+	.name		= "horse",
+};
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S20_3LE | \
+			SNDRV_PCM_FMTBIT_S24_LE)
+
+unsigned int read(struct snd_soc_codec *codec, unsigned int reg);
+int write(struct snd_soc_codec *, unsigned int reg, unsigned int);
+
+
+static struct snd_soc_codec_driver soc_codec_sun4a_codec = {
+	.controls = sun4a_dac,
+	.num_controls = ARRAY_SIZE(sun4a_dac),
+};
+
+static struct snd_soc_codec_driver soc_codec_sun4i_codec = {
+	.controls = sun4i_dac,
+	.num_controls = ARRAY_SIZE(sun4i_dac),
+};
+
+static struct snd_soc_codec_driver soc_codec_sun7i_codec = {
+	.controls = sun7i_dac_ctls,
+	.num_controls = ARRAY_SIZE(sun7i_dac_ctls),
+};
+
+static struct snd_soc_dai_driver dit_stub_dai = {
+	.name		= "dog",
+	.playback 	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 384,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+};
+
+static const struct regmap_config sunxi_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_MIC_CRT,
+};
+
+static const struct of_device_id snd_sunxi_codec_ids[] = {
+	{ .compatible = "allwinner,sun4i-a10a-codec", .data = (void *)SUN4A},
+	{ .compatible = "allwinner,sun4i-a10-codec", .data = (void *)SUN4I},
+	{ .compatible = "allwinner,sun5i-a13-codec", .data = (void *)SUN5I},
+	{ .compatible = "allwinner,sun7i-a20-codec", .data = (void *)SUN7I},
+	{}
+};
+MODULE_DEVICE_TABLE(of, snd_sunxi_codec_ids);
+
+static int sunxi_codec_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct card_data *priv;
+	struct resource res;
+	int ret;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	of_id = of_match_device(snd_sunxi_codec_ids, &pdev->dev);
+	if (!of_id)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "could not allocate DAI object\n");
+		return -ENOMEM;
+	}
+	
+	priv->id = (int)of_id->data;
+
+	/* Get the addresses and IRQ */
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		dev_err(&pdev->dev, "could not determine device resources\n");
+		return ret;
+	}
+	priv->baseaddr = of_iomap(np, 0);
+	if (!priv->baseaddr) {
+		dev_err(&pdev->dev, "could not map device resources\n");
+		return -ENOMEM;
+	}
+	priv->codec_phys = res.start;
+
+	priv->regmap = devm_regmap_init_mmio(&pdev->dev, priv->baseaddr, &sunxi_regmap_config);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	priv->irq = irq_of_parse_and_map(np, 0);
+	if (!priv->irq) {
+		dev_err(&pdev->dev, "no irq for node %s\n", np->full_name);
+		return -ENXIO;
+	}
+
+	/* Clock */
+	priv->codec_apbclk = devm_clk_get(dev, "apb");
+	if (IS_ERR(priv->codec_apbclk)) {
+		dev_err(dev, "failed to get apb clock.\n");
+		return PTR_ERR(priv->codec_apbclk);
+	}
+	priv->codec_pll2clk = devm_clk_get(dev, "pll2");
+	if (IS_ERR(priv->codec_pll2clk)) {
+		dev_err(dev, "failed to get pll2 clock.\n");
+		return PTR_ERR(priv->codec_pll2clk);
+	}
+	priv->codec_moduleclk = devm_clk_get(dev, "codec");
+	if (IS_ERR(priv->codec_moduleclk)) {
+		dev_err(dev, "failed to get codec clock.\n");
+		return PTR_ERR(priv->codec_moduleclk);
+	}
+	ret = clk_set_rate(priv->codec_pll2clk, 24576000);
+	if (ret) {
+		dev_err(dev, "set codec base clock failed!\n");
+		return ret;
+	}
+	if (clk_prepare_enable(priv->codec_pll2clk)) {
+		dev_err(dev, "try to enable codec_pll2clk failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(priv->codec_apbclk)) {
+		dev_err(dev, "try to enable apb_codec_clk failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(priv->codec_moduleclk)) {
+		dev_err(dev, "try to enable codec failed\n");
+		ret = -EINVAL;
+		goto exit_clkdisable_apb_clk;
+	}
+	dev_set_drvdata(&pdev->dev, priv);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_component, &sunxi_dai, 1);
+	if (ret)
+		return ret;
+
+	switch (priv->id) {
+	case SUN4A:
+		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun4a_codec, &dit_stub_dai, 1);
+	case SUN4I:
+	case SUN5I:
+		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun4i_codec, &dit_stub_dai, 1);
+	case SUN7I:
+		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun7i_codec, &dit_stub_dai, 1);
+	}
+	if (ret)
+		return ret;
+
+	snd_dmaengine_pcm_register(&pdev->dev, NULL, SND_DMAENGINE_PCM_FLAG_NO_RESIDUE);
+
+	codec_init(priv);
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+
+	resume_work_queue = create_singlethread_workqueue("codec_resume");
+	if (resume_work_queue == NULL) {
+		printk("[su4i-codec] try to create workqueue for codec failed!\n");
+		ret = -ENOMEM;
+		goto err_resume_work_queue;
+	}
+#endif
+	printk("JDS - codec driver success registered\n");
+	return ret;
+
+err_resume_work_queue:
+exit_clkdisable_apb_clk:
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int snd_sunxi_codec_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct card_data *priv = dev_get_drvdata(&pdev->dev);
+
+	if (priv->running)
+		clk_disable(priv->codec_moduleclk);
+
+	return 0;
+}
+
+static int snd_sunxi_codec_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct card_data *priv = dev_get_drvdata(&pdev->dev);
+
+	if (priv->running) {
+		clk_enable(priv->codec_moduleclk);
+		sunxi_configure(priv);
+		sunxi_clock(priv, priv->saved_params.core_freq,
+				priv->saved_params.rate);
+	}
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(sunxi_dev_pm_ops, snd_sunxi_codec_suspend, \
+		snd_sunxi_codec_resume);
+
+#define sunxi_DEV_PM_OPS (&sunxi_dev_pm_ops)
+
+#else
+#define sunxi_DEV_PM_OPS NULL
+
+#endif
+
+static int sunxi_codec_remove(struct platform_device *pdev)
+{
+#ifdef JDS
+	clk_disable(codec_moduleclk);
+	//释放codec_pll2clk时钟句柄
+	clk_put(codec_pll2clk);
+	//释放codec_apbclk时钟句柄
+	clk_put(codec_apbclk);
+
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+#endif
+	return 0;
+	snd_dmaengine_pcm_unregister(&pdev->dev);
+}
+
+static void sunxi_codec_shutdown(struct platform_device *devptr)
+{
+#ifdef JDS
+	if (gpio_pa_shutdown) {
+//JDS		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+		mdelay(50);
+	}
+	regmap_update_bits(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x0);
+	mdelay(100);
+	//pa mute
+	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	mdelay(500);
+	//disable dac analog
+	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x0);
+	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x0);
+
+	//disable dac to pa
+	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x0);
+	regmap_update_bits(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x0);
+
+	clk_disable(codec_moduleclk);
+#endif
+}
+
+/*method relating*/
+static struct platform_driver sunxi_codec_driver =
+{
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_remove,
+	.shutdown = sunxi_codec_shutdown,
+#ifdef CONFIG_PM
+//JDS	.suspend = snd_sunxi_codec_suspend,
+//JDS	.resume = snd_sunxi_codec_resume,
+#endif
+	.driver = {
+		.name = "sunxi-codec",
+		.of_match_table = snd_sunxi_codec_ids,
+	},
+};
+
+module_platform_driver(sunxi_codec_driver);
+
+MODULE_ALIAS("platform:sunxi-codec-dai");
+MODULE_DESCRIPTION("sunxi CODEC ALSA codec driver");
+MODULE_AUTHOR("software");
+MODULE_LICENSE("GPL v2");
+
diff --git a/sound/soc/sunxi/stub.c b/sound/soc/sunxi/stub.c
new file mode 100644
index 0000000..8b2c634
--- /dev/null
+++ b/sound/soc/sunxi/stub.c
@@ -0,0 +1,104 @@
+/*
+ * ALSA SoC SPDIF DIT driver
+ *
+ *  This driver is used by controllers which can operate in DIT (SPDI/F) where
+ *  no codec is needed.  This file provides stub codec that can be used
+ *  in these configurations. TI DaVinci Audio controller uses this driver.
+ *
+ * Author:      Steve Chen,  <schen@mvista.com>
+ * Copyright:   (C) 2009 MontaVista Software, Inc., <source@mvista.com>
+ * Copyright:   (C) 2009  Texas Instruments, India
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <linux/of.h>
+#include "sunxi-codec.h"
+
+#define DRV_NAME "awstub"
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S20_3LE | \
+			SNDRV_PCM_FMTBIT_S24_LE)
+
+
+
+static const struct snd_soc_dapm_widget dit_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("Mic Bias"),
+	SND_SOC_DAPM_OUTPUT("HP_OUT"),
+	SND_SOC_DAPM_INPUT("MIC_IN"),
+	SND_SOC_DAPM_INPUT("LINE_IN"),
+};
+
+static struct snd_soc_codec_driver soc_codec_stub = {
+	.dapm_widgets = dit_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(dit_widgets),
+};
+
+#ifdef JDS
+static struct snd_soc_codec_driver soc_codec_sun4a_codec = {
+	.controls = sun4a_dac,
+	.num_controls = ARRAY_SIZE(sun4a_dac),
+};
+
+static struct snd_soc_codec_driver soc_codec_sun4i_codec = {
+	.controls = sun4i_dac,
+	.num_controls = ARRAY_SIZE(sun4i_dac),
+};
+#endif
+
+static struct snd_soc_dai_driver awstub_dai = {
+	.name		= "awstub",
+	.playback 	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 384,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+};
+
+static int stub_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_stub, &awstub_dai, 1);
+}
+
+static int stub_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id stub_dt_ids[] = {
+	{ .compatible = "allwinner,stub", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, stub_dt_ids);
+#endif
+
+static struct platform_driver stub_driver = {
+	.probe		= stub_probe,
+	.remove		= stub_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(stub_dt_ids),
+	},
+};
+
+module_platform_driver(stub_driver);
+
+MODULE_AUTHOR("Steve Chen <schen@mvista.com>");
+MODULE_DESCRIPTION("AWStub codec driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/sunxi/sunxi-codec.c b/sound/soc/sunxi/sunxi-codec.c
new file mode 100644
index 0000000..9f13308
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-codec.c
@@ -0,0 +1,686 @@
+/*
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/clk.h>
+#include <linux/regmap.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+
+//Codec Register
+#define SUNXI_DAC_DPC                (0x00)
+#define SUNXI_DAC_FIFOC              (0x04)
+#define SUNXI_DAC_FIFOS              (0x08)
+#define SUNXI_DAC_TXDATA             (0x0c)
+#define SUNXI_DAC_ACTL               (0x10)
+#define SUNXI_DAC_TUNE               (0x14)
+#define SUNXI_DAC_DEBUG              (0x18)
+#define SUNXI_ADC_FIFOC              (0x1c)
+#define SUNXI_ADC_FIFOS              (0x20)
+#define SUNXI_ADC_RXDATA             (0x24)
+#define SUNXI_ADC_ACTL               (0x28)
+#define SUNXI_ADC_DEBUG              (0x2c)
+#define SUNXI_DAC_TXCNT              (0x30)
+#define SUNXI_ADC_RXCNT              (0x34)
+#define SUNXI_BIAS_CRT               (0x38)
+#define SUNXI_MIC_CRT                (0x3c)
+#define SUNXI_CODEC_REGS_NUM         (13)
+
+#define DAIFMT_16BITS             (16)
+#define DAIFMT_20BITS             (20)
+
+#define DAIFMT_BS_MASK            (~(1<<16))  	//FIFO big small mode mask
+#define DAIFMT_BITS_MASK          (~(1<<5))		//FIFO Bits select mask,not used yet.
+#define SAMPLE_RATE_MASK          (~(7<<29))  	//Sample Rate slect mask
+
+#define DAC_EN                    (31)
+#define DIGITAL_VOL               (12)
+//For CODEC OLD VERSION
+#define DAC_VERSION               (23)
+
+#define DAC_CHANNEL		  (6)
+#define LAST_SE                   (26)
+#define TX_FIFO_MODE              (24)
+#define DRA_LEVEL                 (21)
+#define TX_TRI_LEVEL              (8)
+#define DAC_MODE                  (6)			//not used yet
+#define TASR                      (5)			//not used yet
+#define DAC_DRQ                   (4)
+#define DAC_FIFO_FLUSH            (0)
+
+#define VOLUME                    (0)
+#define PA_MUTE                   (6)
+#define MIXPAS                    (7)
+#define DACPAS                    (8)
+#define MIXEN                     (29)
+#define DACAEN_L                  (30)
+#define DACAEN_R                  (31)
+
+#define ADC_DIG_EN                (28)
+#define RX_FIFO_MODE              (24)
+#define RX_TRI_LEVEL              (8)
+#define ADC_MODE                  (7)
+#define RASR                      (6)
+#define ADC_DRQ                   (4)
+#define ADC_FIFO_FLUSH            (0)
+
+#define  ADC_LF_EN                (31)
+#define  ADC_RI_EN                (30)
+#define  ADC_EN                   (30)
+#define  MIC1_EN                  (29)
+#define  MIC2_EN                  (28)
+#define  VMIC_EN                  (27)
+#define  MIC_GAIN                 (25)
+#define  ADC_SELECT               (17)
+#define  PA_ENABLE                (4)
+#define  HP_DIRECT                (3)
+
+
+enum sunxi_device_id {SUN4A, SUN4I, SUN5I, SUN7I}; 
+
+struct sunxi_priv {
+	struct regmap *regmap;
+	int irq;
+	struct clk *clk_apb, *clk_pll2, *clk_module;
+
+	enum sunxi_device_id id;
+
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+};
+
+static int codec_play_start(struct sunxi_priv *priv)
+{
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+#endif
+	//flush TX FIFO
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_FIFO_FLUSH, 0x1 << DAC_FIFO_FLUSH);
+	//enable dac drq
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_DRQ, 0x1 << DAC_DRQ);
+	return 0;
+}
+
+static int codec_play_stop(struct sunxi_priv *priv)
+{
+	//pa mute
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+#endif
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
+	mdelay(5);
+	//disable dac drq
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_DRQ, 0x0 << DAC_DRQ);
+	//pa mute
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_L, 0x0 << DACAEN_L);
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_R, 0x0 << DACAEN_R);
+	return 0;
+}
+
+static int codec_capture_start(struct sunxi_priv *priv)
+{
+	//enable adc drq
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+#endif
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DRQ, 0x1 << ADC_DRQ);
+	return 0;
+}
+
+static int codec_capture_stop(struct sunxi_priv *priv)
+{
+	//disable adc drq
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DRQ, 0x0 << ADC_DRQ);
+	//enable mic1 pa
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << MIC1_EN, 0x0 << MIC1_EN);
+	//enable VMIC
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << VMIC_EN, 0x0 << VMIC_EN);
+	if (priv->id == SUN7I) {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_TUNE, 0x3 << 8, 0x0 << 8);
+	}
+	//enable adc digital
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DIG_EN, 0x0 << ADC_DIG_EN);
+	//set RX FIFO mode
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << RX_FIFO_MODE, 0x0 << RX_FIFO_MODE);
+	//flush RX FIFO
+	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_FIFO_FLUSH, 0x0 << ADC_FIFO_FLUSH);
+	//enable adc1 analog
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << ADC_EN, 0x0 << ADC_EN);
+	return 0;
+}
+
+static int sunxi_codec_trigger(struct snd_pcm_substream *substream, int cmd,
+	struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	printk("JDS - sunxi_codec_trigger cmd %d\n", cmd);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			codec_capture_start(priv);
+		else
+			codec_play_start(priv);
+		break;		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			codec_capture_stop(priv);
+		else
+			codec_play_stop(priv);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sunxi_codec_prepare(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	printk("JDS - sunxi_codec_prepare\n");
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1 << DAC_EN, 0x1 << DAC_EN);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_FIFO_FLUSH, 0x1 << DAC_FIFO_FLUSH);
+		//set TX FIFO send drq level
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0xf << TX_TRI_LEVEL, 0xf << TX_TRI_LEVEL);
+		if (substream->runtime->rate > 32000) {
+			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << 28, 0x0 << 28);
+		} else {
+			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << 28, 0x1 << 28);
+		}
+		//set TX FIFO MODE
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << TX_FIFO_MODE, 0x1 << TX_FIFO_MODE);
+		//send last sample when dac fifo under run
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << LAST_SE, 0x0 << LAST_SE);
+		//enable dac analog
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_L, 0x1 << DACAEN_L);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_R, 0x1 << DACAEN_R);
+		//enable dac to pa
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACPAS, 0x1 << DACPAS);
+	} else {
+		//enable mic1 pa
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << MIC1_EN, 0x1 << MIC1_EN);
+		//mic1 gain 32dB
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << 25, 0x1 << 25);
+		//enable VMIC
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << VMIC_EN, 0x1 << VMIC_EN);
+
+		if (priv->id == SUN7I) {
+			/* boost up record effect */
+			regmap_update_bits(priv->regmap, SUNXI_DAC_TUNE, 0x3 << 8, 0x1 << 8);
+		}
+
+		//enable adc digital
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DIG_EN, 0x1 << ADC_DIG_EN);
+		//set RX FIFO mode
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << RX_FIFO_MODE, 0x1 << RX_FIFO_MODE);
+		//flush RX FIFO
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_FIFO_FLUSH, 0x1 << ADC_FIFO_FLUSH);
+		//set RX FIFO rec drq level
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0xf << RX_TRI_LEVEL, 0x7 << RX_TRI_LEVEL);
+		//enable adc1 analog
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << ADC_EN, 0x3 << ADC_EN);
+	}
+	return 0;
+}
+
+static int sunxi_codec_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+	unsigned int rate = params_rate(params);
+
+	printk("CLK - sunxi_codec_hw_params substream %p runtime %p\n", substream, rtd);
+	switch (params_rate(params)) {
+	case 44100:
+	case 22050:
+	case 11025:
+	default:
+		clk_set_rate(priv->clk_pll2, 22579200);
+		clk_set_rate(priv->clk_module, 22579200);
+		break;
+	case 192000:
+	case 96000:
+	case 48000:
+	case 32000:
+	case 24000:
+	case 16000:
+	case 12000:
+	case 8000:
+		clk_set_rate(priv->clk_pll2, 24576000);
+		clk_set_rate(priv->clk_module, 24576000);
+		break;
+	}
+
+	switch (params_rate(params)) {
+	default:
+	case 44100:
+		rate = 0;
+		break;
+	case 22050:
+		rate = 2;
+		break;
+	case 11025:
+		rate = 4;
+		break;
+	case 192000:
+		rate = 6;
+		break;
+	case 96000:
+		rate = 7;
+		break;
+	case 48000:
+		rate = 0;
+		break;
+	case 32000:
+		rate = 1;
+		break;
+	case 24000:
+		rate = 2;
+		break;
+	case 16000:
+		rate = 3;
+		break;
+	case 12000:
+		rate = 4;
+		break;
+	case 8000:
+		rate = 5;
+		break;
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 7 << 29, rate << 29);
+		if (substream->runtime->channels == 1)
+			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << 6, 1 << 6);
+		else
+			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << 6, 0 << 6);
+	} else  {
+		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 7 << 29, rate << 29);
+		if (substream->runtime->channels == 1)
+			regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 1 << 7, 1 << 7);
+		else
+			regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 1 << 7, 0 << 7);
+	}
+	return 0;
+}
+
+static const struct snd_kcontrol_new sun7i_dac_ctls[] = {
+	/*SUNXI_DAC_ACTL = 0x10,PAVOL*/
+	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
+	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0), 
+	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+	SOC_SINGLE("MIC output volume", SUNXI_DAC_ACTL, 20, 7, 0),
+	/*	FM Input to output mixer Gain Control
+	* 	From -4.5db to 6db,1.5db/step,default is 0db
+	*	-4.5db:0x0,-3.0db:0x1,-1.5db:0x2,0db:0x3
+	*	1.5db:0x4,3.0db:0x5,4.5db:0x6,6db:0x7
+	*/
+	SOC_SINGLE("Fm output Volume", SUNXI_DAC_ACTL, 23, 7, 0),
+	/*	Line-in gain stage to output mixer Gain Control
+	*	0:-1.5db,1:0db
+	*/
+	SOC_SINGLE("Line output Volume", SUNXI_DAC_ACTL, 26, 1, 0),
+
+	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
+	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
+	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0), 
+	SOC_SINGLE("Linein Pre-AMP", SUNXI_ADC_ACTL, 13, 7, 0), 
+	SOC_SINGLE("LINEIN APM Volume", SUNXI_MIC_CRT, 13, 0x7, 0),
+	/* ADC Input Gain Control, capture volume
+	* 000:-4.5db,001:-3db,010:-1.5db,011:0db,100:1.5db,101:3db,110:4.5db,111:6db
+	*/
+	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0),
+	/*
+	*	MIC2 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
+	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
+	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
+	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
+	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
+	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
+	SOC_SINGLE("Mic2 gain Volume", SUNXI_MIC_CRT, 26, 7, 0),
+	/*
+	*	MIC1 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	SOC_SINGLE("Mic1 gain Volume", SUNXI_MIC_CRT, 29, 3, 0), 
+};
+
+
+static int sunxi_codec_dai_probe(struct snd_soc_dai *dai)
+{
+	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	printk("CLK - sunxi_codec_dai_probe %p\n", priv);
+	snd_soc_dai_init_dma_data(dai, &priv->playback_dma_data, &priv->capture_dma_data);
+
+	return 0;
+}
+
+static int sunxi_codec_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	int ret;
+	printk("JDS - CLK sunxi_codec_startup %p %p\n", codec, priv->clk_module);
+	ret = clk_prepare_enable(priv->clk_module);
+	if (ret)
+		return ret;
+
+	printk("JDS - sunxi_codec_startup - ok\n");
+	return 0;
+}
+
+static void sunxi_codec_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_card *card = codec->card;
+	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+
+	printk("JDS - sunxi_codec_shutdown\n");
+	clk_disable_unprepare(priv->clk_module);
+}
+
+static const struct snd_soc_dai_ops sunxi_codec_dai_ops = {
+	.startup = sunxi_codec_startup,
+	.shutdown = sunxi_codec_shutdown,
+	.trigger = sunxi_codec_trigger,
+	.hw_params = sunxi_codec_hw_params,
+	.prepare = sunxi_codec_prepare,
+};
+
+static struct snd_soc_dai_driver sunxi_codec_dai = {
+	.probe = sunxi_codec_dai_probe,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+
+		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_11025 |\
+			 SNDRV_PCM_RATE_22050| SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\
+			 SNDRV_PCM_RATE_48000 |SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000 |\
+			 SNDRV_PCM_RATE_KNOT),
+		.rate_min = 8000,
+		.rate_max = 192000,
+	},
+	.ops = &sunxi_codec_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_codec_component = {
+	.name = "sunxi-codec",
+};
+
+static const struct regmap_config sunxi_codec_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_MIC_CRT,
+};
+
+static const struct snd_soc_dapm_widget codec_dapm_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("Mic Bias"),
+	SND_SOC_DAPM_OUTPUT("HP_OUT"),
+	SND_SOC_DAPM_INPUT("MIC_IN"),
+	SND_SOC_DAPM_INPUT("LINE_IN"),
+};
+
+static struct snd_soc_dai_link cdc_dai = {
+	.name = "cdc",
+	.stream_name = "CDC PCM",
+	.codec_dai_name = "sunxi-codec-dai",
+	.cpu_dai_name = "1c22c00.codec",
+	.codec_name = "1c22c00.codec",
+	.platform_name = "1c22c00.codec",
+	//.init = tegra_wm8903_init,
+	//.ops = &tegra_wm8903_ops,
+	.dai_fmt = SND_SOC_DAIFMT_I2S,
+};
+
+static struct snd_soc_card snd_soc_sunxi_codec = {
+	.name = "sunxi-codec",
+	.owner = THIS_MODULE,
+	.dai_link = &cdc_dai,
+	.num_links = 1,
+};
+
+static struct snd_soc_codec_driver dummy_codec = {
+	.controls = sun7i_dac_ctls,
+	.num_controls = ARRAY_SIZE(sun7i_dac_ctls),
+	.dapm_widgets = codec_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(codec_dapm_widgets),
+};
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_192000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S8 | \
+			SNDRV_PCM_FMTBIT_U8 | \
+			SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_U16_LE | \
+			SNDRV_PCM_FMTBIT_S24_LE | \
+			SNDRV_PCM_FMTBIT_U24_LE | \
+			SNDRV_PCM_FMTBIT_S32_LE | \
+			SNDRV_PCM_FMTBIT_U32_LE | \
+			SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE)
+static struct snd_soc_dai_driver dummy_dai = {
+	.name = "sunxi-codec-dai",
+	.playback = {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+	.capture = {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates = STUB_RATES,
+		.formats = STUB_FORMATS,
+	 },
+};
+
+static const struct of_device_id sunxi_codec_of_match[] = {
+	{ .compatible = "allwinner,sun4i-a10a-codec", .data = (void *)SUN4A},
+	{ .compatible = "allwinner,sun4i-a10-codec", .data = (void *)SUN4I},
+	{ .compatible = "allwinner,sun5i-a13-codec", .data = (void *)SUN5I},
+	{ .compatible = "allwinner,sun7i-a20-codec", .data = (void *)SUN7I},
+	{}
+};
+MODULE_DEVICE_TABLE(of, sunxi_codec_of_match);
+
+static int sunxi_codec_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_card *card = &snd_soc_sunxi_codec;
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct sunxi_priv *priv;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	of_id = of_match_device(sunxi_codec_of_match, dev);
+	if (!of_id)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	card->dev = &pdev->dev;
+	platform_set_drvdata(pdev, card);
+	snd_soc_card_set_drvdata(card, priv);
+
+	priv->id = (int)of_id->data;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	priv->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					    &sunxi_codec_regmap_config);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	priv->irq = irq_of_parse_and_map(np, 0);
+	if (!priv->irq) {
+		dev_err(dev, "no irq for node %s\n", np->full_name);
+		return -ENXIO;
+	}
+
+	/* Clock */
+	priv->clk_apb = devm_clk_get(dev, "apb");
+	if (IS_ERR(priv->clk_apb)) {
+		dev_err(dev, "failed to get apb clock.\n");
+		return PTR_ERR(priv->clk_apb);
+	}
+	priv->clk_pll2 = devm_clk_get(dev, "pll2");
+	if (IS_ERR(priv->clk_pll2)) {
+		dev_err(dev, "failed to get pll2 clock.\n");
+		return PTR_ERR(priv->clk_pll2);
+	}
+	priv->clk_module = devm_clk_get(dev, "codec");
+	if (IS_ERR(priv->clk_module)) {
+		dev_err(dev, "failed to get codec clock.\n");
+		return PTR_ERR(priv->clk_module);
+	}
+	printk("CLK = card %p priv %p priv->clk_module %p\n", card, priv, priv->clk_module);
+
+	ret = clk_set_rate(priv->clk_pll2, 24576000);
+	if (ret) {
+		dev_err(dev, "set codec base clock rate failed!\n");
+		return ret;
+	}
+	if (clk_prepare_enable(priv->clk_pll2)) {
+		dev_err(dev, "try to enable clk_pll2 failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(priv->clk_apb)) {
+		dev_err(dev, "try to enable clk_apb failed\n");
+		return -EINVAL;
+	}
+
+	priv->playback_dma_data.addr = res->start + SUNXI_DAC_TXDATA;
+	priv->playback_dma_data.maxburst = 4;
+	priv->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	priv->capture_dma_data.addr = res->start + SUNXI_ADC_RXDATA;
+	priv->capture_dma_data.maxburst = 4;
+	priv->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	ret = snd_soc_register_codec(&pdev->dev, &dummy_codec, &dummy_dai, 1);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_codec_component, &sunxi_codec_dai, 1);
+	if (ret)
+		goto err_clk_disable;
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret)
+		goto err_clk_disable;
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+		goto err_fini_utils;
+	}
+
+	ret = snd_soc_of_parse_audio_routing(card, "routing");
+	if (ret)
+		goto err;
+
+	return 0;
+
+err_fini_utils:
+err:
+err_clk_disable:
+	clk_disable_unprepare(priv->clk_module);
+	clk_disable_unprepare(priv->clk_apb);
+	clk_disable_unprepare(priv->clk_pll2);
+	return ret;
+}
+
+static int sunxi_codec_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_priv *priv = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(priv->clk_module);
+	clk_disable_unprepare(priv->clk_apb);
+	clk_disable_unprepare(priv->clk_pll2);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_codec_driver = {
+	.driver = {
+		.name = "sunxi-codec",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_codec_of_match,
+	},
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_dev_remove,
+};
+module_platform_driver(sunxi_codec_driver);
+
+MODULE_ALIAS("platform:sunxi-codec");
+MODULE_DESCRIPTION("sunxi CODEC ALSA codec driver");
+MODULE_AUTHOR("software");
+MODULE_LICENSE("GPL v2");
+
