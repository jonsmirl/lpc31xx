Bottom: d90793d567f477f784df988b4f53d0f7f49b6a8f
Top:    de77d8887082c6061300f418516e9ca61fc3667b
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-06-24 08:33:34 -0400

Initial sound driver port

---

diff --git a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
index bed74a9..a347eff 100644
--- a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
+++ b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
@@ -137,6 +137,10 @@
 			status = "okay";
 		};
 
+		codec@1c22c00 {
+			status = "okay";
+		};
+
 		ir0: ir@01c21800 {
 			pinctrl-names = "default";
 			pinctrl-0 = <&ir0_pins_a>;
diff --git a/arch/arm/boot/dts/sun7i-a20.dtsi b/arch/arm/boot/dts/sun7i-a20.dtsi
index 263eb79..1a44eba 100644
--- a/arch/arm/boot/dts/sun7i-a20.dtsi
+++ b/arch/arm/boot/dts/sun7i-a20.dtsi
@@ -91,6 +91,14 @@
 			clock-output-names = "pll1";
 		};
 
+		pll2: clk@01c20008 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sun7i-a20-pll2-clk";
+			reg = <0x01c20008 0x4>;
+			clocks = <&osc24M>;
+			clock-output-names = "pll2";
+		};
+
 		pll4: clk@01c20018 {
 			#clock-cells = <0>;
 			compatible = "allwinner,sun7i-a20-pll4-clk";
@@ -327,6 +335,30 @@
 			clock-output-names = "ir1";
 		};
 
+		i2s0_clk: clk@01c200b8 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200b8 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s0";
+		};
+
+		ac97_clk: clk@01c200bc {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200bc 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "ac97";
+		};
+
+		spdif_clk: clk@01c200c0 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200c0 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "spdif";
+		};
+
 		usb_clk: clk@01c200cc {
 			#clock-cells = <1>;
 		        #reset-cells = <1>;
@@ -344,6 +376,30 @@
 			clock-output-names = "spi3";
 		};
 
+		i2s1_clk: clk@01c200d8 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200d8 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s1";
+		};
+
+		i2s2_clk: clk@01c200dc {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200dc 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s2";
+		};
+
+		codec_clk: clk@01c20140 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-codec-clk";
+			reg = <0x01c20140 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "codec";
+		};
+
 		mbus_clk: clk@01c2015c {
 			#clock-cells = <0>;
 			compatible = "allwinner,sun4i-a10-mod0-clk";
@@ -807,6 +863,72 @@
 			clocks = <&osc24M>;
 			#pwm-cells = <3>;
 		};
+		
+		spdif@01c21000 {
+			compatible = "allwinner,sun7i-a20-spdif";
+			reg = <0x01C21000 0x40>;
+			interrupts = <0 13 4>;
+			clocks = <&pll2>, <&apb0_gates 1>, <&spdif_clk>;
+			clock-names = "pll2", "apb", "spdif";
+			dmas = <&dma 0 2>, <&dma 0 2>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		ac97@01c21400 {
+			compatible = "allwinner,sun7i-a20-ac97";
+			reg = <0x01C21400 0x40>;
+			interrupts = <0 14 4>;
+			clocks = <&pll2>, <&apb0_gates 2>, <&ac97_clk>;
+			clock-names = "pll2", "apb", "ac97";
+			dmas = <&dma 0 5>, <&dma 0 5>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s0: i2s@01c22000 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C22000 0x40>;
+			interrupts = <0 16 4>;
+			clocks = <&pll2>, <&apb0_gates 3>, <&i2s0_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 3>, <&dma 0 3>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s1: i2s@01c22400 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C22400 0x40>;
+			interrupts = <0 87 4>;
+			clocks = <&pll2>, <&apb0_gates 4>, <&i2s1_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 4>, <&dma 0 4>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s2: i2s@01c24400 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C24400 0x40>;
+			interrupts = <0 90 4>;
+			clocks = <&pll2>, <&apb0_gates 8>, <&i2s2_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 6>, <&dma 0 6>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		codec: codec@01c22c00 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun7i-a20-codec";
+			reg = <0x01C22c00 0x40>;
+			interrupts = <0 30 4>;
+			clocks = <&pll2>, <&apb0_gates 0>, <&codec_clk>;
+			clock-names = "pll2", "apb", "codec";
+			dmas = <&dma 0 19>, <&dma 0 19>;
+			dma-names = "rx", "tx";
+		};
 
 		ir0: ir@01c21800 {
 			compatible = "allwinner,sun7i-a20-ir";
@@ -851,8 +973,8 @@
 			reg-shift = <2>;
 			reg-io-width = <4>;
 			clocks = <&apb1_gates 16>;
-			dmas = <&dma 0 8>, <&dma 0 8>;
-			dma-names = "rx", "tx";
+			/*dmas = <&dma 0 8>, <&dma 0 8>;
+			dma-names = "rx", "tx"; */
 			status = "disabled";
 		};
 
@@ -1031,4 +1153,36 @@
 			interrupts = <1 9 0xf04>;
 		};
 	};
+
+	ac: ac@0 {
+		compatible = "allwinner,sunxi-ac";
+	}
+
+	sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,widgets =
+			"Microphone", "Microphone Jack",
+			"Headphone", "Headphone Jack",
+			"Line", "Line In Jack";
+		simple-audio-card,routing =
+			"MIC_IN", "Microphone Jack",
+			"Microphone Jack", "Mic Bias",
+			"LINE_IN", "Line In Jack",
+			"Headphone Jack", "HP_OUT";
+
+		simple-audio-card,cpu {
+			sound-dai = <&codec>;
+			master-clkdir-out;
+			frame-master;
+			bitclock-master;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&ac>;
+			frame-master;
+			bitclock-master;
+		};
+	};
+	
 };
diff --git a/cop b/cop
new file mode 100755
index 0000000..727aee3
--- /dev/null
+++ b/cop
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+
+make zImage modules uImage dtbs
+cp /work/hans/sound/soc/sunxi/sunxi-codec.ko /work/root/lib/modules/3.15.0+/kernel/sound/soc/sunxi
+
diff --git a/drivers/clk/sunxi/clk-sunxi.c b/drivers/clk/sunxi/clk-sunxi.c
index 1d16c0c..b3483a7 100644
--- a/drivers/clk/sunxi/clk-sunxi.c
+++ b/drivers/clk/sunxi/clk-sunxi.c
@@ -212,6 +212,30 @@ static void sun8i_a23_get_pll1_factors(u32 *freq, u32 parent_rate,
 }
 
 /**
+ * sun7i_get_pll2_factors()
+ * parent_rate is always 24Mhz
+ */
+
+static void sun7i_get_pll2_factors(u32 *freq, u32 parent_rate,
+				   u8 *n, u8 *k, u8 *m, u8 *p)
+{
+	printk("JDS - sun7i_get_pll2_factors %d\n", *freq);
+	/* we were called to round the frequency, we can now return */
+	if (n == NULL)
+		return;
+	
+	if (*freq == 22579200) {
+		*n = 79;
+		*m = 21;  /* Pre */
+		*k = 4;   /* Post */
+	} else  {
+		*n = 86;
+		*m = 21;  /* Pre */
+		*k = 4;   /* Post */
+	}
+}
+
+/**
  * sun4i_get_pll5_factors() - calculates n, k factors for PLL5
  * PLL5 rate is calculated as follows
  * rate = parent_rate * n * (k + 1)
@@ -482,6 +506,15 @@ static struct clk_factors_config sun8i_a23_pll1_config = {
 	.n_from_one = 1,
 };
 
+static struct clk_factors_config sun7i_pll2_config = {
+	.nshift = 8,
+	.nwidth = 7,
+	.kshift = 26,
+	.kwidth = 4,
+	.mshift = 0,
+	.mwidth = 5,
+};
+
 static struct clk_factors_config sun4i_pll5_config = {
 	.nshift = 8,
 	.nwidth = 5,
@@ -538,6 +571,12 @@ static const struct factors_data sun8i_a23_pll1_data __initconst = {
 	.getter = sun8i_a23_get_pll1_factors,
 };
 
+static const struct factors_data sun7i_a20_pll2_data __initconst = {
+	.enable = 31,
+	.table = &sun7i_pll2_config,
+	.getter = sun7i_get_pll2_factors,
+};
+
 static const struct factors_data sun7i_a20_pll4_data __initconst = {
 	.enable = 31,
 	.table = &sun4i_pll5_config,
@@ -945,6 +984,10 @@ static const struct gates_data sun6i_a31_usb_gates_data __initconst = {
 	.reset_mask = BIT(2) | BIT(1) | BIT(0),
 };
 
+static const struct gates_data sunxi_codec_data __initconst = {
+	.mask = {BIT(31)},
+};
+
 static void __init sunxi_gates_clk_setup(struct device_node *node,
 					 struct gates_data *data)
 {
@@ -1195,12 +1238,12 @@ free_clkdata:
 }
 
 
-
 /* Matches for factors clocks */
 static const struct of_device_id clk_factors_match[] __initconst = {
 	{.compatible = "allwinner,sun4i-a10-pll1-clk", .data = &sun4i_pll1_data,},
 	{.compatible = "allwinner,sun6i-a31-pll1-clk", .data = &sun6i_a31_pll1_data,},
 	{.compatible = "allwinner,sun8i-a23-pll1-clk", .data = &sun8i_a23_pll1_data,},
+	{.compatible = "allwinner,sun7i-a20-pll2-clk", .data = &sun7i_a20_pll2_data,},
 	{.compatible = "allwinner,sun7i-a20-pll4-clk", .data = &sun7i_a20_pll4_data,},
 	{.compatible = "allwinner,sun4i-a10-apb1-clk", .data = &sun4i_apb1_data,},
 	{.compatible = "allwinner,sun4i-a10-mod0-clk", .data = &sun4i_mod0_data,},
@@ -1258,6 +1301,7 @@ static const struct of_device_id clk_gates_match[] __initconst = {
 	{.compatible = "allwinner,sun4i-a10-usb-clk", .data = &sun4i_a10_usb_gates_data,},
 	{.compatible = "allwinner,sun5i-a13-usb-clk", .data = &sun5i_a13_usb_gates_data,},
 	{.compatible = "allwinner,sun6i-a31-usb-clk", .data = &sun6i_a31_usb_gates_data,},
+	{.compatible = "allwinner,sunxi-codec-clk", .data = &sunxi_codec_data,},
 	{}
 };
 
diff --git a/drivers/dma/of-dma.c b/drivers/dma/of-dma.c
index e8fe9dc..4fb133c 100644
--- a/drivers/dma/of-dma.c
+++ b/drivers/dma/of-dma.c
@@ -159,6 +159,7 @@ struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
 		return ERR_PTR(-ENODEV);
 	}
 
+	printk("JDS = of_dma_request_slave_channel %s %s\n", name, np->full_name);
 	count = of_property_count_strings(np, "dma-names");
 	if (count < 0) {
 		pr_err("%s: dma-names property of node '%s' missing or empty\n",
diff --git a/drivers/dma/sun4i-dma.c b/drivers/dma/sun4i-dma.c
index 7b986bd..21b62a2 100644
--- a/drivers/dma/sun4i-dma.c
+++ b/drivers/dma/sun4i-dma.c
@@ -8,6 +8,8 @@
  * (at your option) any later version.
  */
 
+#define DEBUG
+
 #include <linux/bitmap.h>
 #include <linux/bitops.h>
 #include <linux/clk.h>
@@ -286,6 +288,7 @@ static struct sun4i_dma_pchan *find_and_use_pchan(struct sun4i_ddma_dev *priv,
 	unsigned long flags;
 	int i, max;
 
+	printk("JDS - find_and_use_pchan\n");
 	spin_lock_irqsave(&priv->lock, flags);
 
 	/* pchans 0-NDMA_NR_MAX_CHANNELS are normal, and
@@ -327,6 +330,7 @@ static void release_pchan(struct sun4i_ddma_dev *priv,
 static void configure_pchan(struct sun4i_dma_pchan *pchan,
 			    struct sun4i_ddma_promise *d)
 {
+	printk("JDS - configure_pchan\n");
 	if (pchan->is_dedicated) {
 		/* Configure addresses and misc parameters */
 		writel_relaxed(d->src, pchan->base + DDMA_SRC_ADDR_REG);
@@ -383,6 +387,7 @@ static int execute_vchan_pending(struct sun4i_ddma_dev *priv,
 	unsigned long flags;
 	int ret = 0;
 
+	printk("JDS - execute_vchan_pending\n");
 	/* We need a pchan to do anything, so secure one if available */
 	pchan = find_and_use_pchan(priv, vchan);
 	if (!pchan)
@@ -456,6 +461,7 @@ generate_ndma_promise(struct dma_chan *chan, dma_addr_t src, dma_addr_t dest,
 	struct sun4i_ddma_promise *promise;
 	int ret;
 
+	printk("JDS - generate_ndma_promise\n");
 	promise = kzalloc(sizeof(*promise), GFP_NOWAIT);
 	if (!promise)
 		return NULL;
@@ -512,6 +518,7 @@ generate_ddma_promise(struct dma_chan *chan, dma_addr_t src, dma_addr_t dest,
 	struct sun4i_ddma_promise *promise;
 	int ret;
 
+	printk("JDS - generate_ddma_promise\n");
 	promise = kzalloc(sizeof(*promise), GFP_NOWAIT);
 	if (!promise)
 		return NULL;
@@ -603,6 +610,7 @@ sun4i_dma_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest,
 	struct sun4i_ddma_promise *promise;
 	struct sun4i_ddma_contract *contract;
 
+	printk("JDS - sun4i_dma_prep_dma_memcpy\n");
 	contract = generate_ddma_contract();
 	if (!contract)
 		return NULL;
@@ -637,6 +645,73 @@ sun4i_dma_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest,
 	return vchan_tx_prep(&vchan->vc, &contract->vd, flags);
 }
 
+static struct dma_async_tx_descriptor *sun4i_dma_prep_dma_cyclic(
+		struct dma_chan *chan, dma_addr_t buf, size_t len,
+		size_t period_len, enum dma_transfer_direction dir,
+		unsigned long flags, void *context) {
+	struct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);
+	struct dma_slave_config *sconfig = &vchan->cfg;
+	struct sun4i_ddma_promise *promise;
+	struct sun4i_ddma_contract *contract;
+	dma_addr_t src, dest;
+
+	printk("JDS - sun4i_dma_prep_dma_cyclic\n");
+	if (!is_slave_direction(dir)) {
+		dev_err(chan2dev(chan), "Invalid DMA direction\n");
+		return NULL;
+	}
+
+	contract = generate_ddma_contract();
+	if (!contract)
+		return NULL;
+
+	/* Figure out addresses */
+	if (dir == DMA_MEM_TO_DEV) {
+		src = buf;
+		dest = sconfig->dst_addr;
+	} else {
+		src = sconfig->src_addr;
+		dest = buf;
+	}
+
+	if (vchan->is_dedicated)
+		promise = generate_ddma_promise(chan, src, dest, len, sconfig);
+	else
+		promise = generate_ndma_promise(chan, src, dest, len, sconfig);
+
+	if (!promise) {
+		kfree(contract);
+		return NULL;
+	}
+
+	/* Figure out endpoints */
+	if (vchan->is_dedicated && dir == DMA_MEM_TO_DEV) {
+		promise->cfg |= DDMA_CFG_CONT_MODE | DDMA_CFG_SRC_DRQ_TYPE(DDMA_DRQ_TYPE_SDRAM) |
+			    DDMA_CFG_SRC_ADDR_MODE(DDMA_ADDR_MODE_LINEAR) |
+			    DDMA_CFG_DEST_DRQ_TYPE(vchan->endpoint) |
+			    DDMA_CFG_DEST_ADDR_MODE(DDMA_ADDR_MODE_IO);
+	} else if (!vchan->is_dedicated && dir == DMA_MEM_TO_DEV) {
+		promise->cfg |= NDMA_CFG_CONT_MODE | NDMA_CFG_SRC_DRQ_TYPE(NDMA_DRQ_TYPE_SDRAM) |
+			    NDMA_CFG_DEST_DRQ_TYPE(vchan->endpoint) |
+			    NDMA_CFG_DEST_FIXED_ADDR;
+	} else if (vchan->is_dedicated) {
+		promise->cfg |= DDMA_CFG_CONT_MODE | DDMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |
+			    DDMA_CFG_SRC_ADDR_MODE(DDMA_ADDR_MODE_IO) |
+			    DDMA_CFG_DEST_DRQ_TYPE(DDMA_DRQ_TYPE_SDRAM) |
+			    DDMA_CFG_DEST_ADDR_MODE(DDMA_ADDR_MODE_LINEAR);
+	} else {
+		promise->cfg |= NDMA_CFG_CONT_MODE | NDMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |
+			    NDMA_CFG_SRC_FIXED_ADDR |
+			    NDMA_CFG_DEST_DRQ_TYPE(NDMA_DRQ_TYPE_SDRAM);
+	}
+
+	/* Fill the contract with our only promise */
+	list_add_tail(&promise->list, &contract->demands);
+
+	/* And add it to the vchan */
+	return vchan_tx_prep(&vchan->vc, &contract->vd, flags);
+}
+
 static struct dma_async_tx_descriptor *
 sun4i_dma_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 			unsigned int sg_len, enum dma_transfer_direction dir,
@@ -651,6 +726,7 @@ sun4i_dma_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 	u32 endpoints, para;
 	int i;
 
+	printk("JDS - sun4i_dma_prep_slave_sg\n");
 	if (!sgl)
 		return NULL;
 
@@ -723,6 +799,7 @@ static void sun4i_ddma_terminate_all(struct sun4i_dma_vchan *vchan)
 	u32 n_busy = NDMA_CFG_LOADING;
 
 
+	printk("sun4i_ddma_terminate_all\n");
 	spin_lock_irqsave(&vchan->vc.lock, flags);
 	vchan_get_all_descriptors(&vchan->vc, &head);
 	spin_unlock_irqrestore(&vchan->vc.lock, flags);
@@ -751,6 +828,8 @@ static int sun4i_dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 	struct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);
 	int ret = 0;
 
+	printk("JDS - sun4i_dma_control cmd %d\n", cmd);
+
 	switch (cmd) {
 	case DMA_RESUME:
 	case DMA_PAUSE:
@@ -771,6 +850,7 @@ static int sun4i_dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 		break;
 	}
 
+	printk("JDS - sun4i_dma_control, %d\n", ret);
 	return ret;
 }
 
@@ -962,6 +1042,7 @@ static int sun4i_dma_probe(struct platform_device *pdev)
 	priv->slave.device_issue_pending	= sun4i_dma_issue_pending;
 	priv->slave.device_prep_slave_sg	= sun4i_dma_prep_slave_sg;
 	priv->slave.device_prep_dma_memcpy	= sun4i_dma_prep_dma_memcpy;
+	priv->slave.device_prep_dma_cyclic	= sun4i_dma_prep_dma_cyclic;
 	priv->slave.device_control		= sun4i_dma_control;
 	priv->slave.chancnt			= DDMA_NR_MAX_VCHANS;
 
diff --git a/sound/core/pcm_dmaengine.c b/sound/core/pcm_dmaengine.c
index 76cbb9e..fd420af 100644
--- a/sound/core/pcm_dmaengine.c
+++ b/sound/core/pcm_dmaengine.c
@@ -148,10 +148,12 @@ static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 	enum dma_transfer_direction direction;
 	unsigned long flags = DMA_CTRL_ACK;
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit\n");
 	direction = snd_pcm_substream_to_dma_direction(substream);
 
 	if (!substream->runtime->no_period_wakeup)
 		flags |= DMA_PREP_INTERRUPT;
+	printk("JDS - dmaengine_pcm_prepare_and_submit a\n");
 
 	prtd->pos = 0;
 	desc = dmaengine_prep_dma_cyclic(chan,
@@ -159,13 +161,16 @@ static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 		snd_pcm_lib_buffer_bytes(substream),
 		snd_pcm_lib_period_bytes(substream), direction, flags);
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit b\n");
 	if (!desc)
 		return -ENOMEM;
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit c\n");
 	desc->callback = dmaengine_pcm_dma_complete;
 	desc->callback_param = substream;
 	prtd->cookie = dmaengine_submit(desc);
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit d\n");
 	return 0;
 }
 
@@ -185,12 +190,17 @@ int snd_dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int ret;
 
+	printk("JDS = snd_dmaengine_pcm_trigger cmd %d prtd %p runtime %p\n", cmd, prtd, runtime);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
+	printk("JDS = snd_dmaengine_pcm_trigger a\n");
 		ret = dmaengine_pcm_prepare_and_submit(substream);
+	printk("JDS = snd_dmaengine_pcm_trigger b\n");
 		if (ret)
 			return ret;
+	printk("JDS = snd_dmaengine_pcm_trigger c\n");
 		dma_async_issue_pending(prtd->dma_chan);
+	printk("JDS = snd_dmaengine_pcm_trigger d\n");
 		break;
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
@@ -212,6 +222,7 @@ int snd_dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		return -EINVAL;
 	}
 
+	printk("JDS = snd_dmaengine_pcm_trigger f\n");
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_dmaengine_pcm_trigger);
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 0060b31..8f08e4b 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -52,6 +52,7 @@ source "sound/soc/s6000/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/sirf/Kconfig"
 source "sound/soc/spear/Kconfig"
+source "sound/soc/sunxi/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/txx9/Kconfig"
 source "sound/soc/ux500/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 5f1df02..50c7ab3 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -29,6 +29,7 @@ obj-$(CONFIG_SND_SOC)	+= s6000/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= sirf/
 obj-$(CONFIG_SND_SOC)	+= spear/
+obj-$(CONFIG_SND_SOC)	+= sunxi/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= txx9/
 obj-$(CONFIG_SND_SOC)	+= ux500/
diff --git a/sound/soc/generic/simple-card.c b/sound/soc/generic/simple-card.c
index 21f1ccb..917db58 100644
--- a/sound/soc/generic/simple-card.c
+++ b/sound/soc/generic/simple-card.c
@@ -8,6 +8,9 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+
+#define DEBUG
+
 #include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/module.h>
@@ -96,7 +99,7 @@ asoc_simple_card_sub_parse_of(struct device_node *np,
 	struct device_node *node;
 	struct clk *clk;
 	int ret;
-
+printk("JDS - asoc_simple_card_sub_parse_of\n");
 	/*
 	 * get node via "sound-dai = <&phandle port>"
 	 * it will be used as xxx_of_node on soc_bind_dai_link()
@@ -105,16 +108,19 @@ asoc_simple_card_sub_parse_of(struct device_node *np,
 	if (!node)
 		return -ENODEV;
 	*p_node = node;
+printk("JDS - asoc_simple_card_sub_parse_of 1\n");
 
 	/* get dai->name */
 	ret = snd_soc_of_get_dai_name(np, name);
 	if (ret < 0)
 		return ret;
+printk("JDS - asoc_simple_card_sub_parse_of 2\n");
 
 	/* parse TDM slot */
 	ret = snd_soc_of_parse_tdm_slot(np, &dai->slots, &dai->slot_width);
 	if (ret)
 		return ret;
+printk("JDS - asoc_simple_card_sub_parse_of 3\n");
 
 	/*
 	 * bitclock-inversion, frame-inversion
@@ -135,6 +141,7 @@ asoc_simple_card_sub_parse_of(struct device_node *np,
 		if (IS_ERR(clk)) {
 			ret = PTR_ERR(clk);
 			return ret;
+printk("JDS - asoc_simple_card_sub_parse_of 4\n");
 		}
 
 		dai->sysclk = clk_get_rate(clk);
@@ -148,6 +155,7 @@ asoc_simple_card_sub_parse_of(struct device_node *np,
 			dai->sysclk = clk_get_rate(clk);
 	}
 
+printk("JDS - asoc_simple_card_sub_parse_of 5\n");
 	return 0;
 }
 
@@ -158,7 +166,7 @@ static int simple_card_cpu_codec_of(struct device_node *node,
 {
 	struct device_node *np;
 	int ret;
-
+printk("JDS - simple_card_cpu_codec_of\n");
 	/* CPU sub-node */
 	ret = -EINVAL;
 	np = of_get_child_by_name(node, "simple-audio-card,cpu");
@@ -169,6 +177,7 @@ static int simple_card_cpu_codec_of(struct device_node *node,
 						&dai_link->cpu_dai_name);
 		of_node_put(np);
 	}
+printk("JDS - simple_card_cpu_codec_of  %d\n", ret);
 	if (ret < 0)
 		return ret;
 
@@ -182,6 +191,7 @@ static int simple_card_cpu_codec_of(struct device_node *node,
 						&dai_link->codec_dai_name);
 		of_node_put(np);
 	}
+printk("JDS - simple_card_cpu_codec_of 2 %d\n", ret);
 	return ret;
 }
 
@@ -196,7 +206,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 	char *name;
 	unsigned int daifmt;
 	int ret;
-
+printk("JDS - asoc_simple_card_parse_of 1\n");
 	/* parsing the card name from DT */
 	snd_soc_of_parse_card_name(&priv->snd_card, "simple-audio-card,name");
 
@@ -204,7 +214,8 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 	daifmt = snd_soc_of_parse_daifmt(node, "simple-audio-card,") &
 		(SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_INV_MASK);
 
-	/* off-codec widgets */
+printk("JDS - asoc_simple_card_parse_of 2\n");
+	/* off-codec widgets */ 
 	if (of_property_read_bool(node, "simple-audio-card,widgets")) {
 		ret = snd_soc_of_parse_audio_simple_widgets(&priv->snd_card,
 					"simple-audio-card,widgets");
@@ -212,6 +223,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 			return ret;
 	}
 
+printk("JDS - asoc_simple_card_parse_of 3\n");
 	/* DAPM routes */
 	if (of_property_read_bool(node, "simple-audio-card,routing")) {
 		ret = snd_soc_of_parse_audio_routing(&priv->snd_card,
@@ -220,6 +232,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 			return ret;
 	}
 
+printk("JDS - asoc_simple_card_parse_of 4\n");
 	/* loop on the DAI links */
 	np = NULL;
 	for (;;) {
@@ -234,6 +247,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 		if (ret < 0)
 			goto err;
 
+printk("JDS - asoc_simple_card_parse_of 5\n");
 		/*
 		 * overwrite cpu_dai->fmt as its DAIFMT_MASTER bit is based on CODEC
 		 * while the other bits should be identical unless buggy SW/HW design.
@@ -283,6 +297,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 	return 0;
 
 err:
+printk("JDS - asoc_simple_card_parse_of err\n");
 	of_node_put(np);
 	return ret;
 }
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 051c006..dc3b7c1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -21,7 +21,7 @@
  *   o Add more codecs and platforms to ensure good API coverage.
  *   o Support TDM on PCM and I2S
  */
-
+#define DEBUG
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
@@ -4667,6 +4667,7 @@ int snd_soc_of_get_dai_name(struct device_node *of_node,
 	struct of_phandle_args args;
 	int ret;
 
+printk("JDS = snd_soc_of_get_dai_name\n");
 	ret = of_parse_phandle_with_args(of_node, "sound-dai",
 					 "#sound-dai-cells", 0, &args);
 	if (ret)
@@ -4674,11 +4675,13 @@ int snd_soc_of_get_dai_name(struct device_node *of_node,
 
 	ret = -EPROBE_DEFER;
 
+printk("JDS = snd_soc_of_get_dai_name a\n");
 	mutex_lock(&client_mutex);
 	list_for_each_entry(pos, &component_list, list) {
 		if (pos->dev->of_node != args.np)
 			continue;
 
+printk("JDS = snd_soc_of_get_dai_name b\n");
 		if (pos->driver->of_xlate_dai_name) {
 			ret = pos->driver->of_xlate_dai_name(pos, &args, dai_name);
 		} else {
@@ -4703,9 +4706,12 @@ int snd_soc_of_get_dai_name(struct device_node *of_node,
 
 			ret = 0;
 
+printk("JDS = snd_soc_of_get_dai_name c\n");
 			*dai_name = pos->dai_drv[id].name;
+printk("JDS = snd_soc_of_get_dai_name name %s\n", *dai_name);
 			if (!*dai_name)
 				*dai_name = pos->name;
+printk("JDS = snd_soc_of_get_dai_name d *s\n", *dai_name);
 		}
 
 		break;
@@ -4713,6 +4719,7 @@ int snd_soc_of_get_dai_name(struct device_node *of_node,
 	mutex_unlock(&client_mutex);
 
 	of_node_put(args.np);
+printk("JDS = snd_soc_of_get_dai_name e\n");
 
 	return ret;
 }
diff --git a/sound/soc/soc-generic-dmaengine-pcm.c b/sound/soc/soc-generic-dmaengine-pcm.c
index 5bace12..f64f2f4 100644
--- a/sound/soc/soc-generic-dmaengine-pcm.c
+++ b/sound/soc/soc-generic-dmaengine-pcm.c
@@ -65,15 +65,19 @@ int snd_dmaengine_pcm_prepare_slave_config(struct snd_pcm_substream *substream,
 	struct snd_dmaengine_dai_dma_data *dma_data;
 	int ret;
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config\n");
 	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config 1\n");
 	ret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);
 	if (ret)
 		return ret;
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config 2\n");
 	snd_dmaengine_pcm_set_config_from_dai_data(substream, dma_data,
 		slave_config);
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config 3\n");
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_dmaengine_pcm_prepare_slave_config);
@@ -90,6 +94,7 @@ static int dmaengine_pcm_hw_params(struct snd_pcm_substream *substream,
 	struct dma_slave_config slave_config;
 	int ret;
 
+	printk("JDS - dmaengine_pcm_hw_params pcm %p\n", pcm);
 	memset(&slave_config, 0, sizeof(slave_config));
 
 	if (!pcm->config)
@@ -107,6 +112,7 @@ static int dmaengine_pcm_hw_params(struct snd_pcm_substream *substream,
 			return ret;
 	}
 
+	printk("JDS - dmaengine_pcm_hw_params ret\n");
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
 }
 
@@ -121,12 +127,14 @@ static int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substrea
 	struct snd_pcm_hardware hw;
 	int ret;
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams pcm %p\n", pcm);
 	if (pcm->config && pcm->config->pcm_hardware)
 		return snd_soc_set_runtime_hwparams(substream,
 				pcm->config->pcm_hardware);
 
 	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams dma_data %p\n", dma_data);
 	memset(&hw, 0, sizeof(hw));
 	hw.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
 			SNDRV_PCM_INFO_INTERLEAVED;
@@ -137,6 +145,7 @@ static int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substrea
 	hw.buffer_bytes_max = SIZE_MAX;
 	hw.fifo_size = dma_data->fifo_size;
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams dma_data 2  %p\n", dma_data);
 	if (pcm->flags & SND_DMAENGINE_PCM_FLAG_NO_RESIDUE)
 		hw.info |= SNDRV_PCM_INFO_BATCH;
 
@@ -148,6 +157,7 @@ static int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substrea
 			hw.info |= SNDRV_PCM_INFO_BATCH;
 	}
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams dma_data 3 %p\n", dma_data);
 	return snd_soc_set_runtime_hwparams(substream, &hw);
 }
 
@@ -158,6 +168,7 @@ static int dmaengine_pcm_open(struct snd_pcm_substream *substream)
 	struct dma_chan *chan = pcm->chan[substream->stream];
 	int ret;
 
+	printk("JDS - dmaengine_pcm_open\n");
 	ret = dmaengine_pcm_set_runtime_hwparams(substream);
 	if (ret)
 		return ret;
@@ -178,6 +189,7 @@ static struct dma_chan *dmaengine_pcm_compat_request_channel(
 	struct snd_dmaengine_dai_dma_data *dma_data;
 	dma_filter_fn fn = NULL;
 
+	printk("JDS - dmaengine_pcm_compat_request_channel\n");
 	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
 	if ((pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX) && pcm->chan[0])
@@ -219,6 +231,7 @@ static int dmaengine_pcm_new(struct snd_soc_pcm_runtime *rtd)
 	unsigned int i;
 	int ret;
 
+	printk("JDS - dmaengine_pcm_new\n");
 	if (config && config->prealloc_buffer_size) {
 		prealloc_buffer_size = config->prealloc_buffer_size;
 		max_buffer_size = config->pcm_hardware->buffer_bytes_max;
@@ -319,6 +332,7 @@ static int dmaengine_pcm_request_chan_of(struct dmaengine_pcm *pcm,
 	const char *name;
 	struct dma_chan *chan;
 
+	printk("JDS - dmaengine_pcm_request_chan_of\n");
 	if ((pcm->flags & (SND_DMAENGINE_PCM_FLAG_NO_DT |
 			   SND_DMAENGINE_PCM_FLAG_CUSTOM_CHANNEL_NAME)) ||
 	    !dev->of_node)
@@ -388,6 +402,7 @@ int snd_dmaengine_pcm_register(struct device *dev,
 	struct dmaengine_pcm *pcm;
 	int ret;
 
+	printk("JDS - snd_dmaengine_pcm_register\n");
 	pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
 	if (!pcm)
 		return -ENOMEM;
diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
new file mode 100644
index 0000000..72bb3c4
--- /dev/null
+++ b/sound/soc/sunxi/Kconfig
@@ -0,0 +1,9 @@
+config SND_SUNXI_SOC_CODEC
+	tristate "APB On-Chip sun4i and sun5i Codec"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	default y
+
+config SND_SUNXI_SOC_CODEC_JDS
+	tristate "JDS version - APB On-Chip sun4i and sun5i Codec"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	default y
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
new file mode 100644
index 0000000..c15cb8b
--- /dev/null
+++ b/sound/soc/sunxi/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_SND_SUNXI_SOC_CODEC) += sunxi-codec.o
+obj-$(CONFIG_SND_SUNXI_SOC_CODEC_JDS) += sunxi_codec_main.o
+
+
diff --git a/sound/soc/sunxi/sunxi-codec.c b/sound/soc/sunxi/sunxi-codec.c
new file mode 100644
index 0000000..e82997d
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-codec.c
@@ -0,0 +1,1771 @@
+/*
+ *   Driver for CODEC on Allwinner CPUs
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License.
+ *
+ *
+ ***************************************************************************************************/
+#define DEBUG
+#ifndef CONFIG_PM
+#define CONFIG_PM
+#endif
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#ifdef CONFIG_PM
+#include <linux/pm.h>
+#endif
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include "sunxi-codec.h"
+
+/* Structure/enum declaration ------------------------------- */
+struct card_data {
+	struct device *dev; /* parent device */
+	struct resource *codec_base_res; /* resources found */
+	struct resource *codec_base_req; /* resources found */
+
+	spinlock_t lock;
+
+	long samplerate;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	
+	enum sunxi_device_id id;
+	struct dma_chan		*rx_dma_chan;
+	struct dma_chan		*tx_dma_chan;
+};
+
+#define SCRIPT_AUDIO_OK (0)
+static int has_playback, has_capture;
+static int gpio_pa_shutdown = 0;
+struct clk *codec_apbclk, *codec_pll2clk, *codec_moduleclk;
+
+static volatile unsigned int capture_dmasrc = 0;
+static volatile unsigned int capture_dmadst = 0;
+static volatile unsigned int play_dmasrc = 0;
+static volatile unsigned int play_dmadst = 0;
+
+#ifdef JDS
+static struct sunxi_dma_params sunxi_codec_pcm_stereo_play = {
+	.client.name = "CODEC PCM Stereo PLAY",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel = DMACH_NADDA_PLAY,
+#endif
+	.dma_addr = CODEC_BASSADDRESS + SUNXI_DAC_TXDATA, //发送数据地址
+};
+
+static struct sunxi_dma_params sunxi_codec_pcm_stereo_capture = {
+	.client.name = "CODEC PCM Stereo CAPTURE",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel = DMACH_NADDA_CAPTURE, //only support half full
+#endif	
+	.dma_addr = CODEC_BASSADDRESS + SUNXI_ADC_RXDATA, //接收数据地址
+};
+#endif
+
+struct sunxi_playback_runtime_data {
+	spinlock_t lock;
+	int state;
+	unsigned int dma_loaded;
+	unsigned int dma_limit;
+	unsigned int dma_period;
+	dma_addr_t dma_start;
+	dma_addr_t dma_pos;
+	dma_addr_t dma_end;
+	struct sunxi_dma_params *params;
+};
+
+struct sunxi_capture_runtime_data {
+	spinlock_t lock;
+	int state;
+	unsigned int dma_loaded;
+	unsigned int dma_limit;
+	unsigned int dma_period;
+	dma_addr_t dma_start;
+	dma_addr_t dma_pos;
+	dma_addr_t dma_end;
+	struct sunxi_dma_params *params;
+};
+
+/*播放设备硬件定义*/
+static struct snd_pcm_hardware sunxi_pcm_playback_hardware =
+{
+	.info = (SNDRV_PCM_INFO_INTERLEAVED |
+			SNDRV_PCM_INFO_BLOCK_TRANSFER |
+			SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+			SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |SNDRV_PCM_RATE_11025 |\
+ SNDRV_PCM_RATE_22050| SNDRV_PCM_RATE_32000 |\
+ SNDRV_PCM_RATE_44100| SNDRV_PCM_RATE_48000 |SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000 |\
+ SNDRV_PCM_RATE_KNOT),
+	.rate_min = 8000,
+	.rate_max = 192000,
+	.channels_min = 1,
+	.channels_max = 2,
+	.buffer_bytes_max = 128*1024, //最大的缓冲区大小
+	.period_bytes_min = 1024*4,//最小周期大小
+	.period_bytes_max = 1024*32,//最大周期大小
+	.periods_min = 4,//最小周期数
+	.periods_max = 8,//最大周期数
+	.fifo_size = 32,//fifo字节数
+};
+
+/*录音设备硬件定义*/
+static struct snd_pcm_hardware sunxi_pcm_capture_hardware =
+{
+	.info = (SNDRV_PCM_INFO_INTERLEAVED |
+			SNDRV_PCM_INFO_BLOCK_TRANSFER |
+			SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+			SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |SNDRV_PCM_RATE_11025 |\
+ SNDRV_PCM_RATE_22050| SNDRV_PCM_RATE_32000 |\
+ SNDRV_PCM_RATE_44100| SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 |SNDRV_PCM_RATE_192000 |\
+ SNDRV_PCM_RATE_KNOT),
+	.rate_min = 8000,
+	.rate_max = 192000,
+	.channels_min = 1,
+	.channels_max = 2,
+	.buffer_bytes_max = 128*1024, //最大的缓冲区大小
+	.period_bytes_min = 1024*4,//最小周期大小
+	.period_bytes_max = 1024*32,//最大周期大小
+	.periods_min = 4,//最小周期数
+	.periods_max = 8,//最大周期数
+	.fifo_size = 32,//fifo字节数
+};
+
+static void codec_resume_events(struct work_struct *work);
+struct workqueue_struct *resume_work_queue;
+static DECLARE_WORK(codec_resume_work, codec_resume_events);
+
+static unsigned int rates[] = { 8000, 11025, 12000, 16000, 22050, 24000, 24000, 32000, 44100, 48000, 96000, 192000 };
+
+static struct snd_pcm_hw_constraint_list hw_constraints_rates =
+{
+	.count = ARRAY_SIZE(rates),
+	.list = rates,
+	.mask = 0,
+};
+
+/**
+ * codec_wrreg_bits - update codec register bits
+ * @reg: codec register
+ * @mask: register mask
+ * @value: new value
+ *
+ * Writes new register value.
+ * Return 1 for change else 0.
+ */
+int codec_wrreg_bits(unsigned short reg, unsigned int mask, unsigned int value)
+{
+	int change;
+	unsigned int old, new;
+
+	old = codec_rdreg(reg);
+	new = (old & ~mask) | value;
+	change = old != new;
+
+	if (change) {
+		codec_wrreg(reg, new);
+	}
+	return change;
+}
+
+/**
+ *	snd_codec_info_volsw	-	single	mixer	info	callback
+ *	@kcontrol:	mixer control
+ *	@uinfo:	control	element	information
+ *	Callback to provide information about a single mixer control
+ *
+ * 	info()函数用于获得该control的详细信息，该函数必须填充传递给它的第二个参数snd_ctl_elem_info结构体
+ *
+ *	Returns 0 for success
+ */
+int snd_codec_info_volsw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	struct codec_mixer_control *mc = (struct codec_mixer_control*) kcontrol->private_value;
+	int max = mc->max;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+
+	if (max == 1)
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN; //the info of type
+	else
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+
+	uinfo->count = shift == rshift ? 1 : 2; //the info of elem count
+	uinfo->value.integer.min = 0; //the info of min value
+	uinfo->value.integer.max = max; //the info of max value
+	return 0;
+}
+
+/**
+ *	snd_codec_get_volsw	-	single	mixer	get	callback
+ *	@kcontrol:	mixer	control
+ *	@ucontrol:	control	element	information
+ *
+ *	Callback to get the value of a single mixer control
+ *	get()函数用于得到control的目前值并返回用户空间
+ *	return 0 for success.
+ */
+int snd_codec_get_volsw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct codec_mixer_control *mc = (struct codec_mixer_control*) kcontrol->private_value;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	/*fls(7) = 3,fls(1)=1,fls(0)=0,fls(15)=4,fls(3)=2,fls(23)=5*/
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	unsigned int reg = mc->reg;
+
+	ucontrol->value.integer.value[0] = (codec_rdreg(reg) >> shift) & mask;
+	if (shift != rshift)
+		ucontrol->value.integer.value[1] = (codec_rdreg(reg) >> rshift) & mask;
+
+	/*将获得的值写入snd_ctl_elem_value*/
+	if (invert) {
+		ucontrol->value.integer.value[0] = max - ucontrol->value.integer.value[0];
+		if (shift != rshift)
+			ucontrol->value.integer.value[1] = max - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+
+/**
+ *	snd_codec_put_volsw	-	single	mixer put callback
+ *	@kcontrol:	mixer	control
+ *	@ucontrol:	control	element	information
+ *
+ *	put()用于从用户空间写入值，如果值被改变，该函数返回1，否则返回0.
+ *	Callback to put the value of a single mixer control
+ *
+ * return 0 for success.
+ */
+int snd_codec_put_volsw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct codec_mixer_control *mc = (struct codec_mixer_control*) kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	unsigned int val, val2, val_mask;
+
+	val = (ucontrol->value.integer.value[0] & mask);
+	if (invert)
+		val = max - val;
+	val <<= shift;
+	val_mask = mask << shift;
+	if (shift != rshift) {
+		val2 = (ucontrol->value.integer.value[1] & mask);
+		if (invert)
+			val2 = max - val2;
+		val_mask |= mask << rshift;
+		val |= val2 << rshift;
+	}
+
+	return codec_wrreg_bits(reg, val_mask, val);
+}
+
+int codec_wr_control(u32 reg, u32 mask, u32 shift, u32 val)
+{
+	u32 reg_val;
+	reg_val = val << shift;
+	mask = mask << shift;
+	codec_wrreg_bits(reg, mask, reg_val);
+	return 0;
+}
+
+int codec_rd_control(u32 reg, u32 bit, u32 *val)
+{
+	return 0;
+}
+
+/**
+ *	codec_reset - reset the codec
+ * @codec	SoC Audio Codec
+ * Reset the codec, set the register of codec default value
+ * Return 0 for success
+ */
+static int codec_init(struct card_data *priv)
+{
+	//enable dac digital
+	codec_wr_control(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x1);
+
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x1, 28, 0x1);
+	//set digital volume to maximum
+	if (priv->id == SUN4A)
+		codec_wr_control(SUNXI_DAC_DPC, 0x6, DIGITAL_VOL, 0x0);
+
+	//pa mute
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	//enable PA
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x1);
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x3, DRA_LEVEL, 0x3);
+	//set volume
+	if ((priv->id == SUN4A) || (priv->id == SUN4I)) {
+		int device_lr_change = 0;
+		if (priv->id == SUN4A)
+			codec_wr_control(SUNXI_DAC_ACTL, 0x6, VOLUME, 0x01);
+		else 
+			codec_wr_control(SUNXI_DAC_ACTL, 0x6, VOLUME, 0x3b);
+#ifdef JDS
+		rc = script_parser_fetch("audio_para", "audio_lr_change", &device_lr_change, 1);
+		if (rc != SCRIPT_AUDIO_OK) {
+			pr_err("No audio_lr_change in fex audio_para\n");
+			return -1;
+		}
+#endif
+		if (device_lr_change)
+			codec_wr_control(SUNXI_DAC_DEBUG, 0x1, DAC_CHANNEL, 0x1);
+	} else {
+		codec_wr_control(SUNXI_DAC_ACTL, 0x6, VOLUME, 0x3b);
+	}
+	return 0;
+}
+
+static int codec_play_open(struct snd_pcm_substream *substream)
+{
+	codec_wr_control(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x1);
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x1, DAC_FIFO_FLUSH, 0x1);
+	//set TX FIFO send drq level
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x4, TX_TRI_LEVEL, 0xf);
+	if (substream->runtime->rate > 32000) {
+		codec_wr_control(SUNXI_DAC_FIFOC, 0x1, 28, 0x0);
+	} else {
+		codec_wr_control(SUNXI_DAC_FIFOC, 0x1, 28, 0x1);
+	}
+	//set TX FIFO MODE
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x1, TX_FIFO_MODE, 0x1);
+	//send last sample when dac fifo under run
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x1, LAST_SE, 0x0);
+	//enable dac analog
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x1);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x1);
+	//enable dac to pa
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x1);
+	return 0;
+}
+
+static int codec_capture_open(struct card_data *priv)
+{
+	//enable mic1 pa
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, MIC1_EN, 0x1);
+	//mic1 gain 32dB
+	codec_wr_control(SUNXI_ADC_ACTL, 0x3, 25, 0x1);
+	//enable VMIC
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, VMIC_EN, 0x1);
+
+	if (priv->id == SUN7I) {
+		/* boost up record effect */
+		codec_wr_control(SUNXI_DAC_TUNE, 0x3, 8, 0x3);
+	}
+
+	//enable adc digital
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_DIG_EN, 0x1);
+	//set RX FIFO mode
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, RX_FIFO_MODE, 0x1);
+	//flush RX FIFO
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_FIFO_FLUSH, 0x1);
+	//set RX FIFO rec drq level
+	codec_wr_control(SUNXI_ADC_FIFOC, 0xf, RX_TRI_LEVEL, 0x7);
+	//enable adc1 analog
+	codec_wr_control(SUNXI_ADC_ACTL, 0x3, ADC_EN, 0x3);
+	return 0;
+}
+
+static int codec_play_start(void)
+{
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+#endif
+	//flush TX FIFO
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x1, DAC_FIFO_FLUSH, 0x1);
+	//enable dac drq
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x1, DAC_DRQ, 0x1);
+	return 0;
+}
+
+static int codec_play_stop(void)
+{
+	//pa mute
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+#endif
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	mdelay(5);
+	//disable dac drq
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x1, DAC_DRQ, 0x0);
+	//pa mute
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x0);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x0);
+	return 0;
+}
+
+static int codec_capture_start(void)
+{
+	//enable adc drq
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+#endif
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_DRQ, 0x1);
+	return 0;
+}
+
+static int codec_capture_stop(struct card_data *priv)
+{
+	//disable adc drq
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_DRQ, 0x0);
+	//enable mic1 pa
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, MIC1_EN, 0x0);
+
+	//enable VMIC
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, VMIC_EN, 0x0);
+	if (priv->id == SUN7I) {
+		codec_wr_control(SUNXI_DAC_TUNE, 0x3, 8, 0x0);
+	}
+	//enable adc digital
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_DIG_EN, 0x0);
+	//set RX FIFO mode
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, RX_FIFO_MODE, 0x0);
+	//flush RX FIFO
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_FIFO_FLUSH, 0x0);
+	//enable adc1 analog
+	codec_wr_control(SUNXI_ADC_ACTL, 0x3, ADC_EN, 0x0);
+	return 0;
+}
+
+static int codec_dev_free(struct snd_device *device)
+{
+	return 0;
+}
+
+struct sunxi_controls {
+	
+};
+
+/*	对sunxi-codec.c各寄存器的各种设定，或读取。主要实现函数有三个.
+ * 	.info = snd_codec_info_volsw, .get = snd_codec_get_volsw,\.put = snd_codec_put_volsw,
+ * It should be noted that the only difference between sunxi and sun5i is the Master Playback Volume
+ */
+static const struct snd_kcontrol_new sun4i_dac[] = {
+	//FOR B C VERSION
+	CODEC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), CODEC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	CODEC_SINGLE("Fm Volume", SUNXI_DAC_ACTL, 23, 7, 0), //Fm 音量
+	CODEC_SINGLE("Line Volume", SUNXI_DAC_ACTL, 26, 1, 0), //Line音量
+	CODEC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	CODEC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	CODEC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	CODEC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	CODEC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	CODEC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	CODEC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
+	CODEC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+};
+
+static const struct snd_kcontrol_new sun4a_dac[] = {
+	//For A VERSION
+	CODEC_SINGLE("Master Playback Volume", SUNXI_DAC_DPC, 12, 0x3f, 0), //62 steps, 3e + 1 = 3f 主音量控制
+	CODEC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	CODEC_SINGLE("Fm Volume", SUNXI_DAC_ACTL, 23, 7, 0), //Fm 音量
+	CODEC_SINGLE("Line Volume", SUNXI_DAC_ACTL, 26, 1, 0), //Line音量
+	CODEC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	CODEC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	CODEC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	CODEC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	CODEC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	CODEC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	CODEC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
+	CODEC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+};
+
+static const struct snd_kcontrol_new sunxi_adc_controls[] = { 
+	CODEC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
+	CODEC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
+	CODEC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0),
+	CODEC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0), //录音音量
+	CODEC_SINGLE("Line Capture Volume", SUNXI_ADC_ACTL, 13, 7, 0), 
+	CODEC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
+	CODEC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
+	CODEC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
+	CODEC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), CODEC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), CODEC_SINGLE("ADC Input Mux",
+	SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
+};
+
+static const struct snd_kcontrol_new sun7i_dac_ctls[] = {
+	/*SUNXI_DAC_ACTL = 0x10,PAVOL*/
+	CODEC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
+	CODEC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	CODEC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	CODEC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	CODEC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	CODEC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	CODEC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	CODEC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	CODEC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0), 
+	CODEC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+	CODEC_SINGLE("MIC output volume", SUNXI_DAC_ACTL, 20, 7, 0),
+	/*	FM Input to output mixer Gain Control
+	* 	From -4.5db to 6db,1.5db/step,default is 0db
+	*	-4.5db:0x0,-3.0db:0x1,-1.5db:0x2,0db:0x3
+	*	1.5db:0x4,3.0db:0x5,4.5db:0x6,6db:0x7
+	*/
+	CODEC_SINGLE("Fm output Volume", SUNXI_DAC_ACTL, 23, 7, 0),
+	/*	Line-in gain stage to output mixer Gain Control
+	*	0:-1.5db,1:0db
+	*/
+	CODEC_SINGLE("Line output Volume", SUNXI_DAC_ACTL, 26, 1, 0),
+};
+
+static const struct snd_kcontrol_new sun7i_adc_ctls[] = { 
+	CODEC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
+	CODEC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
+	CODEC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0), 
+	CODEC_SINGLE("Linein Pre-AMP", SUNXI_ADC_ACTL, 13, 7, 0), CODEC_SINGLE("LINEIN APM Volume", SUNXI_MIC_CRT, 13, 0x7, 0),
+	/* ADC Input Gain Control, capture volume
+	* 000:-4.5db,001:-3db,010:-1.5db,011:0db,100:1.5db,101:3db,110:4.5db,111:6db
+	*/
+	CODEC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0),
+	/*
+	*	MIC2 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	CODEC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
+	CODEC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
+	CODEC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
+	CODEC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
+	CODEC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
+	CODEC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
+	CODEC_SINGLE("Mic2 gain Volume", SUNXI_MIC_CRT, 26, 7, 0),
+	/*
+	*	MIC1 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	CODEC_SINGLE("Mic1 gain Volume", SUNXI_MIC_CRT, 29, 3, 0), 
+};
+
+int snd_chip_codec_mixer_new(struct card_data *priv)
+{
+	/*
+	 *	每个alsa预定义的组件在构造时需调用snd_device_new()，而每个组件的析构方法则在函数集中被包含
+	 *	对于PCM、AC97此类预定义组件，我们不需要关心它们的析构，而对于自定义的组件，则需要填充snd_device_ops
+	 *	中的析构函数指针dev_free，这样，当snd_card_free()被调用时，组件将被自动释放。
+	 */
+	static struct snd_device_ops ops = {
+		.dev_free = codec_dev_free,
+	};
+	unsigned char *clnt = "codec";
+	int idx;
+	int err;
+	/*
+	 *	snd_ctl_new1函数用于创建一个snd_kcontrol并返回其指针，
+	 *	snd_ctl_add函数用于将创建的snd_kcontrol添加到对应的card中。
+	 */
+	if (priv->id == SUN4A) {
+		if (has_playback)
+			for (idx = 0; idx < ARRAY_SIZE(sun4a_dac); idx++)
+				if ((err = snd_ctl_add(priv->card, snd_ctl_new1(&sun4a_dac[idx], clnt))) < 0)
+					return err;
+		if (has_capture)
+			for (idx = 0; idx < ARRAY_SIZE(sunxi_adc_controls); idx++)
+				if ((err = snd_ctl_add(priv->card, snd_ctl_new1(&sunxi_adc_controls[idx], clnt))) < 0)
+					return err;
+	} else if ((priv->id == SUN4I) || (priv->id == SUN5I)) {
+		
+		if (has_playback)
+			for (idx = 0; idx < ARRAY_SIZE(sun4i_dac); idx++)
+				if ((err = snd_ctl_add(priv->card, snd_ctl_new1(&sun4i_dac[idx], clnt))) < 0)
+					return err;
+		if (has_capture)
+			for (idx = 0; idx < ARRAY_SIZE(sunxi_adc_controls); idx++)
+				if ((err = snd_ctl_add(priv->card, snd_ctl_new1(&sunxi_adc_controls[idx], clnt))) < 0)
+					return err;
+	} else if (priv->id == SUN7I) {
+		if (has_playback)
+			for (idx = 0; idx < ARRAY_SIZE(sun7i_dac_ctls); idx++)
+				if ((err = snd_ctl_add(priv->card, snd_ctl_new1(&sun7i_dac_ctls[idx], clnt))) < 0)
+					return err;
+		if (has_capture)
+			for (idx = 0; idx < ARRAY_SIZE(sun7i_adc_ctls); idx++)
+				if ((err = snd_ctl_add(priv->card, snd_ctl_new1(&sun7i_adc_ctls[idx], clnt))) < 0)
+					return err;
+	}
+	/*
+	 *	当card被创建后，设备（组件）能够被创建并关联于该card。第一个参数是snd_card_create
+	 *	创建的card指针，第二个参数type指的是device-level即设备类型，形式为SNDRV_DEV_XXX,包括
+	 *	SNDRV_DEV_CODEC、SNDRV_DEV_CONTROL、SNDRV_DEV_PCM、SNDRV_DEV_RAWMIDI等、用户自定义的
+	 *	设备的device-level是SNDRV_DEV_LOWLEVEL，ops参数是1个函数集（snd_device_ops结构体）的
+	 *	指针，device_data是设备数据指针，snd_device_new本身不会分配设备数据的内存，因此事先应
+	 *	分配。在这里在snd_card_create分配。
+	 */
+	if ((err = snd_device_new(priv->card, SNDRV_DEV_CODEC, clnt, &ops)) < 0) {
+		return err;
+	}
+
+	strcpy(priv->card->mixername, "codec Mixer");
+
+	return 0;
+}
+
+static void sunxi_pcm_enqueue(struct snd_pcm_substream *substream)
+{
+	int play_ret = 0, capture_ret = 0;
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+	dma_addr_t play_pos = 0, capture_pos = 0;
+	unsigned long play_len = 0, capture_len = 0;
+	unsigned int play_limit = 0, capture_limit = 0;
+	
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		play_prtd = substream->runtime->private_data;
+		play_pos = play_prtd->dma_pos;
+		play_len = play_prtd->dma_period;
+		play_limit = play_prtd->dma_limit;
+		while (play_prtd->dma_loaded < play_limit) {
+			if ((play_pos + play_len) > play_prtd->dma_end) {
+				play_len = play_prtd->dma_end - play_pos;
+			}
+//JDS			play_ret = sunxi_dma_enqueue(play_prtd->params, play_pos, play_len, 0);
+			if (play_ret == 0) {
+				play_prtd->dma_loaded++;
+				play_pos += play_prtd->dma_period;
+				if (play_pos >= play_prtd->dma_end)
+					play_pos = play_prtd->dma_start;
+			} else {
+				break;
+			}
+		}
+		play_prtd->dma_pos = play_pos;
+	} else {
+		capture_prtd = substream->runtime->private_data;
+		capture_pos = capture_prtd->dma_pos;
+		capture_len = capture_prtd->dma_period;
+		capture_limit = capture_prtd->dma_limit;
+		while (capture_prtd->dma_loaded < capture_limit) {
+			if ((capture_pos + capture_len) > capture_prtd->dma_end) {
+				capture_len = capture_prtd->dma_end - capture_pos;
+			}
+//JDS			capture_ret = sunxi_dma_enqueue(capture_prtd->params, capture_pos, capture_len, 1);
+			if (capture_ret == 0) {
+				capture_prtd->dma_loaded++;
+				capture_pos += capture_prtd->dma_period;
+				if (capture_pos >= capture_prtd->dma_end)
+					capture_pos = capture_prtd->dma_start;
+			} else {
+				break;
+			}
+		}
+		capture_prtd->dma_pos = capture_pos;
+	}
+}
+
+static void sunxi_audio_capture_buffdone(struct sunxi_dma_params *dma, void *dev_id)
+{
+	struct sunxi_capture_runtime_data *capture_prtd;
+	struct snd_pcm_substream *substream = dev_id;
+
+	capture_prtd = substream->runtime->private_data;
+	if (substream) {
+		snd_pcm_period_elapsed(substream);
+	}
+
+	spin_lock(&capture_prtd->lock);
+	{
+		capture_prtd->dma_loaded--;
+		sunxi_pcm_enqueue(substream);
+	}
+	spin_unlock(&capture_prtd->lock);
+}
+
+static void sunxi_audio_play_buffdone(struct sunxi_dma_params *dma, void *dev_id)
+{
+	struct sunxi_playback_runtime_data *play_prtd;
+	struct snd_pcm_substream *substream = dev_id;
+
+	play_prtd = substream->runtime->private_data;
+	if (substream) {
+		snd_pcm_period_elapsed(substream);
+	}
+
+	spin_lock(&play_prtd->lock);
+	{
+		play_prtd->dma_loaded--;
+		sunxi_pcm_enqueue(substream);
+	}
+	spin_unlock(&play_prtd->lock);
+}
+
+static snd_pcm_uframes_t snd_sunxi_codec_pointer(struct snd_pcm_substream *substream)
+{
+	unsigned long play_res = 0, capture_res = 0;
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		play_prtd = substream->runtime->private_data;
+		spin_lock(&play_prtd->lock);
+//JDS		sunxi_dma_getcurposition(play_prtd->params, (dma_addr_t*) &play_dmasrc, (dma_addr_t*) &play_dmadst);
+		play_res = play_dmasrc + play_prtd->dma_period - play_prtd->dma_start;
+		spin_unlock(&play_prtd->lock);
+		if (play_res >= snd_pcm_lib_buffer_bytes(substream)) {
+			if (play_res == snd_pcm_lib_buffer_bytes(substream))
+				play_res = 0;
+		}
+		return bytes_to_frames(substream->runtime, play_res);
+	} else {
+		capture_prtd = substream->runtime->private_data;
+		spin_lock(&capture_prtd->lock);
+//JDS		sunxi_dma_getcurposition(capture_prtd->params, (dma_addr_t*) &capture_dmasrc, (dma_addr_t*) &capture_dmadst);
+		capture_res = capture_dmadst + capture_prtd->dma_period - capture_prtd->dma_start;
+		spin_unlock(&capture_prtd->lock);
+		if (capture_res >= snd_pcm_lib_buffer_bytes(substream)) {
+			if (capture_res == snd_pcm_lib_buffer_bytes(substream))
+				capture_res = 0;
+		}
+		return bytes_to_frames(substream->runtime, capture_res);
+	}
+}
+
+static int sunxi_codec_pcm_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)
+{
+	int play_ret = 0, capture_ret = 0;
+	struct snd_pcm_runtime *play_runtime = NULL, *capture_runtime = NULL;
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+	unsigned long play_totbytes = 0, capture_totbytes = 0;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		play_runtime = substream->runtime;
+		play_prtd = play_runtime->private_data;
+		play_totbytes = params_buffer_bytes(params);
+		snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+		if (play_prtd->params == NULL) {
+//JDS			play_prtd->params = &sunxi_codec_pcm_stereo_play;
+//JDS			play_ret = sunxi_dma_request(play_prtd->params, 0);
+			if (play_ret < 0) {
+				printk(KERN_ERR "failed to get dma channel. ret == %d\n", play_ret);
+				return play_ret;
+			}
+//JDS			play_ret = sunxi_dma_set_callback(play_prtd->params, sunxi_audio_play_buffdone, substream);
+			if (play_ret < 0) {
+				printk(KERN_ERR "failed to set dma callback. ret == %d\n", play_ret);
+//JDS				sunxi_dma_release(play_prtd->params);
+				play_prtd->params = NULL;
+				return play_ret;
+			}
+			snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+			play_runtime->dma_bytes = play_totbytes;
+			spin_lock_irq(&play_prtd->lock);
+			play_prtd->dma_loaded = 0;
+			play_prtd->dma_limit = play_runtime->hw.periods_min;
+			play_prtd->dma_period = params_period_bytes(params);
+			play_prtd->dma_start = play_runtime->dma_addr;
+
+			play_dmasrc = play_prtd->dma_start;
+			play_prtd->dma_pos = play_prtd->dma_start;
+			play_prtd->dma_end = play_prtd->dma_start + play_totbytes;
+
+			spin_unlock_irq(&play_prtd->lock);
+		}
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		capture_runtime = substream->runtime;
+		capture_prtd = capture_runtime->private_data;
+		capture_totbytes = params_buffer_bytes(params);
+		snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+		if (capture_prtd->params == NULL) {
+//JDS			capture_prtd->params = &sunxi_codec_pcm_stereo_capture;
+//JDS			capture_ret = sunxi_dma_request(capture_prtd->params, 0);
+			if (capture_ret < 0) {
+				printk(KERN_ERR "failed to get dma channel. capture_ret == %d\n", capture_ret);
+				return capture_ret;
+			}
+//JDS			capture_ret = sunxi_dma_set_callback(capture_prtd->params, sunxi_audio_capture_buffdone, substream);
+			if (capture_ret < 0) {
+				printk(KERN_ERR "failed to set dma callback. capture_ret == %d\n", capture_ret);
+//JDS				sunxi_dma_release(capture_prtd->params);
+				capture_prtd->params = NULL;
+				return capture_ret;
+			}
+			snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+			capture_runtime->dma_bytes = capture_totbytes;
+			spin_lock_irq(&capture_prtd->lock);
+			capture_prtd->dma_loaded = 0;
+			capture_prtd->dma_limit = capture_runtime->hw.periods_min;
+			capture_prtd->dma_period = params_period_bytes(params);
+			capture_prtd->dma_start = capture_runtime->dma_addr;
+
+			capture_dmadst = capture_prtd->dma_start;
+			capture_prtd->dma_pos = capture_prtd->dma_start;
+			capture_prtd->dma_end = capture_prtd->dma_start + capture_totbytes;
+
+			spin_unlock_irq(&capture_prtd->lock);
+		}
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int snd_sunxi_codec_hw_free(struct snd_pcm_substream *substream)
+{
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		play_prtd = substream->runtime->private_data;
+#ifdef JDS
+		if (play_prtd->params)
+			sunxi_dma_flush(play_prtd->params);
+		snd_pcm_set_runtime_buffer(substream, NULL);
+		if (play_prtd->params) {
+			sunxi_dma_stop(play_prtd->params);
+			sunxi_dma_release(play_prtd->params);
+			play_prtd->params = NULL;
+			/*
+			 * Clear out the DMA and any allocated buffers.
+			 */
+			snd_pcm_lib_free_pages(substream);
+		}
+#endif
+	} else {
+		capture_prtd = substream->runtime->private_data;
+#ifdef JDS		
+		if (capture_prtd->params)
+			sunxi_dma_flush(capture_prtd->params);
+		snd_pcm_set_runtime_buffer(substream, NULL);
+		if (capture_prtd->params) {
+			sunxi_dma_stop(capture_prtd->params);
+			sunxi_dma_release(capture_prtd->params);
+			capture_prtd->params = NULL;
+			/*
+			 * Clear out the DMA and any allocated buffers.
+			 */
+			snd_pcm_lib_free_pages(substream);
+		}
+#endif
+	}
+	return 0;
+}
+
+static int snd_sunxi_codec_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct card_data *priv = rtd->cpu_dai->dev->platform_data;
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	struct dma_hw_conf codec_play_dma_conf;
+	struct dma_hw_conf codec_capture_dma_conf;
+#else
+#ifdef JDS
+	dma_config_t codec_play_dma_conf;
+	dma_config_t codec_capture_dma_conf;
+#endif
+#endif
+
+	int play_ret = 0, capture_ret = 0;
+	unsigned int reg_val;
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		switch (substream->runtime->rate) {
+		case 44100:
+			clk_set_rate(codec_pll2clk, 22579200);
+			clk_set_rate(codec_moduleclk, 22579200);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (0 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+
+			break;
+		case 22050:
+			clk_set_rate(codec_pll2clk, 22579200);
+			clk_set_rate(codec_moduleclk, 22579200);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (2 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 11025:
+			clk_set_rate(codec_pll2clk, 22579200);
+			clk_set_rate(codec_moduleclk, 22579200);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (4 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 48000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (0 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 96000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (7 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 192000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (6 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 32000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (1 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 24000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (2 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 16000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (3 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 12000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (4 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 8000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (5 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		default:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (0 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		}
+
+		switch (substream->runtime->channels) {
+		case 1:
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val |= (1 << 6);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 2:
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(1 << 6);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		default:
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(1 << 6);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		}
+	} else {
+		switch (substream->runtime->rate) {
+		case 44100:
+			clk_set_rate(codec_pll2clk, 22579200);
+			clk_set_rate(codec_moduleclk, 22579200);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (0 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+
+			break;
+		case 22050:
+			clk_set_rate(codec_pll2clk, 22579200);
+			clk_set_rate(codec_moduleclk, 22579200);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (2 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 11025:
+			clk_set_rate(codec_pll2clk, 22579200);
+			clk_set_rate(codec_moduleclk, 22579200);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (4 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 48000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (0 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 32000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (1 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 24000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (2 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 16000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (3 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 12000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (4 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 8000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (5 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		default:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (0 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		}
+
+		switch (substream->runtime->channels) {
+		case 1:
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val |= (1 << 7);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 2:
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(1 << 7);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		default:
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(1 << 7);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		}
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		play_prtd = substream->runtime->private_data;
+		/* return if this is a bufferless transfer e.g.
+		 * codec <--> BT codec or GSM modem -- lg FIXME */
+		if (!play_prtd->params)
+			return 0;
+		//open the dac channel register
+		codec_play_open(substream);
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+
+		codec_play_dma_conf.drqsrc_type = D_DRQSRC_SDRAM;
+		codec_play_dma_conf.drqdst_type = DRQ_TYPE_AUDIO;
+		codec_play_dma_conf.xfer_type = DMAXFER_D_BHALF_S_BHALF;
+		codec_play_dma_conf.address_type = DMAADDRT_D_FIX_S_INC;
+		codec_play_dma_conf.dir = SW_DMA_WDEV;
+		codec_play_dma_conf.reload = 0;
+		codec_play_dma_conf.hf_irq = SW_DMA_IRQ_FULL;
+		codec_play_dma_conf.from = play_prtd->dma_start;
+		codec_play_dma_conf.to = play_prtd->params->dma_addr;
+#else
+#ifdef JDS
+		memset(&codec_play_dma_conf, 0, sizeof(codec_play_dma_conf));
+		codec_play_dma_conf.xfer_type.src_data_width = DATA_WIDTH_16BIT;
+		codec_play_dma_conf.xfer_type.src_bst_len = DATA_BRST_4;
+		codec_play_dma_conf.xfer_type.dst_data_width = DATA_WIDTH_16BIT;
+		codec_play_dma_conf.xfer_type.dst_bst_len = DATA_BRST_4;
+		codec_play_dma_conf.address_type.src_addr_mode = NDMA_ADDR_INCREMENT;
+		codec_play_dma_conf.address_type.dst_addr_mode = NDMA_ADDR_NOCHANGE;
+		codec_play_dma_conf.src_drq_type = N_SRC_SDRAM;
+		codec_play_dma_conf.dst_drq_type = N_DST_AUDIO_CODEC_DA;
+		codec_play_dma_conf.bconti_mode = false;
+		codec_play_dma_conf.irq_spt = CHAN_IRQ_FD;
+#endif
+#endif
+
+//JDS		play_ret = sunxi_dma_config(play_prtd->params, &codec_play_dma_conf, 0);
+		/* flush the DMA channel */
+		play_prtd->dma_loaded = 0;
+//JDS		if (sunxi_dma_flush(play_prtd->params) == 0)
+//JDS			play_prtd->dma_pos = play_prtd->dma_start;
+		/* enqueue dma buffers */
+		sunxi_pcm_enqueue(substream);
+		return play_ret;
+	} else {
+		capture_prtd = substream->runtime->private_data;
+		/* return if this is a bufferless transfer e.g.
+		 * codec <--> BT codec or GSM modem -- lg FIXME */
+		if (!capture_prtd->params)
+			return 0;
+		//open the adc channel register
+		codec_capture_open(priv);
+		//set the dma
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+
+		codec_capture_dma_conf.drqsrc_type = DRQ_TYPE_AUDIO;
+		codec_capture_dma_conf.drqdst_type = D_DRQSRC_SDRAM;
+		codec_capture_dma_conf.xfer_type = DMAXFER_D_BHALF_S_BHALF;
+		codec_capture_dma_conf.address_type = DMAADDRT_D_INC_S_FIX;
+		codec_capture_dma_conf.dir = SW_DMA_RDEV;
+		codec_capture_dma_conf.reload = 0;
+		codec_capture_dma_conf.hf_irq = SW_DMA_IRQ_FULL;
+		codec_capture_dma_conf.from = capture_prtd->params->dma_addr;
+		codec_capture_dma_conf.to = capture_prtd->dma_start;
+#else
+#ifdef JDS
+		memset(&codec_capture_dma_conf, 0, sizeof(codec_capture_dma_conf));
+		codec_capture_dma_conf.xfer_type.src_data_width = DATA_WIDTH_16BIT;
+		codec_capture_dma_conf.xfer_type.src_bst_len = DATA_BRST_4;
+		codec_capture_dma_conf.xfer_type.dst_data_width = DATA_WIDTH_16BIT;
+		codec_capture_dma_conf.xfer_type.dst_bst_len = DATA_BRST_4;
+		codec_capture_dma_conf.address_type.src_addr_mode = NDMA_ADDR_NOCHANGE;
+		codec_capture_dma_conf.address_type.dst_addr_mode = NDMA_ADDR_INCREMENT;
+		codec_capture_dma_conf.src_drq_type = N_SRC_AUDIO_CODEC_AD;
+		codec_capture_dma_conf.dst_drq_type = N_DST_SDRAM;
+		codec_capture_dma_conf.bconti_mode = false;
+		codec_capture_dma_conf.irq_spt = CHAN_IRQ_FD;
+#endif
+#endif
+
+//JDS		capture_ret = sunxi_dma_config(capture_prtd->params, &codec_capture_dma_conf, 0);
+		/* flush the DMA channel */
+		capture_prtd->dma_loaded = 0;
+//JDS		if (sunxi_dma_flush(capture_prtd->params) == 0)
+//JDS			capture_prtd->dma_pos = capture_prtd->dma_start;
+
+		/* enqueue dma buffers */
+		sunxi_pcm_enqueue(substream);
+		return capture_ret;
+	}
+}
+
+static int snd_sunxi_codec_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct card_data *priv = rtd->cpu_dai->dev->platform_data;
+	int play_ret = 0, capture_ret = 0;
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		play_prtd = substream->runtime->private_data;
+		spin_lock(&play_prtd->lock);
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			play_prtd->state |= ST_RUNNING;
+			codec_play_start();
+			sunxi_pcm_enqueue(substream);
+//JDS			sunxi_dma_start(play_prtd->params);
+			if (substream->runtime->rate >= 192000) {
+			} else if (substream->runtime->rate > 22050) {
+				mdelay(2);
+			} else {
+				mdelay(7);
+			}
+			//pa unmute
+			codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x1);
+			break;
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+			codec_play_stop();
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+			play_prtd->state &= ~ST_RUNNING;
+			codec_play_stop();
+//JDS			sunxi_dma_stop(play_prtd->params);
+			break;
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			play_prtd->state &= ~ST_RUNNING;
+//JDS			sunxi_dma_stop(play_prtd->params);
+			play_prtd->dma_loaded = 0;
+			break;
+		default:
+			printk("error:%s,%d\n", __func__, __LINE__);
+			play_ret = -EINVAL;
+			break;
+		}
+		spin_unlock(&play_prtd->lock);
+	} else {
+		capture_prtd = substream->runtime->private_data;
+		spin_lock(&capture_prtd->lock);
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			capture_prtd->state |= ST_RUNNING;
+			codec_capture_start();
+			mdelay(1);
+			codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_FIFO_FLUSH, 0x1);
+//JDS			sunxi_dma_start(capture_prtd->params);
+			break;
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+			codec_capture_stop(priv);
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+			capture_prtd->state &= ~ST_RUNNING;
+			codec_capture_stop(priv);
+//JDS			sunxi_dma_stop(capture_prtd->params);
+			break;
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			capture_prtd->state &= ~ST_RUNNING;
+//JDS			sunxi_dma_stop(capture_prtd->params);
+			break;
+		default:
+			printk("error:%s,%d\n", __func__, __LINE__);
+			capture_ret = -EINVAL;
+			break;
+		}
+		spin_unlock(&capture_prtd->lock);
+	}
+	return 0;
+}
+
+static int snd_sunxicard_capture_open(struct snd_pcm_substream *substream)
+{
+	/*获得PCM运行时信息指针*/
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err;
+	struct sunxi_capture_runtime_data *capture_prtd;
+
+	capture_prtd = kzalloc(sizeof(struct sunxi_capture_runtime_data), GFP_KERNEL);
+	if (capture_prtd == NULL)
+		return -ENOMEM;
+
+	spin_lock_init(&capture_prtd->lock);
+
+	runtime->private_data = capture_prtd;
+
+	runtime->hw = sunxi_pcm_capture_hardware;
+
+	/* ensure that buffer size is a multiple of period size */
+	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+	if ((err = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates)) < 0)
+		return err;
+
+	return 0;
+}
+
+static int snd_sunxicard_capture_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	kfree(runtime->private_data);
+	return 0;
+}
+
+static int snd_sunxicard_playback_open(struct snd_pcm_substream *substream)
+{
+	/*获得PCM运行时信息指针*/
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err;
+	struct sunxi_playback_runtime_data *play_prtd;
+
+	play_prtd = kzalloc(sizeof(struct sunxi_playback_runtime_data), GFP_KERNEL);
+	if (play_prtd == NULL)
+		return -ENOMEM;
+
+	spin_lock_init(&play_prtd->lock);
+
+	runtime->private_data = play_prtd;
+
+	runtime->hw = sunxi_pcm_playback_hardware;
+
+	/* ensure that buffer size is a multiple of period size */
+	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+	if ((err = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates)) < 0)
+		return err;
+
+	return 0;
+}
+
+static int snd_sunxicard_playback_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	kfree(runtime->private_data);
+	return 0;
+}
+
+static struct snd_pcm_ops sunxi_pcm_playback_ops =
+{
+	.open = snd_sunxicard_playback_open, //打开
+	.close = snd_sunxicard_playback_close,//关闭
+	.ioctl = snd_pcm_lib_ioctl,//I/O控制
+	.hw_params = sunxi_codec_pcm_hw_params,//硬件参数
+	.hw_free = snd_sunxi_codec_hw_free,//资源释放
+	.prepare = snd_sunxi_codec_prepare,//准备
+	.trigger = snd_sunxi_codec_trigger,//在pcm被开始、停止或暂停时调用
+	.pointer = snd_sunxi_codec_pointer,//当前缓冲区的硬件位置
+};
+
+static struct snd_pcm_ops sunxi_pcm_capture_ops =
+{
+	.open = snd_sunxicard_capture_open, //打开
+	.close = snd_sunxicard_capture_close,//关闭
+	.ioctl = snd_pcm_lib_ioctl,//I/O控制
+	.hw_params = sunxi_codec_pcm_hw_params,//硬件参数
+	.hw_free = snd_sunxi_codec_hw_free,//资源释放
+	.prepare = snd_sunxi_codec_prepare,//准备
+	.trigger = snd_sunxi_codec_trigger,//在pcm被开始、停止或暂停时调用
+	.pointer = snd_sunxi_codec_pointer,//当前缓冲区的硬件位置
+};
+
+static int snd_card_sunxi_codec_pcm(struct card_data *card_data, int device)
+{
+	struct snd_pcm *pcm;
+	int err;
+
+	/*创建PCM实例*/
+	err = snd_pcm_new(card_data->card, "M1 PCM", device,
+			has_playback, has_capture, &pcm);
+	if (err < 0) {
+		pr_err("snd_pcm_new M1 PCM failed: %d\n", err);
+		return err;
+	}
+
+	/*
+	 * this sets up our initial buffers and sets the dma_type to isa.
+	 * isa works but I'm not sure why (or if) it's the right choice
+	 * this may be too large, trying it for now
+	 */
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+			snd_dma_isa_data(),
+			32*1024, 32*1024);
+	/*
+	 *	设置PCM操作，第1个参数是snd_pcm的指针，第2 个参数是SNDRV_PCM_STREAM_PLAYBACK
+	 *	或SNDRV_ PCM_STREAM_CAPTURE，而第3 个参数是PCM 操作结构体snd_pcm_ops
+	 */
+	if (has_playback)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &sunxi_pcm_playback_ops);
+	if (has_capture)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &sunxi_pcm_capture_ops);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &sunxi_pcm_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &sunxi_pcm_capture_ops);
+	pcm->private_data = card_data; //置pcm->private_data为芯片特定数据
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "sunxi PCM");
+	/* setup DMA controller */
+
+	return 0;
+}
+
+void snd_sunxi_codec_free(struct snd_card *card)
+{
+}
+
+static void codec_resume_events(struct work_struct *work)
+{
+	printk("%s,%d\n", __func__, __LINE__);
+#ifdef JDS
+	if (sunxi_is_sun7i())
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	else
+		codec_wr_control(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x1);
+#endif
+	msleep(20);
+	//enable PA
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x1);
+	msleep(550);
+	//enable dac analog
+#ifdef JDS
+	if (sunxi_is_sun7i()) {
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x1);
+		codec_wr_control(SUNXI_ADC_ACTL, 0x1, 8, 0x0);
+	} else {
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x1);
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x1);
+
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x1);
+	}
+#endif
+	if (gpio_pa_shutdown) {
+		msleep(50);
+//JDS		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+	}
+}
+
+static const struct of_device_id snd_sunxi_codec_ids[] = {
+	{ .compatible = "allwinner,sun4i-a10a-codec", .data = (void *)SUN4A},
+	{ .compatible = "allwinner,sun4i-a10-codec", .data = (void *)SUN4I},
+	{ .compatible = "allwinner,sun5i-a13-codec", .data = (void *)SUN5I},
+	{ .compatible = "allwinner,sun7i-a20-codec", .data = (void *)SUN7I},
+	{}
+};
+MODULE_DEVICE_TABLE(of, snd_sunxi_codec_ids);
+
+static int sunxi_codec_probe(struct platform_device *pdev)
+{
+	struct dma_slave_config dma_sconfig;
+	struct snd_card *card;
+	struct card_data *priv;
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	const struct of_device_id *of_id;
+	int err;
+	int ret;
+
+	has_playback = 1; 
+	has_capture = 1;
+	
+	/* Clock */
+	codec_apbclk = devm_clk_get(dev, "apb");
+	if (IS_ERR(codec_apbclk)) {
+		dev_err(dev, "failed to get apb clock.\n");
+		return PTR_ERR(codec_apbclk);
+	}
+	codec_pll2clk = devm_clk_get(dev, "pll2");
+	if (IS_ERR(codec_pll2clk)) {
+		dev_err(dev, "failed to get pll2 clock.\n");
+		return PTR_ERR(codec_pll2clk);
+	}
+	codec_moduleclk = devm_clk_get(dev, "codec");
+	if (IS_ERR(codec_moduleclk)) {
+		dev_err(dev, "failed to get codec clock.\n");
+		return PTR_ERR(codec_moduleclk);
+	}
+	ret = clk_set_rate(codec_pll2clk, 24576000);
+	if (ret) {
+		dev_err(dev, "set codec base clock failed!\n");
+		return ret;
+	}
+	if (clk_prepare_enable(codec_pll2clk)) {
+		dev_err(dev, "try to enable codec_pll2clk failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(codec_apbclk)) {
+		dev_err(dev, "try to enable apb_codec_clk failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(codec_moduleclk)) {
+		dev_err(dev, "try to enable codec failed\n");
+		ret = -EINVAL;
+		goto exit_clkdisable_apb_clk;
+	}
+	
+	ret = snd_card_create(0, "sunxi-codec", THIS_MODULE, sizeof(struct card_data),
+			      &card);
+	if (ret != 0) {
+		return -ENOMEM;
+	}
+	/*从private_data中取出分配的内存大小*/
+	priv = card->private_data;
+	/*声卡芯片的专用数据*/
+	card->private_free = snd_sunxi_codec_free; //card私有数据释放
+	
+	of_id = of_match_device(snd_sunxi_codec_ids, &pdev->dev);
+	priv->id = (int)of_id->data;
+	
+	priv->card = card;
+	priv->samplerate = AUDIO_RATE_DEFAULT;
+
+	/* IO */
+	priv->codec_base_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->dev = &pdev->dev;
+
+	if (priv->codec_base_res == NULL) {
+		ret = -ENOENT;
+		printk("codec insufficient resources\n");
+		goto out;
+	}
+	/* codec address remap */
+	priv->codec_base_req = request_mem_region(priv->codec_base_res->start, 0x40, pdev->name);
+	if (priv->codec_base_req == NULL) {
+		ret = -EIO;
+		printk("cannot claim codec address reg area\n");
+		goto out;
+	}
+	baseaddr = ioremap(priv->codec_base_res->start, 0x40);
+
+	if (baseaddr == NULL) {
+		ret = -EINVAL;
+		dev_err(priv->dev,"failed to ioremap codec address reg\n");
+		goto out;
+	}
+#ifdef JDS
+printk("jds - widgets");
+	/* off-codec widgets */
+	if (of_property_read_bool(np, "widgets")) {
+		ret = snd_soc_of_parse_audio_simple_widgets(&priv->snd_card, "widgets");
+		if (ret)
+			return ret;
+	}
+
+printk("jds - routes");
+	/* DAPM routes */
+	if (of_property_read_bool(np, "routing")) {
+		ret = snd_soc_of_parse_audio_routing(&priv->snd_card, "routing");
+		if (ret)
+			return ret;
+	}
+#endif
+	
+	priv->tx_dma_chan = dma_request_slave_channel_reason(&pdev->dev, "tx");
+	if (IS_ERR(priv->tx_dma_chan)) {
+		dev_err(priv->dev, "Unable to acquire DMA channel TX\n");
+		ret = PTR_ERR(priv->tx_dma_chan);
+		goto err_free_master;
+	}
+
+	dma_sconfig.direction = DMA_MEM_TO_DEV;
+	dma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	dma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	dma_sconfig.dst_addr = priv->codec_base_res->start + SUNXI_DAC_TXDATA;
+	dma_sconfig.src_maxburst = 1;
+	dma_sconfig.dst_maxburst = 1;
+
+	ret = dmaengine_slave_config(priv->tx_dma_chan, &dma_sconfig);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to configure TX DMA slave\n");
+		goto err_tx_dma_release;
+	}
+
+	priv->rx_dma_chan = dma_request_slave_channel_reason(&pdev->dev, "rx");
+	if (IS_ERR(priv->rx_dma_chan)) {
+		dev_err(&pdev->dev, "Unable to acquire DMA channel RX\n");
+		ret = PTR_ERR(priv->rx_dma_chan);
+		goto err_tx_dma_release;
+	}
+
+	dma_sconfig.direction = DMA_DEV_TO_MEM;
+	dma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	dma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	dma_sconfig.src_addr = priv->codec_base_res->start + SUNXI_ADC_RXDATA;
+	dma_sconfig.src_maxburst = 1;
+	dma_sconfig.dst_maxburst = 1;
+
+	ret = dmaengine_slave_config(priv->rx_dma_chan, &dma_sconfig);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to configure RX DMA slave\n");
+		goto err_rx_dma_release;
+	}
+
+	/*
+	 *	mixer,注册control(mixer)接口
+	 *	创建一个control至少要实现snd_kcontrol_new中的info(),get()和put()这三个成员函数
+	 */
+	if ((err = snd_chip_codec_mixer_new(priv)))
+		goto nodev;
+
+	/*
+	 *	PCM,录音放音相关，注册PCM接口
+	 */
+	if ((err = snd_card_sunxi_codec_pcm(priv, 0)) < 0)
+		goto nodev;
+
+	strcpy(card->driver, "sunxi-CODEC");
+	strcpy(card->shortname, "sunxi-CODEC");
+	sprintf(card->longname, "sunxi-CODEC  Audio Codec");
+
+	snd_card_set_dev(card, &pdev->dev);
+
+	//注册card
+	if ((err = snd_card_register(card)) == 0) {
+		platform_set_drvdata(pdev, card);
+	} else {
+		return err;
+	}
+
+#ifdef JDS
+	gpio_pa_shutdown = gpio_request_ex("audio_para", "audio_pa_ctrl");
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+#endif
+	codec_init(priv);
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+#endif
+	resume_work_queue = create_singlethread_workqueue("codec_resume");
+	if (resume_work_queue == NULL) {
+		printk("[su4i-codec] try to create workqueue for codec failed!\n");
+		ret = -ENOMEM;
+		goto err_resume_work_queue;
+	}
+	printk("jds - codec ok, %s\n", of_id->compatible);
+	return 0;
+	
+err_rx_dma_release:
+err_free_master:
+err_tx_dma_release:
+err_resume_work_queue:
+out:
+	dev_err(priv->dev, "not found (%d).\n", ret);
+exit_clkdisable_clk:
+	clk_disable_unprepare(codec_moduleclk);
+exit_clkdisable_apb_clk:
+	clk_disable_unprepare(codec_apbclk);
+
+nodev:
+	snd_card_free(card);
+	return err;
+}
+
+/*	suspend state,先disable左右声道，然后静音，再disable pa(放大器)，
+ *	disable 耳机，disable dac->pa，最后disable DAC
+ * 	顺序不可调，否则刚关闭声卡的时候可能出现噪音
+ */
+static int snd_sunxi_codec_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	printk("[audio codec]:suspend start5000\n");
+	if (gpio_pa_shutdown) {
+//JDS		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+		mdelay(50);
+	}
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x0);
+	mdelay(100);
+	//pa mute
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	mdelay(500);
+	//disable dac analog
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x0);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x0);
+
+	//disable dac to pa
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x0);
+	codec_wr_control(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x0);
+
+	clk_disable(codec_moduleclk);
+	printk("[audio codec]:suspend end\n");
+	return 0;
+}
+
+/*	resume state,先unmute，
+ *	再enable DAC，enable L/R DAC,enable PA，
+ * 	enable 耳机，enable dac to pa
+ *	顺序不可调，否则刚打开声卡的时候可能出现噪音
+ */
+static int snd_sunxi_codec_resume(struct platform_device *pdev)
+{
+	printk("[audio codec]:resume start\n");
+	if (-1 == clk_enable(codec_moduleclk)) {
+		printk("open codec_moduleclk failed; \n");
+	}
+
+	queue_work(resume_work_queue, &codec_resume_work);
+	printk("[audio codec]:resume end\n");
+	return 0;
+}
+
+static int sunxi_codec_remove(struct platform_device *devptr)
+{
+	clk_disable(codec_moduleclk);
+	//释放codec_pll2clk时钟句柄
+	clk_put(codec_pll2clk);
+	//释放codec_apbclk时钟句柄
+	clk_put(codec_apbclk);
+
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+	return 0;
+}
+
+static void sunxi_codec_shutdown(struct platform_device *devptr)
+{
+	if (gpio_pa_shutdown) {
+//JDS		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+		mdelay(50);
+	}
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x0);
+	mdelay(100);
+	//pa mute
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	mdelay(500);
+	//disable dac analog
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x0);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x0);
+
+	//disable dac to pa
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x0);
+	codec_wr_control(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x0);
+
+	clk_disable(codec_moduleclk);
+}
+
+/*method relating*/
+static struct platform_driver sunxi_codec_driver =
+{
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_remove,
+	.shutdown = sunxi_codec_shutdown,
+#ifdef CONFIG_PM
+	.suspend = snd_sunxi_codec_suspend,
+	.resume = snd_sunxi_codec_resume,
+#endif
+	.driver = {
+		.name = "sunxi-codec",
+		.of_match_table = snd_sunxi_codec_ids,
+	},
+};
+
+module_platform_driver(sunxi_codec_driver);
+
+MODULE_ALIAS("platform:sunxi-codec-dai");
+MODULE_DESCRIPTION("sunxi CODEC ALSA codec driver");
+MODULE_AUTHOR("software");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/sunxi/sunxi-codec.h b/sound/soc/sunxi/sunxi-codec.h
new file mode 100644
index 0000000..7974b27
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-codec.h
@@ -0,0 +1,167 @@
+/*
+ * sound/soc/sunxi/sunxi-codec.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef _SUNXI_CODEC_H
+#define _SUNXI_CODEC_H
+
+//Codec Register
+#define CODEC_BASSADDRESS         (0x01c22c00)
+#define SUNXI_DAC_DPC                (0x00)
+#define SUNXI_DAC_FIFOC              (0x04)
+#define SUNXI_DAC_FIFOS              (0x08)
+#define SUNXI_DAC_TXDATA             (0x0c)
+#define SUNXI_DAC_ACTL               (0x10)
+#define SUNXI_DAC_TUNE               (0x14)
+#define SUNXI_DAC_DEBUG              (0x18)
+#define SUNXI_ADC_FIFOC              (0x1c)
+#define SUNXI_ADC_FIFOS              (0x20)
+#define SUNXI_ADC_RXDATA             (0x24)
+#define SUNXI_ADC_ACTL               (0x28)
+#define SUNXI_ADC_DEBUG              (0x2c)
+#define SUNXI_DAC_TXCNT              (0x30)
+#define SUNXI_ADC_RXCNT              (0x34)
+#define SUNXI_BIAS_CRT               (0x38)
+#define SUNXI_MIC_CRT                (0x3c)
+#define SUNXI_CODEC_REGS_NUM         (13)
+
+#define DAIFMT_16BITS             (16)
+#define DAIFMT_20BITS             (20)
+
+#define DAIFMT_BS_MASK            (~(1<<16))  	//FIFO big small mode mask
+#define DAIFMT_BITS_MASK          (~(1<<5))		//FIFO Bits select mask,not used yet.
+#define SAMPLE_RATE_MASK          (~(7<<29))  	//Sample Rate slect mask
+
+#define DAC_EN                    (31)
+#define DIGITAL_VOL               (12)
+//For CODEC OLD VERSION
+#define DAC_VERSION               (23)
+
+#define DAC_CHANNEL		  (6)
+#define LAST_SE                   (26)
+#define TX_FIFO_MODE              (24)
+#define DRA_LEVEL                 (21)
+#define TX_TRI_LEVEL              (8)
+#define DAC_MODE                  (6)			//not used yet
+#define TASR                      (5)			//not used yet
+#define DAC_DRQ                   (4)
+#define DAC_FIFO_FLUSH            (0)
+
+#define VOLUME                    (0)
+#define PA_MUTE                   (6)
+#define MIXPAS                    (7)
+#define DACPAS                    (8)
+#define MIXEN                     (29)
+#define DACAEN_L                  (30)
+#define DACAEN_R                  (31)
+
+#define ADC_DIG_EN                (28)
+#define RX_FIFO_MODE              (24)
+#define RX_TRI_LEVEL              (8)
+#define ADC_MODE                  (7)
+#define RASR                      (6)
+#define ADC_DRQ                   (4)
+#define ADC_FIFO_FLUSH            (0)
+
+#define  ADC_LF_EN                (31)
+#define  ADC_RI_EN                (30)
+#define  ADC_EN                   (30)
+#define  MIC1_EN                  (29)
+#define  MIC2_EN                  (28)
+#define  VMIC_EN                  (27)
+#define  MIC_GAIN                 (25)
+#define  ADC_SELECT               (17)
+#define  PA_ENABLE                (4)
+#define  HP_DIRECT                (3)
+
+enum m1_codec_config {
+	CMD_MIC_SEL =0,
+	CMD_ADC_SEL,
+};
+
+#define AUDIO_RATE_DEFAULT	44100
+#define ST_RUNNING		(1<<0)
+#define ST_OPENED		(1<<1)
+
+extern void  __iomem *baseaddr;
+#define codec_rdreg(reg)	    readl((baseaddr+(reg)))
+#define codec_wrreg(reg,val)  writel((val),(baseaddr+(reg)))
+
+/*
+* Convenience kcontrol builders
+*/
+#define CODEC_SINGLE_VALUE(xreg, xshift, xmax,	xinvert)\
+		((unsigned long)&(struct codec_mixer_control)\
+		{.reg	=	xreg,	.shift	=	xshift,	.rshift	=	xshift,	.max	=	xmax,\
+   	.invert	=	xinvert})
+
+#define CODEC_SINGLE(xname,	reg,	shift,	max,	invert)\
+{	.iface	= SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\
+	.info	= snd_codec_info_volsw,	.get = snd_codec_get_volsw,\
+	.put	= snd_codec_put_volsw,\
+	.private_value	= CODEC_SINGLE_VALUE(reg, shift, max, invert)}
+
+/*	mixer control*/
+struct	codec_mixer_control{
+	int	min;
+	int     max;
+	int     where;
+	unsigned int mask;
+	unsigned int reg;
+	unsigned int rreg;
+	unsigned int shift;
+	unsigned int rshift;
+	unsigned int invert;
+	unsigned int value;
+};
+
+struct sunxi_codec_dma_params {
+	unsigned int data_size;
+	dma_addr_t tx_rx_addr;
+//JDS	struct stedma40_chan_cfg *dma_cfg;
+};
+
+enum sunxi_device_id {SUN4A, SUN4I, SUN5I, SUN7I}; 
+
+extern int devm_sunxi_pcm_platform_register(struct platform_device *pdev);
+
+struct sunxi_params {
+	u32 rate;
+	u32 core_freq;
+	u32 mute;
+};
+
+/* Structure/enum declaration ------------------------------- */
+struct card_data {
+	struct regmap *regmap;
+	struct sunxi_params saved_params;
+	enum sunxi_device_id id;
+	struct dma_chan		*rx_dma_chan;
+	struct dma_chan		*tx_dma_chan;
+	int irq;
+	unsigned int codec_phys;
+	void  __iomem *baseaddr;
+	struct clk *codec_apbclk, *codec_pll2clk, *codec_moduleclk;
+	u32 running;
+};
+
+#endif
diff --git a/sound/soc/sunxi/sunxi_codec_main.c b/sound/soc/sunxi/sunxi_codec_main.c
new file mode 100644
index 0000000..5143b42
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_codec_main.c
@@ -0,0 +1,752 @@
+/*
+ * ALSA SoC codec Out Audio Layer for spear processors
+ *
+ * Copyright (C) 2012 ST Microelectronics
+ * Vipin Kumar <vipin.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/regmap.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include "sunxi-codec.h"
+
+static void codec_resume_events(struct work_struct *work);
+struct workqueue_struct *resume_work_queue;
+static DECLARE_WORK(codec_resume_work, codec_resume_events);
+
+static void sunxi_configure(struct card_data *priv)
+{
+#ifdef JDS
+	writel(sunxi_RESET, priv->io_base + sunxi_SOFT_RST);
+	mdelay(1);
+	writel(readl(priv->io_base + sunxi_SOFT_RST) & ~sunxi_RESET,
+			priv->io_base + sunxi_SOFT_RST);
+
+	writel(sunxi_FDMA_TRIG_16 | sunxi_MEMFMT_16_16 |
+			sunxi_VALID_HW | sunxi_USER_HW |
+			sunxi_CHNLSTA_HW | sunxi_PARITY_HW,
+			priv->io_base + sunxi_CFG);
+
+	writel(0x7F, priv->io_base + sunxi_INT_STA_CLR);
+	writel(0x7F, priv->io_base + sunxi_INT_EN_CLR);
+#endif 
+}
+
+static int sunxi_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *cpu_dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	ret = clk_enable(priv->codec_moduleclk);
+	if (ret)
+		return ret;
+
+	priv->running = true;
+	sunxi_configure(priv);
+
+	return 0;
+}
+
+static void sunxi_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return;
+
+	clk_disable(priv->codec_moduleclk);
+	priv->running = false;
+}
+
+static void sunxi_clock(struct card_data *priv, u32 core_freq,
+		u32 rate)
+{
+#ifdef JDS
+	u32 divider, ctrl;
+	clk_set_rate(priv->clk, core_freq);
+	divider = DIV_ROUND_CLOSEST(clk_get_rate(priv->clk), (rate * 128));
+
+	ctrl = readl(priv->io_base + sunxi_CTRL);
+	ctrl &= ~codec_DIVIDER_MASK;
+	ctrl |= (divider << codec_DIVIDER_SHIFT) & codec_DIVIDER_MASK;
+	writel(ctrl, priv->io_base + sunxi_CTRL);
+#endif
+}
+
+static int sunxi_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params,
+		struct snd_soc_dai *dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	u32 rate, core_freq;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	rate = params_rate(params);
+
+	switch (rate) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64000:
+		/*
+		 * The clock is multiplied by 10 to bring it to feasible range
+		 * of frequencies for sscg
+		 */
+		core_freq = 64000 * 128 * 10;	/* 81.92 MHz */
+		break;
+	case 5512:
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		core_freq = 176400 * 128;	/* 22.5792 MHz */
+		break;
+	case 48000:
+	case 96000:
+	case 192000:
+	default:
+		core_freq = 192000 * 128;	/* 24.576 MHz */
+		break;
+	}
+
+	sunxi_clock(priv, core_freq, rate);
+	priv->saved_params.core_freq = core_freq;
+	priv->saved_params.rate = rate;
+
+	return 0;
+}
+
+static int sunxi_trigger(struct snd_pcm_substream *substream, int cmd,
+		struct snd_soc_dai *dai)
+{
+#ifdef JDS
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	u32 ctrl;
+#endif
+	int ret = 0;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+#ifdef JDS		
+			ctrl = readl(priv->io_base + sunxi_CTRL);
+			ctrl &= ~codec_OPMODE_MASK;
+			if (!priv->saved_params.mute)
+				ctrl |= codec_OPMODE_AUD_DATA |
+					codec_STATE_NORMAL;
+			else
+				ctrl |= codec_OPMODE_MUTE_PCM;
+			writel(ctrl, priv->io_base + sunxi_CTRL);
+#endif
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+#ifdef JDS		
+		ctrl = readl(priv->io_base + sunxi_CTRL);
+		ctrl &= ~codec_OPMODE_MASK;
+		ctrl |= codec_OPMODE_OFF;
+		writel(ctrl, priv->io_base + sunxi_CTRL);
+#endif
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sunxi_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+#ifdef JDS
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	u32 val;
+
+	priv->saved_params.mute = mute;
+	val = readl(priv->io_base + sunxi_CTRL);
+	val &= ~codec_OPMODE_MASK;
+
+	if (mute)
+		val |= codec_OPMODE_MUTE_PCM;
+	else {
+		if (priv->running)
+			val |= codec_OPMODE_AUD_DATA | codec_STATE_NORMAL;
+		else
+			val |= codec_OPMODE_OFF;
+	}
+
+	writel(val, priv->io_base + sunxi_CTRL);
+#endif
+	return 0;
+}
+
+static int codec_mute_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	ucontrol->value.integer.value[0] = priv->saved_params.mute;
+	return 0;
+}
+
+static int codec_mute_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	if (priv->saved_params.mute == ucontrol->value.integer.value[0])
+		return 0;
+
+	sunxi_digital_mute(cpu_dai, ucontrol->value.integer.value[0]);
+
+	return 1;
+}
+
+#ifdef JDS
+static void codec_resume_events(struct work_struct *work)
+{
+	printk("%s,%d\n", __func__, __LINE__);
+
+	if (priv->id == SUN7I) {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	else
+		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1, DAC_EN, 0x1);
+
+	msleep(20);
+	//enable PA
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x1);
+	msleep(550);
+	//enable dac analog
+
+	if (priv->id == SUN7I) {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x1);
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1, 8, 0x0);
+	} else {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x1);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x1);
+
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACPAS, 0x1);
+	}
+	if (gpio_pa_shutdown) {
+		msleep(50);
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+	}
+}
+#endif
+
+
+
+/**
+ *	codec_reset - reset the codec
+ * @codec	SoC Audio Codec
+ * Reset the codec, set the register of codec default value
+ * Return 0 for success
+ */
+static int codec_init(struct card_data *priv)
+{
+	//enable dac digital
+	regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1 << DAC_EN, 0x1 << DAC_EN);
+
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << 28, 0x1 << 28);
+	//set digital volume to maximum
+	if (priv->id == SUN4A)
+		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x6 << DIGITAL_VOL, 0x0 << DIGITAL_VOL);
+
+	//pa mute
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
+	//enable PA
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << PA_ENABLE, 0x1 << PA_ENABLE);
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x3 << DRA_LEVEL, 0x3 << DRA_LEVEL);
+	//set volume
+	if ((priv->id == SUN4A) || (priv->id == SUN4I)) {
+		int device_lr_change = 0;
+		if (priv->id == SUN4A)
+			regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x01 << VOLUME);
+		else 
+			regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x3b << VOLUME);
+#ifdef JDS
+		rc = script_parser_fetch("audio_para", "audio_lr_change", &device_lr_change, 1);
+		if (rc != SCRIPT_AUDIO_OK) {
+			pr_err("No audio_lr_change in fex audio_para\n");
+			return -1;
+		}
+#endif
+		if (device_lr_change)
+			regmap_update_bits(priv->regmap, SUNXI_DAC_DEBUG, 0x1 << DAC_CHANNEL, 0x1 << DAC_CHANNEL);
+	} else {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x3b << VOLUME);
+	}
+	return 0;
+}
+
+
+/*	对sunxi-codec.c各寄存器的各种设定，或读取。主要实现函数有三个.
+ * 	.info = snd_codec_info_volsw, .get = snd_codec_get_volsw,\.put = snd_codec_put_volsw,
+ * It should be noted that the only difference between sunxi and sun5i is the Master Playback Volume
+ */
+static const struct snd_kcontrol_new sun4i_dac[] = {
+	//FOR B C VERSION
+	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
+	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	SOC_SINGLE("Fm Volume", SUNXI_DAC_ACTL, 23, 7, 0), //Fm 音量
+	SOC_SINGLE("Line Volume", SUNXI_DAC_ACTL, 26, 1, 0), //Line音量
+	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
+	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+};
+
+static const struct snd_kcontrol_new sun4a_dac[] = {
+	//For A VERSION
+	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_DPC, 12, 0x3f, 0), //62 steps, 3e + 1 = 3f 主音量控制
+	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	SOC_SINGLE("Fm Volume", SUNXI_DAC_ACTL, 23, 7, 0), //Fm 音量
+	SOC_SINGLE("Line Volume", SUNXI_DAC_ACTL, 26, 1, 0), //Line音量
+	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
+	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+};
+
+static const struct snd_kcontrol_new sunxi_adc_controls[] = { 
+	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
+	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
+	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0),
+	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0), //录音音量
+	SOC_SINGLE("Line Capture Volume", SUNXI_ADC_ACTL, 13, 7, 0), 
+	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
+	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
+	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
+	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
+	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
+	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
+};
+
+static const struct snd_kcontrol_new sun7i_dac_ctls[] = {
+	/*SUNXI_DAC_ACTL = 0x10,PAVOL*/
+	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
+	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0), 
+	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+	SOC_SINGLE("MIC output volume", SUNXI_DAC_ACTL, 20, 7, 0),
+	/*	FM Input to output mixer Gain Control
+	* 	From -4.5db to 6db,1.5db/step,default is 0db
+	*	-4.5db:0x0,-3.0db:0x1,-1.5db:0x2,0db:0x3
+	*	1.5db:0x4,3.0db:0x5,4.5db:0x6,6db:0x7
+	*/
+	SOC_SINGLE("Fm output Volume", SUNXI_DAC_ACTL, 23, 7, 0),
+	/*	Line-in gain stage to output mixer Gain Control
+	*	0:-1.5db,1:0db
+	*/
+	SOC_SINGLE("Line output Volume", SUNXI_DAC_ACTL, 26, 1, 0),
+};
+
+static const struct snd_kcontrol_new sun7i_adc_ctls[] = { 
+	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
+	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
+	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0), 
+	SOC_SINGLE("Linein Pre-AMP", SUNXI_ADC_ACTL, 13, 7, 0), 
+	SOC_SINGLE("LINEIN APM Volume", SUNXI_MIC_CRT, 13, 0x7, 0),
+	/* ADC Input Gain Control, capture volume
+	* 000:-4.5db,001:-3db,010:-1.5db,011:0db,100:1.5db,101:3db,110:4.5db,111:6db
+	*/
+	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0),
+	/*
+	*	MIC2 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
+	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
+	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
+	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
+	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
+	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
+	SOC_SINGLE("Mic2 gain Volume", SUNXI_MIC_CRT, 26, 7, 0),
+	/*
+	*	MIC1 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	SOC_SINGLE("Mic1 gain Volume", SUNXI_MIC_CRT, 29, 3, 0), 
+};
+
+
+
+static int sunxi_soc_dai_probe(struct snd_soc_dai *dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	struct snd_dmaengine_dai_dma_data *playback_dma_data;
+	struct snd_dmaengine_dai_dma_data *capture_dma_data;
+
+	playback_dma_data = devm_kzalloc(dai->dev,
+					 sizeof(*playback_dma_data),
+					 GFP_KERNEL);
+	if (!playback_dma_data)
+		return -ENOMEM;
+
+	capture_dma_data = devm_kzalloc(dai->dev,
+					sizeof(*capture_dma_data),
+					GFP_KERNEL);
+	if (!capture_dma_data)
+		return -ENOMEM;
+
+	playback_dma_data->addr = priv->codec_phys + SUNXI_DAC_TXDATA;
+	capture_dma_data->addr = priv->codec_phys + SUNXI_ADC_RXDATA;
+
+	playback_dma_data->maxburst = 4;
+	capture_dma_data->maxburst = 4;
+
+	playback_dma_data->addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	playback_dma_data->addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	snd_soc_dai_init_dma_data(dai, playback_dma_data, capture_dma_data);
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_dai_ops = {
+	.digital_mute	= sunxi_digital_mute,
+	.startup	= sunxi_startup,
+	.shutdown	= sunxi_shutdown,
+	.trigger	= sunxi_trigger,
+	.hw_params	= sunxi_hw_params,
+};
+
+static struct snd_soc_dai_driver sunxi_dai = {
+	.name		= "cat",
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+				 SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | \
+				 SNDRV_PCM_RATE_192000),
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.probe = sunxi_soc_dai_probe,
+	.ops = &sunxi_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_component = {
+	.name		= "horse",
+};
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S20_3LE | \
+			SNDRV_PCM_FMTBIT_S24_LE)
+
+unsigned int read(struct snd_soc_codec *codec, unsigned int reg);
+int write(struct snd_soc_codec *, unsigned int reg, unsigned int);
+
+
+static struct snd_soc_codec_driver soc_codec_sun4a_codec = {
+	.controls = sun4a_dac,
+	.num_controls = ARRAY_SIZE(sun4a_dac),
+};
+
+static struct snd_soc_codec_driver soc_codec_sun4i_codec = {
+	.controls = sun4i_dac,
+	.num_controls = ARRAY_SIZE(sun4i_dac),
+};
+
+static struct snd_soc_codec_driver soc_codec_sun7i_codec = {
+	.controls = sun7i_dac_ctls,
+	.num_controls = ARRAY_SIZE(sun7i_dac_ctls),
+};
+
+static struct snd_soc_dai_driver dit_stub_dai = {
+	.name		= "dog",
+	.playback 	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 384,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+};
+
+static const struct regmap_config sunxi_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_MIC_CRT,
+};
+
+static const struct of_device_id snd_sunxi_codec_ids[] = {
+	{ .compatible = "allwinner,sun4i-a10a-codec", .data = (void *)SUN4A},
+	{ .compatible = "allwinner,sun4i-a10-codec", .data = (void *)SUN4I},
+	{ .compatible = "allwinner,sun5i-a13-codec", .data = (void *)SUN5I},
+	{ .compatible = "allwinner,sun7i-a20-codec", .data = (void *)SUN7I},
+	{}
+};
+MODULE_DEVICE_TABLE(of, snd_sunxi_codec_ids);
+
+static int sunxi_codec_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct card_data *priv;
+	struct resource res;
+	int ret;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	of_id = of_match_device(snd_sunxi_codec_ids, &pdev->dev);
+	if (!of_id)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "could not allocate DAI object\n");
+		return -ENOMEM;
+	}
+	
+	priv->id = (int)of_id->data;
+
+	/* Get the addresses and IRQ */
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		dev_err(&pdev->dev, "could not determine device resources\n");
+		return ret;
+	}
+	priv->baseaddr = of_iomap(np, 0);
+	if (!priv->baseaddr) {
+		dev_err(&pdev->dev, "could not map device resources\n");
+		return -ENOMEM;
+	}
+	priv->codec_phys = res.start;
+
+	priv->regmap = devm_regmap_init_mmio(&pdev->dev, priv->baseaddr, &sunxi_regmap_config);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	priv->irq = irq_of_parse_and_map(np, 0);
+	if (!priv->irq) {
+		dev_err(&pdev->dev, "no irq for node %s\n", np->full_name);
+		return -ENXIO;
+	}
+
+	/* Clock */
+	priv->codec_apbclk = devm_clk_get(dev, "apb");
+	if (IS_ERR(priv->codec_apbclk)) {
+		dev_err(dev, "failed to get apb clock.\n");
+		return PTR_ERR(priv->codec_apbclk);
+	}
+	priv->codec_pll2clk = devm_clk_get(dev, "pll2");
+	if (IS_ERR(priv->codec_pll2clk)) {
+		dev_err(dev, "failed to get pll2 clock.\n");
+		return PTR_ERR(priv->codec_pll2clk);
+	}
+	priv->codec_moduleclk = devm_clk_get(dev, "codec");
+	if (IS_ERR(priv->codec_moduleclk)) {
+		dev_err(dev, "failed to get codec clock.\n");
+		return PTR_ERR(priv->codec_moduleclk);
+	}
+	ret = clk_set_rate(priv->codec_pll2clk, 24576000);
+	if (ret) {
+		dev_err(dev, "set codec base clock failed!\n");
+		return ret;
+	}
+	if (clk_prepare_enable(priv->codec_pll2clk)) {
+		dev_err(dev, "try to enable codec_pll2clk failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(priv->codec_apbclk)) {
+		dev_err(dev, "try to enable apb_codec_clk failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(priv->codec_moduleclk)) {
+		dev_err(dev, "try to enable codec failed\n");
+		ret = -EINVAL;
+		goto exit_clkdisable_apb_clk;
+	}
+	dev_set_drvdata(&pdev->dev, priv);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_component, &sunxi_dai, 1);
+	if (ret)
+		return ret;
+
+	switch (priv->id) {
+	case SUN4A:
+		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun4a_codec, &dit_stub_dai, 1);
+	case SUN4I:
+	case SUN5I:
+		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun4i_codec, &dit_stub_dai, 1);
+	case SUN7I:
+		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun7i_codec, &dit_stub_dai, 1);
+	}
+	if (ret)
+		return ret;
+
+	snd_dmaengine_pcm_register(&pdev->dev, NULL, SND_DMAENGINE_PCM_FLAG_NO_RESIDUE);
+
+	codec_init(priv);
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+
+	resume_work_queue = create_singlethread_workqueue("codec_resume");
+	if (resume_work_queue == NULL) {
+		printk("[su4i-codec] try to create workqueue for codec failed!\n");
+		ret = -ENOMEM;
+		goto err_resume_work_queue;
+	}
+#endif
+	printk("JDS - codec driver success registered\n");
+	return ret;
+
+err_resume_work_queue:
+exit_clkdisable_apb_clk:
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int snd_sunxi_codec_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct card_data *priv = dev_get_drvdata(&pdev->dev);
+
+	if (priv->running)
+		clk_disable(priv->codec_moduleclk);
+
+	return 0;
+}
+
+static int snd_sunxi_codec_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct card_data *priv = dev_get_drvdata(&pdev->dev);
+
+	if (priv->running) {
+		clk_enable(priv->codec_moduleclk);
+		sunxi_configure(priv);
+		sunxi_clock(priv, priv->saved_params.core_freq,
+				priv->saved_params.rate);
+	}
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(sunxi_dev_pm_ops, snd_sunxi_codec_suspend, \
+		snd_sunxi_codec_resume);
+
+#define sunxi_DEV_PM_OPS (&sunxi_dev_pm_ops)
+
+#else
+#define sunxi_DEV_PM_OPS NULL
+
+#endif
+
+static int sunxi_codec_remove(struct platform_device *pdev)
+{
+#ifdef JDS
+	clk_disable(codec_moduleclk);
+	//释放codec_pll2clk时钟句柄
+	clk_put(codec_pll2clk);
+	//释放codec_apbclk时钟句柄
+	clk_put(codec_apbclk);
+
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+#endif
+	return 0;
+	snd_dmaengine_pcm_unregister(&pdev->dev);
+}
+
+static void sunxi_codec_shutdown(struct platform_device *devptr)
+{
+#ifdef JDS
+	if (gpio_pa_shutdown) {
+//JDS		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+		mdelay(50);
+	}
+	regmap_update_bits(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x0);
+	mdelay(100);
+	//pa mute
+	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	mdelay(500);
+	//disable dac analog
+	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x0);
+	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x0);
+
+	//disable dac to pa
+	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x0);
+	regmap_update_bits(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x0);
+
+	clk_disable(codec_moduleclk);
+#endif
+}
+
+/*method relating*/
+static struct platform_driver sunxi_codec_driver =
+{
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_remove,
+	.shutdown = sunxi_codec_shutdown,
+#ifdef CONFIG_PM
+//JDS	.suspend = snd_sunxi_codec_suspend,
+//JDS	.resume = snd_sunxi_codec_resume,
+#endif
+	.driver = {
+		.name = "sunxi-codec",
+		.of_match_table = snd_sunxi_codec_ids,
+	},
+};
+
+module_platform_driver(sunxi_codec_driver);
+
+MODULE_ALIAS("platform:sunxi-codec-dai");
+MODULE_DESCRIPTION("sunxi CODEC ALSA codec driver");
+MODULE_AUTHOR("software");
+MODULE_LICENSE("GPL v2");
+
