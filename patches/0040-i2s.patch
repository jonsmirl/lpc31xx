Bottom: 07bc6fe92f07a19caf9f3f65b4a6a0ebfe932f01
Top:    63620f7ddfbb7170a2a3474aad51468589784e47
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-11-25 15:21:19 -0500

i2s rework


---

diff --git a/arch/arm/boot/dts/ea3131.dts b/arch/arm/boot/dts/ea3131.dts
index a1957f1..63853ee 100644
--- a/arch/arm/boot/dts/ea3131.dts
+++ b/arch/arm/boot/dts/ea3131.dts
@@ -42,6 +42,9 @@
 		uda1380: codec@1a {
 			compatible = "nxp,uda1380";
 			reg = <0x1a>;
+			/* power-gpio = <&gpio 0x59 0>; */
+			/* reset-gpio = <&gpio 0x51 0>; */
+			/* dac-clk = "sysclk"; */
 		};
 	};
 	spi@15002000 {
@@ -64,11 +67,15 @@
 			gpio-pendown = <&gpio_gpio 4 0>;
 		};
 	};
-	sound {
+	i2s@16000000 {
+		i2s@1 {
+			receive-slave;
+		};
+	};
+	sound@1 {
 		compatible = "ea,ea3131-uda1380";
 		audio-codec = <&uda1380>;
-		i2s-controller = <&i2s>;
-		i2s-channel = <1>;
+		i2s-controller = <&i2s1>;
 	};
 	nand@17000800 {
 		bank-width = <2>;
diff --git a/arch/arm/boot/dts/lpc3130.dtsi b/arch/arm/boot/dts/lpc3130.dtsi
index 17c78f3..1ed417a 100644
--- a/arch/arm/boot/dts/lpc3130.dtsi
+++ b/arch/arm/boot/dts/lpc3130.dtsi
@@ -196,10 +196,22 @@
 		#address-cells = <1>;
 		#size-cells = <0>;				
 	};
-	i2s: i2s@16000000 {
+	i2s@16000000 {
+		#address-cells = <2>;
+		#size-cells = <0>;
 		compatible = "nxp,lpc31xx-i2s";
 		reg = <0x16000000 0x1000>;
-		interrupts = <13 14 15 16>;
+		
+		i2s0:i2s@0 {
+			reg = <0x80 0x180>;
+			interrupts = <13 15>;
+			/*receive-slave;*/ /* default is master */
+		};
+		i2s1:i2s@1 {
+			reg = <0x100 0x200>;
+			interrupts = <14 16>;
+			/*receive-slave;*/ /* default is master */
+		};
 	};
 	dma@17000000 {
 		compatible = "nxp,lpc31xx-dma";
diff --git a/drivers/dma/lpc31xx-dma.c b/drivers/dma/lpc31xx-dma.c
index 8c4c009..a569188 100644
--- a/drivers/dma/lpc31xx-dma.c
+++ b/drivers/dma/lpc31xx-dma.c
@@ -28,6 +28,7 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/dma-mapping.h>
+#include <linux/io.h>
 
 #include <mach/dma.h>
 #include <mach/clock.h>
@@ -38,17 +39,17 @@ struct lpc31xx_dma_engine;
 /***********************************************************************
  * DMA register definitions
  **********************************************************************/
-#define DMACH_SRC_ADDR(ch)    __REG (DMA_PHYS + ((ch) << 5) + 0x00)
-#define DMACH_DST_ADDR(ch)    __REG (DMA_PHYS + ((ch) << 5) + 0x04)
-#define DMACH_LEN(ch)         __REG (DMA_PHYS + ((ch) << 5) + 0x08)
-#define DMACH_CFG(ch)         __REG (DMA_PHYS + ((ch) << 5) + 0x0C)
-#define DMACH_EN(ch)          __REG (DMA_PHYS + ((ch) << 5) + 0x10)
-#define DMACH_TCNT(ch)        __REG (DMA_PHYS + ((ch) << 5) + 0x1C)
-#define DMACH_ALT_EN          __REG (DMA_PHYS + 0x400)
-#define DMACH_IRQ_STATUS      __REG (DMA_PHYS + 0x404)
-#define DMACH_IRQ_MASK        __REG (DMA_PHYS + 0x408)
-#define DMACH_ALT_PHYS(ch)    (DMA_PHYS + 0x200 + ((ch) << 4))
-#define DMACH_SOFT_INT_PHYS   (DMA_PHYS + 0x40C )
+#define DMACH_SRC_ADDR(edmac)		(edmac->edma->regs + (edmac->number << 5) + 0x00)
+#define DMACH_DST_ADDR(edmac)		(edmac->edma->regs + (edmac->number << 5) + 0x04)
+#define DMACH_LEN(edmac)		(edmac->edma->regs + (edmac->number << 5) + 0x08)
+#define DMACH_CFG(edmac)		(edmac->edma->regs + (edmac->number << 5) + 0x0C)
+#define DMACH_EN(edmac)			(edmac->edma->regs + (edmac->number << 5) + 0x10)
+#define DMACH_TCNT(edmac)		(edmac->edma->regs + (edmac->number << 5) + 0x1C)
+#define DMACH_ALT_EN(edma)		(edma->regs + 0x400)
+#define DMACH_IRQ_STATUS(edma)		(edma->regs + 0x404)
+#define DMACH_IRQ_MASK(edma)		(edma->regs + 0x408)
+#define DMACH_ALT_PHYS(edmac)		(edmac->edma->regs + 0x200 + (edmac->number << 4))
+#define DMACH_SOFT_INT_PHYS(edma)	(edma->regs + 0x40C )
 
 /***********************************************************************
 * Channel CONFIGURATION register defines
@@ -119,6 +120,7 @@ struct lpc31xx_dma_engine;
 struct lpc31xx_dma_desc {
 	uint32_t src_addr;
 	uint32_t dst_addr;
+	uint32_t cfg;
 	size_t size;
 	bool complete;
 	struct dma_async_tx_descriptor txd;
@@ -162,7 +164,6 @@ struct lpc31xx_dma_chan {
 	struct dma_chan chan;
 	int number;
 	const struct lpc31xx_dma_engine	*edma;
-	void __iomem *regs;
 	struct tasklet_struct tasklet;
 	unsigned long flags;
 /* Channel is configured for cyclic transfers */
@@ -190,6 +191,8 @@ struct lpc31xx_dma_engine {
 
 	struct lpc31xx_dma_chan	channels[DMA_MAX_CHANNELS];
 	int irq;
+	void __iomem *regs;
+	struct resource *mem;
 };
 
 static inline struct device *chan2dev(struct lpc31xx_dma_chan *edmac)
@@ -311,66 +314,52 @@ static bool lpc31xx_dma_advance_active(struct lpc31xx_dma_chan *edmac)
  * M2P DMA implementation
  */
 
-static void m2p_set_control(struct lpc31xx_dma_chan *edmac, uint32_t control)
-{
-	printk("jds - m2p_set_control\n");
-#if 0
-	writel(control, edmac->regs + M2P_CONTROL);
-	/*
-	 * LPC31xx User's Guide states that we must perform a dummy read after
-	 * write to the control register.
-	 */
-	readl(edmac->regs + M2P_CONTROL);
-#endif
-}
-
 static int m2p_hw_setup(struct lpc31xx_dma_chan *edmac)
 {
 	struct lpc31xx_dma_data *data = edmac->chan.private;
 	uint32_t control;
 
 	printk("jds - m2p_hw_setup\n");
-#if 0
-	writel(data->port & 0xf, edmac->regs + M2P_PPALLOC);
 
-	control = M2P_CONTROL_CH_ERROR_INT | M2P_CONTROL_ICE
-		| M2P_CONTROL_ENABLE;
-	m2p_set_control(edmac, control);
-#endif
+	//writel(data->port & 0xf, edmac->regs + M2P_PPALLOC);
+
+	//control = M2P_CONTROL_CH_ERROR_INT | M2P_CONTROL_ICE
+	//	| M2P_CONTROL_ENABLE;
+	//m2p_set_control(edmac, control);
+
 	return 0;
 }
 
 static inline uint32_t m2p_channel_state(struct lpc31xx_dma_chan *edmac)
 {
 	printk("jds - m2p_channel_state\n");
-#if 0
-	return (readl(edmac->regs + M2P_STATUS) >> 4) & 0x3;
-#endif
+
+	//return (readl(edmac->regs + M2P_STATUS) >> 4) & 0x3;
+	return 0;
 }
 
 static void m2p_hw_shutdown(struct lpc31xx_dma_chan *edmac)
 {
 	uint32_t control;
-	printk("jds - m2p_channel_state\n");
-#if 0
-	control = readl(edmac->regs + M2P_CONTROL);
-	control &= ~(M2P_CONTROL_STALLINT | M2P_CONTROL_NFBINT);
-	m2p_set_control(edmac, control);
+	printk("jds - m2p_channel_stutdown\n");
 
-	while (m2p_channel_state(edmac) >= M2P_STATE_ON)
-		cpu_relax();
+	//control = readl(edmac->regs + M2P_CONTROL);
+	//control &= ~(M2P_CONTROL_STALLINT | M2P_CONTROL_NFBINT);
+	//m2p_set_control(edmac, control);
 
-	m2p_set_control(edmac, 0);
+	//while (m2p_channel_state(edmac) >= M2P_STATE_ON)
+	//	cpu_relax();
+
+	//m2p_set_control(edmac, 0);
+
+	//while (m2p_channel_state(edmac) == M2P_STATE_STALL)
+	//	cpu_relax();
 
-	while (m2p_channel_state(edmac) == M2P_STATE_STALL)
-		cpu_relax();
-#endif
 }
 
 static void m2p_fill_desc(struct lpc31xx_dma_chan *edmac)
 {
 	struct lpc31xx_dma_desc *desc;
-	uint32_t bus_addr;
 
 	printk("jds - m2p_fill_desc\n");
 	desc = lpc31xx_dma_get_active(edmac);
@@ -378,47 +367,24 @@ static void m2p_fill_desc(struct lpc31xx_dma_chan *edmac)
 		dev_warn(chan2dev(edmac), "M2P: empty descriptor list\n");
 		return;
 	}
-#if 0
-	if (lpc31xx_dma_chan_direction(&edmac->chan) == DMA_MEM_TO_DEV)
-		bus_addr = desc->src_addr;
-	else
-		bus_addr = desc->dst_addr;
-
-	if (edmac->buffer == 0) {
-		writel(desc->size, edmac->regs + M2P_MAXCNT0);
-		writel(bus_addr, edmac->regs + M2P_BASE0);
-	} else {
-		writel(desc->size, edmac->regs + M2P_MAXCNT1);
-		writel(bus_addr, edmac->regs + M2P_BASE1);
-	}
-#endif
-	edmac->buffer ^= 1;
+	__raw_writel(desc->src_addr, DMACH_SRC_ADDR(edmac));
+	__raw_writel(desc->dst_addr, DMACH_DST_ADDR(edmac));
+	__raw_writel(desc->size, DMACH_LEN(edmac));
+	__raw_writel(desc->cfg, DMACH_CFG(edmac));
 }
 
 static void m2p_hw_submit(struct lpc31xx_dma_chan *edmac)
 {
 	printk("jds - m2p_hw_submit\n");
-#if 0
-	uint32_t control = readl(edmac->regs + M2P_CONTROL);
 
 	m2p_fill_desc(edmac);
-	control |= M2P_CONTROL_STALLINT;
-
-	if (lpc31xx_dma_advance_active(edmac)) {
-		m2p_fill_desc(edmac);
-		control |= M2P_CONTROL_NFBINT;
-	}
-
-	m2p_set_control(edmac, control);
-#endif
 }
 
 static int m2p_hw_interrupt(struct lpc31xx_dma_chan *edmac)
 {
 	printk("jds - m2p_hw_interrupt\n");
-#if 0
+#ifdef JDS
 	uint32_t irq_status = readl(edmac->regs + M2P_INTERRUPT);
-	uint32_t control;
 
 	if (irq_status & M2P_INTERRUPT_ERROR) {
 		struct lpc31xx_dma_desc *desc = lpc31xx_dma_get_active(edmac);
@@ -1142,6 +1108,7 @@ static void lpc31xx_dma_issue_pending(struct dma_chan *chan)
 
 static int __init lpc31xx_dma_probe(struct platform_device *pdev)
 {
+	struct resource *res;
 	struct lpc31xx_dma_engine *edma;
 	int ret, i;
 
@@ -1187,27 +1154,48 @@ static int __init lpc31xx_dma_probe(struct platform_device *pdev)
 	edma->dma_dev.device_control = lpc31xx_dma_control;
 	edma->dma_dev.device_issue_pending = lpc31xx_dma_issue_pending;
 
-	platform_set_drvdata(pdev, edma);
-
-	ret = dma_async_device_register(&edma->dma_dev);
-	if (ret) {
-		dev_err(&pdev->dev, "unable to register\n");
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
 		goto err_init;
 	}
 
+	edma->mem = request_mem_region(res->start, resource_size(res), pdev->name);
+	edma->regs = ioremap(res->start, resource_size(res));
+	if (!edma->regs) {
+		ret = -ENXIO;
+		goto fail_release_mem;
+	}
+
 	edma->irq = platform_get_irq(pdev, 0);
 	if (edma->irq < 0) {
 		dev_err(&pdev->dev, "failed to get irq resources\n");
-		goto err_init;
+		goto fail_release_unmap;
 	}
 	dma_irq_mask = 0xFFFFFFFF;
-	DMACH_IRQ_MASK = dma_irq_mask;
+	__raw_writel(dma_irq_mask, DMACH_IRQ_MASK(edma));
 	ret = request_irq (edma->irq, lpc31xx_dma_irq_handler, 0, "DMAC", edma);
-	if (ret)
-		printk (KERN_ERR "request_irq() returned error %d\n", ret);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get irq resources\n");
+		goto fail_release_unmap;
+	}
+
+	platform_set_drvdata(pdev, edma);
+
+	ret = dma_async_device_register(&edma->dma_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to register\n");
+		goto fail_release_irq;
+	}
 
 	return 0;
 
+fail_release_irq:
+	free_irq(edma->irq, edma);
+fail_release_unmap:
+	iounmap(edma->regs);
+fail_release_mem:
+	release_mem_region(res->start, resource_size(res));
 err_init:
 	kfree(edma);
 	printk("JDS - lpc31xx_dma_probe err %d\n", ret);
diff --git a/include/sound/soc-dai.h b/include/sound/soc-dai.h
index 1f69e0a..0e0249f 100644
--- a/include/sound/soc-dai.h
+++ b/include/sound/soc-dai.h
@@ -274,6 +274,7 @@ static inline void snd_soc_dai_set_dma_data(struct snd_soc_dai *dai,
 					    const struct snd_pcm_substream *ss,
 					    void *data)
 {
+printk("JDS setting dma_data %p\n", data);
 	if (ss->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		dai->playback_dma_data = data;
 	else
diff --git a/sound/soc/lpc31xx/Kconfig b/sound/soc/lpc31xx/Kconfig
index 91bddac..5de80f8 100644
--- a/sound/soc/lpc31xx/Kconfig
+++ b/sound/soc/lpc31xx/Kconfig
@@ -16,6 +16,7 @@ config SND_LPC315X_SOC
 
 config SND_LPC31XX_SOC_I2S
         bool
+        select SND_SOC_DMAENGINE_PCM
 
 config SND_EA3131_SOC_I2S_UDA1380
         bool "EA3131 SoC Audio for the UDA1380 CODEC using I2S/I2C"
@@ -45,8 +46,6 @@ config SND_USE_EA3131
         depends on SND_LPC31XX_SOC
 	select SND_EA3131_SOC_I2S_UDA1380
 	select SND_I2C1_CHANNEL_UDA1380
-	select SND_I2S_RX1_MASTER
-	select SND_I2S_TX1_MASTER
 	select SND_CODEC_FS256
         help
           Say Y to configuration audio for the EA3131 board. The EA3131
@@ -58,8 +57,6 @@ config SND_USE_EA3152
 	depends on SND_LPC315X_SOC
 	select SND_LPC315X_SOC_I2S_LPC315X_CODEC
 	select SND_I2C1_CHANNEL_LPC315X_CODEC
-	select SND_I2S_RX1_MASTER
-	select SND_I2S_TX1_MASTER
 	select SND_CODEC_FS128
 	help
 		Say Y to configuration audio for the EA3152 board. The EA3152
@@ -81,58 +78,6 @@ config SND_I2C1_CHANNEL_LPC315X_CODEC
 	  Analog Die Audio CODEC. Not selecting this option will use I2C0.
 
 choice
-	prompt "I2S RX channel configuration"
-	depends on SND_LPC31XX_SOC_I2S
-	help
-	  This menu selects the I2S RX (record) channel configurations
-
-	config SND_I2S_RX0_MASTER
-	bool "I2S RX0 master mode"
-	help
-	  Select this option to only used the I2S RX0 channel for
-	  audio record in master mode.
-
-	config SND_I2S_RX1_MASTER
-	bool "I2S RX1 master mode"
-	help
-	  Select this option to only used the I2S RX1 channel for
-	  audio record in master mode.
-
-	config SND_I2S_RX0_SLAVE
-	bool "I2S RX0 slave mode"
-	help
-	  Select this option to only used the I2S RX0 channel for
-	  audio record in slave mode.
-
-	config SND_I2S_RX1_SLAVE
-	bool "I2S RX1 slave mode"
-	help
-	  Select this option to only used the I2S RX1 channel for
-	  audio record in slave mode.
-
-endchoice
-
-choice
-	prompt "I2S TX channel configuration"
-	depends on SND_LPC31XX_SOC_I2S
-	help
-	  This menu selects the I2S TX (playback) channel configurations
-
-	config SND_I2S_TX0_MASTER
-	bool "I2S TX0 master mode"
-	help
-	  Select this option to only used the I2S TX0 channel for
-	  audio playback in master mode.
-
-	config SND_I2S_TX1_MASTER
-	bool "I2S TX1 master mode"
-	help
-	  Select this option to only used the I2S TX1 channel for
-	  audio record in playback mode.
-
-endchoice
-
-choice
 	prompt "WS clock divider"
 	depends on SND_LPC31XX_SOC_I2S && SND_LPC31XX_SOC
 	help
diff --git a/sound/soc/lpc31xx/ea3131-uda1380.c b/sound/soc/lpc31xx/ea3131-uda1380.c
index 601fafc..3fd51d1 100644
--- a/sound/soc/lpc31xx/ea3131-uda1380.c
+++ b/sound/soc/lpc31xx/ea3131-uda1380.c
@@ -30,6 +30,7 @@
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/i2c.h>
+#include <linux/slab.h>
 
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -147,8 +148,9 @@ static struct snd_soc_dai_link ea3131_uda1380_dai[] = {
 	},
 };
 
-static struct snd_soc_card snd_soc_machine_ea3131 = {
+static struct snd_soc_card card_ea3131_template = {
 	.name = "lpc31xx-i2s-uda1380",
+	.owner = THIS_MODULE,
 	.dai_link = &ea3131_uda1380_dai[0],
 	.num_links = ARRAY_SIZE(ea3131_uda1380_dai),
 };
@@ -163,7 +165,7 @@ static struct platform_device *ea3131_snd_device;
 
 static int __devinit ea3131_asoc_probe(struct platform_device *pdev)
 {
-	struct platform_device *snd_dev;
+	struct snd_soc_card* card;
 	int ret = 0;
 	struct i2c_adapter *adapter;
 
@@ -172,12 +174,6 @@ static int __devinit ea3131_asoc_probe(struct platform_device *pdev)
 	 */
 	lpc31xx_main_clk_rate(48000);
 
-	snd_dev = platform_device_alloc("soc-audio", -1);
-	if (!snd_dev) {
-		dev_err(&pdev->dev, "failed to alloc soc-audio device\n");
-		return -ENOMEM;
-	}
-
 	ea3131_uda1380_dai[0].codec_of_node = of_parse_phandle(
 			pdev->dev.of_node, "audio-codec", 0);
 	if (!ea3131_uda1380_dai[0].codec_of_node) {
@@ -187,16 +183,27 @@ static int __devinit ea3131_asoc_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	ea3131_uda1380_dai[0].cpu_dai_of_node = of_parse_phandle(
+	ea3131_uda1380_dai[0].cpu_of_node = of_parse_phandle(
 			pdev->dev.of_node, "i2s-controller", 0);
-	if (!ea3131_uda1380_dai[0].cpu_dai_of_node) {
+	if (!ea3131_uda1380_dai[0].cpu_of_node) {
 		dev_err(&pdev->dev,
 			"Property 'i2s-controller' missing or invalid\n");
 		ret = -EINVAL;
 		goto err;
 	}
 
-	platform_set_drvdata(snd_dev, &snd_soc_machine_ea3131);
+	card = kzalloc(sizeof(card_ea3131_template), GFP_KERNEL);
+	*card = card_ea3131_template;
+
+	card->dev = &pdev->dev;
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed %d\n", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, card);
+#ifdef JDS
 
 	ret = platform_device_add(snd_dev);
 	if (ret) {
@@ -205,6 +212,7 @@ static int __devinit ea3131_asoc_probe(struct platform_device *pdev)
 	}
 
 	platform_set_drvdata(pdev, snd_dev);
+#endif
 	return 0;
 
 err:
@@ -213,9 +221,12 @@ err:
 
 static int __devexit ea3131_asoc_remove(struct platform_device *pdev)
 {
-	platform_device_unregister(ea3131_snd_device);
+	struct snd_soc_card* card;
+
+	card = platform_get_drvdata(pdev);
+	snd_soc_unregister_card(card);
+
 	lpc31xx_main_clk_rate(0);
-	ea3131_snd_device = NULL;
 	return 0;
 }
 
diff --git a/sound/soc/lpc31xx/lpc31xx-i2s.c b/sound/soc/lpc31xx/lpc31xx-i2s.c
index 4bdb17c..3125535 100644
--- a/sound/soc/lpc31xx/lpc31xx-i2s.c
+++ b/sound/soc/lpc31xx/lpc31xx-i2s.c
@@ -39,140 +39,55 @@
 #include <mach/registers.h>
 #include <mach/hardware.h>
 
-#include "lpc31xx-i2s-clocking.h"
 #include "lpc31xx-pcm.h"
 #include "lpc31xx-i2s.h"
 
-#define I2S_NAME "lpc31xx-i2s"
-
-/* All major audio rates are support and 16-bit I2S data is supported */
-#define LPC31XX_I2S_RATES \
-    (SNDRV_PCM_RATE_8000  | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
-     SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
-     SNDRV_PCM_RATE_48000)
-#define LPC31XX_I2S_FORMATS (SNDRV_PCM_FMTBIT_S16)
-
-#define CH_PLAY 0
-#define CH_REC  1
-
-/* Structure that keeps I2S direction data */
-struct lpc31xx_i2s_ch_info {
-	char *name;                 /* Name of this channel */
-	unsigned short ch_on;       /* Flag used to indicate if clocks are on */
-	unsigned short daifmt;
-	uint32_t ws_freq;
-	int i2s_ch;
-	enum i2s_supp_clks chclk;
-};
-
-/* Common I2S structure data */
-struct lpc31xx_i2s_info {
-	spinlock_t lock;
-	unsigned short initialized;
-	struct lpc31xx_i2s_ch_info ch_info[2];
-	uint32_t freq;
-};
-
-/* Common I2S structure data */
-static struct lpc31xx_i2s_info i2s_info =
-{
-	.lock = __SPIN_LOCK_UNLOCKED(i2s_info.lock),
-	.initialized = 0,
-	.ch_info = 
-	{
-		[0] =
-		{
-#if defined (CONFIG_SND_I2S_TX0_MASTER)
-			.name  = "i2s0_play",
-			.chclk = CLK_TX_0,
-			.i2s_ch = I2S_CH_TX0,
-#else
-			.name  = "i2s1_play",
-			.chclk = CLK_TX_1,
-			.i2s_ch = I2S_CH_TX1,
-#endif
-			.ch_on = 0,
-		},
-		[1] =
-		{
-#if defined (CONFIG_SND_I2S_RX0_MASTER)
-			.name  = "i2s0_mrec",
-			.chclk = CLK_RX_0,
-			.i2s_ch = I2S_CH_RX0,
-#endif
-#if defined (CONFIG_SND_I2S_RX1_MASTER)
-			.name  = "i2s1_mrec",
-			.chclk = CLK_RX_1,
-			.i2s_ch = I2S_CH_RX1,
-#endif
-#if defined (SND_I2S_RX0_SLAVE)
-			.name  = "i2s0_srec",
-			/* Not supported yet, generate an error */
-			.i2s_ch = I2S_CH_RX0,
-#error
-#endif
-#if defined (SND_I2S_RX1_SLAVE)
-			.name  = "i2s1_srec",
-			/* Not supported yet, generate an error */
-			.i2s_ch = I2S_CH_RX1,
-#error
-#endif
-			.ch_on = 0,
-		},
-	},
-};
+static struct resource *lpc31xx_mem = 0;
+static void __iomem *lpc31xx_regs = 0;
 
 static inline void
-lpc31xx_i2s_write(const struct lpc31xx_i2s_res_info *info, uint32_t reg, uint32_t value)
+lpc31xx_i2s_write(void __iomem *regs, uint32_t reg, uint32_t value)
 {
-	__raw_writel(value, info->regs + reg);
+	__raw_writel(value, regs + reg);
 }
 
 static inline uint32_t
-lpc31xx_i2s_read(const struct lpc31xx_i2s_res_info *info, uint32_t reg)
+lpc31xx_i2s_read(void __iomem *regs, uint32_t reg)
 {
 	uint32_t value;
-	value = __raw_readl(info->regs + reg);
+	value = __raw_readl(regs + reg);
 	return value;
 }
 
-static inline int lpc31xx_get_ch_dir(struct snd_pcm_substream *substream)
-{
-	int dir = CH_REC;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		dir = CH_PLAY;
-	}
-
-	return dir;
-}
-
 static void lpc31xx_i2s_shutdown(struct snd_pcm_substream *substream,
 									struct snd_soc_dai *dai)
 {
-	int dir = lpc31xx_get_ch_dir(substream);
+	struct lpc31xx_i2s_pair *pair = snd_soc_dai_get_drvdata(dai);
+	struct lpc31xx_i2s_channel *chan;
+
+	chan = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? &pair->tx : &pair->rx);
 
-	if (i2s_info.ch_info[dir].ch_on == 0) {
+	if (chan->ch_on == 0) {
 		/* This channel is not enabled! */
-		pr_warning("%s: I2S channel is not on!\n", i2s_info.ch_info[dir].name);
+		pr_warning("%s: I2S channel is not on!\n", "fixme");
 		return;
 	}
 
 	/* Channel specific shutdown */
-	lpc31xx_chan_clk_enable(i2s_info.ch_info[dir].chclk, 0, 0);
-	i2s_info.ch_info[dir].ch_on = 0;
+	lpc31xx_chan_clk_enable(chan->chclk, 0, 0);
+	chan->ch_on = 0;
 
 	/* Can we shutdown I2S interface to save some power? */
-	if (i2s_info.ch_info[1 - dir].ch_on != 0) {
+	if (chan->ch_on != 0) {
 		/* Other channel is busy, exit without shutting down main clock */
 		return;
 	}
 
 	/* Safe to shut down */
-	if (i2s_info.initialized == 0) {
+	if (pair->initialized == 0) {
 		/* Nothing is enabled! */
 		pr_warning("I2S shutdown (%s) when nothing is enabled!\n",
-			i2s_info.ch_info[dir].name);
+				"fixme");
 		return;
 	}
 
@@ -180,70 +95,63 @@ static void lpc31xx_i2s_shutdown(struct snd_pcm_substream *substream,
 	cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 0);
 	cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 0);
 
-	i2s_info.initialized = 0;
+	pair->initialized = 0;
 }
 
-static int lpc31xx_i2s_startup(struct snd_pcm_substream *substream,
-								struct snd_soc_dai *dai)
+static int lpc31xx_i2s_startup(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)
 {
-	struct lpc31xx_i2s_res_info *info = snd_soc_dai_get_drvdata(dai);
-	int dir = lpc31xx_get_ch_dir(substream);
+	struct lpc31xx_i2s_pair *pair = snd_soc_dai_get_drvdata(dai);
+	struct lpc31xx_i2s_channel *chan;
 
-	/* Select master/slave mode for RX channel */
-	if (dir == CH_REC) {
-#if defined (CONFIG_SND_I2S_RX0_SLAVE) | defined (CONFIG_SND_I2S_RX1_SLAVE)
-		lpc31xx_i2s_write(info, I2S_CFG_MUX_SETTINGS, 0);
-#endif
-#if defined (CONFIG_SND_I2S_RX0_MASTER)
-		lpc31xx_i2s_write(info, I2S_CFG_MUX_SETTINGS, I2S_RXO_SELECT_MASTER);
-#endif
-#if defined (CONFIG_SND_I2S_RX1_MASTER)
-		lpc31xx_i2s_write(info, I2S_CFG_MUX_SETTINGS, I2S_RX1_SELECT_MASTER);
-#endif
-	}
-
-	if (i2s_info.ch_info[dir].ch_on != 0) {
+	chan = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? &pair->tx : &pair->rx);
+	if (chan->ch_on != 0) {
 		/* This channel already enabled! */
-		pr_warning("%s: I2S channel is busy!\n", i2s_info.ch_info[dir].name);
+		pr_warning("%s: I2S channel is busy!\n", "fixme");
 		return -EBUSY;
 	}
 
 	/* Initialize I2S interface */
-	if (i2s_info.initialized == 0) {
+	if (pair->initialized == 0) {
 		/* Enable I2S register access clock */
 		cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 1);
 		cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 1);
 
-		i2s_info.initialized = 1;
+		pair->initialized = 1;
 	}
 
 	/* Channel specific init, ok to leave the clocks off for now */
-	i2s_info.ch_info[dir].ch_on = 1;
-	lpc31xx_chan_clk_enable(i2s_info.ch_info[dir].chclk, 0, 0);
+	chan->ch_on = 1;
+	lpc31xx_chan_clk_enable(chan->chclk, 0, 0);
 
 	/* Mask all interrupts for the I2S channel */
-	lpc31xx_i2s_write(info, I2S_CH_INT_MASK(i2s_info.ch_info[dir].i2s_ch), I2S_FIFO_ALL_MASK);
+	//lpc31xx_i2s_write(info, I2S_CH_INT_MASK(channel->dir_info[dir].i2s_ch), I2S_FIFO_ALL_MASK);
 
+	/* Tx/Rx DMA config */
+	snd_soc_dai_set_dma_data(dai, substream, &chan->dma_params);
 	return 0;
 }
 
 static int lpc31xx_i2s_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
 				      int clk_id, unsigned int freq, int dir)
 {
+	struct lpc31xx_i2s_pair *pair = snd_soc_dai_get_drvdata(cpu_dai);
+
 	/* Will use in HW params later */
-//	i2s_info.ch_info[cpu_dai->id].ws_freq = freq;
-	i2s_info.ch_info[CH_REC].ws_freq = freq;
-	i2s_info.ch_info[CH_PLAY].ws_freq = freq;
+//	pair->dir_info[cpu_dai->id].ws_freq = freq;
+	pair->tx.ws_freq = freq;
+	pair->rx.ws_freq = freq;
 	return 0;
 }
 
 static int lpc31xx_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,
 				   unsigned int fmt)
 {
+	struct lpc31xx_i2s_pair *pair = snd_soc_dai_get_drvdata(cpu_dai);
+
 	/* Will use in HW params later */
-//	i2s_info.ch_info[cpu_dai->id].daifmt = fmt;
-	i2s_info.ch_info[CH_REC].daifmt = fmt;
-	i2s_info.ch_info[CH_PLAY].daifmt = fmt;
+//	pair->dir_info[cpu_dai->id].daifmt = fmt;
+	pair->tx.daifmt = fmt;
+	pair->rx.daifmt = fmt;
 
 	return 0;
 }
@@ -263,51 +171,52 @@ static int lpc31xx_i2s_hw_params(struct snd_pcm_substream *substream,
 			         struct snd_pcm_hw_params *params,
 					 struct snd_soc_dai *dai)
 {
-	struct lpc31xx_i2s_res_info *info = snd_soc_dai_get_drvdata(dai);
-	int dir = lpc31xx_get_ch_dir(substream);
+	struct lpc31xx_i2s_pair *pair = snd_soc_dai_get_drvdata(dai);
+	struct lpc31xx_i2s_channel *chan;
 	uint32_t tmp;
 
+	chan = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? &pair->tx : &pair->rx);
+
 	/* Setup the I2S data format */
 	tmp = 0;
-	switch (i2s_info.ch_info[dir].daifmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	switch (chan->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) {
 		case SND_SOC_DAIFMT_I2S:
-			spin_lock_irq(&i2s_info.lock);
-			tmp = lpc31xx_i2s_read(info, I2S_FORMAT_SETTINGS) &
-				~I2S_SET_FORMAT(i2s_info.ch_info[dir].i2s_ch,
+			spin_lock_irq(&pair->lock);
+			tmp = lpc31xx_i2s_read(lpc31xx_regs, I2S_FORMAT_SETTINGS) &
+				~I2S_SET_FORMAT(chan->i2s_ch,
 				I2S_FORMAT_MASK);
-			lpc31xx_i2s_write(info, I2S_FORMAT_SETTINGS, tmp | I2S_SET_FORMAT(i2s_info.ch_info[dir].i2s_ch,
+			lpc31xx_i2s_write(lpc31xx_regs, I2S_FORMAT_SETTINGS, tmp | I2S_SET_FORMAT(chan->i2s_ch,
 				I2S_FORMAT_I2S));
-			spin_unlock_irq(&i2s_info.lock);
+			spin_unlock_irq(&pair->lock);
 			break;
 
 		default:
-			pr_warning("%s: Unsupported audio data format\n",
-				i2s_info.ch_info[dir].name);
+			pr_warning("%s: Unsupported audio data format\n", "fixme");
 			return -EINVAL;
 	}
 
 #if defined (CONFIG_SND_DEBUG_VERBOSE)
-	pr_info("Desired clock rate : %d\n", i2s_info.ch_info[dir].ws_freq);
+	pr_info("Desired clock rate : %d\n", chan->ws_freq);
 	pr_info("Channels           : %d\n", params_channels(params));
-	pr_info("Data format        : %d\n", i2s_info.ch_info[dir].daifmt);
+	pr_info("Data format        : %d\n", chan->daifmt);
 #endif
 
 	/* The playback and record rates are shared, so just set the CODEC clock
 	   to the selected rate (will actually generate 256 * rate) */
-	i2s_info.freq = i2s_info.ch_info[dir].ws_freq;
-	if (lpc31xx_main_clk_rate(i2s_info.freq) == 0)
+	pair->freq = chan->ws_freq;
+	if (lpc31xx_main_clk_rate(pair->freq) == 0)
 	{
 		pr_warning("Unsupported audio data rate (%d)\n",
-			i2s_info.freq);
+			pair->freq);
 		return -EINVAL;
 	}
 
 	/* Now setup the selected channel clocks (WS and BCK) */
-	if (lpc31xx_chan_clk_enable(i2s_info.ch_info[dir].chclk, i2s_info.freq,
-		(i2s_info.freq * 32)) == 0)
+	if (lpc31xx_chan_clk_enable(chan->chclk, pair->freq,
+		(pair->freq * 32)) == 0)
 	{
 		pr_warning("Unsupported channel data rates (ws=%d, bck=%d)\n",
-			i2s_info.freq, (i2s_info.freq * 32));
+			pair->freq, (pair->freq * 32));
 		return -EINVAL;
 	}
 
@@ -331,6 +240,7 @@ static int lpc31xx_i2s_trigger(struct snd_pcm_substream *substream, int cmd, str
 		pr_warning("lpc31xx_i2s_triggers: Unsupported cmd: %d\n",
 				cmd);
 		ret = -EINVAL;
+		break;
 	}
 
 	return ret;
@@ -339,12 +249,14 @@ static int lpc31xx_i2s_trigger(struct snd_pcm_substream *substream, int cmd, str
 #ifdef CONFIG_PM
 static int lpc31xx_i2s_suspend(struct snd_soc_dai *cpu_dai)
 {
+	struct lpc31xx_i2s_pair *pair = snd_soc_dai_get_drvdata(cpu_dai);
+
 	/* Shutdown active clocks */
-	if (i2s_info.ch_info[CH_PLAY].ch_on != 0) {
-		lpc31xx_chan_clk_enable(i2s_info.ch_info[CH_PLAY].chclk, 0, 0);
+	if (pair->tx.ch_on != 0) {
+		lpc31xx_chan_clk_enable(pair->tx.chclk, 0, 0);
 	}
-	if (i2s_info.ch_info[CH_REC].ch_on != 0) {
-		lpc31xx_chan_clk_enable(i2s_info.ch_info[CH_REC].chclk, 0, 0);
+	if (pair->rx.ch_on != 0) {
+		lpc31xx_chan_clk_enable(pair->rx.chclk, 0, 0);
 	}
 
 	/* Disable I2S register access clock */
@@ -358,20 +270,22 @@ static int lpc31xx_i2s_suspend(struct snd_soc_dai *cpu_dai)
 
 static int lpc31xx_i2s_resume(struct snd_soc_dai *cpu_dai)
 {
+	struct lpc31xx_i2s_pair *pair = snd_soc_dai_get_drvdata(cpu_dai);
+
 	/* resume main clocks */
-	lpc31xx_main_clk_rate(i2s_info.freq);
+	lpc31xx_main_clk_rate(pair->freq);
 	/* Enable I2S register access clock */
 	cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 1);
 	cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 1);
 
 	/* resume active clocks */
-	if (i2s_info.ch_info[CH_PLAY].ch_on != 0) {
-		lpc31xx_chan_clk_enable(i2s_info.ch_info[CH_PLAY].chclk,
-		i2s_info.ch_info[CH_PLAY].ws_freq, (i2s_info.freq * 32));
+	if (pair->tx.ch_on != 0) {
+		lpc31xx_chan_clk_enable(pair->tx.chclk,
+		pair->tx.ws_freq, (pair->freq * 32));
 	}
-	if (i2s_info.ch_info[CH_REC].ch_on != 0) {
-		lpc31xx_chan_clk_enable(i2s_info.ch_info[CH_REC].chclk,
-		i2s_info.ch_info[CH_REC].ws_freq, (i2s_info.freq * 32));
+	if (pair->rx.ch_on != 0) {
+		lpc31xx_chan_clk_enable(pair->rx.chclk,
+		pair->rx.ws_freq, (pair->freq * 32));
 	}
 
 	return 0;
@@ -383,109 +297,159 @@ static int lpc31xx_i2s_resume(struct snd_soc_dai *cpu_dai)
 #endif
 
 static struct snd_soc_dai_ops lpc31xx_i2s_dai_ops = {
-		.startup = lpc31xx_i2s_startup,
-		.shutdown = lpc31xx_i2s_shutdown,
-		.trigger = lpc31xx_i2s_trigger,
-		.hw_params = lpc31xx_i2s_hw_params,
-		.set_sysclk = lpc31xx_i2s_set_dai_sysclk,
-		.set_fmt = lpc31xx_i2s_set_dai_fmt,
-		.set_clkdiv = lpc31xx_i2s_set_dai_clkdiv,
+	.startup = lpc31xx_i2s_startup,
+	.shutdown = lpc31xx_i2s_shutdown,
+	.trigger = lpc31xx_i2s_trigger,
+	.hw_params = lpc31xx_i2s_hw_params,
+	.set_sysclk = lpc31xx_i2s_set_dai_sysclk,
+	.set_fmt = lpc31xx_i2s_set_dai_fmt,
+	.set_clkdiv = lpc31xx_i2s_set_dai_clkdiv,
 };
 
-struct snd_soc_dai_driver lpc31xx_i2s_dai = {
-	 .name = I2S_NAME,
-	 .id = 0,
-	 .suspend = lpc31xx_i2s_suspend,
-	 .resume = lpc31xx_i2s_resume,
-	 .playback = {
-		      .channels_min = 2,
-		      .channels_max = 2,
-		      .rates = LPC31XX_I2S_RATES,
-		      .formats = LPC31XX_I2S_FORMATS,
-		      },
-	 .capture = {
-		     .channels_min = 2,
-		     .channels_max = 2,
-		     .rates = LPC31XX_I2S_RATES,
-		     .formats = LPC31XX_I2S_FORMATS,
-		     },
-	 .ops = &lpc31xx_i2s_dai_ops,
+static struct snd_soc_dai_driver dai_driver = {
+	.name = "is2",
+	.id = 1,
+	.suspend = lpc31xx_i2s_suspend,
+	.resume = lpc31xx_i2s_resume,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = LPC31XX_I2S_RATES,
+		.formats = LPC31XX_I2S_FORMATS,
+	},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = LPC31XX_I2S_RATES,
+		.formats = LPC31XX_I2S_FORMATS,
+	},
+	.ops = &lpc31xx_i2s_dai_ops,
 	.symmetric_rates = 1,
 };
-EXPORT_SYMBOL_GPL(lpc31xx_i2s_dai);
+
+static struct device i2s[2];
 
 static __devinit int lpc31xx_i2s_dev_probe(struct platform_device *pdev)
 {
-	struct lpc31xx_i2s_res_info *info;
+	struct lpc31xx_i2s_pair *pair;
+	struct device_node *child;
+	const __be32 *prop;
 	struct resource *res;
-	int err;
-
-	info = kzalloc(sizeof(struct lpc31xx_i2s_info), GFP_KERNEL);
-	if (!info) {
-		err = -ENOMEM;
-		goto fail;
-	}
+	int i, err, len, tx, rx, slave;
 
-	dev_set_drvdata(&pdev->dev, info);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		err = -ENODEV;
-		goto fail_free_info;
-	}
-
-	info->mem = request_mem_region(res->start, resource_size(res),
-				       pdev->name);
-	if (!info->mem) {
-		err = -EBUSY;
-		goto fail_free_info;
+		goto fail;
 	}
 
-	info->regs = ioremap(info->mem->start, resource_size(info->mem));
-	if (!info->regs) {
+	lpc31xx_mem = request_mem_region(res->start, resource_size(res), pdev->name);
+	lpc31xx_regs = ioremap(res->start, resource_size(res));
+	if (!lpc31xx_regs) {
 		err = -ENXIO;
 		goto fail_release_mem;
 	}
 
-	err = snd_soc_register_dai(&pdev->dev, &lpc31xx_i2s_dai);
-	if (err)
-		goto fail_unmap_mem;
-
+	/* Workaround for ASOC not supporting two independent DAIs
+	 * co-mingled onto a single device.
+	 */
+	i = 0;
+	for_each_child_of_node(pdev->dev.of_node, child) {
+		/* Device address */
+		prop = of_get_property(child, "reg", &len);
+		if (!prop || len < 2*sizeof(*prop)) {
+			dev_err(&pdev->dev, "%s has no 'reg' property\n",
+				child->full_name);
+			continue;
+		}
+		tx = be32_to_cpu(*prop);
+		rx = be32_to_cpu(*(prop+1));
+		if (!(((tx == 0x80) && (rx == 0x180)) || ((tx == 0x100) && (rx == 0x200)))) {
+			dev_err(&pdev->dev, "%s valid regs 0x80/0x180 or 0x100/0x200\n",
+				child->full_name);
+			continue;
+		}
+		prop = of_get_property(child, "receive-slave", NULL);
+		slave = lpc31xx_i2s_read(lpc31xx_regs, I2S_CFG_MUX_SETTINGS);
+		if (prop)
+			slave &= ~(tx == 0x80 ? I2S_RXO_SELECT_MASTER : I2S_RX1_SELECT_MASTER);
+		else
+			slave |= (tx == 0x80 ? I2S_RXO_SELECT_MASTER : I2S_RX1_SELECT_MASTER);
+		lpc31xx_i2s_write(lpc31xx_regs, I2S_CFG_MUX_SETTINGS, slave);
+
+		pair = kzalloc(sizeof(*pair), GFP_KERNEL);
+		if (pair == NULL) {
+			err = ENOMEM;
+			goto fail_unmap_mem;
+		}
+		spin_lock_init(&pair->lock);
+		i2s[i] = pdev->dev;
+		i2s[i].of_node = child;
+
+		if (tx == 0x80) {
+			pair->tx.cfg = res->start + 0x080;
+			pair->tx.dma_addr = res->start + 0x0E0;
+			pair->tx.dma_params.port = 0;
+			pair->rx.cfg = res->start + 0x180;
+			pair->rx.dma_addr = res->start + 0x1E0;
+		} else {
+			pair->tx.cfg = res->start + 0x100;
+			pair->tx.dma_addr = res->start + 0x160;
+			pair->rx.cfg = res->start + 0x200;
+			pair->rx.dma_addr = res->start + 0x260;
+		}
+		dev_set_drvdata(&i2s[i], pair);
+
+		err = snd_soc_register_dai(&i2s[i], &dai_driver);
+		if (err)
+			goto fail_unmap_mem;
+		i++;
+	}
 	return 0;
 
 fail_unmap_mem:
-	iounmap(info->regs);
+	iounmap(lpc31xx_regs);
 fail_release_mem:
-	release_mem_region(info->mem->start, resource_size(info->mem));
-fail_free_info:
-	kfree(info);
+	if (lpc31xx_mem) {
+		release_mem_region(lpc31xx_mem->start, resource_size(lpc31xx_mem));
+		lpc31xx_mem = 0;
+	}
 fail:
 	return err;
 }
 
 static __devexit int lpc31xx_i2s_dev_remove(struct platform_device *pdev)
 {
-	snd_soc_unregister_dai(&pdev->dev);
+	struct lpc31xx_i2s_pair *pair;
+
+	snd_soc_unregister_dai(&i2s[0]);
+	pair = dev_get_drvdata(&i2s[0]);
+	kfree(pair);
+
+	snd_soc_unregister_dai(&i2s[1]);
+	pair = dev_get_drvdata(&i2s[1]);
+	kfree(pair);
+
+	iounmap(lpc31xx_regs);
+	if (lpc31xx_mem)
+		release_mem_region(lpc31xx_mem->start, resource_size(lpc31xx_mem));
 	return 0;
 }
 
-#if defined(CONFIG_OF)
 static const struct of_device_id lpc31xx_i2s_of_match[] = {
 	{ .compatible = "nxp,lpc31xx-i2s" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, lpc31xx_i2s_of_match);
-#endif
 
 static struct platform_driver lpc31xx_i2s_driver = {
 	.probe  = lpc31xx_i2s_dev_probe,
 	.remove = lpc31xx_i2s_dev_remove,
 	.driver = {
-		.name = I2S_NAME,
+		.name = "lpc31xx-i2s",
 		.owner = THIS_MODULE,
-#ifdef CONFIG_OF
 		.of_match_table = lpc31xx_i2s_of_match,
-#endif
 	},
 };
 
@@ -505,5 +469,5 @@ module_exit(lpc31xx_i2s_exit);
 MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
 MODULE_DESCRIPTION("ASoC LPC31XX I2S interface");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:" I2S_NAME);
+MODULE_ALIAS("platform:lpc31xx-i2s");
 
diff --git a/sound/soc/lpc31xx/lpc31xx-i2s.h b/sound/soc/lpc31xx/lpc31xx-i2s.h
index 61ef01f..496f69e 100644
--- a/sound/soc/lpc31xx/lpc31xx-i2s.h
+++ b/sound/soc/lpc31xx/lpc31xx-i2s.h
@@ -24,18 +24,15 @@
 #define __SOUND_SOC_LPC31XX_I2S_H
 
 #include <linux/types.h>
-
-extern struct snd_soc_dai_driver lpc31xx_i2s_dai;
-
-struct lpc31xx_i2s_res_info {
-	struct resource			*mem;
-	void __iomem			*regs;
-};
+#include <mach/dma.h>
+#include "lpc31xx-i2s-clocking.h"
 
 /***********************************************************************
 * Audio Subsystem (ADSS) register definitions
 **********************************************************************/
 
+#define I2S_PHY_ADDRESS 0x16000000
+
 /* I2S Controller Module Register Structure */
 #define I2S_FORMAT_SETTINGS       0x00
 #define I2S_CFG_MUX_SETTINGS      0x04
@@ -90,7 +87,48 @@ struct lpc31xx_i2s_res_info {
 #define I2S_FIFO_RIGHT_EMPTY      _BIT(9) /* TX only */
 #define I2S_FIFO_ALL_MASK         0x3FF
 
+#define DMA_SLV_I2STX0_L   7
+#define DMA_SLV_I2STX0_R   8
+#define DMA_SLV_I2STX1_L   9
+#define DMA_SLV_I2STX1_R   10
+#define DMA_SLV_I2SRX0_L   11
+#define DMA_SLV_I2SRX0_R   12
+#define DMA_SLV_I2SRX1_L   13
+#define DMA_SLV_I2SRX1_R   14
+
+/* All major audio rates are support and 16-bit I2S data is supported */
+#define LPC31XX_I2S_RATES \
+    (SNDRV_PCM_RATE_8000  | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+     SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | \
+     SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_176400| \
+     SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000)
+//#define LPC31XX_I2S_FORMATS (SNDRV_PCM_FMTBIT_S16 | SNDRV_PCM_FMTBIT_S24)
+#define LPC31XX_I2S_FORMATS (SNDRV_PCM_FMTBIT_S16)
 
+#define CH_PLAY 0
+#define CH_REC  1
+
+/* Structure that keeps I2S direction data */
+struct lpc31xx_i2s_channel {
+	unsigned short ch_on;       /* Flag used to indicate if clocks are on */
+	unsigned short daifmt;
+	uint32_t ws_freq;
+	int i2s_ch, slave;
+	enum i2s_supp_clks chclk;
+	long cfg;
+	uint32_t dma_addr;
+	struct lpc31xx_dma_data dma_params;
+};
+
+
+/* Common I2S structure data */
+struct lpc31xx_i2s_pair {
+	spinlock_t lock;
+	unsigned short initialized;
+	uint32_t freq;
+	struct lpc31xx_i2s_channel tx;
+	struct lpc31xx_i2s_channel rx;
+};
 
 #endif
 
diff --git a/sound/soc/lpc31xx/lpc31xx-pcm.c b/sound/soc/lpc31xx/lpc31xx-pcm.c
index fa2655e..d39e7b0 100644
--- a/sound/soc/lpc31xx/lpc31xx-pcm.c
+++ b/sound/soc/lpc31xx/lpc31xx-pcm.c
@@ -29,6 +29,7 @@
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
 
 #include <mach/dma.h>
 #include <mach/hardware.h>
@@ -55,6 +56,253 @@ static u64 lpc31xx_pcm_dmamask = DMA_BIT_MASK(32);
 #define MAX_BYTES_PERIOD (32 * 1024)
 #endif
 
+
+/*
+ * ASoC platform driver
+ */
+static struct snd_pcm_hardware snd_lpc31xx_hardware = {
+	.info = (SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_INTERLEAVED |
+		 SNDRV_PCM_INFO_RESUME |
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER),
+	.formats = (SND_SOC_DAIFMT_I2S),
+	.period_bytes_min = MIN_BYTES_PERIOD,
+	.period_bytes_max = MAX_BYTES_PERIOD,
+	.periods_min = MIN_PERIODS,
+	.periods_max = MAX_PERIODS,
+	.buffer_bytes_max = (MAX_PERIODS * MAX_BYTES_PERIOD)
+};
+
+
+static int lpc31xx_pcm_allocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *dmabuf = &substream->dma_buffer;
+	size_t size = snd_lpc31xx_hardware.buffer_bytes_max;
+
+	dmabuf->dev.type = SNDRV_DMA_TYPE_DEV;
+	dmabuf->dev.dev = pcm->card->dev;
+	dmabuf->private_data = NULL;
+	dmabuf->area = dma_alloc_coherent(pcm->card->dev, size,
+					  &dmabuf->addr, GFP_KERNEL);
+
+	pr_debug("lpc31xx-pcm:"
+		"preallocate_dma_buffer: area=%p, addr=%p, size=%d\n",
+		(void *) dmabuf->area,
+		(void *) dmabuf->addr,
+		size);
+
+	if (!dmabuf->area)
+		return -ENOMEM;
+
+	dmabuf->bytes = size;
+
+	return 0;
+}
+
+static int lpc31xx_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_soc_dai *dai = rtd->cpu_dai;
+	struct snd_pcm *pcm = rtd->pcm;
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &lpc31xx_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (dai->driver->playback.channels_min) {
+		ret = lpc31xx_pcm_allocate_dma_buffer(
+			  pcm, SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->driver->capture.channels_min) {
+		pr_debug("%s: Allocating PCM capture DMA buffer\n", SND_NAME);
+		ret = lpc31xx_pcm_allocate_dma_buffer(
+			  pcm, SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+out:
+	return ret;
+}
+
+static void lpc31xx_pcm_free(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (substream == NULL)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_coherent(pcm->card->dev, buf->bytes,
+				  buf->area, buf->addr);
+
+		buf->area = NULL;
+	}
+}
+
+static int snd_lpc31xx_pcm_mmap(struct snd_pcm_substream *substream,
+			    struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+static bool filter(struct dma_chan *chan, void *param)
+{
+	chan->private = param;
+	return true;
+}
+
+static int snd_lpc31xx_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);
+	struct lpc31xx_pcm_dma_params *dma_params;
+	struct dma_slave_config slave_config;
+	int ret;
+
+	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	ret = snd_hwparams_to_dma_slave_config(substream, params, &slave_config);
+	if (ret)
+		return ret;
+
+	slave_config.device_fc = false;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		//slave_config.dst_addr = dma_params->dma_addr;
+		//slave_config.dst_maxburst = dma_params->burstsize;
+	} else {
+		//slave_config.src_addr = dma_params->dma_addr;
+		//slave_config.src_maxburst = dma_params->burstsize;
+	}
+
+	ret = dmaengine_slave_config(chan, &slave_config);
+	if (ret)
+		return ret;
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	return 0;
+}
+
+static int snd_lpc31xx_open(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct lpc31xx_pcm_dma_params *dma_params;
+	struct lpc31xx_dma_data *dma_data;
+	int ret;
+
+	snd_soc_set_runtime_hwparams(substream, &snd_lpc31xx_hardware);
+
+	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	dma_data = kzalloc(sizeof(*dma_data), GFP_KERNEL);
+	dma_data->port = 0;
+	dma_data->direction = 0;
+	dma_data->name = 0;
+
+	ret = snd_dmaengine_pcm_open(substream, filter, dma_data);
+	if (ret) {
+		kfree(dma_data);
+		return 0;
+	}
+	snd_dmaengine_pcm_set_data(substream, dma_data);
+	return 0;
+}
+
+static int snd_lpc31xx_close(struct snd_pcm_substream *substream)
+{
+	struct lpc31xx_dma_data *dma_data = snd_dmaengine_pcm_get_data(substream);
+
+	snd_dmaengine_pcm_close(substream);
+	kfree(dma_data);
+
+	return 0;
+}
+
+static struct snd_pcm_ops lpc31xx_pcm_ops = {
+	.open		= snd_lpc31xx_open,
+	.close		= snd_lpc31xx_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= snd_lpc31xx_pcm_hw_params,
+	.trigger	= snd_dmaengine_pcm_trigger,
+	.pointer	= snd_dmaengine_pcm_pointer_no_residue,
+	.mmap		= snd_lpc31xx_pcm_mmap,
+};
+
+static struct snd_soc_platform_driver lpc31xx_soc_platform = {
+	.ops		= &lpc31xx_pcm_ops,
+	.pcm_new	= lpc31xx_pcm_new,
+	.pcm_free	= lpc31xx_pcm_free,
+};
+
+static int __devinit lpc31xx_soc_platform_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_platform(&pdev->dev, &lpc31xx_soc_platform);
+}
+
+static int __devexit lpc31xx_soc_platform_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver lpc31xx_pcm_driver = {
+	.driver = {
+			.name = "lpc31xx-pcm-audio",
+			.owner = THIS_MODULE,
+	},
+	.probe = lpc31xx_soc_platform_probe,
+	.remove = __devexit_p(lpc31xx_soc_platform_remove),
+};
+
+module_platform_driver(lpc31xx_pcm_driver);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:lpc31xx-pcm-audio");
+
+#ifdef OLD_CODE
+
+#define SND_NAME "lpc31xx-pcm-audio"
+static u64 lpc31xx_pcm_dmamask = DMA_BIT_MASK(32);
+
+#if defined (CONFIG_SND_USE_DMA_LINKLIST)
+/* The DMA controller in the LPC31XX has limited interrupt support
+   for DMA. A timer is used instead to update the current buffer
+   position */
+#define MIN_PERIODS 8
+#define MAX_PERIODS 32
+#define DMA_LIST_SIZE (MAX_PERIODS * sizeof(dma_sg_ll_t))
+#define MIN_BYTES_PERIOD 2048
+#define MAX_BYTES_PERIOD 4096
+#define MINTICKINC ((MIN_BYTES_PERIOD * HZ * (MIN_PERIODS / 4)) / (48000 * 2 * 2))
+
+#else
+#define MIN_PERIODS 2
+#define MAX_PERIODS 2
+#define MIN_BYTES_PERIOD (32 * 1024)
+#define MAX_BYTES_PERIOD (32 * 1024)
+#endif
+
 #if defined (CONFIG_SND_I2S_TX0_MASTER)
 #define TX_FIFO_ADDR (I2S_PHYS + 0x0E0)
 #define TX_DMA_CHCFG DMA_SLV_I2STX0_L
@@ -570,3 +818,5 @@ MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
 MODULE_DESCRIPTION("NXP LPC31XX PCM module");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:lpc323x-audio");
+
+#endif
diff --git a/sound/soc/lpc31xx/lpc31xx-pcm.h b/sound/soc/lpc31xx/lpc31xx-pcm.h
index ddd1462..2134499 100644
--- a/sound/soc/lpc31xx/lpc31xx-pcm.h
+++ b/sound/soc/lpc31xx/lpc31xx-pcm.h
@@ -23,7 +23,5 @@
 #ifndef __SOUND_SOC_LPC31XX_PCM_H
 #define __SOUND_SOC_LPC31XX_PCM_H
 
-extern struct snd_soc_platform_driver lpc31xx_asoc_platform;
-
 #endif
 
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c501af6..eacfc69 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -22,6 +22,8 @@
  *   o Support TDM on PCM and I2S
  */
 
+#define DEBUG
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
