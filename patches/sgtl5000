Bottom: f6e8b9c55bf96b34d899cebd3094217adc493e39
Top:    a1d2ee10d887ca2a9fd3048cf77e80433ae02ae7
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-08-17 10:24:02 -0400



---

diff --git a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
index 5843f86..7fe6355 100644
--- a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
+++ b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
@@ -157,7 +157,7 @@
 			sgtl5000: sgtl5000@a {
 				compatible = "fsl,sgtl5000";
 				reg = <0x0a>;
-				clocks = <&iis0>;
+				pwms = <&pwm 0 200 0>;
 
 				#sound-dai-cells = <0>;
 				VDDA-supply = <&reg_vcc3v3>;
@@ -195,8 +195,8 @@
 		};
 
 		dailink0_master: simple-audio-card,codec {
+			system-clock-frequency = <24000000>;
 			sound-dai = <&sgtl5000>;
-			clocks = <&iis0>;
 		};
 	};
 
diff --git a/arch/arm/boot/dts/sun7i-a20.dtsi b/arch/arm/boot/dts/sun7i-a20.dtsi
index 0a03350..32a9ea1 100644
--- a/arch/arm/boot/dts/sun7i-a20.dtsi
+++ b/arch/arm/boot/dts/sun7i-a20.dtsi
@@ -860,7 +860,9 @@
 			compatible = "allwinner,sun7i-a20-pwm";
 			reg = <0x01c20e00 0xc>;
 			clocks = <&osc24M>;
+			#clock-cells = <1>;
 			#pwm-cells = <3>;
+			clock-output-names = "pwm0", "pwm1";
 			status = "disabled";
 		};
 
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index dd09d05..50934ee 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -16,6 +16,7 @@
 #include <linux/pm.h>
 #include <linux/i2c.h>
 #include <linux/clk.h>
+#include <linux/pwm.h>
 #include <linux/regmap.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
@@ -130,6 +131,7 @@ struct sgtl5000_priv {
 	struct ldo_regulator *ldo;
 	struct regmap *regmap;
 	struct clk *mclk;
+	struct pwm_device *pwm;
 	int revision;
 };
 
@@ -614,7 +616,7 @@ static int sgtl5000_set_clock(struct snd_soc_codec *codec, int frame_rate)
 	 * calculate the divider of mclk/sample_freq,
 	 * factor of freq =96k can only be 256, since mclk in range (12m,27m)
 	 */
-	switch (DIV_ROUND_UP(sgtl5000->sysclk, sys_fs)) {
+	switch (DIV_ROUND_CLOSEST(sgtl5000->sysclk, sys_fs)) {
 	case 256:
 		clk_ctl |= SGTL5000_MCLK_FREQ_256FS <<
 			SGTL5000_MCLK_FREQ_SHIFT;
@@ -1446,8 +1448,9 @@ static int sgtl5000_fill_defaults(struct sgtl5000_priv *sgtl5000)
 static int sgtl5000_i2c_probe(struct i2c_client *client,
 			      const struct i2c_device_id *id)
 {
+	struct device_node *np = client->dev.of_node;
 	struct sgtl5000_priv *sgtl5000;
-	int ret, reg, rev;
+	int ret, reg, rev, period;
 
 	sgtl5000 = devm_kzalloc(&client->dev, sizeof(struct sgtl5000_priv),
 								GFP_KERNEL);
@@ -1464,22 +1467,35 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 	sgtl5000->mclk = devm_clk_get(&client->dev, NULL);
 	if (IS_ERR(sgtl5000->mclk)) {
 		ret = PTR_ERR(sgtl5000->mclk);
-		dev_err(&client->dev, "Failed to get mclock: %d\n", ret);
-		/* Defer the probe to see if the clk will be provided later */
-		if (ret == -ENOENT)
-			return -EPROBE_DEFER;
-		return ret;
+		sgtl5000->pwm = devm_of_pwm_get(&client->dev, np, NULL);
+		if (IS_ERR(sgtl5000->pwm)) {
+			/* Defer the probe to see if the clk will be provided later */
+			dev_err(&client->dev, "Failed to get mclock, defering: %d\n", ret);
+			if (ret == -ENOENT)
+				return -EPROBE_DEFER;
+			return ret;
+		}
+		period = pwm_get_period(sgtl5000->pwm);
+		ret = pwm_config(sgtl5000->pwm, period / 2, period); 
+		if (ret)
+			return ret;
+		ret = pwm_enable(sgtl5000->pwm);
+		if (ret)
+			return ret;
+	} else {
+		ret = clk_prepare_enable(sgtl5000->mclk);
+		if (ret)
+			return ret;
 	}
-
-	ret = clk_prepare_enable(sgtl5000->mclk);
-	if (ret)
-		return ret;
+	printk("JDS sgtl5000_i2c_probe 1\n");
 
 	/* read chip information */
 	ret = regmap_read(sgtl5000->regmap, SGTL5000_CHIP_ID, &reg);
+	printk("JDS sgtl5000_i2c_probe 1a %d\n", ret);
 	if (ret)
 		goto disable_clk;
 
+	printk("JDS sgtl5000_i2c_probe 2\n");
 	if (((reg & SGTL5000_PARTID_MASK) >> SGTL5000_PARTID_SHIFT) !=
 	    SGTL5000_PARTID_PART_ID) {
 		dev_err(&client->dev,
@@ -1488,10 +1504,12 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 		goto disable_clk;
 	}
 
+	printk("JDS sgtl5000_i2c_probe 3\n");
 	rev = (reg & SGTL5000_REVID_MASK) >> SGTL5000_REVID_SHIFT;
 	dev_info(&client->dev, "sgtl5000 revision 0x%x\n", rev);
 	sgtl5000->revision = rev;
 
+	printk("JDS sgtl5000_i2c_probe 4\n");
 	i2c_set_clientdata(client, sgtl5000);
 
 	/* Ensure sgtl5000 will start with sane register values */
diff --git a/sound/soc/sunxi/sunxi-i2s.c b/sound/soc/sunxi/sunxi-i2s.c
index f77f33c..e1061a2 100644
--- a/sound/soc/sunxi/sunxi-i2s.c
+++ b/sound/soc/sunxi/sunxi-i2s.c
@@ -119,14 +119,14 @@ void sunxi_snd_txctrl_i2s(struct sunxi_priv *priv, struct snd_pcm_substream *sub
 		regmap_update_bits(priv->regmap, SUNXI_I2S_INT, SUNXI_I2SINT_TXDRQEN_MASK, 0);
 	}
 
-/*	{
+	{
 	int i;
 	for (i = SUNXI_I2S_CTL; i <= SUNXI_I2S_RXCHMAP; i += 4)  {
 		regmap_read(priv->regmap, i, &reg_val);
 		printk("REG %02x VAL %08x\n", i, reg_val);
 	}
 	}
-*/
+
 }
 
 void sunxi_snd_rxctrl_i2s(struct sunxi_priv *priv, int on)
