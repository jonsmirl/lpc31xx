Bottom: ace9271b373bf417b1e2769c7a3b74d23a8c5713
Top:    1d1949107d4fedf6a22ba9a0313d6664b97a426a
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-08-17 10:24:02 -0400



---

diff --git a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
index 1fb13f99..2267a54 100644
--- a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
+++ b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
@@ -176,7 +176,7 @@
 			sgtl5000: sgtl5000@a {
 				compatible = "fsl,sgtl5000";
 				reg = <0x0a>;
-				clocks = <&iis0>;
+				pwms = <&pwm 0 40 0>;
 
 				#sound-dai-cells = <0>;
 				VDDA-supply = <&reg_vcc3v3>;
@@ -214,8 +214,8 @@
 		};
 
 		dailink0_master: simple-audio-card,codec {
+			system-clock-frequency = <24000000>;
 			sound-dai = <&sgtl5000>;
-			clocks = <&iis0>;
 		};
 	};
 
diff --git a/arch/arm/boot/dts/sun7i-a20.dtsi b/arch/arm/boot/dts/sun7i-a20.dtsi
index b273092..ed05a86 100644
--- a/arch/arm/boot/dts/sun7i-a20.dtsi
+++ b/arch/arm/boot/dts/sun7i-a20.dtsi
@@ -860,6 +860,7 @@
 			reg = <0x01c20e00 0xc>;
 			clocks = <&osc24M>;
 			#pwm-cells = <3>;
+			clock-output-names = "pwm0", "pwm1";
 			status = "disabled";
 		};
 
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index a7c777a..8df83f9 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -16,6 +16,7 @@
 #include <linux/pm.h>
 #include <linux/i2c.h>
 #include <linux/clk.h>
+#include <linux/pwm.h>
 #include <linux/regmap.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
@@ -130,6 +131,7 @@ struct sgtl5000_priv {
 	struct ldo_regulator *ldo;
 	struct regmap *regmap;
 	struct clk *mclk;
+	struct pwm_device *pwm;
 	int revision;
 };
 
@@ -614,7 +616,7 @@ static int sgtl5000_set_clock(struct snd_soc_codec *codec, int frame_rate)
 	 * calculate the divider of mclk/sample_freq,
 	 * factor of freq =96k can only be 256, since mclk in range (12m,27m)
 	 */
-	switch (DIV_ROUND_UP(sgtl5000->sysclk, sys_fs)) {
+	switch (DIV_ROUND_CLOSEST(sgtl5000->sysclk, sys_fs)) {
 	case 256:
 		clk_ctl |= SGTL5000_MCLK_FREQ_256FS <<
 			SGTL5000_MCLK_FREQ_SHIFT;
@@ -1451,8 +1453,9 @@ static int sgtl5000_fill_defaults(struct sgtl5000_priv *sgtl5000)
 static int sgtl5000_i2c_probe(struct i2c_client *client,
 			      const struct i2c_device_id *id)
 {
+	struct device_node *np = client->dev.of_node;
 	struct sgtl5000_priv *sgtl5000;
-	int ret, reg, rev;
+	int ret, reg, rev, period;
 
 	sgtl5000 = devm_kzalloc(&client->dev, sizeof(struct sgtl5000_priv),
 								GFP_KERNEL);
@@ -1469,21 +1472,34 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 	sgtl5000->mclk = devm_clk_get(&client->dev, NULL);
 	if (IS_ERR(sgtl5000->mclk)) {
 		ret = PTR_ERR(sgtl5000->mclk);
-		dev_err(&client->dev, "Failed to get mclock: %d\n", ret);
-		/* Defer the probe to see if the clk will be provided later */
-		if (ret == -ENOENT)
-			return -EPROBE_DEFER;
-		return ret;
+		sgtl5000->pwm = devm_of_pwm_get(&client->dev, np, NULL);
+		if (IS_ERR(sgtl5000->pwm)) {
+			/* Defer the probe to see if the clk will be provided later */
+			dev_err(&client->dev, "Failed to get mclock, defering: %d\n", ret);
+			if (ret == -ENOENT)
+				return -EPROBE_DEFER;
+			return ret;
+		}
+		period = pwm_get_period(sgtl5000->pwm);
+		ret = pwm_config(sgtl5000->pwm, period / 2, period); 
+		if (ret)
+			return ret;
+		ret = pwm_enable(sgtl5000->pwm);
+		if (ret)
+			return ret;
+	} else {
+		ret = clk_prepare_enable(sgtl5000->mclk);
+		if (ret)
+			return ret;
 	}
 
-	ret = clk_prepare_enable(sgtl5000->mclk);
-	if (ret)
-		return ret;
-
 	/* read chip information */
 	ret = regmap_read(sgtl5000->regmap, SGTL5000_CHIP_ID, &reg);
-	if (ret)
+	if (ret) {
+		dev_err(&client->dev,
+			"Unable to read I2C %d\n", reg);
 		goto disable_clk;
+	}
 
 	if (((reg & SGTL5000_PARTID_MASK) >> SGTL5000_PARTID_SHIFT) !=
 	    SGTL5000_PARTID_PART_ID) {
diff --git a/sound/soc/generic/simple-card.c b/sound/soc/generic/simple-card.c
index e10dd51..c123fa7 100644
--- a/sound/soc/generic/simple-card.c
+++ b/sound/soc/generic/simple-card.c
@@ -8,6 +8,9 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+
+#define DEBUG
+
 #include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/module.h>
diff --git a/sound/soc/sunxi/sunxi-i2s.c b/sound/soc/sunxi/sunxi-i2s.c
index f77f33c..27505b8 100644
--- a/sound/soc/sunxi/sunxi-i2s.c
+++ b/sound/soc/sunxi/sunxi-i2s.c
@@ -119,14 +119,14 @@ void sunxi_snd_txctrl_i2s(struct sunxi_priv *priv, struct snd_pcm_substream *sub
 		regmap_update_bits(priv->regmap, SUNXI_I2S_INT, SUNXI_I2SINT_TXDRQEN_MASK, 0);
 	}
 
-/*	{
+	{
 	int i;
 	for (i = SUNXI_I2S_CTL; i <= SUNXI_I2S_RXCHMAP; i += 4)  {
 		regmap_read(priv->regmap, i, &reg_val);
 		printk("REG %02x VAL %08x\n", i, reg_val);
 	}
 	}
-*/
+
 }
 
 void sunxi_snd_rxctrl_i2s(struct sunxi_priv *priv, int on)
@@ -153,18 +153,11 @@ void sunxi_snd_rxctrl_i2s(struct sunxi_priv *priv, int on)
 	}
 }
 
-static inline int sunxi_snd_is_clkmaster(struct sunxi_priv *priv)
-{
-	u32 reg_val;
-
-	regmap_read(priv->regmap, SUNXI_I2S_CTL, &reg_val);
-	return ((reg_val & SUNXI_I2SCTL_MS_MASK) ? 0 : 1);
-}
-
 static int sunxi_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
 {
 	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
 	u32 reg_val;
+	int ret;
 
 	printk("JDS - sunxi_i2s_set_fmt %08x\n", fmt);
 
@@ -187,6 +180,16 @@ static int sunxi_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
 		regmap_update_bits(priv->regmap, SUNXI_I2S_CTL, SUNXI_I2SCTL_MS_MASK, 0);
 		printk("JDS - sunxi_i2s_set_fmt master\n");
 		priv->master = 1;
+		/* Enable iis on a basic rate */
+		ret = clk_set_rate(priv->clk_iis, 24576000);
+		if (ret) {
+			dev_err(priv->dev, "failed to set i2s base clock rate\n");
+			return ret;
+		}
+		if (clk_prepare_enable(priv->clk_iis)) {
+			dev_err(priv->dev, "failed to enable iis clock\n");
+			return -EINVAL;
+		}
 		break;
 	default:
 		return -EINVAL;
@@ -576,6 +579,7 @@ static const struct regmap_config sunxi_i2s_regmap_config = {
 	.val_bits	= 32,
 	.max_register 	= SUNXI_I2S_RXCHMAP,
 	.volatile_table	= &sunxi_i2s_volatile_regs,
+	.fast_io	= true,
 };
 
 static const struct of_device_id sunxi_i2s_of_match[] = {
@@ -609,6 +613,7 @@ static int sunxi_i2s_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	priv->revision = (enum sunxi_soc_family)of_id->data;
+	priv->dev = &pdev->dev;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	base = devm_ioremap_resource(dev, res);
@@ -631,7 +636,7 @@ static int sunxi_i2s_probe(struct platform_device *pdev)
 		dev_err(dev, "failed to get iis clock\n");
 		return PTR_ERR(priv->clk_iis);
 	}
-
+#ifdef JDS
 	/* Enable iis on a basic rate */
 	ret = clk_set_rate(priv->clk_iis, 24576000);
 	if (ret) {
@@ -642,7 +647,7 @@ static int sunxi_i2s_probe(struct platform_device *pdev)
 		dev_err(dev, "failed to enable iis clock\n");
 		return -EINVAL;
 	}
-
+#endif
 	/* Enable the bus clock */
 	if (clk_prepare_enable(priv->clk_apb)) {
 		dev_err(dev, "failed to enable apb clock\n");
diff --git a/sound/soc/sunxi/sunxi-i2s.h b/sound/soc/sunxi/sunxi-i2s.h
index 0401af7..ccd8906 100644
--- a/sound/soc/sunxi/sunxi-i2s.h
+++ b/sound/soc/sunxi/sunxi-i2s.h
@@ -393,6 +393,7 @@ struct sunxi_priv {
 	struct clk *clk_apb, *clk_iis, *clk_mclk;
 	struct clk_divider mclk_div;
 	int master, sysclk;
+	struct device *dev;
 
 	struct snd_dmaengine_dai_dma_data playback_dma_data;
 	struct snd_dmaengine_dai_dma_data capture_dma_data;
