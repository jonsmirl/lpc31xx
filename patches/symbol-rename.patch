Bottom: 9e99bf9a5a0ac73d643ca2fe99b58cbc2961809c
Top:    36d1245146ab853483073c38c6f743107de19178
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-06-09 16:20:05 -0400

r2


---

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 4cfb074..72fff0a 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -987,7 +987,7 @@ config ARCH_LPC31XX
 	select ARCH_REQUIRE_GPIOLIB
 	select ARCH_USES_GETTIMEOFFSET
 	help
-	  Say Y here for systems based on one of the NXP LPC313x & LPC315x
+	  Say Y here for systems based on one of the NXP LPC31xx
 	  System on a Chip processors.  These CPUs include an ARM926EJS
 	  core with a wide array of integrated devices for
 	  hand-held and low-power applications.
diff --git a/arch/arm/mach-lpc31xx/Kconfig b/arch/arm/mach-lpc31xx/Kconfig
index 63ce681..7b0478d 100644
--- a/arch/arm/mach-lpc31xx/Kconfig
+++ b/arch/arm/mach-lpc31xx/Kconfig
@@ -1,8 +1,8 @@
-menu "LPC313x Implementations"
+menu "LPC31xx Implementations"
 	depends on ARCH_LPC31XX
 
 choice
-	prompt "LPC313x Platform type"
+	prompt "LPC31xx Platform type"
 	default MACH_EA313X
 
 config MACH_EA313X
diff --git a/arch/arm/mach-lpc31xx/board-ea313x.c b/arch/arm/mach-lpc31xx/board-ea313x.c
index aa11885..5c659ca 100644
--- a/arch/arm/mach-lpc31xx/board-ea313x.c
+++ b/arch/arm/mach-lpc31xx/board-ea313x.c
@@ -1,4 +1,4 @@
-/*  arch/arm/mach-lpc313x/ea313x.c
+/*  arch/arm/mach-lpc31xx/ea313x.c
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
@@ -59,7 +59,7 @@
 reads but just changes address. But DM9000 requires nCS and nOE change between address. So access
 other chip select area (nCS0) to force de-assertion of nCS1 and nOE1. Or else wait for long time
 such as 80 usecs.
-LPC313x has external logic outside of MPMC IP to toggle nOE to split consecutive reads.
+LPC31xx has external logic outside of MPMC IP to toggle nOE to split consecutive reads.
 The latest Apex bootloader patch makes use of this feature.
 For this to work SYS_MPMC_WTD_DEL0 & SYS_MPMC_WTD_DEL1 should be programmed with MPMC_STWTRD0
 & MPMC_STWTRD1 values. The logic only deactivates the nOE for one clock cycle which is
@@ -105,7 +105,7 @@ static struct i2c_board_info ea3152_i2c1_devices[] __initdata = {
 };
 #endif
 
-void lpc313x_vbus_power(int enable)
+void lpc31xx_vbus_power(int enable)
 {
 	printk (KERN_INFO "enabling USB host vbus_power %d\n", enable);
 	//gpio_set_value(VBUS_PWR_EN, enable);
@@ -139,10 +139,10 @@ static const char *ea3131_dt_match[] __initconst = {
 };
 
 DT_MACHINE_START(EA313X, "NXP EA3131 (Device Tree Support)")
-	.map_io		= lpc313x_map_io,
+	.map_io		= lpc31xx_map_io,
 	.init_early	= lpc31xx_init_early,
 	.init_irq	= lpc31xx_init_irq,
-	.timer		= &lpc313x_timer,
+	.timer		= &lpc31xx_timer,
 	.init_machine	= ea3131_dt_init,
 	.dt_compat	= ea3131_dt_match,
 	.restart	= arch_reset,
diff --git a/arch/arm/mach-lpc31xx/board-val3153.c b/arch/arm/mach-lpc31xx/board-val3153.c
deleted file mode 100644
index addfb0f..0000000
--- a/arch/arm/mach-lpc31xx/board-val3153.c
+++ /dev/null
@@ -1,460 +0,0 @@
-/*  arch/arm/mach-lpc313x/val3153.c
- *
- *  Author:	Durgesh Pattamatta
- *  Copyright (C) 2009 NXP semiconductors
- *
- *  VAL3153 board init routines.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#include <linux/device.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/spi/spi.h>
-#include <linux/delay.h>
-#include <asm/system.h>
-
-#include <mach/hardware.h>
-#include <asm/irq.h>
-#include <asm/pgtable.h>
-#include <asm/page.h>
-#include <asm/sizes.h>
-
-#include <asm/mach/map.h>
-#include <asm/mach-types.h>
-
-#include <asm/mach/arch.h>
-#include <mach/gpio.h>
-#include <mach/board.h>
-
-/* mci platform functions */
-static int mci_init(u32 slot_id, irq_handler_t , void *);
-static int mci_get_ro(u32 slot_id);
-static int mci_get_cd(u32 slot_id);
-static int mci_get_ocr(u32 slot_id);
-static void mci_setpower(u32 slot_id, u32 volt);
-static void mci_exit(u32 slot_id);
-static void mci_select_slot(u32 slot_id);
-static int mci_get_bus_wd(u32 slot_id);
-
-
-static struct resource cs89x0_resources[] = {
-	[0] = {
-		.start	= EXT_SRAM1_PHYS + 0x10000,
-		.end	= EXT_SRAM1_PHYS + 0x10000 + 16,
-		.flags	= IORESOURCE_MEM,
-	} ,
-	[1] = {
-		.start	= IRQ_CS8900_ETH_INT,
-		.end	= IRQ_CS8900_ETH_INT,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device cs89x0_device = {
-	.name		= "cs89x0",
-	.num_resources	= ARRAY_SIZE(cs89x0_resources),
-	.resource	= cs89x0_resources,
-};
-
-static struct resource lpc313x_mci_resources[] = {
-	[0] = {
-		.start  = IO_SDMMC_PHYS,
-		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_MCI,
-		.end	= IRQ_MCI,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-#if defined (CONFIG_MTD_NAND_LPC313X)
-static struct resource lpc313x_nand_resources[] = {
-	[0] = {
-		.start  = IO_NAND_PHYS,
-		.end	= IO_NAND_PHYS + IO_NAND_SIZE,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start 	= IO_NAND_BUF_PHYS,
-		.end 	= IO_NAND_BUF_PHYS + IO_NAND_BUF_SIZE,
-		.flags	= IORESOURCE_MEM,
-	},
-	[2] = {
-		.start 	= IRQ_NAND_FLASH,
-		.end 	= IRQ_NAND_FLASH,
-		.flags	= IORESOURCE_IRQ,
-	}
-};
-
-#define BLK_SIZE (2048 * 64)
-static struct mtd_partition val3153_nand0_partitions[] = {
-	{
-		.name	= "lpc313x-boot",
-		.offset	= 0,
-		.size	= (BLK_SIZE * 1)
-	},
-	{
-		.name	= "apex",
-		.offset	= (BLK_SIZE * 1),
-		.size	= (BLK_SIZE * 3)
-	},
-	{
-		.name	= "apex-prms",
-		.offset	= (BLK_SIZE * 4),
-		.size	= (BLK_SIZE * 2)
-	},
-	{
-		.name	= "lpc313x-kernel",
-		.offset	= (BLK_SIZE * 6),
-		.size	= (BLK_SIZE * 32) /* 4MB space */
-	},
-	{
-		.name	= "lpc313x-ramdsk",
-		.offset	= (BLK_SIZE * 38),
-		.size	= (BLK_SIZE * 128) /* 16MB space */
-	},
-	{
-		.name	= "lpc313x-rootfs",
-		.offset	= (BLK_SIZE * 166),
-		.size	= MTDPART_SIZ_FULL
-	},
-};
-
-static struct lpc313x_nand_timing val3153_nanddev_timing = {
-	.ns_trsd	= 80, // FIXME - need to optimize timings
-	.ns_tals	= 80,
-	.ns_talh	= 80,
-	.ns_tcls	= 80,
-	.ns_tclh	= 80,
-	.ns_tdrd	= 80,
-	.ns_tebidel	= 80,
-	.ns_tch		= 80,
-	.ns_tcs		= 80,
-	.ns_treh	= 80,
-	.ns_trp		= 80,
-	.ns_trw		= 80,
-	.ns_twp		= 80
-};
-
-static struct lpc313x_nand_dev_info val3153_ndev[] = {
-	{
-		.name		= "nand0",
-		.nr_partitions	= ARRAY_SIZE(val3153_nand0_partitions),
-		.partitions	= val3153_nand0_partitions
-	}
-};
-
-static struct lpc313x_nand_cfg val3153_plat_nand = {
-	.nr_devices	= ARRAY_SIZE(val3153_ndev),
-	.devices	= val3153_ndev,
-	.timing		= &val3153_nanddev_timing,
-	.support_16bit	= 0,
-};
-
-static u64 nand_dmamask = 0xffffffffUL;
-static struct platform_device	lpc313x_nand_device = {
-	.name		= "lpc313x_nand",
-	.dev		= {
-		.dma_mask		= &nand_dmamask,
-		.coherent_dma_mask	= 0xffffffff,
-				.platform_data	= &val3153_plat_nand,
-	},
-	.num_resources	= ARRAY_SIZE(lpc313x_nand_resources),
-	.resource	= lpc313x_nand_resources,
-};
-#endif
-
-#if defined(CONFIG_SPI_LPC313X)
-static struct resource lpc313x_spi_resources[] = {
-	[0] = {
-		.start	= SPI_PHYS,
-		.end	= SPI_PHYS + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_SPI,
-		.end	= IRQ_SPI,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static void spi_set_cs_state(int cs_num, int state)
-{
-	/* Only CS0 is supported, so no checks are needed */
-	(void) cs_num;
-
-	/* Set GPO state for CS0 */
-	lpc313x_gpio_set_value(GPIO_SPI_CS_OUT0, state);
-}
-
-struct lpc313x_spics_cfg lpc313x_stdspics_cfg[] =
-{
-	/* SPI CS0 */
-	[0] =
-	{
-		.spi_spo	= 0, /* Low clock between transfers */
-		.spi_sph	= 0, /* Data capture on first clock edge (high edge with spi_spo=0) */
-		.spi_cs_set	= spi_set_cs_state,
-	},
-};
-
-struct lpc313x_spi_cfg lpc313x_spidata =
-{
-	.num_cs			= ARRAY_SIZE(lpc313x_stdspics_cfg),
-	.spics_cfg		= lpc313x_stdspics_cfg,
-};
-
-static u64 lpc313x_spi_dma_mask = 0xffffffffUL;
-static struct platform_device lpc313x_spi_device = {
-	.name		= "spi_lpc313x",
-	.id		= 0,
-	.dev		= {
-		.dma_mask = &lpc313x_spi_dma_mask,
-		.coherent_dma_mask = 0xffffffffUL,
-		.platform_data	= &lpc313x_spidata,
-	},
-	.num_resources	= ARRAY_SIZE(lpc313x_spi_resources),
-	.resource	= lpc313x_spi_resources,
-};
-
-/* If both SPIDEV and MTD data flash are enabled with the same chip select, only 1 will work */
-#if defined(CONFIG_SPI_SPIDEV)
-/* SPIDEV driver registration */
-static int __init lpc313x_spidev_register(void)
-{
-	struct spi_board_info info =
-	{
-		.modalias = "spidev",
-		.max_speed_hz = 1000000,
-		.bus_num = 0,
-		.chip_select = 0,
-	};
-
-	return spi_register_board_info(&info, 1);
-}
-arch_initcall(lpc313x_spidev_register);
-#endif
-#endif
-
-
-static struct lpc313x_mci_board val3153_mci_platform_data = {
-	.num_slots		= 2,
-	.detect_delay_ms	= 250,
-	.init 			= mci_init,
-	.get_ro			= mci_get_ro,
-	.get_cd 		= mci_get_cd,
-	.get_ocr		= mci_get_ocr,
-	.get_bus_wd		= mci_get_bus_wd,
-	.setpower 		= mci_setpower,
-	.select_slot		= mci_select_slot,
-	.exit			= mci_exit,
-};
-
-static u64 mci_dmamask = 0xffffffffUL;
-static struct platform_device	lpc313x_mci_device = {
-	.name		= "lpc313x_mmc",
-	.num_resources	= ARRAY_SIZE(lpc313x_mci_resources),
-	.dev		= {
-		.dma_mask		= &mci_dmamask,
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &val3153_mci_platform_data,
-	},
-	.resource	= lpc313x_mci_resources,
-};
-
-
-
-static struct platform_device *devices[] __initdata = {
-	&cs89x0_device,
-	&lpc313x_mci_device,
-#if defined (CONFIG_MTD_NAND_LPC313X)
-	&lpc313x_nand_device,
-#endif
-#if defined(CONFIG_SPI_LPC313X)
-	&lpc313x_spi_device,
-#endif
-
-};
-
-static struct map_desc val3153_io_desc[] __initdata = {
-	{
-		.virtual	= io_p2v(EXT_SRAM0_PHYS),
-		.pfn		= __phys_to_pfn(EXT_SRAM0_PHYS),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(EXT_SRAM1_PHYS + 0x10000),
-		.pfn		= __phys_to_pfn(EXT_SRAM1_PHYS + 0x10000),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_SDMMC_PHYS),
-		.pfn		= __phys_to_pfn(IO_SDMMC_PHYS),
-		.length		= IO_SDMMC_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_NAND_PHYS),
-		.pfn		= __phys_to_pfn(IO_NAND_PHYS),
-		.length		= IO_NAND_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_NAND_BUF_PHYS),
-		.pfn		= __phys_to_pfn(IO_NAND_BUF_PHYS),
-		.length		= IO_NAND_BUF_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_USB_PHYS),
-		.pfn		= __phys_to_pfn(IO_USB_PHYS),
-		.length		= IO_USB_SIZE,
-		.type		= MT_DEVICE
-	},
-
-};
-
-static struct lpc313x_mci_irq_data irq_data[2] = {
-	{
-		.irq = IRQ_SDMMC_CD0,
-	},
-	{
-		.irq = IRQ_SDMMC_CD1,
-	},
-};
-
-static irqreturn_t val313x_mci_detect_interrupt(int irq, void *data)
-{
-	struct lpc313x_mci_irq_data	*pdata = data;
-	u32 slot_id = (pdata->irq == irq_data[0].irq)?0:1;
-
-	/* select the opposite level senstivity */
-	int level = mci_get_cd(slot_id)?IRQ_TYPE_LEVEL_LOW:IRQ_TYPE_LEVEL_HIGH;
-
-	set_irq_type(pdata->irq, level);
-
-	/* change the polarity of irq trigger */
-	return pdata->irq_hdlr(irq, pdata->data);
-}
-
-static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
-{
-	int ret;
-	/* select the opposite level senstivity */
-	int level = mci_get_cd(slot_id)?IRQ_TYPE_LEVEL_LOW:IRQ_TYPE_LEVEL_HIGH;
-
-	/* set slot_select, cd and wp pins as GPIO pins */
-	gpio_direction_input(GPIO_GPIO12);
-	gpio_direction_input(GPIO_GPIO13);
-	gpio_direction_input(GPIO_GPIO14);
-	gpio_direction_input(GPIO_GPIO15);
-	gpio_direction_input(GPIO_MI2STX_DATA0);
-
-	/* set card detect irq info */
-	irq_data[slot_id].data = data;
-	irq_data[slot_id].irq_hdlr = irqhdlr;
-	set_irq_type(irq_data[slot_id].irq, level);
-	ret = request_irq(irq_data[slot_id].irq,
-			val313x_mci_detect_interrupt,
-			level,
-			(slot_id)?"mmc-cd1":"mmc-cd0",
-			&irq_data[slot_id]);
-
-	/****temporary for PM testing */
-	enable_irq_wake(irq_data[0].irq);
-	enable_irq_wake(irq_data[1].irq);
-	return ret;
-
-}
-
-static int mci_get_ro(u32 slot_id)
-{
-	return gpio_get_value((slot_id)?GPIO_GPIO15:GPIO_GPIO14);
-}
-
-static int mci_get_cd(u32 slot_id)
-{
-	return gpio_get_value((slot_id)?GPIO_GPIO13:GPIO_GPIO12);
-}
-
-static int mci_get_ocr(u32 slot_id)
-{
-	return MMC_VDD_32_33 | MMC_VDD_33_34;
-}
-
-static void mci_setpower(u32 slot_id, u32 volt)
-{
-	/* power is always on for both slots nothing to do*/
-}
-
-static void mci_exit(u32 slot_id)
-{
-	free_irq(irq_data[slot_id].irq, &irq_data[slot_id]);
-}
-
-static void mci_select_slot(u32 slot_id)
-{
-	/* select slot 1 for anything other than 0*/
-	gpio_set_value(GPIO_MI2STX_DATA0, (slot_id)?1:0);
-}
-static int mci_get_bus_wd(u32 slot_id)
-{
-	return 4;
-}
-
-void lpc313x_vbus_power(int enable)
-{
-	printk(KERN_INFO "%s VBUS power!!!\n", (enable)?"Enabling":"Disabling" );
-	if (enable) 
-		gpio_set_value(GPIO_GPIO18, 0);
-	else
-		gpio_set_value(GPIO_GPIO18, 1);
-
-	udelay(500);
-	udelay(500);
-}
-
-
-static void __init val3153_init(void)
-{
-	lpc313x_init();
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-}
-
-static void __init val3153_map_io(void)
-{
-	lpc313x_map_io();
-	iotable_init(val3153_io_desc, ARRAY_SIZE(val3153_io_desc));
-}
-
-MACHINE_START(VAL3153, "NXP VAL3153")
-	/* Maintainer: Durgesh Pattamatta, NXP */
-	.phys_io	= IO_APB01_PHYS,
-	.io_pg_offst	= (io_p2v(IO_APB01_PHYS) >> 18) & 0xfffc,
-	.boot_params	= 0x30000100,
-	.map_io		= val3153_map_io,
-	.init_irq	= lpc313x_init_irq,
-	.timer		= &lpc313x_timer,
-	.init_machine	= val3153_init,
-MACHINE_END
diff --git a/arch/arm/mach-lpc31xx/borad-val3154.c b/arch/arm/mach-lpc31xx/borad-val3154.c
deleted file mode 100644
index 4cc59d0..0000000
--- a/arch/arm/mach-lpc31xx/borad-val3154.c
+++ /dev/null
@@ -1,304 +0,0 @@
-/*  arch/arm/mach-lpc313x/val3154.c
- *
- *  Author:	Durgesh Pattamatta
- *  Copyright (C) 2009 NXP semiconductors
- *
- *  val3154 board init routines.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#include <linux/device.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/spi/spi.h>
-
-#include <asm/system.h>
-#include <mach/hardware.h>
-#include <asm/irq.h>
-#include <asm/pgtable.h>
-#include <asm/page.h>
-#include <asm/sizes.h>
-
-#include <asm/mach/map.h>
-#include <asm/mach-types.h>
-
-#include <asm/mach/arch.h>
-#include <mach/gpio.h>
-#include <mach/i2c.h>
-#include <mach/board.h>
-
-/* mci platform functions */
-static int mci_init(u32 slot_id, irq_handler_t , void *);
-static int mci_get_ro(u32 slot_id);
-static int mci_get_cd(u32 slot_id);
-static int mci_get_ocr(u32 slot_id);
-static void mci_setpower(u32 slot_id, u32 volt);
-static void mci_exit(u32 slot_id);
-static int mci_get_bus_wd(u32 slot_id);
-
-static struct resource lpc313x_mci_resources[] = {
-	[0] = {
-		.start  = IO_SDMMC_PHYS,
-		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_MCI,
-		.end	= IRQ_MCI,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-static struct lpc313x_mci_board val3154_mci_platform_data = {
-	.num_slots		= 1,
-	.detect_delay_ms	= 250,
-	.init 			= mci_init,
-	.get_ro			= mci_get_ro,
-	.get_cd 		= mci_get_cd,
-	.get_ocr		= mci_get_ocr,
-	.get_bus_wd		= mci_get_bus_wd,
-	.setpower 		= mci_setpower,
-	.exit			= mci_exit,
-};
-
-static u64 mci_dmamask = 0xffffffffUL;
-static struct platform_device	lpc313x_mci_device = {
-	.name		= "lpc313x_mmc",
-	.num_resources	= ARRAY_SIZE(lpc313x_mci_resources),
-	.dev		= {
-		.dma_mask		= &mci_dmamask,
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &val3154_mci_platform_data,
-	},
-	.resource	= lpc313x_mci_resources,
-};
-
-
-#if defined(CONFIG_SPI_LPC313X)
-static struct resource lpc313x_spi_resources[] = {
-	[0] = {
-		.start	= SPI_PHYS,
-		.end	= SPI_PHYS + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_SPI,
-		.end	= IRQ_SPI,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static void spi_set_cs_state(int cs_num, int state)
-{
-	/* Only CS0 is supported, so no checks are needed */
-	(void) cs_num;
-
-	/* Set GPO state for CS0 */
-	lpc313x_gpio_set_value(GPIO_SPI_CS_OUT0, state);
-}
-
-struct lpc313x_spics_cfg lpc313x_stdspics_cfg[] =
-{
-	/* SPI CS0 */
-	[0] =
-	{
-		.spi_spo	= 0, /* Low clock between transfers */
-		.spi_sph	= 0, /* Data capture on first clock edge (high edge with spi_spo=0) */
-		.spi_cs_set	= spi_set_cs_state,
-	},
-};
-
-struct lpc313x_spi_cfg lpc313x_spidata =
-{
-	.num_cs			= ARRAY_SIZE(lpc313x_stdspics_cfg),
-	.spics_cfg		= lpc313x_stdspics_cfg,
-};
-
-static u64 lpc313x_spi_dma_mask = 0xffffffffUL;
-static struct platform_device lpc313x_spi_device = {
-	.name		= "spi_lpc313x",
-	.id		= 0,
-	.dev		= {
-		.dma_mask = &lpc313x_spi_dma_mask,
-		.coherent_dma_mask = 0xffffffffUL,
-		.platform_data	= &lpc313x_spidata,
-	},
-	.num_resources	= ARRAY_SIZE(lpc313x_spi_resources),
-	.resource	= lpc313x_spi_resources,
-};
-
-/* If both SPIDEV and MTD data flash are enabled, only 1 will work */
-#if defined(CONFIG_SPI_SPIDEV)
-/* SPIDEV driver registration */
-static int __init lpc313x_spidev_register(void)
-{
-	struct spi_board_info info =
-	{
-		.modalias = "spidev",
-		.max_speed_hz = 1000000,
-		.bus_num = 0,
-		.chip_select = 0,
-	};
-
-	return spi_register_board_info(&info, 1);
-}
-arch_initcall(lpc313x_spidev_register);
-#endif
-#endif
-
-
-static struct platform_device *devices[] __initdata = {
-	&lpc313x_mci_device,
-#if defined(CONFIG_SPI_LPC313X)
-	&lpc313x_spi_device,
-#endif
-};
-
-static struct map_desc val3154_io_desc[] __initdata = {
-	{
-		.virtual	= io_p2v(EXT_SRAM0_PHYS),
-		.pfn		= __phys_to_pfn(EXT_SRAM0_PHYS),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(EXT_SRAM1_PHYS + 0x10000),
-		.pfn		= __phys_to_pfn(EXT_SRAM1_PHYS + 0x10000),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_SDMMC_PHYS),
-		.pfn		= __phys_to_pfn(IO_SDMMC_PHYS),
-		.length		= IO_SDMMC_SIZE,
-		.type		= MT_DEVICE
-	},
-};
-
-static struct i2c_board_info val3154_i2c_devices[] __initdata = {
-	{
-		I2C_BOARD_INFO("lpc3152-psu", 0x0C),
-	},
-};
-
-static struct lpc313x_mci_irq_data irq_data = {
-	.irq = IRQ_SDMMC_CD,
-};
-
-static irqreturn_t val3154_mci_detect_interrupt(int irq, void *data)
-{
-	struct lpc313x_mci_irq_data	*pdata = data;
-
-	/* select the opposite level senstivity */
-	int level = mci_get_cd(0)?IRQ_TYPE_LEVEL_LOW:IRQ_TYPE_LEVEL_HIGH;
-
-	set_irq_type(pdata->irq, level);
-
-	/* change the polarity of irq trigger */
-	return pdata->irq_hdlr(irq, pdata->data);
-}
-
-static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
-{
-	int ret;
-	/* select the opposite level senstivity */
-	int level = mci_get_cd(0)?IRQ_TYPE_LEVEL_LOW:IRQ_TYPE_LEVEL_HIGH;
-
-	/* set slot_select, cd and wp pins as GPIO pins */
-	gpio_direction_input(GPIO_MI2STX_BCK0);
-
-	/* set card detect irq info */
-	irq_data.data = data;
-	irq_data.irq_hdlr = irqhdlr;
-	set_irq_type(irq_data.irq, level);
-	ret = request_irq(irq_data.irq,
-			val3154_mci_detect_interrupt,
-			level,
-			"mmc-cd", 
-			&irq_data);
-	return ret;
-
-}
-
-static int mci_get_ro(u32 slot_id)
-{
-	return 0;
-}
-
-static int mci_get_cd(u32 slot_id)
-{
-	return gpio_get_value(GPIO_MI2STX_BCK0);
-}
-
-static int mci_get_ocr(u32 slot_id)
-{
-	return MMC_VDD_32_33 | MMC_VDD_33_34;
-}
-
-static void mci_setpower(u32 slot_id, u32 volt)
-{
-	gpio_set_value(GPIO_MI2STX_DATA0, 0);
-}
-static int mci_get_bus_wd(u32 slot_id)
-{
-	return 4;
-}
-
-static void mci_exit(u32 slot_id)
-{
-	free_irq(irq_data.irq, &irq_data);
-}
-
-void lpc313x_vbus_power(int enable)
-{
-	if (enable) 
-		gpio_set_value(GPIO_I2SRX_DATA0, 1);
-	else
-		gpio_set_value(GPIO_I2SRX_DATA0, 0);
-}
-
-static void __init val3154_init(void)
-{
-	lpc313x_init();
-	/* register i2cdevices */
-	lpc313x_register_i2c_devices();
-	
-	i2c_register_board_info(1, val3154_i2c_devices,
-		ARRAY_SIZE(val3154_i2c_devices));
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-}
-
-static void __init val3154_map_io(void)
-{
-	lpc313x_map_io();
-	iotable_init(val3154_io_desc, ARRAY_SIZE(val3154_io_desc));
-}
-
-
-MACHINE_START(VAL3154, "NXP VAL3154")
-	/* Maintainer: Durgesh Pattamatta, NXP */
-	.phys_io	= IO_APB01_PHYS,
-	.io_pg_offst	= (io_p2v(IO_APB01_PHYS) >> 18) & 0xfffc,
-	.boot_params	= 0x30000100,
-	.map_io		= val3154_map_io,
-	.init_irq	= lpc313x_init_irq,
-	.timer		= &lpc313x_timer,
-	.init_machine	= val3154_init,
-MACHINE_END
diff --git a/arch/arm/mach-lpc31xx/clock.c b/arch/arm/mach-lpc31xx/clock.c
index 2bc3921..51d623b 100644
--- a/arch/arm/mach-lpc31xx/clock.c
+++ b/arch/arm/mach-lpc31xx/clock.c
@@ -1,9 +1,9 @@
-/*  arch/arm/mach-lpc313x/clock.c
+/*  arch/arm/mach-lpc31xx/clock.c
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- *  CGU driver for LPC313x & LPC315x.
+ *  CGU driver for LPC31xx
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -692,7 +692,7 @@ u32 cgu_get_pll_freq(CGU_HPLL_ID_T pll_id, u32 infreq)
  * The debugfs stuff below is mostly optimized away when
  * CONFIG_DEBUG_FS is not set.
  */
-static int lpc313x_cgu_clocks_show(struct seq_file *s, void *v)
+static int lpc31xx_cgu_clocks_show(struct seq_file *s, void *v)
 {
 	u32 clk_id = CGU_SYS_FIRST;
 	u32 end_id = (CGU_SYSCLK_O_LAST + 1);
@@ -709,32 +709,32 @@ static int lpc313x_cgu_clocks_show(struct seq_file *s, void *v)
 	return 0;
 }
 
-static int lpc313x_cgu_clocks_open(struct inode *inode, struct file *file)
+static int lpc31xx_cgu_clocks_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, lpc313x_cgu_clocks_show, inode->i_private);
+	return single_open(file, lpc31xx_cgu_clocks_show, inode->i_private);
 }
 
-static const struct file_operations lpc313x_cgu_clocks_fops = {
+static const struct file_operations lpc31xx_cgu_clocks_fops = {
 	.owner		= THIS_MODULE,
-	.open		= lpc313x_cgu_clocks_open,
+	.open		= lpc31xx_cgu_clocks_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
 	.release	= single_release,
 };
 
-static void lpc313x_cgu_init_debugfs(void)
+static void lpc31xx_cgu_init_debugfs(void)
 {
 	struct dentry		*node;
 
 	node = debugfs_create_file("cgu_clks", S_IRUSR, NULL, NULL,
-			&lpc313x_cgu_clocks_fops);
+			&lpc31xx_cgu_clocks_fops);
 	if (IS_ERR(node))
 		printk("cgu_init: failed to initialize debugfs for CGU\n");
 
 	return;
 }
 #else
-static void lpc313x_cgu_init_debugfs(void) {}
+static void lpc31xx_cgu_init_debugfs(void) {}
 #endif
 /***********************************************************************
 * Initialize CGU data structure with PLL frequency passed by the boot 
@@ -776,7 +776,7 @@ int __init cgu_init(char *str)
 	g_clkin_freq[6] = cgu_get_pll_freq(CGU_HPLL1_ID, FFAST_CLOCK);
  	printk(/*KERN_INFO*/ "cgu_init pll set at %d\n", g_clkin_freq[6]);
 	
-	lpc313x_cgu_init_debugfs();
+	lpc31xx_cgu_init_debugfs();
 
 	return 0;
 }
diff --git a/arch/arm/mach-lpc31xx/dma.c b/arch/arm/mach-lpc31xx/dma.c
index 62e2ca0..e4bdcc1 100644
--- a/arch/arm/mach-lpc31xx/dma.c
+++ b/arch/arm/mach-lpc31xx/dma.c
@@ -1,9 +1,9 @@
-/*  arch/arm/mach-lpc313x/dma.c
+/*  arch/arm/mach-lpc31xx/dma.c
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- *  DMA driver for machines with LPC313x and LPC315x SoCs.
+ *  DMA driver for machines with LPC31xx SoCs.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -38,12 +38,12 @@
 #ifdef LPDMA
 static spinlock_t driver_lock; /* to guard state variables */
 
-static inline void lpc313x_dma_lock(void)
+static inline void lpc31xx_dma_lock(void)
 {
 	spin_lock(&driver_lock);
 }
 
-static inline void lpc313x_dma_unlock(void)
+static inline void lpc31xx_dma_unlock(void)
 {
 	spin_unlock(&driver_lock);
 }
@@ -113,7 +113,7 @@ int dma_request_channel_x (char *name, dma_cb_t cb, void *data)
 	if (!name)
 		return -EINVAL;
 
-	lpc313x_dma_lock();
+	lpc31xx_dma_lock();
 
 	memset(&dma_setup, 0, sizeof(dma_setup));
 
@@ -132,12 +132,12 @@ int dma_request_channel_x (char *name, dma_cb_t cb, void *data)
 		        dma_irq_mask &= ~mask;  /* enable the IRQ: dafault behavior */
 			DMACH_IRQ_MASK = dma_irq_mask;
 			local_irq_restore(flags);
-			lpc313x_dma_unlock();
+			lpc31xx_dma_unlock();
 			return chn;
 		}
 		mask = mask << 2;
 	}
-	lpc313x_dma_unlock();
+	lpc31xx_dma_unlock();
 	return -EBUSY;
 }
 
@@ -153,7 +153,7 @@ int dma_request_specific_channel (int chn, char *name, void (*cb)(int, dma_irq_t
 	if (dma_channels[chn].name)
 		return -EBUSY;
 
-	lpc313x_dma_lock();
+	lpc31xx_dma_lock();
 
 	memset(&dma_setup, 0, sizeof(dma_setup));
 
@@ -168,7 +168,7 @@ int dma_request_specific_channel (int chn, char *name, void (*cb)(int, dma_irq_t
 	dma_irq_mask &= ~(1 << (2 * chn));  /* enable the IRQ: dafault behavior */
 	DMACH_IRQ_MASK = dma_irq_mask;
 	local_irq_restore(flags);
-	lpc313x_dma_unlock();
+	lpc31xx_dma_unlock();
 	return chn;
 }
 
@@ -181,7 +181,7 @@ int dma_set_irq_mask(unsigned int chn, int half_int, int fin_int)
 		return -EINVAL;
 	}
 
-	lpc313x_dma_lock();
+	lpc31xx_dma_lock();
 	local_irq_save(flags);
 
 	if (fin_int)
@@ -197,7 +197,7 @@ int dma_set_irq_mask(unsigned int chn, int half_int, int fin_int)
 	DMACH_IRQ_MASK = dma_irq_mask;
 
 	local_irq_restore(flags);
-	lpc313x_dma_unlock();
+	lpc31xx_dma_unlock();
 
 	return 0;
 }
@@ -242,7 +242,7 @@ int dma_release_channel_x (unsigned int chn)
 		return -EINVAL;
 	}
 
-	lpc313x_dma_lock();
+	lpc31xx_dma_lock();
 
 	local_irq_save(flags);
 
@@ -258,7 +258,7 @@ int dma_release_channel_x (unsigned int chn)
 	dma_channels[chn].callback_handler = NULL;
 	dma_channels[chn].data = NULL;
 
-	lpc313x_dma_unlock();
+	lpc31xx_dma_unlock();
 	dma_decrement_usage();
 
 	return 0;
@@ -368,7 +368,7 @@ int dma_request_sg_channel (char *name, dma_cb_t cb, void *data,
 	if (softirqen & usesoftirq)
 		return -EBUSY;
 
-	lpc313x_dma_lock();
+	lpc31xx_dma_lock();
 
 	for (chn = 0; chn < DMA_MAX_CHANNELS - 1; chn++)
 		if (!dma_channels[chn].name && !dma_channels[chn + 1].name) {
@@ -377,7 +377,7 @@ int dma_request_sg_channel (char *name, dma_cb_t cb, void *data,
 		}
 
 	if (!sg_higher_channel[chn]) {
-		lpc313x_dma_unlock();
+		lpc31xx_dma_unlock();
 		return -EBUSY;
 	}
 
@@ -406,7 +406,7 @@ int dma_request_sg_channel (char *name, dma_cb_t cb, void *data,
 		local_irq_restore(flags);
 	}
 
-	lpc313x_dma_unlock();
+	lpc31xx_dma_unlock();
 
 	return sg_higher_channel[chn];
 }
@@ -426,7 +426,7 @@ int dma_request_specific_sg_channel (int chn, char *name, dma_cb_t cb,
 	if (sg_higher_channel[chn] || dma_channels[chn].name || dma_channels[chn - 1].name)
 		return -EBUSY;
 
-	lpc313x_dma_lock();
+	lpc31xx_dma_lock();
 
 	sg_higher_channel[chn] = chn;
 
@@ -467,12 +467,12 @@ int dma_prog_sg_channel(int chn, u32 dma_sg_list)
 
 	dma_config = DMA_CFG_CMP_CH_EN | DMA_CFG_CMP_CH_NR(chn - 1);
 
-	lpc313x_dma_lock();
+	lpc31xx_dma_lock();
 	DMACH_SRC_ADDR(chn) = dma_sg_list;
 	DMACH_DST_ADDR(chn) = DMACH_ALT_PHYS(chn - 1);
 	DMACH_LEN(chn) = 0x4;
 	DMACH_CFG(chn) = dma_config;
-	lpc313x_dma_unlock();
+	lpc31xx_dma_unlock();
 
 	return 0;
 }
@@ -487,7 +487,7 @@ int dma_channel_enabled(unsigned int chn)
 }
 
 #if 0
-static int __init lpc313x_dma_init (void)
+static int __init lpc31xx_dma_init (void)
 {
 	int ret = 0;
 
@@ -512,7 +512,7 @@ int dma_release_sg_channel (unsigned int chn)
 		return -EINVAL;
 	}
 
-	lpc313x_dma_lock();
+	lpc31xx_dma_lock();
 
 	if (softirqmask[chn] != 0) {
 		local_irq_save(flags);
@@ -534,7 +534,7 @@ int dma_release_sg_channel (unsigned int chn)
 
 	sg_higher_channel[chn] = 0;
 
-	lpc313x_dma_unlock();
+	lpc31xx_dma_unlock();
 	dma_decrement_usage();
 	return 0;
 }
@@ -563,7 +563,7 @@ int dma_read_counter (unsigned int chn, unsigned int * pcnt){return 0;}
 int dma_prepare_sg_list(int n, dma_sg_ll_t * sg){return 0;}
 #endif
 
-//device_initcall(lpc313x_dma_init);
+//device_initcall(lpc31xx_dma_init);
 
 EXPORT_SYMBOL(dma_request_channel_x);
 EXPORT_SYMBOL(dma_request_specific_channel);
diff --git a/arch/arm/mach-lpc31xx/dt.c b/arch/arm/mach-lpc31xx/dt.c
index f5749b2..01af063 100644
--- a/arch/arm/mach-lpc31xx/dt.c
+++ b/arch/arm/mach-lpc31xx/dt.c
@@ -40,7 +40,7 @@ static void __init lpc31xx_dt_init(void)
 
 void __init lpc31xx_dt_init_common(struct of_dev_auxdata* auxdata)
 {
-	lpc313x_init();
+	lpc31xx_init();
 	of_platform_populate(NULL, of_default_bus_match_table,
 			     auxdata, NULL);
 }
@@ -58,10 +58,10 @@ static const char *lpc31xx_dt_match[] __initconst = {
 };
 
 DT_MACHINE_START(EA313X, "NXP LPC31xx (Device Tree Support)")
-	.map_io		= lpc313x_map_io,
+	.map_io		= lpc31xx_map_io,
 	.init_early	= lpc31xx_init_early,
 	.init_irq	= lpc31xx_init_irq,
-	.timer		= &lpc313x_timer,
+	.timer		= &lpc31xx_timer,
 	.init_machine	= lpc31xx_dt_init,
 	.dt_compat	= lpc31xx_dt_match,
 	.restart	= arch_reset,
diff --git a/arch/arm/mach-lpc31xx/evtr.c b/arch/arm/mach-lpc31xx/evtr.c
index 12081f6..a331f15 100644
--- a/arch/arm/mach-lpc31xx/evtr.c
+++ b/arch/arm/mach-lpc31xx/evtr.c
@@ -652,7 +652,7 @@ static const struct of_device_id evtr_of_match[] __initconst = {
 	{},
 };
 
-static int __devinit lpc313x_evtr_probe(struct platform_device *pdev)
+static int __devinit lpc31xx_evtr_probe(struct platform_device *pdev)
 {
 	const __be32 *ip;
 	struct device_node *np = pdev->dev.of_node;
@@ -682,30 +682,30 @@ static int __devinit lpc313x_evtr_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int lpc313x_evtr_remove(struct platform_device *pdev)
+static int lpc31xx_evtr_remove(struct platform_device *pdev)
 {
 	return -EBUSY;
 }
 
-static struct platform_driver lpc313x_evtr_driver = {
+static struct platform_driver lpc31xx_evtr_driver = {
 	.driver = {
 		.name = "lpc31xx-evtr",
 		.owner = THIS_MODULE,
 		.of_match_table = evtr_of_match,
 	},
-	.probe = lpc313x_evtr_probe,
-	.remove = lpc313x_evtr_remove,
+	.probe = lpc31xx_evtr_probe,
+	.remove = lpc31xx_evtr_remove,
 };
 
-static __init int lpc313x_evtr_init(void)
+static __init int lpc31xx_evtr_init(void)
 {
-	if (platform_driver_register(&lpc313x_evtr_driver))
+	if (platform_driver_register(&lpc31xx_evtr_driver))
 		printk(KERN_ERR "Unable to register Event Router driver\n");
 
 	return 0;
 }
 
 /* Make sure we get initialised before anyone else tries to use us */
-core_initcall(lpc313x_evtr_init);
+core_initcall(lpc31xx_evtr_init);
 
 
diff --git a/arch/arm/mach-lpc31xx/generic.c b/arch/arm/mach-lpc31xx/generic.c
index 9fce256..d257d47 100644
--- a/arch/arm/mach-lpc31xx/generic.c
+++ b/arch/arm/mach-lpc31xx/generic.c
@@ -1,9 +1,9 @@
-/*  arch/arm/mach-lpc313x/generic.c
+/*  arch/arm/mach-lpc31xx/generic.c
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- *  Common code for machines with LPC313x and LPC315x SoCs.
+ *  Common code for machines with LPC31xx SoCs.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -36,7 +36,7 @@
 
 /* local functions */
 
-static void lpc313x_uart_pm(struct uart_port * port, unsigned int state,
+static void lpc31xx_uart_pm(struct uart_port * port, unsigned int state,
 			      unsigned int oldstate)
 {
 	switch (state) {
@@ -59,7 +59,7 @@ static void lpc313x_uart_pm(struct uart_port * port, unsigned int state,
 		break;
 	case 1:
 		/* we can wake the system in this state. So leave clocks on */
-		printk(KERN_INFO "lpc313x_uart_pm: UART can wake\n");
+		printk(KERN_INFO "lpc31xx_uart_pm: UART can wake\n");
 		break;
 	case 3:
 		/*
@@ -81,7 +81,7 @@ static void lpc313x_uart_pm(struct uart_port * port, unsigned int state,
 		gpio_direction_output(GPIO_UART_TXD, 0);
 		break;
 	default:
-		printk(KERN_ERR "lpc313x_uart_pm: unknown pm %d\n", state);
+		printk(KERN_ERR "lpc31xx_uart_pm: unknown pm %d\n", state);
 	}
 
 }
@@ -96,7 +96,7 @@ static struct plat_serial8250_port platform_serial_ports[] = {
 		.iotype = UPIO_MEM,
 		.type	= PORT_NXP16750,
 		.flags = UPF_BOOT_AUTOCONF | UPF_BUGGY_UART | UPF_SKIP_TEST,
-		.pm = lpc313x_uart_pm,
+		.pm = lpc31xx_uart_pm,
 	},
 	{
 		.flags		= 0
@@ -121,7 +121,7 @@ static struct platform_device *devices[] __initdata = {
 	&lpc31xx_pcm_device,
 };
 
-static struct map_desc lpc313x_io_desc[] __initdata = {
+static struct map_desc lpc31xx_io_desc[] __initdata = {
 	{
 		.virtual	= io_p2v(IO_APB1_PHYS),
 		.pfn		= __phys_to_pfn(IO_APB1_PHYS),
@@ -178,13 +178,13 @@ static struct map_desc lpc313x_io_desc[] __initdata = {
 	},
 };
 
-void __init lpc313x_map_io(void)
+void __init lpc31xx_map_io(void)
 {
-	iotable_init(lpc313x_io_desc, ARRAY_SIZE(lpc313x_io_desc));
+	iotable_init(lpc31xx_io_desc, ARRAY_SIZE(lpc31xx_io_desc));
 }
 extern int __init cgu_init(char *str);
 
-void __init lpc313x_uart_init(void)
+void __init lpc31xx_uart_init(void)
 {
 	int mul, div;
 
@@ -196,7 +196,7 @@ void __init lpc313x_uart_init(void)
 	}
 }
 
-void __init lpc313x_init(void)
+void __init lpc31xx_init(void)
 {
 	/* cgu init */
 	clk_init();
@@ -240,14 +240,14 @@ void __init lpc313x_init(void)
 	/* AUDIO CODEC CLOCK (256FS) */
 	GPIO_DRV_IP(IOCONF_I2STX_1, 0x8);
 #endif
-	lpc313x_uart_init();
+	lpc31xx_uart_init();
 
 	return platform_add_devices(devices, ARRAY_SIZE(devices));
 }
 
 
 #if defined(CONFIG_SERIAL_8250_CONSOLE)
-static int __init lpc313x_init_console(void)
+static int __init lpc31xx_init_console(void)
 {
 	static __initdata char serr[] =
 		KERN_ERR "Serial port #%u setup failed\n";
@@ -285,7 +285,7 @@ static int __init lpc313x_init_console(void)
 
 	return 0;
 }
-console_initcall(lpc313x_init_console);
+console_initcall(lpc31xx_init_console);
 
 #endif /*CONFIG_SERIAL_8250_CONSOLE*/
 
diff --git a/arch/arm/mach-lpc31xx/include/mach/board.h b/arch/arm/mach-lpc31xx/include/mach/board.h
index 7be6e8b..f17126f 100644
--- a/arch/arm/mach-lpc31xx/include/mach/board.h
+++ b/arch/arm/mach-lpc31xx/include/mach/board.h
@@ -1,9 +1,9 @@
-/*  arch/arm/mach-lpc313x/generic.h
+/*  arch/arm/mach-lpc31xx/generic.h
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- *  Defines prototypes for generic init functions LPC313x and LPC315x SoCs.
+ *  Defines prototypes for generic init functions LPC31xx SoCs.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -30,16 +30,16 @@
 #include <linux/mmc/host.h>
 
 
-extern void __init lpc313x_map_io(void);
+extern void __init lpc31xx_map_io(void);
 extern void __init lpc31xx_init_irq(void);
-extern void __init lpc313x_init(void);
-extern int __init lpc313x_register_i2c_devices(void);
-extern void lpc313x_vbus_power(int enable);
-extern int lpc313x_entering_suspend_mem(void);
+extern void __init lpc31xx_init(void);
+extern int __init lpc31xx_register_i2c_devices(void);
+extern void lpc31xx_vbus_power(int enable);
+extern int lpc31xx_entering_suspend_mem(void);
 
 
 struct sys_timer;
-extern struct sys_timer lpc313x_timer;
+extern struct sys_timer lpc31xx_timer;
 
 /*
  * Timing information structure for the NAND interface. Although there are
@@ -52,7 +52,7 @@ extern struct sys_timer lpc313x_timer;
  * information on what these timings are and set the value for each timing
  * with the matching value from the NAND device data sheet.
  */
-struct lpc313x_nand_timing
+struct lpc31xx_nand_timing
 {
 	u32 ns_trsd;
 	u32 ns_tals;
@@ -74,7 +74,7 @@ struct lpc313x_nand_timing
  * and partitioning scheme. One of these structures is required for each
  * device attached to a chip select of the NAND controller.
  */
-struct lpc313x_nand_dev_info
+struct lpc31xx_nand_dev_info
 {
 	char *name; /* Informational name only */
 	int nr_partitions; /* Number of partitions on this device */
@@ -84,10 +84,10 @@ struct lpc313x_nand_dev_info
 /*
  * High level NAND configuration structure
  */
-struct lpc313x_nand_cfg {
+struct lpc31xx_nand_cfg {
 	int nr_devices;
-	struct lpc313x_nand_dev_info *devices;
-	struct lpc313x_nand_timing *timing;
+	struct lpc31xx_nand_dev_info *devices;
+	struct lpc31xx_nand_timing *timing;
 	int support_16bit;
 };
 
@@ -95,7 +95,7 @@ struct lpc313x_nand_cfg {
  * Specifies behaviour of each supported chip select
  */
 typedef void (*spi_cs_sel)(int, int);
-struct lpc313x_spics_cfg {
+struct lpc31xx_spics_cfg {
 	/* spi_spo is the serial clock polarity between transfers, 1 = high level,
 	   0 = low */
 	u8 spi_spo;
@@ -108,10 +108,10 @@ struct lpc313x_spics_cfg {
 /*
  * Defines the number of chip selects and the cs data
  */
-struct lpc313x_spi_cfg {
+struct lpc31xx_spi_cfg {
 	u32 num_cs; /* Number of CS supported on this board */
 	/* Array of cs setup data (num_cs entries) */
-	struct lpc313x_spics_cfg *spics_cfg;
+	struct lpc31xx_spics_cfg *spics_cfg;
 };
 
 #if defined (CONFIG_MACH_VAL3153) 
diff --git a/arch/arm/mach-lpc31xx/include/mach/clock.h b/arch/arm/mach-lpc31xx/include/mach/clock.h
index ed22aeb..96a28cf 100644
--- a/arch/arm/mach-lpc31xx/include/mach/clock.h
+++ b/arch/arm/mach-lpc31xx/include/mach/clock.h
@@ -1,9 +1,9 @@
-/* linux/arch/arm/mach-lpc313x/include/mach/clock.h
+/* linux/arch/arm/mach-lpc31xx/include/mach/clock.h
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- *  CGU defines and register structures for LPC313x and LPC315x SoCs.
+ *  CGU defines and register structures for LPC31xx SoCs.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-lpc31xx/include/mach/constants.h b/arch/arm/mach-lpc31xx/include/mach/constants.h
index b645671..2bf9f45 100644
--- a/arch/arm/mach-lpc31xx/include/mach/constants.h
+++ b/arch/arm/mach-lpc31xx/include/mach/constants.h
@@ -1,9 +1,9 @@
-/* linux/arch/arm/mach-lpc313x/include/mach/constants.h
+/* linux/arch/arm/mach-lpc31xx/include/mach/constants.h
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- * Manifest constants for LPC313x and LPC315x SoCs.
+ * Manifest constants for LPC31xx SoCs.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-lpc31xx/include/mach/debug-macro.S b/arch/arm/mach-lpc31xx/include/mach/debug-macro.S
index 46193e7..c682819 100644
--- a/arch/arm/mach-lpc31xx/include/mach/debug-macro.S
+++ b/arch/arm/mach-lpc31xx/include/mach/debug-macro.S
@@ -1,4 +1,4 @@
-/* linux/arch/arm/mach-lpc313x/include/mach/debug-macro.S
+/* linux/arch/arm/mach-lpc31xx/include/mach/debug-macro.S
  *
  * Debugging macro include header
  *
diff --git a/arch/arm/mach-lpc31xx/include/mach/dma.h b/arch/arm/mach-lpc31xx/include/mach/dma.h
index 0e06a68..ca1a854 100644
--- a/arch/arm/mach-lpc31xx/include/mach/dma.h
+++ b/arch/arm/mach-lpc31xx/include/mach/dma.h
@@ -1,9 +1,9 @@
-/*  linux/arch/arm/mach-lpc313x/include/mach/dma.h
+/*  linux/arch/arm/mach-lpc31xx/include/mach/dma.h
  *  
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- * DMA register defines & structures for LPC313x and LPC315x SoCs.
+ * DMA register defines & structures for LPC31xx SoCs.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-lpc31xx/include/mach/entry-macro.S b/arch/arm/mach-lpc31xx/include/mach/entry-macro.S
index cabe6fa..80d7294 100644
--- a/arch/arm/mach-lpc31xx/include/mach/entry-macro.S
+++ b/arch/arm/mach-lpc31xx/include/mach/entry-macro.S
@@ -1,7 +1,7 @@
 /*
- * linux/arch/arm/mach-lpc313x/include/mach/entry-macro.S
+ * linux/arch/arm/mach-lpc31xx/include/mach/entry-macro.S
  *
- * Low-level IRQ helper macros for LPC313x-based platforms
+ * Low-level IRQ helper macros for LPC31xx-based platforms
  *
  * This file is licensed under  the terms of the GNU General Public
  * License version 2. This program is licensed "as is" without any
diff --git a/arch/arm/mach-lpc31xx/include/mach/gpio.h b/arch/arm/mach-lpc31xx/include/mach/gpio.h
index 4792ac1..af8e223 100644
--- a/arch/arm/mach-lpc31xx/include/mach/gpio.h
+++ b/arch/arm/mach-lpc31xx/include/mach/gpio.h
@@ -1,9 +1,9 @@
-/* linux/arch/arm/mach-lpc313x/include/mach/gpio.h
+/* linux/arch/arm/mach-lpc31xx/include/mach/gpio.h
  *  
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- * GPIO defines & routines for LPC313x and LPC315x SoCs.
+ * GPIO defines & routines for LPC31xx SoCs.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,8 +20,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  */
-#ifndef _LPC313X_GPIO_H
-#define _LPC313X_GPIO_H
+#ifndef _LPC31XX_GPIO_H
+#define _LPC31XX_GPIO_H
 
 #include <linux/irqflags.h>
 #include <mach/hardware.h>
@@ -146,7 +146,7 @@
 
                 
 #if 0
-static inline int lpc313x_gpio_ip_driven(unsigned gpio)
+static inline int lpc31xx_gpio_ip_driven(unsigned gpio)
 {
 	unsigned long flags;
 	int port = (gpio & GPIO_PORT_MASK);
@@ -171,28 +171,28 @@ static inline int lpc313x_gpio_ip_driven(unsigned gpio)
                
 /*-------------------------------------------------------------------------*/
 
-/* Wrappers for "new style" GPIO calls. These calls LPC313x specific versions
+/* Wrappers for "new style" GPIO calls. These calls LPC31xx specific versions
  * to allow future extension of GPIO logic.
 */
 static inline  int gpio_direction_input(unsigned gpio)
 {
-	return lpc313x_gpio_direction_input(gpio);
+	return lpc31xx_gpio_direction_input(gpio);
 }
 
 static inline int gpio_direction_output(unsigned gpio, int value)
 {
-	lpc313x_gpio_set_value(gpio, value);
+	lpc31xx_gpio_set_value(gpio, value);
 	return 0;
 }
 
 static inline int gpio_get_value(unsigned gpio)
 {
-	return lpc313x_gpio_get_value(gpio);
+	return lpc31xx_gpio_get_value(gpio);
 }
 
 static inline void gpio_set_value(unsigned gpio, int value)
 {
-	lpc313x_gpio_set_value(gpio, value);
+	lpc31xx_gpio_set_value(gpio, value);
 }
 static inline int gpio_request(unsigned gpio, const char *label)
 {
@@ -204,10 +204,10 @@ static inline int gpio_request(unsigned gpio, const char *label)
  **/
 static inline void gpio_free( unsigned gpio)
 {
-	lpc313x_gpio_ip_driven(gpio);
+	lpc31xx_gpio_ip_driven(gpio);
 }
 int gpio_is_valid(unsigned pin);
 #endif
 
 
-#endif /*_LPC313X_GPIO_H*/
+#endif /*_LPC31XX_GPIO_H*/
diff --git a/arch/arm/mach-lpc31xx/include/mach/hardware.h b/arch/arm/mach-lpc31xx/include/mach/hardware.h
index 9858ebf..a612cdb 100644
--- a/arch/arm/mach-lpc31xx/include/mach/hardware.h
+++ b/arch/arm/mach-lpc31xx/include/mach/hardware.h
@@ -1,9 +1,9 @@
-/* linux/arch/arm/mach-lpc313x/include/mach/hardware.h
+/* linux/arch/arm/mach-lpc31xx/include/mach/hardware.h
  *  
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- * Hardware register defines for LPC313x and LPC315x SoCs.
+ * Hardware register defines for LPC31xx SoCs.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-lpc31xx/include/mach/i2c.h b/arch/arm/mach-lpc31xx/include/mach/i2c.h
index 24aaaa6..1b0ca35 100644
--- a/arch/arm/mach-lpc31xx/include/mach/i2c.h
+++ b/arch/arm/mach-lpc31xx/include/mach/i2c.h
@@ -1,9 +1,9 @@
-/* linux/arch/arm/mach-lpc313x/include/mach/i2c.h
+/* linux/arch/arm/mach-lpc31xx/include/mach/i2c.h
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- * LPC313x-specific tweaks for NXP I2C block
+ * LPC31xx-specific tweaks for NXP I2C block
  *
  * Based on mach-pnx4008/include/mach/i2c.h by Vitaly Wool <vwool@ru.mvista.com>
  *
@@ -71,6 +71,6 @@ enum {
 #define I2C_REG_TXS(a)	((a)->ioaddr + 0x28)	/* Tx slave FIFO (RO) */
 #define I2C_REG_STFL(a)	((a)->ioaddr + 0x2c)	/* Tx slave FIFO level (RO) */
 
-#define I2C_CHIP_NAME		"LPC313x-I2C"
+#define I2C_CHIP_NAME		"LPC31xx-I2C"
 
 #endif				/* __ASM_ARCH_I2C_H___ */
diff --git a/arch/arm/mach-lpc31xx/include/mach/io.h b/arch/arm/mach-lpc31xx/include/mach/io.h
index 33dc8d2..fa93eed 100644
--- a/arch/arm/mach-lpc31xx/include/mach/io.h
+++ b/arch/arm/mach-lpc31xx/include/mach/io.h
@@ -1,9 +1,9 @@
-/* linux/arch/arm/mach-lpc313x/include/mach/io.h
+/* linux/arch/arm/mach-lpc31xx/include/mach/io.h
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- * IO space defines for LPC313x and LPC315x SoCs.
+ * IO space defines for LPC31xx SoCs.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-lpc31xx/include/mach/irqs.h b/arch/arm/mach-lpc31xx/include/mach/irqs.h
index 274ac62..7ded119 100644
--- a/arch/arm/mach-lpc31xx/include/mach/irqs.h
+++ b/arch/arm/mach-lpc31xx/include/mach/irqs.h
@@ -1,9 +1,9 @@
-/* linux/arch/arm/mach-lpc313x/include/mach/irqs.h
+/* linux/arch/arm/mach-lpc31xx/include/mach/irqs.h
  *
  * Author:	Durgesh Pattamatta
  * Copyright (C) 2009 NXP semiconductors
  *
- * IRQ defines for LPC313x and LPC315x SoCs.
+ * IRQ defines for LPC31xx SoCs.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-lpc31xx/include/mach/lpc315x_ad.h b/arch/arm/mach-lpc31xx/include/mach/lpc315x_ad.h
index 9c5b68a..2e49fd7 100644
--- a/arch/arm/mach-lpc31xx/include/mach/lpc315x_ad.h
+++ b/arch/arm/mach-lpc31xx/include/mach/lpc315x_ad.h
@@ -1,5 +1,5 @@
 /*
- * arch/arm/mach-lpc313x/include/mach/lpc315x_ad.h
+ * arch/arm/mach-lpc31xx/include/mach/lpc315x_ad.h
  *
  * Author: Kevin Wells <kevin.wells@nxp.com>
  *
diff --git a/arch/arm/mach-lpc31xx/include/mach/memory.h b/arch/arm/mach-lpc31xx/include/mach/memory.h
index 049b534..e3d2f0e 100644
--- a/arch/arm/mach-lpc31xx/include/mach/memory.h
+++ b/arch/arm/mach-lpc31xx/include/mach/memory.h
@@ -1,9 +1,9 @@
-/*  linux/arch/arm/mach-lpc313x/include/mach/memory.h
+/*  linux/arch/arm/mach-lpc31xx/include/mach/memory.h
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- *  Memory defines for machines with LPC313x and LPC315x SoCs.
+ *  Memory defines for machines with LPC31xx SoCs.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-lpc31xx/include/mach/registers.h b/arch/arm/mach-lpc31xx/include/mach/registers.h
index 4334ea4..456f5c6 100644
--- a/arch/arm/mach-lpc31xx/include/mach/registers.h
+++ b/arch/arm/mach-lpc31xx/include/mach/registers.h
@@ -1,9 +1,9 @@
-/* linux/arch/arm/mach-lpc313x/include/mach/registers.h
+/* linux/arch/arm/mach-lpc31xx/include/mach/registers.h
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- * Register defines for LPC313x and LPC315x SoCs.
+ * Register defines for LPC31xx SoCs.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-lpc31xx/include/mach/system.h b/arch/arm/mach-lpc31xx/include/mach/system.h
index 867a12f..0cf511e 100644
--- a/arch/arm/mach-lpc31xx/include/mach/system.h
+++ b/arch/arm/mach-lpc31xx/include/mach/system.h
@@ -1,4 +1,4 @@
-/* linux/arch/arm/mach-lpc313x/include/mach/system.h
+/* linux/arch/arm/mach-lpc31xx/include/mach/system.h
  *  
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
diff --git a/arch/arm/mach-lpc31xx/include/mach/timex.h b/arch/arm/mach-lpc31xx/include/mach/timex.h
index a3a4484..0bc61e0 100644
--- a/arch/arm/mach-lpc31xx/include/mach/timex.h
+++ b/arch/arm/mach-lpc31xx/include/mach/timex.h
@@ -1,4 +1,4 @@
-/*  linux/arch/arm/mach-lpc313x/include/mach/timex.h
+/*  linux/arch/arm/mach-lpc31xx/include/mach/timex.h
  *  
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
diff --git a/arch/arm/mach-lpc31xx/include/mach/uncompress.h b/arch/arm/mach-lpc31xx/include/mach/uncompress.h
index 7a8c7af..320ab47 100644
--- a/arch/arm/mach-lpc31xx/include/mach/uncompress.h
+++ b/arch/arm/mach-lpc31xx/include/mach/uncompress.h
@@ -1,9 +1,9 @@
-/*  linux/arch/arm/mach-lpc313x/include/mach/uncompress.h
+/*  linux/arch/arm/mach-lpc31xx/include/mach/uncompress.h
  *  
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- * Decompression UART routines for LPC313x and LPC315x SoCs.
+ * Decompression UART routines for LPC31xx SoCs.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-lpc31xx/include/mach/vmalloc.h b/arch/arm/mach-lpc31xx/include/mach/vmalloc.h
index 8f19964..4f9ca60 100644
--- a/arch/arm/mach-lpc31xx/include/mach/vmalloc.h
+++ b/arch/arm/mach-lpc31xx/include/mach/vmalloc.h
@@ -1,4 +1,4 @@
-/*  linux/arch/arm/mach-lpc313x/include/mach/vmalloc.h
+/*  linux/arch/arm/mach-lpc31xx/include/mach/vmalloc.h
  *  
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
diff --git a/arch/arm/mach-lpc31xx/leds.c b/arch/arm/mach-lpc31xx/leds.c
index aea73b5..26ab4ca 100644
--- a/arch/arm/mach-lpc31xx/leds.c
+++ b/arch/arm/mach-lpc31xx/leds.c
@@ -1,4 +1,4 @@
-/*  linux/arch/arm/mach-lpc313x/leds.c
+/*  linux/arch/arm/mach-lpc31xx/leds.c
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
diff --git a/arch/arm/mach-lpc31xx/pm.c b/arch/arm/mach-lpc31xx/pm.c
index e5addcd..194c02d 100644
--- a/arch/arm/mach-lpc31xx/pm.c
+++ b/arch/arm/mach-lpc31xx/pm.c
@@ -1,9 +1,9 @@
-/*  linux/arch/arm/mach-lpc313x/leds.c
+/*  linux/arch/arm/mach-lpc31xx/leds.c
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- * LPC313x/4x/5x power management.
+ * LPC31xx/4x/5x power management.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -34,19 +34,19 @@
 #include <mach/hardware.h>
 
 
-#define LPC313x_ISRAM_VA io_p2v(ISRAM0_PHYS)
+#define LPC31xx_ISRAM_VA io_p2v(ISRAM0_PHYS)
 
 /*
  * Pointers used for sizing and copying suspend function data
  */
-extern int lpc313x_suspend_mem(void);
-extern int lpc313x_suspend_mem_sz;
+extern int lpc31xx_suspend_mem(void);
+extern int lpc31xx_suspend_mem_sz;
 
 
 /* Enable/Disable external refresh controller used by
  * auto clock scaling feature of CGU.
  */
-static void lpc313x_ext_refresh_en(int enable)
+static void lpc31xx_ext_refresh_en(int enable)
 {
 	if (enable)
 		SYS_MPMC_TESTMODE0 |= _BIT(12);
@@ -54,7 +54,7 @@ static void lpc313x_ext_refresh_en(int enable)
 		SYS_MPMC_TESTMODE0 &= ~_BIT(12);
 
 }
-static int lpc313x_pm_valid_state(suspend_state_t state)
+static int lpc31xx_pm_valid_state(suspend_state_t state)
 {
 	switch (state) {
 		case PM_SUSPEND_ON:
@@ -73,13 +73,13 @@ static suspend_state_t target_state;
 /*
  * Called after processes are frozen, but before we shutdown devices.
  */
-static int lpc313x_pm_begin(suspend_state_t state)
+static int lpc31xx_pm_begin(suspend_state_t state)
 {
 	target_state = state;
 	return 0;
 }
 
-static void lpc313x_clk_debug(void)
+static void lpc31xx_clk_debug(void)
 {
 #ifdef CONFIG_PM_DEBUG
 	u32 i, clk_pcr;
@@ -95,9 +95,9 @@ static void lpc313x_clk_debug(void)
 #endif
 }
 
-static int lpc313x_enter_sleep(u32 standby)
+static int lpc31xx_enter_sleep(u32 standby)
 {
-	int (*lpc313x_suspend_ptr) (u32);
+	int (*lpc31xx_suspend_ptr) (u32);
 	int i;
 	u32 base_clk_state = 0;
 
@@ -106,9 +106,9 @@ static int lpc313x_enter_sleep(u32 standby)
 #endif
 
 	/* print clocks which are still on */
-	lpc313x_clk_debug();
+	lpc31xx_clk_debug();
 
-	lpc313x_ext_refresh_en(0);
+	lpc31xx_ext_refresh_en(0);
 	/*
 	 * To simplify stand-by routine, set FFAST as source clock for the
 	 * non-active switch side of SYS, APB0, APB1, APB2 & APB3 domains.
@@ -138,7 +138,7 @@ static int lpc313x_enter_sleep(u32 standby)
 
 #if defined(BACKUP_ISRAM)
 	/* Allocate some space for temporary IRAM storage */
-	iram_swap_area = kmalloc(lpc313x_suspend_mem_sz, GFP_KERNEL);
+	iram_swap_area = kmalloc(lpc31xx_suspend_mem_sz, GFP_KERNEL);
 	if (!iram_swap_area) {
 		printk(KERN_ERR
 		       "PM Suspend: cannot allocate memory to save portion "
@@ -146,8 +146,8 @@ static int lpc313x_enter_sleep(u32 standby)
 		return -ENOMEM;
 	}
 	/* Backup a small area of IRAM used for the suspend code */
-	memcpy(iram_swap_area, (void *) LPC313x_ISRAM_VA,
-			lpc313x_suspend_mem_sz);
+	memcpy(iram_swap_area, (void *) LPC31xx_ISRAM_VA,
+			lpc31xx_suspend_mem_sz);
 #endif
 
 	/*
@@ -155,19 +155,19 @@ static int lpc313x_enter_sleep(u32 standby)
 	 * needs to run from IRAM as DRAM may no longer be available
 	 * when the PLL is stopped.
 	 */
-	memcpy((void *) LPC313x_ISRAM_VA, &lpc313x_suspend_mem,
-			lpc313x_suspend_mem_sz);
-	flush_icache_range((unsigned long)LPC313x_ISRAM_VA,
-		(unsigned long)(LPC313x_ISRAM_VA) + lpc313x_suspend_mem_sz);
+	memcpy((void *) LPC31xx_ISRAM_VA, &lpc31xx_suspend_mem,
+			lpc31xx_suspend_mem_sz);
+	flush_icache_range((unsigned long)LPC31xx_ISRAM_VA,
+		(unsigned long)(LPC31xx_ISRAM_VA) + lpc31xx_suspend_mem_sz);
 
 	/* Transfer to suspend code in IRAM */
-	lpc313x_suspend_ptr = (void *) LPC313x_ISRAM_VA;
-	(void) lpc313x_suspend_ptr(standby);
+	lpc31xx_suspend_ptr = (void *) LPC31xx_ISRAM_VA;
+	(void) lpc31xx_suspend_ptr(standby);
 
 #if defined(BACKUP_ISRAM)
 	/* Restore original IRAM contents */
-	memcpy((void *) LPC313x_ISRAM_VA, iram_swap_area,
-			lpc313x_suspend_mem_sz);
+	memcpy((void *) LPC31xx_ISRAM_VA, iram_swap_area,
+			lpc31xx_suspend_mem_sz);
 
 	kfree(iram_swap_area);
 #endif
@@ -187,14 +187,14 @@ static int lpc313x_enter_sleep(u32 standby)
 					CGU_SB_PCR_RUN | CGU_SB_PCR_AUTO;
 	}
 
-	lpc313x_ext_refresh_en(1);
+	lpc31xx_ext_refresh_en(1);
 
 	return 0;
 }
 
 
 
-static int lpc313x_pm_enter(suspend_state_t state)
+static int lpc31xx_pm_enter(suspend_state_t state)
 {
 	int ret = 0;
 
@@ -208,7 +208,7 @@ static int lpc313x_pm_enter(suspend_state_t state)
 		 * event router.
 		 */
 		case PM_SUSPEND_MEM:
-			ret = lpc313x_enter_sleep(0);
+			ret = lpc31xx_enter_sleep(0);
 			break;
 
 		/*
@@ -219,7 +219,7 @@ static int lpc313x_pm_enter(suspend_state_t state)
 		 * running without WAK_EN bit set in CGU.
 		 */
 		case PM_SUSPEND_STANDBY:
-			ret = lpc313x_enter_sleep(1);
+			ret = lpc31xx_enter_sleep(1);
 			break;
 
 		case PM_SUSPEND_ON:
@@ -241,7 +241,7 @@ error:
 /*
  * Called right prior to thawing processes.
  */
-static void lpc313x_pm_end(void)
+static void lpc31xx_pm_end(void)
 {
 	target_state = PM_SUSPEND_ON;
 }
@@ -251,21 +251,21 @@ static void lpc313x_pm_end(void)
  * For internal events to wake the chip we should not stop the module 
  * clocks. 
  */
-int lpc313x_entering_suspend_mem(void)
+int lpc31xx_entering_suspend_mem(void)
 {
 	return (target_state == PM_SUSPEND_MEM);
 }
-EXPORT_SYMBOL(lpc313x_entering_suspend_mem);
+EXPORT_SYMBOL(lpc31xx_entering_suspend_mem);
 
 
-static struct platform_suspend_ops lpc313x_pm_ops ={
-	.valid	= lpc313x_pm_valid_state,
-	.begin	= lpc313x_pm_begin,
-	.enter	= lpc313x_pm_enter,
-	.end	= lpc313x_pm_end,
+static struct platform_suspend_ops lpc31xx_pm_ops ={
+	.valid	= lpc31xx_pm_valid_state,
+	.begin	= lpc31xx_pm_begin,
+	.enter	= lpc31xx_pm_enter,
+	.end	= lpc31xx_pm_end,
 };
 
-static int __init lpc313x_pm_init(void)
+static int __init lpc31xx_pm_init(void)
 {
 	pr_info("LPC31: Power Management init.\n");
 
@@ -274,8 +274,8 @@ static int __init lpc313x_pm_init(void)
 	 */
 
 
-	suspend_set_ops(&lpc313x_pm_ops);
+	suspend_set_ops(&lpc31xx_pm_ops);
 
 	return 0;
 }
-arch_initcall(lpc313x_pm_init);
+arch_initcall(lpc31xx_pm_init);
diff --git a/arch/arm/mach-lpc31xx/pm_standby.S b/arch/arm/mach-lpc31xx/pm_standby.S
index 7da73c4..dceb71a 100644
--- a/arch/arm/mach-lpc31xx/pm_standby.S
+++ b/arch/arm/mach-lpc31xx/pm_standby.S
@@ -1,9 +1,9 @@
-/*  linux/arch/arm/mach-lpc313x/pm_standby.S
+/*  linux/arch/arm/mach-lpc31xx/pm_standby.S
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2010 NXP semiconductors
  *
- * Power management code to put LPC313x in sleep state.
+ * Power management code to put LPC31xx in sleep state.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -27,47 +27,47 @@
 #define HPLL_LOCK_TIMEOUT	1000
 
 /* CGU defines */
-#define LPC313x_CGU_NR_BASE     12
+#define LPC31xx_CGU_NR_BASE     12
 
 /* CGU register offsets */
-#define LPC313x_CGU_PWR_OFS      0xC00
-#define LPC313x_CGU_HP0_MD_OFS   0xD00
-#define LPC313x_CGU_HP0_ST_OFS   0xD04
-#define LPC313x_CGU_HP1_MD_OFS   0xD38
-#define LPC313x_CGU_HP1_ST_OFS   0xD3C
+#define LPC31xx_CGU_PWR_OFS      0xC00
+#define LPC31xx_CGU_HP0_MD_OFS   0xD00
+#define LPC31xx_CGU_HP0_ST_OFS   0xD04
+#define LPC31xx_CGU_HP1_MD_OFS   0xD38
+#define LPC31xx_CGU_HP1_ST_OFS   0xD3C
 
 /* CGU bit defines */
-#define LPC313x_PWR_NORM		  (1)
-#define LPC313x_PWR_SLEEP		  (3)
-#define LPC313x_HP_ST_LOCK      (1 << 0)
-#define LPC313x_HP_MODE_PD      (1 << 2)
-#define LPC313x_HP_MODE_EN      (1 << 0)
+#define LPC31xx_PWR_NORM		  (1)
+#define LPC31xx_PWR_SLEEP		  (3)
+#define LPC31xx_HP_ST_LOCK      (1 << 0)
+#define LPC31xx_HP_MODE_PD      (1 << 2)
+#define LPC31xx_HP_MODE_EN      (1 << 0)
 
 /* MPMC register offsets */
-#define LPC313x_MPMC_CTL_OFS    0x000
-#define LPC313x_MPMC_STAT_OFS   0x004
-#define LPC313x_MPMC_DYNC_OFS   0x020
+#define LPC31xx_MPMC_CTL_OFS    0x000
+#define LPC31xx_MPMC_STAT_OFS   0x004
+#define LPC31xx_MPMC_DYNC_OFS   0x020
 
 /* MPMC bit defines */
-#define LPC313x_MPMC_LOW        (0x5)
-#define LPC313x_MPMC_NORM       (0x1)
-#define LPC313x_DYNC_SR         (1 << 2)
-#define LPC313x_STAT_SR         (1 << 2)
-#define LPC313x_STAT_WB         (1 << 1)
-#define LPC313x_STAT_BS         (1 << 0)
+#define LPC31xx_MPMC_LOW        (0x5)
+#define LPC31xx_MPMC_NORM       (0x1)
+#define LPC31xx_DYNC_SR         (1 << 2)
+#define LPC31xx_STAT_SR         (1 << 2)
+#define LPC31xx_STAT_WB         (1 << 1)
+#define LPC31xx_STAT_BS         (1 << 0)
 
 /*
  * Wait until SYSTEM PLL (HPLL0) has locked.
  */
 	.macro wait_hp0_lock
-	tst r10, #LPC313x_HP_MODE_PD
+	tst r10, #LPC31xx_HP_MODE_PD
 	bne 2f
 	mov	r4, #HPLL_LOCK_TIMEOUT
 1:	sub	r4, r4, #1
 	cmp	r4, #0
 	beq	2f
-	ldr	r3, [r1, #LPC313x_CGU_HP0_ST_OFS]
-	tst	r3, #LPC313x_HP_ST_LOCK
+	ldr	r3, [r1, #LPC31xx_CGU_HP0_ST_OFS]
+	tst	r3, #LPC31xx_HP_ST_LOCK
 	beq	1b
 2:
 	.endm
@@ -77,20 +77,20 @@
  */
 	.macro wait_hp1_lock
 	mov	r4, #HPLL_LOCK_TIMEOUT
-	tst r11, #LPC313x_HP_MODE_PD
+	tst r11, #LPC31xx_HP_MODE_PD
 	bne 2f
 1:	sub	r4, r4, #1
 	cmp	r4, #0
 	beq	2f
-	ldr	r3, [r1, #LPC313x_CGU_HP1_ST_OFS]
-	tst	r3, #LPC313x_HP_ST_LOCK
+	ldr	r3, [r1, #LPC31xx_CGU_HP1_ST_OFS]
+	tst	r3, #LPC31xx_HP_ST_LOCK
 	beq	1b
 2:
 	.endm
 
 	.text
 
-ENTRY(lpc313x_suspend_mem)
+ENTRY(lpc31xx_suspend_mem)
 	/* Save registers on stack */
 	stmfd	sp!, {r0 - r12, lr}
 
@@ -108,8 +108,8 @@ ENTRY(lpc313x_suspend_mem)
 	 *  R10 = HPLL0 state
 	 *  R11 = HPLL1 state
 	 */
-	ldr	r1, .lpc313x_va_base_cgu
-	ldr	r2, .lpc313x_va_base_mpmc
+	ldr	r1, .lpc31xx_va_base_cgu
+	ldr	r2, .lpc31xx_va_base_mpmc
 
 	/* Drain write buffer */
 	mcr	p15, 0, r0, c7, c10, 4
@@ -119,32 +119,32 @@ ENTRY(lpc313x_suspend_mem)
 	/* Wait for SDRAM busy status to go busy and then idle
 	 * This guarantees a small windows where DRAM isn't busy
 	 */
-1:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
-	tst r4, #LPC313x_STAT_WB
+1:	ldr r4, [r2, #LPC31xx_MPMC_STAT_OFS]
+	tst r4, #LPC31xx_STAT_WB
 	bne 1b
-2:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
-	tst r4, #LPC313x_STAT_BS
+2:	ldr r4, [r2, #LPC31xx_MPMC_STAT_OFS]
+	tst r4, #LPC31xx_STAT_BS
 	beq 2b
-3:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
-	tst r4, #LPC313x_STAT_BS
+3:	ldr r4, [r2, #LPC31xx_MPMC_STAT_OFS]
+	tst r4, #LPC31xx_STAT_BS
 	bne 3b
-	mov r3, #LPC313x_DYNC_SR
+	mov r3, #LPC31xx_DYNC_SR
 	/* Enable SDRAM self-refresh mode */
-	str	r3, [r2, #LPC313x_MPMC_DYNC_OFS]
+	str	r3, [r2, #LPC31xx_MPMC_DYNC_OFS]
 	/* wait until SDRAM enters self-refresh */
-4:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
-	tst r4, #LPC313x_STAT_SR
+4:	ldr r4, [r2, #LPC31xx_MPMC_STAT_OFS]
+	tst r4, #LPC31xx_STAT_SR
 	beq 4b
 	/* put MPMC in low-power mode */
-	mov r3, #LPC313x_MPMC_LOW
+	mov r3, #LPC31xx_MPMC_LOW
 	/* Enable SDRAM self-refresh mode */
-	str	r3, [r2, #LPC313x_MPMC_CTL_OFS]
+	str	r3, [r2, #LPC31xx_MPMC_CTL_OFS]
 
 	/* Skip PLL power-down for standby. */
 	cmp r0, #0
 	bne 5f
 	/* Switch all bases domain clocks to FFAST.
-	 * lpc313x_enter_suspend_mem() is called before this.
+	 * lpc31xx_enter_suspend_mem() is called before this.
 	 */
 	ldr	r5, [r1]
 	eor r5, r5, #3
@@ -156,23 +156,23 @@ ENTRY(lpc313x_suspend_mem)
 	/*
 	 * power-down plls
 	 */
-	ldr	r10, [r1, #LPC313x_CGU_HP0_MD_OFS]
-	orr r3, r12, #LPC313x_HP_MODE_PD
-	str	r3, [r1, #LPC313x_CGU_HP0_MD_OFS]
-	ldr	r11, [r1, #LPC313x_CGU_HP1_MD_OFS]
-	orr r3, r12, #LPC313x_HP_MODE_PD
-	str	r3, [r1, #LPC313x_CGU_HP1_MD_OFS]
+	ldr	r10, [r1, #LPC31xx_CGU_HP0_MD_OFS]
+	orr r3, r12, #LPC31xx_HP_MODE_PD
+	str	r3, [r1, #LPC31xx_CGU_HP0_MD_OFS]
+	ldr	r11, [r1, #LPC31xx_CGU_HP1_MD_OFS]
+	orr r3, r12, #LPC31xx_HP_MODE_PD
+	str	r3, [r1, #LPC31xx_CGU_HP1_MD_OFS]
 
 	/* Go to sleep zzzzzzzzz */
-5:	mov r3, #LPC313x_PWR_SLEEP
-	str r3, [r1, #LPC313x_CGU_PWR_OFS]
+5:	mov r3, #LPC31xx_PWR_SLEEP
+	str r3, [r1, #LPC31xx_CGU_PWR_OFS]
 
 	/* Skip PLL power-ups for standby. */
 	cmp r0, #0
 	bne 6f
 	/* Turn on plls */
-	str	r10, [r1, #LPC313x_CGU_HP0_MD_OFS]
-	str	r11, [r1, #LPC313x_CGU_HP1_MD_OFS]
+	str	r10, [r1, #LPC31xx_CGU_HP0_MD_OFS]
+	str	r11, [r1, #LPC31xx_CGU_HP1_MD_OFS]
 
 	wait_hp0_lock
 	wait_hp1_lock
@@ -188,29 +188,29 @@ ENTRY(lpc313x_suspend_mem)
 	str	r5, [r1, #4]
 
 	/* restore MPMC from low-power mode */
-6:	MOV r3, #LPC313x_MPMC_NORM
+6:	MOV r3, #LPC31xx_MPMC_NORM
 	/* Enable SDRAM self-refresh mode */
-	str	r3, [r2, #LPC313x_MPMC_CTL_OFS]
+	str	r3, [r2, #LPC31xx_MPMC_CTL_OFS]
 
 	/* Restore dync_ctl. Remove self-refresh. */
 	mov r3, #0
-	str	r3, [r2, #LPC313x_MPMC_DYNC_OFS]
+	str	r3, [r2, #LPC31xx_MPMC_DYNC_OFS]
 	/* wait until SDRAM exits self-refresh */
-7:	ldr r4, [r2, #LPC313x_MPMC_STAT_OFS]
-	tst r4, #LPC313x_STAT_SR
+7:	ldr r4, [r2, #LPC31xx_MPMC_STAT_OFS]
+	tst r4, #LPC31xx_STAT_SR
 	bne 7b
 
 	/* Restore registers, and return */
 	ldmfd	sp!, {r0 - r12, pc}
 
 
-.lpc313x_va_base_cgu:
+.lpc31xx_va_base_cgu:
 	.word io_p2v(CGU_SB_PHYS)
 
-.lpc313x_va_base_mpmc:
+.lpc31xx_va_base_mpmc:
 	.word io_p2v(MPMC_PHYS)
 
-ENTRY(lpc313x_suspend_mem_sz)
-	.word .-lpc313x_suspend_mem
+ENTRY(lpc31xx_suspend_mem_sz)
+	.word .-lpc31xx_suspend_mem
 
 
diff --git a/arch/arm/mach-lpc31xx/psu.c b/arch/arm/mach-lpc31xx/psu.c
index 45b187e..5385fea 100644
--- a/arch/arm/mach-lpc31xx/psu.c
+++ b/arch/arm/mach-lpc31xx/psu.c
@@ -1,4 +1,4 @@
-/*  linux/arch/arm/mach-lpc313x/leds.c
+/*  linux/arch/arm/mach-lpc31xx/leds.c
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
diff --git a/arch/arm/mach-lpc31xx/sram.c b/arch/arm/mach-lpc31xx/sram.c
index ad77715..27f78ea 100644
--- a/arch/arm/mach-lpc31xx/sram.c
+++ b/arch/arm/mach-lpc31xx/sram.c
@@ -1,5 +1,5 @@
 /*
- * LPC313x sram driver
+ * LPC31xx sram driver
  *
  * Copyright (C) 2012 Jon Smirl <jonsmirl@gmail.com?
  *
@@ -34,7 +34,7 @@
 #define MPMC_STWTWR        0x14
 #define MPMC_STWTTURN      0x18
 
-static int lpc313x_sram_probe(struct platform_device *pdev)
+static int lpc31xx_sram_probe(struct platform_device *pdev)
 {
 	const unsigned int *prop;
 	const unsigned int *ranges;
@@ -80,34 +80,34 @@ static int lpc313x_sram_probe(struct platform_device *pdev)
 	return  -EINVAL;
 }
 
-static const struct of_device_id lpc313x_sram_of_match[] = {
+static const struct of_device_id lpc31xx_sram_of_match[] = {
 	{ .compatible = "nxp,lpc31xx-sram" },
 	{},
 };
-MODULE_DEVICE_TABLE(of, lpc313x_sram_of_match);
+MODULE_DEVICE_TABLE(of, lpc31xx_sram_of_match);
 
-static struct platform_driver lpc313x_sram_driver = {
-	.probe = lpc313x_sram_probe,
+static struct platform_driver lpc31xx_sram_driver = {
+	.probe = lpc31xx_sram_probe,
 	.driver = {
 			.owner = THIS_MODULE,
-			.name = "lpc313x-sram",
-			.of_match_table = lpc313x_sram_of_match,
+			.name = "lpc31xx-sram",
+			.of_match_table = lpc31xx_sram_of_match,
 		   },
 };
 
-static int __init lpc313x_sram_init(void)
+static int __init lpc31xx_sram_init(void)
 {
-	return platform_driver_register(&lpc313x_sram_driver);
+	return platform_driver_register(&lpc31xx_sram_driver);
 }
 
-static void __exit lpc313x_sram_exit(void)
+static void __exit lpc31xx_sram_exit(void)
 {
-	platform_driver_unregister(&lpc313x_sram_driver);
+	platform_driver_unregister(&lpc31xx_sram_driver);
 }
 
-module_init(lpc313x_sram_init);
-module_exit(lpc313x_sram_exit);
+module_init(lpc31xx_sram_init);
+module_exit(lpc31xx_sram_exit);
 
 MODULE_AUTHOR("Jon Smirl <jonsmirl@gmail.com>");
-MODULE_DESCRIPTION("Driver for the LPC313x sram");
+MODULE_DESCRIPTION("Driver for the LPC31xx sram");
 MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-lpc31xx/time.c b/arch/arm/mach-lpc31xx/time.c
index d0a34ec..7fc7ecc 100644
--- a/arch/arm/mach-lpc31xx/time.c
+++ b/arch/arm/mach-lpc31xx/time.c
@@ -1,9 +1,9 @@
-/*  arch/arm/mach-lpc313x/time.c
+/*  arch/arm/mach-lpc31xx/time.c
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- *  Timer driver for LPC313x & LPC315x.
+ *  Timer driver for LPC31xx
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -37,20 +37,20 @@
 //#include <mach/cgu.h>
 
 
-static irqreturn_t lpc313x_timer_interrupt(int irq, void *dev_id)
+static irqreturn_t lpc31xx_timer_interrupt(int irq, void *dev_id)
 {
 	TIMER_CLEAR(TIMER0_PHYS) = 0;
 	timer_tick();
 	return IRQ_HANDLED;
 }
 
-static struct irqaction lpc313x_timer_irq = {
-	.name		= "LPC313x Timer Tick",
+static struct irqaction lpc31xx_timer_irq = {
+	.name		= "LPC31xx Timer Tick",
 	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
-	.handler	= lpc313x_timer_interrupt,
+	.handler	= lpc31xx_timer_interrupt,
 };
 
-static void __init lpc313x_timer_init (void)
+static void __init lpc31xx_timer_init (void)
 {
 	/* Switch on needed Timer clocks & switch off others*/
 	cgu_clk_en_dis(CGU_SB_TIMER0_PCLK_ID, 1);
@@ -64,33 +64,33 @@ static void __init lpc313x_timer_init (void)
 	TIMER_LOAD(TIMER0_PHYS) = LATCH;
 	TIMER_CONTROL(TIMER0_PHYS) = (TM_CTRL_ENABLE | TM_CTRL_PERIODIC);
 	TIMER_CLEAR(TIMER0_PHYS) = 0;
-	setup_irq (IRQ_TIMER0, &lpc313x_timer_irq);
+	setup_irq (IRQ_TIMER0, &lpc31xx_timer_irq);
 }
 
 /*!
  * Returns number of us since last clock interrupt.  Note that interrupts
  * will have been disabled by do_gettimeoffset()
  */
-static unsigned long lpc313x_gettimeoffset(void)
+static unsigned long lpc31xx_gettimeoffset(void)
 {
 	u32 elapsed = LATCH - TIMER_VALUE(TIMER0_PHYS);
 	return ((elapsed * 100) / (XTAL_CLOCK / 20000));
 }
 
-static void lpc313x_timer_suspend(void)
+static void lpc31xx_timer_suspend(void)
 {
 	TIMER_CONTROL(TIMER0_PHYS) &= ~TM_CTRL_ENABLE;	/* disable timers */
 }
 
-static void lpc313x_timer_resume(void)
+static void lpc31xx_timer_resume(void)
 {
 	TIMER_CONTROL(TIMER0_PHYS) |= TM_CTRL_ENABLE;	/* enable timers */
 }
 
 
-struct sys_timer lpc313x_timer = {
-	.init = lpc313x_timer_init,
-	.offset = lpc313x_gettimeoffset,
-	.suspend = lpc313x_timer_suspend,
-	.resume = lpc313x_timer_resume,
+struct sys_timer lpc31xx_timer = {
+	.init = lpc31xx_timer_init,
+	.offset = lpc31xx_gettimeoffset,
+	.suspend = lpc31xx_timer_suspend,
+	.resume = lpc31xx_timer_resume,
 };
diff --git a/arch/arm/mach-lpc31xx/usb.c b/arch/arm/mach-lpc31xx/usb.c
index 8b17bac..35c7186 100644
--- a/arch/arm/mach-lpc31xx/usb.c
+++ b/arch/arm/mach-lpc31xx/usb.c
@@ -1,4 +1,4 @@
-/* linux/arch/arm/mach-lpc313x/usb.c -- platform level USB initialization
+/* linux/arch/arm/mach-lpc31xx/usb.c -- platform level USB initialization
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
@@ -97,7 +97,7 @@
 
 /*-------------------------------------------------------------------------*/
 #if defined(CONFIG_USB_GADGET_FSL_USB2) || defined(CONFIG_USB_OTG)
-static struct resource lpc313x_usb_resource[] = {
+static struct resource lpc31xx_usb_resource[] = {
 	[0] = {
 		.start = (u32) (USBOTG_PHYS),
 		.end   = (u32) (USBOTG_PHYS + SZ_4K),
@@ -111,51 +111,51 @@ static struct resource lpc313x_usb_resource[] = {
 };
 #endif
 
-struct lpc313x_usb_board_t {
+struct lpc31xx_usb_board_t {
 	/* timer for VBUS enable */
 	struct timer_list	vbus_timer;
 	/* board specific over current monitor */
 	int	vbus_ovrc_irq;
 };
 
-static struct lpc313x_usb_board_t lpc313x_usb_brd;
+static struct lpc31xx_usb_board_t lpc31xx_usb_brd;
 
 #if defined(CONFIG_USB_GADGET_FSL_USB2) || defined(CONFIG_USB_OTG)
 
-static struct platform_device lpc313x_udc_device = {
+static struct platform_device lpc31xx_udc_device = {
 	.name = "fsl-usb2-udc",
 	.dev = {
 		.dma_mask          = &usb_dmamask,
 		.coherent_dma_mask = 0xffffffff,
-		.release           = lpc313x_usb_release,
+		.release           = lpc31xx_usb_release,
 	},
-	.num_resources = ARRAY_SIZE(lpc313x_usb_resource),
-	.resource      = lpc313x_usb_resource,
+	.num_resources = ARRAY_SIZE(lpc31xx_usb_resource),
+	.resource      = lpc31xx_usb_resource,
 };
 #endif
 
 #if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_OTG)
 
 #ifndef CONFIG_OF
-static struct platform_device lpc313x_ehci_device = {
+static struct platform_device lpc31xx_ehci_device = {
 	.name		= "lpc-ehci",
 	.dev = {
 		.dma_mask          = &usb_dmamask,
 		.coherent_dma_mask = 0xffffffff,
-		.release           = lpc313x_usb_release,
+		.release           = lpc31xx_usb_release,
 	},
-	.num_resources = ARRAY_SIZE(lpc313x_usb_resource),
-	.resource      = lpc313x_usb_resource,
+	.num_resources = ARRAY_SIZE(lpc31xx_usb_resource),
+	.resource      = lpc31xx_usb_resource,
 };
 #endif
 #endif
 
 
-static irqreturn_t lpc313x_vbus_ovrc_irq(int irq, void *data)
+static irqreturn_t lpc31xx_vbus_ovrc_irq(int irq, void *data)
 {
-	struct lpc313x_usb_board_t* brd = data;
+	struct lpc31xx_usb_board_t* brd = data;
 	/* disable VBUS power */
-	lpc313x_vbus_power(0);
+	lpc31xx_vbus_power(0);
 	/* Disable over current IRQ */
 	disable_irq_nosync(irq);
 	printk(KERN_INFO "Disabling VBUS as device is drawing too much current!!\n");
@@ -167,11 +167,11 @@ static irqreturn_t lpc313x_vbus_ovrc_irq(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static void lpc313x_vbusen_timer(unsigned long data)
+static void lpc31xx_vbusen_timer(unsigned long data)
 {
-	struct lpc313x_usb_board_t* brd = (struct lpc313x_usb_board_t*)data;
+	struct lpc31xx_usb_board_t* brd = (struct lpc31xx_usb_board_t*)data;
 	/* enable VBUS power */
-	lpc313x_vbus_power(1);
+	lpc31xx_vbus_power(1);
 	msleep(2);
 	/* enable the VBUS overcurrent monitoring IRQ */
 	enable_irq(brd->vbus_ovrc_irq);
@@ -220,9 +220,9 @@ int __init usbotg_init(void)
 #if defined(CONFIG_USB_GADGET_FSL_USB2)
 		/* register gadget */
 		printk(KERN_INFO "Registering USB gadget 0x%08x 0x%08x (%d)\n", USB_DEV_OTGSC, EVRT_RSR(bank), bank);
-		retval = platform_device_register(&lpc313x_udc_device);
+		retval = platform_device_register(&lpc31xx_udc_device);
 		if ( 0 != retval )
-			printk(KERN_INFO "Can't register lpc313x_udc_device device\n");
+			printk(KERN_INFO "Can't register lpc31xx_udc_device device\n");
 #else
 		printk(KERN_ERR "Unable to register USB gadget. Check USB_ID jumper!!!!!\n");
 #endif
@@ -231,13 +231,13 @@ int __init usbotg_init(void)
 		/* register host */
 #ifndef CONFIG_OF
 		printk(KERN_INFO "Registering USB host 0x%08x 0x%08x (%d)\n", USB_DEV_OTGSC, EVRT_RSR(bank), bank);
-		retval = platform_device_register(&lpc313x_ehci_device);
+		retval = platform_device_register(&lpc31xx_ehci_device);
 		if ( 0 != retval )
-			printk(KERN_INFO "Can't register lpc313x_ehci_device device\n");
+			printk(KERN_INFO "Can't register lpc31xx_ehci_device device\n");
 #endif
 		/* Create VBUS enable timer */
-		setup_timer(&lpc313x_usb_brd.vbus_timer, lpc313x_vbusen_timer,
-				(unsigned long)&lpc313x_usb_brd);
+		setup_timer(&lpc31xx_usb_brd.vbus_timer, lpc31xx_vbusen_timer,
+				(unsigned long)&lpc31xx_usb_brd);
 
 #if defined(CONFIG_MACH_EA313X) || defined(CONFIG_MACH_EA3152)
 		/* set thw I2SRX_WS0 pin as GPIO_IN for vbus overcurrent flag */
@@ -249,17 +249,17 @@ int __init usbotg_init(void)
 		gpio_direction_input(over);
 #endif
 #define IRQ_EA_VBUS_OVRC  37  /* Detect VBUS over current - Host mode */
-		lpc313x_usb_brd.vbus_ovrc_irq = IRQ_EA_VBUS_OVRC;
+		lpc31xx_usb_brd.vbus_ovrc_irq = IRQ_EA_VBUS_OVRC;
 
 #else
-		lpc313x_usb_brd.vbus_ovrc_irq = IRQ_VBUS_OVRC;
+		lpc31xx_usb_brd.vbus_ovrc_irq = IRQ_VBUS_OVRC;
 #endif
 
 #if 0
 		/* request IRQ to handle VBUS power event */
-		retval = request_irq( lpc313x_usb_brd.vbus_ovrc_irq, lpc313x_vbus_ovrc_irq, 
+		retval = request_irq( lpc31xx_usb_brd.vbus_ovrc_irq, lpc31xx_vbus_ovrc_irq,
 			IRQF_DISABLED, "VBUSOVR", 
-			&lpc313x_usb_brd);
+			&lpc31xx_usb_brd);
 		if ( 0 != retval )
 			printk(KERN_INFO "Unable to register IRQ_VBUS_OVRC handler\n");
 #endif
diff --git a/arch/arm/mach-lpc31xx/wdt.c b/arch/arm/mach-lpc31xx/wdt.c
index 160e8cc..fc9a9e7 100644
--- a/arch/arm/mach-lpc31xx/wdt.c
+++ b/arch/arm/mach-lpc31xx/wdt.c
@@ -1,7 +1,7 @@
 /*
- * LPC313x Watchdog timer device registration
+ * LPC31xx Watchdog timer device registration
  *
- * drivers/watchdog/wdt_lpc313x.c
+ * drivers/watchdog/wdt_lpc31xx.c
  *
  * Copyright (C) 2009 NXP Semiconductors
  *
@@ -34,7 +34,7 @@ static struct resource watchdog_resources[] = {
 };
 
 static struct platform_device watchdog_device = {
-	.name = "lpc313x-wdt",
+	.name = "lpc31xx-wdt",
 	.id = -1,
 	.num_resources = ARRAY_SIZE(watchdog_resources),
 	.resource = watchdog_resources,
diff --git a/drivers/dma/lpc31xx-dma.c b/drivers/dma/lpc31xx-dma.c
index 326a03f..f727acb 100644
--- a/drivers/dma/lpc31xx-dma.c
+++ b/drivers/dma/lpc31xx-dma.c
@@ -1,9 +1,9 @@
-/*  arch/arm/mach-lpc313x/dma.c
+/*  arch/arm/mach-lpc31xx/dma.c
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- *  DMA driver for machines with LPC313x and LPC315x SoCs.
+ *  DMA driver for machines with LPC31xx SoCs.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -1149,11 +1149,11 @@ static int __exit lpc31xx_dma_remove(struct platform_device *pdev)
 }
 
 #if defined(CONFIG_OF)
-static const struct of_device_id lpc313x_dma_of_match[] = {
+static const struct of_device_id lpc31xx_dma_of_match[] = {
 	{ .compatible = "nxp,lpc31xx-dma" },
 	{},
 };
-MODULE_DEVICE_TABLE(of, lpc313x_dma_of_match);
+MODULE_DEVICE_TABLE(of, lpc31xx_dma_of_match);
 #endif
 
 static struct platform_driver lpc31xx_dma_driver = {
@@ -1161,7 +1161,7 @@ static struct platform_driver lpc31xx_dma_driver = {
 			.name	= "lpc31xx-dma",
 			.owner = THIS_MODULE,
 #ifdef CONFIG_OF
-			.of_match_table = lpc313x_dma_of_match,
+			.of_match_table = lpc31xx_dma_of_match,
 #endif
 	},
 	.remove		= __exit_p(lpc31xx_dma_remove),
diff --git a/drivers/gpio/gpio-lpc31xx.c b/drivers/gpio/gpio-lpc31xx.c
index 9d57e60..0f25f73 100644
--- a/drivers/gpio/gpio-lpc31xx.c
+++ b/drivers/gpio/gpio-lpc31xx.c
@@ -1,8 +1,8 @@
-/* linux/arch/arm/mach-lpc313x/gpiolib.c
+/* linux/arch/arm/mach-lpc31xx/gpiolib.c
  *
  * Copyright (c) 2011 Jon Smirl <jonsmirl@gmail.com>
  *
- * LPC313X GPIOlib support
+ * LPC31XX GPIOlib support
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -77,7 +77,7 @@ static struct {
 
 #if 0
 /**
- * struct lpc313x_gpio_chip - wrapper for specific implementation of gpio
+ * struct lpc31xx_gpio_chip - wrapper for specific implementation of gpio
  * @chip: The chip structure to be exported via gpiolib.
  * @base: The base pointer to the gpio configuration registers.
  * @config: special function and pull-resistor control information.
@@ -86,10 +86,10 @@ static struct {
  * This wrapper provides the necessary information for the NXP
  * specific gpios being registered with gpiolib.
  */
-struct lpc313x_gpio_chip {
+struct lpc31xx_gpio_chip {
 	struct gpio_chip	chip;
-	struct lpc313x_gpio_cfg	*config;
-	struct lpc313x_gpio_pm	*pm;
+	struct lpc31xx_gpio_cfg	*config;
+	struct lpc31xx_gpio_pm	*pm;
 	int			base;
 #ifdef CONFIG_PM
 	uint32_t		pm_save[4];
@@ -176,12 +176,12 @@ int lpc3131_reg_to_gpio(unsigned index, unsigned gpio)
 EXPORT_SYMBOL(lpc3131_reg_to_gpio);
 
 
-static int lpc313x_gpiochip_remove(struct platform_device *ofdev)
+static int lpc31xx_gpiochip_remove(struct platform_device *ofdev)
 {
 	return -EBUSY;
 }
 
-static int __devinit lpc313x_simple_gpiochip_probe(struct platform_device *pdev)
+static int __devinit lpc31xx_simple_gpiochip_probe(struct platform_device *pdev)
 {
 	struct lpc31xx_gpio_chip *chip;
 	struct gpio_chip *gc;
@@ -211,28 +211,28 @@ static int __devinit lpc313x_simple_gpiochip_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct of_device_id lpc313x_simple_gpiochip_match[] = {
+static const struct of_device_id lpc31xx_simple_gpiochip_match[] = {
 	{ .compatible = "nxp,lpc31xx-gpio", },
 	{}
 };
 
-static struct platform_driver lpc313x_simple_gpiochip_driver = {
+static struct platform_driver lpc31xx_simple_gpiochip_driver = {
 	.driver = {
 		.name = "lpc31xx-gpio",
 		.owner = THIS_MODULE,
-		.of_match_table = lpc313x_simple_gpiochip_match,
+		.of_match_table = lpc31xx_simple_gpiochip_match,
 	},
-	.probe = lpc313x_simple_gpiochip_probe,
-	.remove = lpc313x_gpiochip_remove,
+	.probe = lpc31xx_simple_gpiochip_probe,
+	.remove = lpc31xx_gpiochip_remove,
 };
 
-static __init int lpc313x_gpiolib_init(void)
+static __init int lpc31xx_gpiolib_init(void)
 {
-	if (platform_driver_register(&lpc313x_simple_gpiochip_driver))
+	if (platform_driver_register(&lpc31xx_simple_gpiochip_driver))
 		printk(KERN_ERR "Unable to register simple GPIO driver\n");
 
 	return 0;
 }
 
 /* Make sure we get initialised before anyone else tries to use us */
-core_initcall(lpc313x_gpiolib_init);
+core_initcall(lpc31xx_gpiolib_init);
diff --git a/drivers/misc/lpc31xx/Kconfig b/drivers/misc/lpc31xx/Kconfig
index 6131c40..58404dc 100644
--- a/drivers/misc/lpc31xx/Kconfig
+++ b/drivers/misc/lpc31xx/Kconfig
@@ -1,18 +1,18 @@
-menuconfig NEW_LPC313x_IO
-	bool "NxP lpc313x IO drivers (ADC, PWM, ...)"
+menuconfig NEW_LPC31xx_IO
+	bool "NxP lpc31xx IO drivers (ADC, PWM, ...)"
 	help
-	  Say Y to enable support for lpc313x series MCU's on-chip peripherials like AD-converter and Pulse Width Modulator..
+	  Say Y to enable support for lpc31xx series MCU's on-chip peripherials like AD-converter and Pulse Width Modulator..
 
-if NEW_LPC313x_IO
+if NEW_LPC31xx_IO
 
-config LPC313x_ADC
-	tristate "lpc313x ADC support"
+config LPC31xx_ADC
+	tristate "lpc31xx ADC support"
 	help
-	  Say Y to enable the ADC driver, when built as a module, the module will be called "lpc313x_adc".
+	  Say Y to enable the ADC driver, when built as a module, the module will be called "lpc31xx_adc".
 	  
-config LPC313x_PWM
-	tristate "lpc313x PWM support"
+config LPC31xx_PWM
+	tristate "lpc31xx PWM support"
 	help
-	   Say Y to enable the PWM driver, when built as a moule, the module will be called "lpc313x_pwm".
+	   Say Y to enable the PWM driver, when built as a moule, the module will be called "lpc31xx_pwm".
 
 endif
diff --git a/drivers/misc/lpc31xx/Makefile b/drivers/misc/lpc31xx/Makefile
index 56a9e4b..40c5653 100644
--- a/drivers/misc/lpc31xx/Makefile
+++ b/drivers/misc/lpc31xx/Makefile
@@ -1,4 +1,4 @@
 
-# LPC3131x ADC
-obj-$(CONFIG_LPC313x_ADC)			+= lpc31xx-adc.o
-obj-$(CONFIG_LPC313x_PWM)			+= lpc31xx-pwm.o
+# LPC31xx ADC
+obj-$(CONFIG_LPC31xx_ADC)			+= lpc31xx-adc.o
+obj-$(CONFIG_LPC31xx_PWM)			+= lpc31xx-pwm.o
diff --git a/drivers/misc/lpc31xx/TODO b/drivers/misc/lpc31xx/TODO
index 9bd887b..c59c3ea 100644
--- a/drivers/misc/lpc31xx/TODO
+++ b/drivers/misc/lpc31xx/TODO
@@ -1,4 +1,4 @@
-a list of all TODOs for the adc and pwm driver for lpc313x:
+a list of all TODOs for the adc and pwm driver for lpc31xx:
 
 
 BOTH:
diff --git a/drivers/misc/lpc31xx/lpc31xx-adc.c b/drivers/misc/lpc31xx/lpc31xx-adc.c
index b7d35a9..fd5b6ef 100644
--- a/drivers/misc/lpc31xx/lpc31xx-adc.c
+++ b/drivers/misc/lpc31xx/lpc31xx-adc.c
@@ -1,5 +1,5 @@
 /* 
- * lpc313x_adc.c
+ * lpc31xx_adc.c
  * 
  * * LAST CHANGE: 3. jan. 2012 Nils Stec
  * 
@@ -7,7 +7,7 @@
  *              Michael Schwarz, (c) 2011                                  - the adc code itself
  *              some module parts are by LKMPG                             - taken from version "2007-05-18 ver 2.6.4"
  *
- * ADC driver for LPC313x (gnublin)
+ * ADC driver for LPC31xx (gnublin)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -65,20 +65,20 @@ static int device_open(struct inode *inode, struct file *file) {
 	Device_Open++;
 	
 	if((adc_powersave == 0)||(adc_powersave == ADC_POWERSAVE_AUTO)) {
-		if(adc_powersave == ADC_POWERSAVE_AUTO) lpc313x_init_adc();
+		if(adc_powersave == ADC_POWERSAVE_AUTO) lpc31xx_init_adc();
 		
 		if(adc_averaging == 1) {
 			for(i = 0; i < adc_averagingloops; i++) {
-				addval += lpc313x_adc_read(adc_channel, adc_resolution);
+				addval += lpc31xx_adc_read(adc_channel, adc_resolution);
 			}
 			adcval = addval / adc_averagingloops;
 			sprintf(msg, "0x%03x\n", adcval);
 		} else {
-			adcval = lpc313x_adc_read(adc_channel, adc_resolution);
+			adcval = lpc31xx_adc_read(adc_channel, adc_resolution);
 			sprintf(msg, "0x%03x\n", adcval);
 		}
 		
-		if(adc_powersave == ADC_POWERSAVE_AUTO) lpc313x_deinit_adc();
+		if(adc_powersave == ADC_POWERSAVE_AUTO) lpc31xx_deinit_adc();
 	} else {
 		sprintf(msg, "adc is in powersave mode!\n");
 	}
@@ -102,16 +102,16 @@ static ssize_t device_write(struct file *filp, const char *buff, size_t len, lof
 	config_word = (u16)(ltemp&0xffff);
 	
 	if(config_word & 0x0080) adc_debug = 1; else adc_debug = 0;
-	if(adc_debug) printk(KERN_INFO "[lpc313x adc] got config word 0x%04x, setting up adc:\n", config_word);
+	if(adc_debug) printk(KERN_INFO "[lpc31xx adc] got config word 0x%04x, setting up adc:\n", config_word);
 	
 	// first of all, check if user want's to see status, if, print it and exit
 	if(((config_word >> 12) & 0x000f)>0) {
-		printk(KERN_INFO "[lpc313x adc] channel:'%d', resolution:'%d'\n", adc_channel, adc_resolution);
-		printk(KERN_INFO "[lpc313x adc] averaging:'%d'loops, on:'%d'\n", adc_averagingloops, adc_averaging);
+		printk(KERN_INFO "[lpc31xx adc] channel:'%d', resolution:'%d'\n", adc_channel, adc_resolution);
+		printk(KERN_INFO "[lpc31xx adc] averaging:'%d'loops, on:'%d'\n", adc_averagingloops, adc_averaging);
 		switch(adc_powersave) {
-			case ADC_POWERSAVE_OFF:  printk(KERN_INFO "[lpc313x adc] powersave off, adc always on\n"); break;
-			case ADC_POWERSAVE_ON:   printk(KERN_INFO "[lpc313x adc] powersave on, adc always off\n"); break;
-			case ADC_POWERSAVE_AUTO: printk(KERN_INFO "[lpc313x adc] powersave auto (default)\n");     break;
+			case ADC_POWERSAVE_OFF:  printk(KERN_INFO "[lpc31xx adc] powersave off, adc always on\n"); break;
+			case ADC_POWERSAVE_ON:   printk(KERN_INFO "[lpc31xx adc] powersave on, adc always off\n"); break;
+			case ADC_POWERSAVE_AUTO: printk(KERN_INFO "[lpc31xx adc] powersave auto (default)\n");     break;
 		}
 		return len;
 	}	
@@ -164,29 +164,29 @@ static ssize_t device_write(struct file *filp, const char *buff, size_t len, lof
 	switch(((config_word >> 8) & 0x0003)) {	// get adc powersave mode config
 		case 0:
 			adc_powersave = ADC_POWERSAVE_OFF;	// adc powersave off, adc always on
-			lpc313x_init_adc();			// turn on adc
+			lpc31xx_init_adc();			// turn on adc
 			break;
 		case 1:
 			adc_powersave = ADC_POWERSAVE_AUTO;	// adc powersave auto, on/off when needed, takes more time, saves power (default)
-			lpc313x_deinit_adc();			// turn off adc
+			lpc31xx_deinit_adc();			// turn off adc
 			break;
 		case 2:
 			adc_powersave = ADC_POWERSAVE_ON;	// adc always off
-			lpc313x_deinit_adc();			// turn off adc
+			lpc31xx_deinit_adc();			// turn off adc
 			break;
 		default:
 			adc_powersave = ADC_POWERSAVE_AUTO;	// default behaviour, AUTO
-			lpc313x_deinit_adc();			// turn off adc
+			lpc31xx_deinit_adc();			// turn off adc
 			break;
 	}	
 
 	if(adc_debug) {
-		printk(KERN_INFO "[lpc313x adc] channel:'%d', resolution:'%d'\n", adc_channel, adc_resolution);
-		printk(KERN_INFO "[lpc313x adc] averaging:'%d'loops, on:'%d'\n", adc_averagingloops, adc_averaging);
+		printk(KERN_INFO "[lpc31xx adc] channel:'%d', resolution:'%d'\n", adc_channel, adc_resolution);
+		printk(KERN_INFO "[lpc31xx adc] averaging:'%d'loops, on:'%d'\n", adc_averagingloops, adc_averaging);
 			switch(adc_powersave) {
-				case ADC_POWERSAVE_OFF:  printk(KERN_INFO "[lpc313x adc] powersave off, adc always on\n"); break;
-				case ADC_POWERSAVE_ON:   printk(KERN_INFO "[lpc313x adc] powersave on, adc always off\n"); break;
-				case ADC_POWERSAVE_AUTO: printk(KERN_INFO "[lpc313x adc] powersave auto (default)\n");     break;
+				case ADC_POWERSAVE_OFF:  printk(KERN_INFO "[lpc31xx adc] powersave off, adc always on\n"); break;
+				case ADC_POWERSAVE_ON:   printk(KERN_INFO "[lpc31xx adc] powersave on, adc always off\n"); break;
+				case ADC_POWERSAVE_AUTO: printk(KERN_INFO "[lpc31xx adc] powersave auto (default)\n");     break;
 		}
 	}
 	return len;
@@ -204,31 +204,31 @@ int init_module(void) {
 	
 	Major = register_chrdev(0, DEVICE_NAME, &fops);
 	if (Major < 0) {
-		printk(KERN_ALERT "[lpc313x adc] registering char device failed with %d\n", Major);
+		printk(KERN_ALERT "[lpc31xx adc] registering char device failed with %d\n", Major);
 		return Major;
 	}
 
 	switch(adc_powersave) {
 		case ADC_POWERSAVE_AUTO:
 		case ADC_POWERSAVE_ON:
-			lpc313x_deinit_adc();
+			lpc31xx_deinit_adc();
 			break;
 		case ADC_POWERSAVE_OFF:
-			lpc313x_init_adc();
+			lpc31xx_init_adc();
 			break;
 	}	
 	
-	printk(KERN_INFO "[lpc313x adc] driver loaded with major %d\n", Major);
-	printk(KERN_INFO "[lpc313x adc] >> $ mknod /dev/%s c %d 0\n", DEVICE_NAME, Major);
+	printk(KERN_INFO "[lpc31xx adc] driver loaded with major %d\n", Major);
+	printk(KERN_INFO "[lpc31xx adc] >> $ mknod /dev/%s c %d 0\n", DEVICE_NAME, Major);
 	
 	return SUCCESS;
 }
 
 /** called when module unloaded */
 void cleanup_module(void) {
-	lpc313x_deinit_adc();
+	lpc31xx_deinit_adc();
 	unregister_chrdev(Major, DEVICE_NAME);
-	printk(KERN_INFO "[lpc313x adc] DRIVER UNLOADED\n");
+	printk(KERN_INFO "[lpc31xx adc] DRIVER UNLOADED\n");
 }
 
 /* Called when a process closes the device file. */
@@ -254,7 +254,7 @@ static ssize_t device_read(struct file *filp, char *buffer, size_t length, loff_
 	return bytes_read;
 }
 
-u16 lpc313x_adc_read(int channel, int resolution) {
+u16 lpc31xx_adc_read(int channel, int resolution) {
 	u16 result = 0xffff;
 	int timeout = 0xffffff;
  
@@ -300,7 +300,7 @@ u16 lpc313x_adc_read(int channel, int resolution) {
 	return result;
 }
 
-int lpc313x_init_adc(void) {
+int lpc31xx_init_adc(void) {
 	int dummy;
 	u32 timeout;
 	
@@ -333,7 +333,7 @@ int lpc313x_init_adc(void) {
 	return 0;
 }
 
-int lpc313x_deinit_adc(void) {
+int lpc31xx_deinit_adc(void) {
 	/* wait while there is a conversion */
 	while (ADC_INT_STATUS_REG & 0x10);
 
@@ -350,12 +350,12 @@ int lpc313x_deinit_adc(void) {
 	return 0;
 }
 /*
-int lpc313x_adc_powersave_on(void) {
+int lpc31xx_adc_powersave_on(void) {
 	ADC_CON_REG = ADC_CON_DEFAULT;
 	return 0;
 }
 
-int lpc313x_adc_powersave_off(void) {
+int lpc31xx_adc_powersave_off(void) {
 	ADC_CON_REG |= ADC_ENABLE;
 	return 0;
 }
@@ -367,4 +367,4 @@ module_exit(cleanup_module);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_SUPPORTED_DEVICE("lpc313x adc on gnublin");
+MODULE_SUPPORTED_DEVICE("lpc31xx adc on gnublin");
diff --git a/drivers/misc/lpc31xx/lpc31xx-adc.h b/drivers/misc/lpc31xx/lpc31xx-adc.h
index 659e8f0..c277c59 100644
--- a/drivers/misc/lpc31xx/lpc31xx-adc.h
+++ b/drivers/misc/lpc31xx/lpc31xx-adc.h
@@ -7,7 +7,7 @@
  *              Michael Schwarz, (c) 2011                             - the adc code itself
  *              some module parts are by LKMPG                        - taken from version "2007-05-18 ver 2.6.4"
  * 	
- * ADC driver for LPC313x (gnublin)
+ * ADC driver for LPC31xx (gnublin)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -37,10 +37,10 @@
 
 #define SUCCESS		0
 
-#define DEVICE_NAME	"lpc313x_adc"	/* Dev name as it appears in /proc/devices   */
+#define DEVICE_NAME	"lpc31xx_adc"	/* Dev name as it appears in /proc/devices   */
 #define BUF_LEN 	8		/* length of the receive/send buffer, max 192 byte = 191 chars + trailing zero */
 #define DRIVER_AUTHOR	"2011 Nils Stec \"krumeltee\" <info@fi-no.de>, 2011 Michael Schwarz"
-#define DRIVER_DESC	"lpc313x adc driver for gnublin"
+#define DRIVER_DESC	"lpc31xx adc driver for gnublin"
 
 /* if you haven't applied the adc-registers patch, you will need these defines. */
 /*
@@ -89,10 +89,10 @@ static ssize_t device_read(struct file *, char *, size_t, loff_t *);
 static ssize_t device_write(struct file *, const char *, size_t, loff_t *);
 #endif // __ADC_DRV_C__
 
-static u16 lpc313x_adc_read(int channel, int resolution);
-static int lpc313x_init_adc(void);
-static int lpc313x_deinit_adc(void);
-//static int lpc313x_adc_powersave_on(void);
-//static int lpc313x_adc_powersave_off(void);
+static u16 lpc31xx_adc_read(int channel, int resolution);
+static int lpc31xx_init_adc(void);
+static int lpc31xx_deinit_adc(void);
+//static int lpc31xx_adc_powersave_on(void);
+//static int lpc31xx_adc_powersave_off(void);
 
 #endif // __GNUBLIN_IO_H__
diff --git a/drivers/misc/lpc31xx/lpc31xx-pwm.c b/drivers/misc/lpc31xx/lpc31xx-pwm.c
index 1c23f78..45ca277 100644
--- a/drivers/misc/lpc31xx/lpc31xx-pwm.c
+++ b/drivers/misc/lpc31xx/lpc31xx-pwm.c
@@ -3,7 +3,7 @@
  *  Author:    Michael Schwarz
  *  Copyright (C) 2011 Michael Schwarz
  *
- * PWM module for LPC313x
+ * PWM module for LPC31xx
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -65,7 +65,7 @@ static ssize_t device_write(struct file *filp, const char *buff, size_t len, lof
  pwm_value = (in_buffer[0] + (in_buffer[1] << 8));
  PWM_TMR_REG = pwm_value & PWM_MR_MASK;
  
- printk("[lpc313x pwm debug message] pwm to %d (%d%%)\n", pwm_value, pwm_value * 100 / 4095);
+ printk("[lpc31xx pwm debug message] pwm to %d (%d%%)\n", pwm_value, pwm_value * 100 / 4095);
 
  return len;
 }
@@ -90,7 +90,7 @@ static int device_release(struct inode *inode, struct file *file) {
 
 
 int __init init_pwm(void) {
- printk("[lpc313x pwm] pwm frequency: %u Hz\n", cgu_get_clk_freq(CGU_SB_PWM_CLK_ID) / 4096);
+ printk("[lpc31xx pwm] pwm frequency: %u Hz\n", cgu_get_clk_freq(CGU_SB_PWM_CLK_ID) / 4096);
  
  /* enable clock for PWM */
  cgu_clk_en_dis(CGU_SB_PWM_PCLK_ID, 1);
@@ -103,11 +103,11 @@ int __init init_pwm(void) {
  
  dev_major = register_chrdev(0, DEVICE_NAME, &fops);
  if (dev_major < 0) {
-  printk(KERN_ALERT "[lpc313x pwm] Registering char device failed with %d\n", dev_major);
+  printk(KERN_ALERT "[lpc31xx pwm] Registering char device failed with %d\n", dev_major);
   return dev_major;
  }
- printk(KERN_INFO "[lpc313x pwm] driver loaded with major %d\n", dev_major);
- printk(KERN_INFO "[lpc313x pwm] >> $ mknod /dev/%s c %d 0\n", DEVICE_NAME, dev_major);
+ printk(KERN_INFO "[lpc31xx pwm] driver loaded with major %d\n", dev_major);
+ printk(KERN_INFO "[lpc31xx pwm] >> $ mknod /dev/%s c %d 0\n", DEVICE_NAME, dev_major);
  
  pwm_value = 0; 
  
@@ -115,7 +115,7 @@ int __init init_pwm(void) {
 }
 
 void __exit cleanup_pwm(void) {
- printk("[lpc313x pwm] cleanup\n");
+ printk("[lpc31xx pwm] cleanup\n");
  
  /* disable clock for PWM */
  cgu_clk_en_dis(CGU_SB_PWM_PCLK_ID, 0);
diff --git a/drivers/misc/lpc31xx/lpc31xx-pwm.h b/drivers/misc/lpc31xx/lpc31xx-pwm.h
index 39d1565..777def6 100644
--- a/drivers/misc/lpc31xx/lpc31xx-pwm.h
+++ b/drivers/misc/lpc31xx/lpc31xx-pwm.h
@@ -1,5 +1,5 @@
-#ifndef __LPC313x_PWM_H__
-#define __LPC313x_PWM_H__
+#ifndef __LPC31xx_PWM_H__
+#define __LPC31xx_PWM_H__
 
 
 #define PWM_AUTHOR        "Michael Schwarz"
@@ -29,7 +29,7 @@
 
 
 // device
-#define DEVICE_NAME           "lpc313x_pwm"
+#define DEVICE_NAME           "lpc31xx_pwm"
 #define DEVICE_LEN            4
 
 
@@ -39,4 +39,4 @@ static ssize_t device_read(struct file *, char *, size_t, loff_t *);
 static ssize_t device_write(struct file *, const char *, size_t, loff_t *);
 
 
-#endif // __LPC313x_PWM_H__
\ No newline at end of file
+#endif // __LPC31xx_PWM_H__
diff --git a/drivers/mmc/host/lpc31xx_mmc.c b/drivers/mmc/host/lpc31xx_mmc.c
index c4d9ce7..0dd758c 100644
--- a/drivers/mmc/host/lpc31xx_mmc.c
+++ b/drivers/mmc/host/lpc31xx_mmc.c
@@ -1,7 +1,7 @@
 /*
- * LPC313x MultiMedia Card Interface driver
+ * LPC31xx MultiMedia Card Interface driver
  *
- * drivers/mmc/host/lpc313x_mmc.c
+ * drivers/mmc/host/lpc31xx_mmc.c
  *
  * Copyright (C) 2009 NXP Semiconductors
  *
@@ -54,12 +54,12 @@
 //#define USE_DMA
 //#define BURST_DMA
 
-#define LPC313x_MCI_DATA_ERROR_FLAGS	(SDMMC_INT_DTO | SDMMC_INT_DCRC | SDMMC_INT_HTO | SDMMC_INT_SBE | SDMMC_INT_EBE)
-#define LPC313x_MCI_CMD_ERROR_FLAGS	(SDMMC_INT_RTO | SDMMC_INT_RCRC | SDMMC_INT_RESP_ERR | SDMMC_INT_HLE)
-#define LPC313x_MCI_ERROR_FLAGS		(LPC313x_MCI_DATA_ERROR_FLAGS | LPC313x_MCI_CMD_ERROR_FLAGS | SDMMC_INT_HLE)
-#define LPC313x_MCI_SEND_STATUS		1
-#define LPC313x_MCI_RECV_STATUS		2
-#define LPC313x_MCI_DMA_THRESHOLD	16
+#define LPC31xx_MCI_DATA_ERROR_FLAGS	(SDMMC_INT_DTO | SDMMC_INT_DCRC | SDMMC_INT_HTO | SDMMC_INT_SBE | SDMMC_INT_EBE)
+#define LPC31xx_MCI_CMD_ERROR_FLAGS	(SDMMC_INT_RTO | SDMMC_INT_RCRC | SDMMC_INT_RESP_ERR | SDMMC_INT_HLE)
+#define LPC31xx_MCI_ERROR_FLAGS		(LPC31xx_MCI_DATA_ERROR_FLAGS | LPC31xx_MCI_CMD_ERROR_FLAGS | SDMMC_INT_HLE)
+#define LPC31xx_MCI_SEND_STATUS		1
+#define LPC31xx_MCI_RECV_STATUS		2
+#define LPC31xx_MCI_DMA_THRESHOLD	16
 
 enum {
 	EVENT_CMD_COMPLETE = 0,
@@ -70,7 +70,7 @@ enum {
 };
 
 
-enum lpc313x_mci_state {
+enum lpc31xx_mci_state {
 	STATE_IDLE = 0,
 	STATE_SENDING_CMD,
 	STATE_SENDING_DATA,
@@ -80,16 +80,16 @@ enum lpc313x_mci_state {
 };
 
 /*forward declaration */
-struct lpc313x_mci_slot;
+struct lpc31xx_mci_slot;
 
-struct lpc313x_mci {
+struct lpc31xx_mci {
 	spinlock_t		lock;
 	void __iomem		*regs;
 
 	struct scatterlist	*sg;
 	unsigned int		pio_offset;
 
-	struct lpc313x_mci_slot	*cur_slot;
+	struct lpc31xx_mci_slot	*cur_slot;
 	struct mmc_request	*mrq;
 	struct mmc_command	*cmd;
 	struct mmc_data		*data;
@@ -106,19 +106,19 @@ struct lpc313x_mci {
 	struct tasklet_struct	tasklet;
 	unsigned long		pending_events;
 	unsigned long		completed_events;
-	enum lpc313x_mci_state	state;
+	enum lpc31xx_mci_state	state;
 	struct list_head	queue;
 
 	u32			bus_hz;
 	u32			current_speed;
 	struct platform_device	*pdev;
 	int slot_count;
-	struct lpc313x_mci_slot	*slot[MAX_MCI_SLOTS];
+	struct lpc31xx_mci_slot	*slot[MAX_MCI_SLOTS];
 };
 
-struct lpc313x_mci_slot {
+struct lpc31xx_mci_slot {
 	struct mmc_host		*mmc;
-	struct lpc313x_mci	*host;
+	struct lpc31xx_mci	*host;
 
 	u32			ctype;
 
@@ -127,9 +127,9 @@ struct lpc313x_mci_slot {
 
 	unsigned int		clock;
 	unsigned long		flags;
-#define LPC313x_MMC_CARD_PRESENT	0
-#define LPC313x_MMC_CARD_NEED_INIT	1
-#define LPC313x_MMC_SHUTDOWN		2
+#define LPC31xx_MMC_CARD_PRESENT	0
+#define LPC31xx_MMC_CARD_NEED_INIT	1
+#define LPC31xx_MMC_SHUTDOWN		2
 	int			id;
 	int			irq;
 
@@ -142,23 +142,23 @@ struct lpc313x_mci_slot {
 };
 
 /* Register access macros */
-static inline uint32_t mci_readl(struct lpc313x_mci *host, uint32_t reg)
+static inline uint32_t mci_readl(struct lpc31xx_mci *host, uint32_t reg)
 {
 	return __raw_readl(host->regs + reg);
 }
 
-static inline void mci_writel(struct lpc313x_mci *host, uint32_t reg, uint32_t value)
+static inline void mci_writel(struct lpc31xx_mci *host, uint32_t reg, uint32_t value)
 {
 	__raw_writel(value, host->regs + reg);
 }
 
 
-#define lpc313x_mci_test_and_clear_pending(host, event)		\
+#define lpc31xx_mci_test_and_clear_pending(host, event)		\
 	test_and_clear_bit(event, &host->pending_events)
-#define lpc313x_mci_set_completed(host, event)			\
+#define lpc31xx_mci_set_completed(host, event)			\
 	set_bit(event, &host->completed_events)
 
-#define lpc313x_mci_set_pending(host, event)				\
+#define lpc31xx_mci_set_pending(host, event)				\
 	set_bit(event, &host->pending_events)
 
 #if defined (CONFIG_DEBUG_FS)
@@ -166,9 +166,9 @@ static inline void mci_writel(struct lpc313x_mci *host, uint32_t reg, uint32_t v
  * The debugfs stuff below is mostly optimized away when
  * CONFIG_DEBUG_FS is not set.
  */
-static int lpc313x_mci_req_show(struct seq_file *s, void *v)
+static int lpc31xx_mci_req_show(struct seq_file *s, void *v)
 {
-	struct lpc313x_mci_slot	*slot = s->private;
+	struct lpc31xx_mci_slot	*slot = s->private;
 	struct mmc_request	*mrq;
 	struct mmc_command	*cmd;
 	struct mmc_command	*stop;
@@ -206,20 +206,20 @@ static int lpc313x_mci_req_show(struct seq_file *s, void *v)
 	return 0;
 }
 
-static int lpc313x_mci_req_open(struct inode *inode, struct file *file)
+static int lpc31xx_mci_req_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, lpc313x_mci_req_show, inode->i_private);
+	return single_open(file, lpc31xx_mci_req_show, inode->i_private);
 }
 
-static const struct file_operations lpc313x_mci_req_fops = {
+static const struct file_operations lpc31xx_mci_req_fops = {
 	.owner		= THIS_MODULE,
-	.open		= lpc313x_mci_req_open,
+	.open		= lpc31xx_mci_req_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
 	.release	= single_release,
 };
 
-static int lpc313x_mci_regs_show(struct seq_file *s, void *v)
+static int lpc31xx_mci_regs_show(struct seq_file *s, void *v)
 {
 	seq_printf(s, "STATUS:\t0x%08x\n",SDMMC_STATUS);
 	seq_printf(s, "RINTSTS:\t0x%08x\n",SDMMC_RINTSTS);
@@ -231,23 +231,23 @@ static int lpc313x_mci_regs_show(struct seq_file *s, void *v)
 	return 0;
 }
 
-static int lpc313x_mci_regs_open(struct inode *inode, struct file *file)
+static int lpc31xx_mci_regs_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, lpc313x_mci_regs_show, inode->i_private);
+	return single_open(file, lpc31xx_mci_regs_show, inode->i_private);
 }
 
-static const struct file_operations lpc313x_mci_regs_fops = {
+static const struct file_operations lpc31xx_mci_regs_fops = {
 	.owner		= THIS_MODULE,
-	.open		= lpc313x_mci_regs_open,
+	.open		= lpc31xx_mci_regs_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
 	.release	= single_release,
 };
 
-static void lpc313x_mci_init_debugfs(struct lpc313x_mci_slot *slot)
+static void lpc31xx_mci_init_debugfs(struct lpc31xx_mci_slot *slot)
 {
 	struct mmc_host		*mmc = slot->mmc;
-	struct lpc313x_mci	*host = slot->host;
+	struct lpc31xx_mci	*host = slot->host;
 	struct dentry		*root;
 	struct dentry		*node;
 
@@ -256,13 +256,13 @@ static void lpc313x_mci_init_debugfs(struct lpc313x_mci_slot *slot)
 		return;
 
 	node = debugfs_create_file("regs", S_IRUSR, root, host,
-			&lpc313x_mci_regs_fops);
+			&lpc31xx_mci_regs_fops);
 	if (IS_ERR(node))
 		return;
 	if (!node)
 		goto err;
 
-	node = debugfs_create_file("req", S_IRUSR, root, slot, &lpc313x_mci_req_fops);
+	node = debugfs_create_file("req", S_IRUSR, root, slot, &lpc31xx_mci_req_fops);
 	if (!node)
 		goto err;
 
@@ -298,8 +298,8 @@ static inline unsigned ns_to_clocks(unsigned clkrate, unsigned ns)
 	return clks;
 }
 
-static void lpc313x_mci_set_timeout(struct lpc313x_mci *host,
-		struct lpc313x_mci_slot *slot, struct mmc_data *data)
+static void lpc31xx_mci_set_timeout(struct lpc31xx_mci *host,
+		struct lpc31xx_mci_slot *slot, struct mmc_data *data)
 {
 	unsigned timeout;
 
@@ -313,7 +313,7 @@ static void lpc313x_mci_set_timeout(struct lpc313x_mci *host,
 	mci_writel(host, SDMMC_TMOUT, /*0xffffffff); */ (timeout << 8) | (70));
 }
 
-static u32 lpc313x_mci_prepare_command(struct mmc_host *mmc,
+static u32 lpc31xx_mci_prepare_command(struct mmc_host *mmc,
 				 struct mmc_command *cmd)
 {
 	struct mmc_data	*data;
@@ -354,7 +354,7 @@ static u32 lpc313x_mci_prepare_command(struct mmc_host *mmc,
 }
 
 
-static void lpc313x_mci_start_command(struct lpc313x_mci *host,
+static void lpc31xx_mci_start_command(struct lpc31xx_mci *host,
 		struct mmc_command *cmd, u32 cmd_flags)
 {
  	int tmo = 50;
@@ -370,15 +370,15 @@ static void lpc313x_mci_start_command(struct lpc313x_mci *host,
 		cpu_relax();
 }
 
-static void send_stop_cmd(struct lpc313x_mci *host, struct mmc_data *data)
+static void send_stop_cmd(struct lpc31xx_mci *host, struct mmc_data *data)
 {
-	lpc313x_mci_start_command(host, data->stop, host->stop_cmdr);
+	lpc31xx_mci_start_command(host, data->stop, host->stop_cmdr);
 }
 
 
 #ifdef USE_DMA
 
-static void lpc313x_mci_dma_cleanup(struct lpc313x_mci *host)
+static void lpc31xx_mci_dma_cleanup(struct lpc31xx_mci *host)
 {
 	struct mmc_data			*data = host->data;
 
@@ -388,40 +388,40 @@ static void lpc313x_mci_dma_cleanup(struct lpc313x_mci *host)
 		      ? DMA_TO_DEVICE : DMA_FROM_DEVICE));
 }
 
-static void lpc313x_mci_stop_dma(struct lpc313x_mci *host)
+static void lpc31xx_mci_stop_dma(struct lpc31xx_mci *host)
 {
 	if (host->dma_chn > 0) {
 		dma_stop_channel(host->dma_chn);
-		lpc313x_mci_dma_cleanup(host);
+		lpc31xx_mci_dma_cleanup(host);
 	} else {
 		/* Data transfer was stopped by the interrupt handler */
-		lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
+		lpc31xx_mci_set_pending(host, EVENT_XFER_COMPLETE);
 	}
 }
 
 /* This function is called by the DMA driver from tasklet context. */
-static void lpc313x_mci_dma_complete(int chn, dma_irq_type_t type, void *arg)
+static void lpc31xx_mci_dma_complete(int chn, dma_irq_type_t type, void *arg)
 {
-	struct lpc313x_mci	*host = arg;
+	struct lpc31xx_mci	*host = arg;
 	struct mmc_data		*data = host->data;
 
 	dev_vdbg(&host->pdev->dev, "DMA complete\n");
 
 	spin_lock(&host->lock);
-	lpc313x_mci_dma_cleanup(host);
+	lpc31xx_mci_dma_cleanup(host);
 
 	/*
 	 * If the card was removed, data will be NULL. No point trying
 	 * to send the stop command or waiting for NBUSY in this case.
 	 */
 	if (data) {
-		lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
+		lpc31xx_mci_set_pending(host, EVENT_XFER_COMPLETE);
 		tasklet_schedule(&host->tasklet);
 	}
 	spin_unlock(&host->lock);
 }
 
-static int lpc313x_mci_submit_data_dma(struct lpc313x_mci *host, struct mmc_data *data)
+static int lpc31xx_mci_submit_data_dma(struct lpc31xx_mci *host, struct mmc_data *data)
 {
 	struct scatterlist		*sg;
 	unsigned int			i, direction, sg_len;
@@ -436,7 +436,7 @@ static int lpc313x_mci_submit_data_dma(struct lpc313x_mci *host, struct mmc_data
 	 * non-word-aligned buffers or lengths. Also, we don't bother
 	 * with all the DMA setup overhead for short transfers.
 	 */
-	if (data->blocks * data->blksz < LPC313x_MCI_DMA_THRESHOLD)
+	if (data->blocks * data->blksz < LPC31xx_MCI_DMA_THRESHOLD)
 		return -EINVAL;
 	if (data->blksz & 3)
 		return -EINVAL;
@@ -528,19 +528,19 @@ static int lpc313x_mci_submit_data_dma(struct lpc313x_mci *host, struct mmc_data
 }
 
 #else
-static int lpc313x_mci_submit_data_dma(struct lpc313x_mci *host, struct mmc_data *data)
+static int lpc31xx_mci_submit_data_dma(struct lpc31xx_mci *host, struct mmc_data *data)
 {
 	return -ENOSYS;
 }
 
-static void lpc313x_mci_stop_dma(struct lpc313x_mci *host)
+static void lpc31xx_mci_stop_dma(struct lpc31xx_mci *host)
 {
 	/* Data transfer was stopped by the interrupt handler */
-	lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
+	lpc31xx_mci_set_pending(host, EVENT_XFER_COMPLETE);
 }
 #endif
 
-static void lpc313x_mci_submit_data(struct lpc313x_mci *host, struct mmc_data *data)
+static void lpc31xx_mci_submit_data(struct lpc31xx_mci *host, struct mmc_data *data)
 {
 	data->error = -EINPROGRESS;
 
@@ -548,13 +548,13 @@ static void lpc313x_mci_submit_data(struct lpc313x_mci *host, struct mmc_data *d
 	host->sg = NULL;
 	host->data = data;
 
-	if (lpc313x_mci_submit_data_dma(host, data)) {
+	if (lpc31xx_mci_submit_data_dma(host, data)) {
 		host->sg = data->sg;
 		host->pio_offset = 0;
 		if (data->flags & MMC_DATA_READ)
-			host->dir_status = LPC313x_MCI_RECV_STATUS;
+			host->dir_status = LPC31xx_MCI_RECV_STATUS;
 		else
-			host->dir_status = LPC313x_MCI_SEND_STATUS;
+			host->dir_status = LPC31xx_MCI_SEND_STATUS;
 
 		//SDMMC_INTMASK |= (SDMMC_INT_RXDR | SDMMC_INT_TXDR);
 		mci_writel(host, SDMMC_CTRL, mci_readl(host, SDMMC_CTRL) & ~SDMMC_CTRL_DMA_ENABLE); // enable dma
@@ -568,9 +568,9 @@ static void lpc313x_mci_submit_data(struct lpc313x_mci *host, struct mmc_data *d
     while (mci_readl(host, SDMMC_CMD) & SDMMC_CMD_START); \
 }
 
-void lpc313x_mci_setup_bus(struct lpc313x_mci_slot *slot)
+void lpc31xx_mci_setup_bus(struct lpc31xx_mci_slot *slot)
 {
-	struct lpc313x_mci *host = slot->host;
+	struct lpc31xx_mci *host = slot->host;
 	u32 div;
 
 	if (slot->clock != host->current_speed) {
@@ -602,15 +602,15 @@ void lpc313x_mci_setup_bus(struct lpc313x_mci_slot *slot)
 	mci_writel(host, SDMMC_CTYPE, slot->ctype);
 }
 
-static void lpc313x_mci_select_slot(struct lpc313x_mci_slot *slot, int enable)
+static void lpc31xx_mci_select_slot(struct lpc31xx_mci_slot *slot, int enable)
 {
 	if (gpio_is_valid(slot->gpio_select)) {
-		printk("lpc313x_mci_select_slot %d\n", slot->gpio_select);
+		printk("lpc31xx_mci_select_slot %d\n", slot->gpio_select);
 		gpio_set_value(slot->gpio_select, enable);
 	}
 }
 
-static void lpc313x_mci_set_power(struct lpc313x_mci_slot *slot, int enable)
+static void lpc31xx_mci_set_power(struct lpc31xx_mci_slot *slot, int enable)
 {
 	/* on current version of EA board the card detect
 	 * pull-up in on switched power side. So can't do
@@ -622,8 +622,8 @@ static void lpc313x_mci_set_power(struct lpc313x_mci_slot *slot, int enable)
 	}
 }
 
-static void lpc313x_mci_start_request(struct lpc313x_mci *host,
-		struct lpc313x_mci_slot *slot)
+static void lpc31xx_mci_start_request(struct lpc31xx_mci *host,
+		struct lpc31xx_mci_slot *slot)
 {
 	struct mmc_request	*mrq;
 	struct mmc_command	*cmd;
@@ -634,12 +634,12 @@ static void lpc313x_mci_start_request(struct lpc313x_mci *host,
 	/* now select the proper slot */
 	if (host->cur_slot != slot) {
 		if (host->cur_slot)
-			lpc313x_mci_select_slot(host->cur_slot, 0);
-		lpc313x_mci_select_slot(slot, 1);
+			lpc31xx_mci_select_slot(host->cur_slot, 0);
+		lpc31xx_mci_select_slot(slot, 1);
 	}
 
 	/* Slot specific timing and width adjustment */
-	lpc313x_mci_setup_bus(slot);
+	lpc31xx_mci_setup_bus(slot);
 
 	host->cur_slot = slot;
 	host->mrq = mrq;
@@ -650,30 +650,30 @@ static void lpc313x_mci_start_request(struct lpc313x_mci *host,
 
 	data = mrq->data;
 	if (data) {
-		lpc313x_mci_set_timeout(host, slot, data);
+		lpc31xx_mci_set_timeout(host, slot, data);
 		mci_writel(host, SDMMC_BYTCNT,data->blksz*data->blocks);
 		mci_writel(host, SDMMC_BLKSIZ,data->blksz);
 	}
 
 	cmd = mrq->cmd;
-	cmdflags = lpc313x_mci_prepare_command(slot->mmc, cmd);
+	cmdflags = lpc31xx_mci_prepare_command(slot->mmc, cmd);
 
-	if (unlikely(test_and_clear_bit(LPC313x_MMC_CARD_NEED_INIT, &slot->flags))) 
+	if (unlikely(test_and_clear_bit(LPC31xx_MMC_CARD_NEED_INIT, &slot->flags)))
 	    cmdflags |= SDMMC_CMD_INIT; //this is the first command, let set send the initializtion clock
 	
 	if (data) //we may need to move this code to mci_start_command
-		lpc313x_mci_submit_data(host, data);
+		lpc31xx_mci_submit_data(host, data);
 
 	if (mrq->stop) 
-		host->stop_cmdr = lpc313x_mci_prepare_command(slot->mmc, mrq->stop);
+		host->stop_cmdr = lpc31xx_mci_prepare_command(slot->mmc, mrq->stop);
 
-	lpc313x_mci_start_command(host, cmd, cmdflags);
+	lpc31xx_mci_start_command(host, cmd, cmdflags);
 }
 
 
 
-static void lpc313x_mci_queue_request(struct lpc313x_mci *host,
-		struct lpc313x_mci_slot *slot, struct mmc_request *mrq)
+static void lpc31xx_mci_queue_request(struct lpc31xx_mci *host,
+		struct lpc31xx_mci_slot *slot, struct mmc_request *mrq)
 {
 	dev_vdbg(&slot->mmc->class_dev, "queue request: state=%d\n",
 			host->state);
@@ -683,7 +683,7 @@ static void lpc313x_mci_queue_request(struct lpc313x_mci *host,
 	slot->mrq = mrq;
 	if (host->state == STATE_IDLE) {
 		host->state = STATE_SENDING_CMD;
-		lpc313x_mci_start_request(host, slot);
+		lpc31xx_mci_start_request(host, slot);
 	} else {
 		list_add_tail(&slot->queue_node, &host->queue);
 	}
@@ -691,25 +691,25 @@ static void lpc313x_mci_queue_request(struct lpc313x_mci *host,
 }
 
 
-static void lpc313x_mci_request(struct mmc_host *mmc, struct mmc_request *mrq)
+static void lpc31xx_mci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 {
-	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
-	struct lpc313x_mci	*host = slot->host;
+	struct lpc31xx_mci_slot	*slot = mmc_priv(mmc);
+	struct lpc31xx_mci	*host = slot->host;
 
 	WARN_ON(slot->mrq);
 
-	if (!test_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags)) {
+	if (!test_bit(LPC31xx_MMC_CARD_PRESENT, &slot->flags)) {
 		mrq->cmd->error = -ENOMEDIUM;
 		mmc_request_done(mmc, mrq);
 		return;
 	}
 
-	lpc313x_mci_queue_request(host, slot, mrq);
+	lpc31xx_mci_queue_request(host, slot, mrq);
 }
 
-static void lpc313x_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+static void lpc31xx_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 {
-	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
+	struct lpc31xx_mci_slot	*slot = mmc_priv(mmc);
 
 	slot->ctype = 0; // set default 1 bit mode
 	switch (ios->bus_width) {
@@ -739,7 +739,7 @@ static void lpc313x_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 	switch (ios->power_mode) {
 	case MMC_POWER_UP:
-		set_bit(LPC313x_MMC_CARD_NEED_INIT, &slot->flags);
+		set_bit(LPC31xx_MMC_CARD_NEED_INIT, &slot->flags);
 		break;
 	default:
 		break;
@@ -748,10 +748,10 @@ static void lpc313x_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 
 
-static int lpc313x_mci_get_wp(struct mmc_host *mmc)
+static int lpc31xx_mci_get_wp(struct mmc_host *mmc)
 {
 	int			read_only = -ENOSYS;
-	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
+	struct lpc31xx_mci_slot	*slot = mmc_priv(mmc);
 
 	if (gpio_is_valid(slot->gpio_wp)) {
 		read_only =  gpio_get_value(slot->gpio_wp);
@@ -762,7 +762,7 @@ static int lpc313x_mci_get_wp(struct mmc_host *mmc)
 }
 
 
-static int lpc313x_mci_get_cd(struct lpc313x_mci_slot *slot)
+static int lpc31xx_mci_get_cd(struct lpc31xx_mci_slot *slot)
 {
 	int			present = -ENOSYS;
 
@@ -773,10 +773,10 @@ static int lpc313x_mci_get_cd(struct lpc313x_mci_slot *slot)
 	return present;
 }
 
-static void lpc313x_mci_enable_sdio_irq(struct mmc_host *mmc, int enable)
+static void lpc31xx_mci_enable_sdio_irq(struct mmc_host *mmc, int enable)
 {
-	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
-	struct lpc313x_mci	*host = slot->host;
+	struct lpc31xx_mci_slot	*slot = mmc_priv(mmc);
+	struct lpc31xx_mci	*host = slot->host;
 	unsigned int reg;
 
 	if (enable) {
@@ -789,18 +789,18 @@ static void lpc313x_mci_enable_sdio_irq(struct mmc_host *mmc, int enable)
 	}
 }
 
-static const struct mmc_host_ops lpc313x_mci_ops = {
-	.request	= lpc313x_mci_request,
-	.set_ios	= lpc313x_mci_set_ios,
-	.get_ro		= lpc313x_mci_get_wp,
-	.enable_sdio_irq= lpc313x_mci_enable_sdio_irq,
+static const struct mmc_host_ops lpc31xx_mci_ops = {
+	.request	= lpc31xx_mci_request,
+	.set_ios	= lpc31xx_mci_set_ios,
+	.get_ro		= lpc31xx_mci_get_wp,
+	.enable_sdio_irq= lpc31xx_mci_enable_sdio_irq,
 };
 
-static void lpc313x_mci_request_end(struct lpc313x_mci *host, struct mmc_request *mrq)
+static void lpc31xx_mci_request_end(struct lpc31xx_mci *host, struct mmc_request *mrq)
 	__releases(&host->lock)
 	__acquires(&host->lock)
 {
-	struct lpc313x_mci_slot	*slot = NULL;
+	struct lpc31xx_mci_slot	*slot = NULL;
 	struct mmc_host		*prev_mmc = host->cur_slot->mmc;
 
 	WARN_ON(host->cmd || host->data);
@@ -809,12 +809,12 @@ static void lpc313x_mci_request_end(struct lpc313x_mci *host, struct mmc_request
 	host->mrq = NULL;
 	if (!list_empty(&host->queue)) {
 		slot = list_entry(host->queue.next,
-				struct lpc313x_mci_slot, queue_node);
+				struct lpc31xx_mci_slot, queue_node);
 		list_del(&slot->queue_node);
 		dev_vdbg(&host->pdev->dev, "list not empty: %s is next\n",
 				mmc_hostname(slot->mmc));
 		host->state = STATE_SENDING_CMD;
-		lpc313x_mci_start_request(host, slot);
+		lpc31xx_mci_start_request(host, slot);
 	} else {
 		dev_vdbg(&host->pdev->dev, "list empty\n");
 		host->state = STATE_IDLE;
@@ -828,7 +828,7 @@ static void lpc313x_mci_request_end(struct lpc313x_mci *host, struct mmc_request
 	spin_lock(&host->lock);
 }
 
-static void lpc313x_mci_command_complete(struct lpc313x_mci *host,
+static void lpc31xx_mci_command_complete(struct lpc31xx_mci *host,
 			struct mmc_command *cmd)
 {
 	u32		status = host->cmd_status;
@@ -840,7 +840,7 @@ static void lpc313x_mci_command_complete(struct lpc313x_mci *host,
 	    if(cmd->flags & MMC_RSP_136) {
 
 		/* Read the response from the card (up to 16 bytes).
-		 * LPC313x MMC controller saves bits 127-96 in RESP3
+		 * LPC31xx MMC controller saves bits 127-96 in RESP3
 		 * for easy parsing. But the UNSTUFF_BITS macro in core/mmc.c
 		 * core/sd.c expect those bits be in resp[0]. Hence
 		 * reverse the response word order.
@@ -875,19 +875,19 @@ static void lpc313x_mci_command_complete(struct lpc313x_mci *host,
 
 		if (cmd->data) {
 			host->data = NULL;
-			lpc313x_mci_stop_dma(host);
+			lpc31xx_mci_stop_dma(host);
 		}
 	}
 }
 
-static void lpc313x_mci_tasklet_func(unsigned long priv)
+static void lpc31xx_mci_tasklet_func(unsigned long priv)
 {
-	struct lpc313x_mci	*host = (struct lpc313x_mci *)priv;
+	struct lpc31xx_mci	*host = (struct lpc31xx_mci *)priv;
 	struct mmc_request	*mrq = host->mrq;
 	struct mmc_data		*data = host->data;
 	struct mmc_command	*cmd = host->cmd;
-	enum lpc313x_mci_state	state = host->state;
-	enum lpc313x_mci_state	prev_state;
+	enum lpc31xx_mci_state	state = host->state;
+	enum lpc31xx_mci_state	prev_state;
 	u32			status;
 
 	spin_lock(&host->lock);
@@ -907,15 +907,15 @@ static void lpc313x_mci_tasklet_func(unsigned long priv)
 			break;
 
 		case STATE_SENDING_CMD:
-			if (!lpc313x_mci_test_and_clear_pending(host,
+			if (!lpc31xx_mci_test_and_clear_pending(host,
 						EVENT_CMD_COMPLETE))
 				break;
 
 			host->cmd = NULL;
-			lpc313x_mci_set_completed(host, EVENT_CMD_COMPLETE);
-			lpc313x_mci_command_complete(host, mrq->cmd);
+			lpc31xx_mci_set_completed(host, EVENT_CMD_COMPLETE);
+			lpc31xx_mci_command_complete(host, mrq->cmd);
 			if (!mrq->data || cmd->error) {
-				lpc313x_mci_request_end(host, host->mrq);
+				lpc31xx_mci_request_end(host, host->mrq);
 				goto unlock;
 			}
 
@@ -923,33 +923,33 @@ static void lpc313x_mci_tasklet_func(unsigned long priv)
 			/* fall through */
 
 		case STATE_SENDING_DATA:
-			if (lpc313x_mci_test_and_clear_pending(host,
+			if (lpc31xx_mci_test_and_clear_pending(host,
 						EVENT_DATA_ERROR)) {
-				lpc313x_mci_stop_dma(host);
+				lpc31xx_mci_stop_dma(host);
 				if (data->stop)
 					send_stop_cmd(host, data);
 				state = STATE_DATA_ERROR;
 				break;
 			}
 
-			if (!lpc313x_mci_test_and_clear_pending(host,
+			if (!lpc31xx_mci_test_and_clear_pending(host,
 						EVENT_XFER_COMPLETE))
 				break;
 
-			lpc313x_mci_set_completed(host, EVENT_XFER_COMPLETE);
+			lpc31xx_mci_set_completed(host, EVENT_XFER_COMPLETE);
 			prev_state = state = STATE_DATA_BUSY;
 			/* fall through */
 
 		case STATE_DATA_BUSY:
-			if (!lpc313x_mci_test_and_clear_pending(host,
+			if (!lpc31xx_mci_test_and_clear_pending(host,
 						EVENT_DATA_COMPLETE))
 				break;
 
 			host->data = NULL;
-			lpc313x_mci_set_completed(host, EVENT_DATA_COMPLETE);
+			lpc31xx_mci_set_completed(host, EVENT_DATA_COMPLETE);
 			status = host->data_status;
 
-			if (unlikely(status & LPC313x_MCI_DATA_ERROR_FLAGS)) {
+			if (unlikely(status & LPC31xx_MCI_DATA_ERROR_FLAGS)) {
 				if (status & SDMMC_INT_DTO) {
 					dev_err(&host->pdev->dev,
 							"data timeout error\n");
@@ -971,7 +971,7 @@ static void lpc313x_mci_tasklet_func(unsigned long priv)
 			}
 
 			if (!data->stop) {
-				lpc313x_mci_request_end(host, host->mrq);
+				lpc31xx_mci_request_end(host, host->mrq);
 				goto unlock;
 			}
 
@@ -981,16 +981,16 @@ static void lpc313x_mci_tasklet_func(unsigned long priv)
 			/* fall through */
 
 		case STATE_SENDING_STOP:
-			if (!lpc313x_mci_test_and_clear_pending(host,
+			if (!lpc31xx_mci_test_and_clear_pending(host,
 						EVENT_CMD_COMPLETE))
 				break;
 
 			host->cmd = NULL;
-			lpc313x_mci_command_complete(host, mrq->stop);
-			lpc313x_mci_request_end(host, host->mrq);
+			lpc31xx_mci_command_complete(host, mrq->stop);
+			lpc31xx_mci_request_end(host, host->mrq);
 			goto unlock;
 		case STATE_DATA_ERROR:
-			if (!lpc313x_mci_test_and_clear_pending(host,
+			if (!lpc31xx_mci_test_and_clear_pending(host,
 						EVENT_XFER_COMPLETE))
 				break;
 
@@ -1008,7 +1008,7 @@ unlock:
 
 
 
-inline static void lpc313x_mci_push_data(struct lpc313x_mci *host, void *buf, int cnt)
+inline static void lpc31xx_mci_push_data(struct lpc31xx_mci *host, void *buf, int cnt)
 {
     u32* pData = (u32*)buf;
 
@@ -1022,7 +1022,7 @@ inline static void lpc313x_mci_push_data(struct lpc313x_mci *host, void *buf, in
     }
 }
 
-inline static void lpc313x_mci_pull_data(struct lpc313x_mci *host, void *buf,int cnt)
+inline static void lpc31xx_mci_pull_data(struct lpc31xx_mci *host, void *buf,int cnt)
 {
     u32* pData = (u32*)buf;
 
@@ -1035,7 +1035,7 @@ inline static void lpc313x_mci_pull_data(struct lpc313x_mci *host, void *buf,int
     }
 }
 
-static void lpc313x_mci_read_data_pio(struct lpc313x_mci *host)
+static void lpc31xx_mci_read_data_pio(struct lpc31xx_mci *host)
 {
 	struct scatterlist	*sg = host->sg;
 	void			*buf = sg_virt(sg);
@@ -1049,7 +1049,7 @@ static void lpc313x_mci_read_data_pio(struct lpc313x_mci *host)
 		if(count == 0)
 			old_len = len;
 		if (likely(offset + len <= sg->length)) {
-			lpc313x_mci_pull_data(host, (void *)(buf + offset),len);
+			lpc31xx_mci_pull_data(host, (void *)(buf + offset),len);
 
 			offset += len;
 			nbytes += len;
@@ -1064,7 +1064,7 @@ static void lpc313x_mci_read_data_pio(struct lpc313x_mci *host)
 			}
 		} else {
 			unsigned int remaining = sg->length - offset;
-			lpc313x_mci_pull_data(host, (void *)(buf + offset),remaining);
+			lpc31xx_mci_pull_data(host, (void *)(buf + offset),remaining);
 			nbytes += remaining;
 
 			flush_dcache_page(sg_page(sg));
@@ -1073,17 +1073,17 @@ static void lpc313x_mci_read_data_pio(struct lpc313x_mci *host)
 				goto done;
 			offset = len - remaining;
 			buf = sg_virt(sg);
-			lpc313x_mci_pull_data(host, buf,offset);
+			lpc31xx_mci_pull_data(host, buf,offset);
 			nbytes += offset;
 		}
 
 		status = mci_readl(host, SDMMC_MINTSTS);
 		mci_writel(host, SDMMC_RINTSTS,SDMMC_INT_RXDR); // clear RXDR interrupt
-		if (status & LPC313x_MCI_DATA_ERROR_FLAGS) {
+		if (status & LPC31xx_MCI_DATA_ERROR_FLAGS) {
 			host->data_status = status;
 			data->bytes_xfered += nbytes;
 			smp_wmb();
-			lpc313x_mci_set_pending(host, EVENT_DATA_ERROR);
+			lpc31xx_mci_set_pending(host, EVENT_DATA_ERROR);
 			tasklet_schedule(&host->tasklet);
 			return;
 		}
@@ -1097,10 +1097,10 @@ static void lpc313x_mci_read_data_pio(struct lpc313x_mci *host)
 done:
 	data->bytes_xfered += nbytes;
 	smp_wmb();
-	lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
+	lpc31xx_mci_set_pending(host, EVENT_XFER_COMPLETE);
 }
 
-static void lpc313x_mci_write_data_pio(struct lpc313x_mci *host)
+static void lpc31xx_mci_write_data_pio(struct lpc31xx_mci *host)
 {
 	struct scatterlist	*sg = host->sg;
 	void			*buf = sg_virt(sg);
@@ -1113,7 +1113,7 @@ static void lpc313x_mci_write_data_pio(struct lpc313x_mci *host)
 
 		len = SDMMC_FIFO_SZ - (SDMMC_GET_FCNT(mci_readl(host, SDMMC_STATUS)) << 2);
 		if (likely(offset + len <= sg->length)) {
-			lpc313x_mci_push_data(host, (void *)(buf + offset),len);
+			lpc31xx_mci_push_data(host, (void *)(buf + offset),len);
 
 			offset += len;
 			nbytes += len;
@@ -1128,7 +1128,7 @@ static void lpc313x_mci_write_data_pio(struct lpc313x_mci *host)
 		} else {
 			unsigned int remaining = sg->length - offset;
 
-			lpc313x_mci_push_data(host, (void *)(buf + offset), remaining);
+			lpc31xx_mci_push_data(host, (void *)(buf + offset), remaining);
 			nbytes += remaining;
 
 			host->sg = sg = sg_next(sg);
@@ -1138,17 +1138,17 @@ static void lpc313x_mci_write_data_pio(struct lpc313x_mci *host)
 
 			offset = len - remaining;
 			buf = sg_virt(sg);
-			lpc313x_mci_push_data(host, (void *)buf, offset);
+			lpc31xx_mci_push_data(host, (void *)buf, offset);
 			nbytes += offset;
 		}
 
 		status = mci_readl(host, SDMMC_MINTSTS);
 		mci_writel(host, SDMMC_RINTSTS,SDMMC_INT_TXDR); // clear RXDR interrupt
-		if (status & LPC313x_MCI_DATA_ERROR_FLAGS) {
+		if (status & LPC31xx_MCI_DATA_ERROR_FLAGS) {
 			host->data_status = status;
 			data->bytes_xfered += nbytes;
 			smp_wmb();
-			lpc313x_mci_set_pending(host, EVENT_DATA_ERROR);
+			lpc31xx_mci_set_pending(host, EVENT_DATA_ERROR);
 			tasklet_schedule(&host->tasklet);
 			return;
 		}
@@ -1162,22 +1162,22 @@ static void lpc313x_mci_write_data_pio(struct lpc313x_mci *host)
 done:
 	data->bytes_xfered += nbytes;
 	smp_wmb();
-	lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
+	lpc31xx_mci_set_pending(host, EVENT_XFER_COMPLETE);
 }
 
-static void lpc313x_mci_cmd_interrupt(struct lpc313x_mci *host, u32 status)
+static void lpc31xx_mci_cmd_interrupt(struct lpc31xx_mci *host, u32 status)
 {
 	if(!host->cmd_status)
 		host->cmd_status = status;
 
 	smp_wmb();
-	lpc313x_mci_set_pending(host, EVENT_CMD_COMPLETE);
+	lpc31xx_mci_set_pending(host, EVENT_CMD_COMPLETE);
 	tasklet_schedule(&host->tasklet);
 }
 
-static irqreturn_t lpc313x_mci_interrupt(int irq, void *dev_id)
+static irqreturn_t lpc31xx_mci_interrupt(int irq, void *dev_id)
 {
-	struct lpc313x_mci	*host = dev_id;
+	struct lpc31xx_mci	*host = dev_id;
 	u32			status,  pending;
 	unsigned int		pass_count = 0;
 
@@ -1187,19 +1187,19 @@ static irqreturn_t lpc313x_mci_interrupt(int irq, void *dev_id)
 		pending = mci_readl(host, SDMMC_MINTSTS);// read only mask reg
 		if (!pending)
 			break;
-		if(pending & LPC313x_MCI_CMD_ERROR_FLAGS) {
-		    mci_writel(host, SDMMC_RINTSTS,LPC313x_MCI_CMD_ERROR_FLAGS);  //  clear interrupt
+		if(pending & LPC31xx_MCI_CMD_ERROR_FLAGS) {
+		    mci_writel(host, SDMMC_RINTSTS,LPC31xx_MCI_CMD_ERROR_FLAGS);  //  clear interrupt
 		    host->cmd_status = status;
 		    smp_wmb();
-		    lpc313x_mci_set_pending(host, EVENT_CMD_COMPLETE);
+		    lpc31xx_mci_set_pending(host, EVENT_CMD_COMPLETE);
 		    tasklet_schedule(&host->tasklet);
 		}
 
-		if (pending & LPC313x_MCI_DATA_ERROR_FLAGS) { // if there is an error, let report DATA_ERROR
-			mci_writel(host, SDMMC_RINTSTS,LPC313x_MCI_DATA_ERROR_FLAGS);  // clear interrupt
+		if (pending & LPC31xx_MCI_DATA_ERROR_FLAGS) { // if there is an error, let report DATA_ERROR
+			mci_writel(host, SDMMC_RINTSTS,LPC31xx_MCI_DATA_ERROR_FLAGS);  // clear interrupt
 			host->data_status = status;
 			smp_wmb();
-			lpc313x_mci_set_pending(host, EVENT_DATA_ERROR);
+			lpc31xx_mci_set_pending(host, EVENT_DATA_ERROR);
 			tasklet_schedule(&host->tasklet);
 		}
 
@@ -1209,30 +1209,30 @@ static irqreturn_t lpc313x_mci_interrupt(int irq, void *dev_id)
 		    if (!host->data_status)
 			host->data_status = status;
 		    smp_wmb();
-		    if(host->dir_status == LPC313x_MCI_RECV_STATUS) {
+		    if(host->dir_status == LPC31xx_MCI_RECV_STATUS) {
 			if(host->sg != NULL)
-				lpc313x_mci_read_data_pio(host);
+				lpc31xx_mci_read_data_pio(host);
 		    }
-		    lpc313x_mci_set_pending(host, EVENT_DATA_COMPLETE);
+		    lpc31xx_mci_set_pending(host, EVENT_DATA_COMPLETE);
 		    tasklet_schedule(&host->tasklet);
 		}
 
 		if (pending & SDMMC_INT_RXDR) {
 		    mci_writel(host, SDMMC_RINTSTS,SDMMC_INT_RXDR);  //  clear interrupt
 		    if(host->sg)
-			    lpc313x_mci_read_data_pio(host);
+			    lpc31xx_mci_read_data_pio(host);
 		}
 
 		if (pending & SDMMC_INT_TXDR) {
 		    mci_writel(host, SDMMC_RINTSTS,SDMMC_INT_TXDR);  //  clear interrupt
 		    if(host->sg) {
-			lpc313x_mci_write_data_pio(host);
+			lpc31xx_mci_write_data_pio(host);
 		    }
 		}
 
 		if (pending & SDMMC_INT_CMD_DONE) {
 		    mci_writel(host, SDMMC_RINTSTS,SDMMC_INT_CMD_DONE);  //  clear interrupt
-		    lpc313x_mci_cmd_interrupt(host, status);
+		    lpc31xx_mci_cmd_interrupt(host, status);
 		}
 
 		if (pending & SDMMC_INT_SDIO) {
@@ -1251,28 +1251,28 @@ static irqreturn_t lpc313x_mci_interrupt(int irq, void *dev_id)
  * MMC card detect thread, kicked off from detect interrupt, 1 timer per slot
  *
  */
-static void lpc313x_mci_detect_change(unsigned long slot_data)
+static void lpc31xx_mci_detect_change(unsigned long slot_data)
 {
-	struct lpc313x_mci_slot *slot = (struct lpc313x_mci_slot *) slot_data;
-	struct lpc313x_mci *host;
+	struct lpc31xx_mci_slot *slot = (struct lpc31xx_mci_slot *) slot_data;
+	struct lpc31xx_mci *host;
 	struct mmc_request *mrq;
 	bool present;
 	bool present_old;
 
 	host = slot->host;
 	/*
-	 * lpc313x_mci_cleanup_slot() sets the ATMCI_SHUTDOWN flag before
+	 * lpc31xx_mci_cleanup_slot() sets the ATMCI_SHUTDOWN flag before
 	 * freeing the interrupt. We must not re-enable the interrupt
 	 * if it has been freed, and if we're shutting down, it
 	 * doesn't really matter whether the card is present or not.
 	 */
 	smp_rmb();
-	if (test_bit(LPC313x_MMC_SHUTDOWN, &slot->flags))
+	if (test_bit(LPC31xx_MMC_SHUTDOWN, &slot->flags))
 		return;
 
 	enable_irq(slot->irq);
-	present = lpc313x_mci_get_cd(slot);
-	present_old = test_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
+	present = lpc31xx_mci_get_cd(slot);
+	present_old = test_bit(LPC31xx_MMC_CARD_PRESENT, &slot->flags);
 	dev_dbg(&slot->mmc->class_dev, "detect change: %d (was %d)\n",
 			present, present_old);
 
@@ -1283,12 +1283,12 @@ static void lpc313x_mci_detect_change(unsigned long slot_data)
 
 		spin_lock(&host->lock);
 
-		lpc313x_mci_set_power(slot, present);
+		lpc31xx_mci_set_power(slot, present);
 		if (present) {
-			set_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
-			set_bit(LPC313x_MMC_CARD_NEED_INIT, &slot->flags);
+			set_bit(LPC31xx_MMC_CARD_PRESENT, &slot->flags);
+			set_bit(LPC31xx_MMC_CARD_NEED_INIT, &slot->flags);
 		} else {
-			clear_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
+			clear_bit(LPC31xx_MMC_CARD_PRESENT, &slot->flags);
 		}
 
 
@@ -1314,7 +1314,7 @@ static void lpc313x_mci_detect_change(unsigned long slot_data)
 					/* fall through */
 				case STATE_SENDING_DATA:
 					mrq->data->error = -ENOMEDIUM;
-					lpc313x_mci_stop_dma(host);
+					lpc31xx_mci_stop_dma(host);
 					break;
 				case STATE_DATA_BUSY:
 				case STATE_DATA_ERROR:
@@ -1328,7 +1328,7 @@ static void lpc313x_mci_detect_change(unsigned long slot_data)
 					break;
 				}
 
-				lpc313x_mci_request_end(host, mrq);
+				lpc31xx_mci_request_end(host, mrq);
 			} else {
 				list_del(&slot->queue_node);
 				mrq->cmd->error = -ENOMEDIUM;
@@ -1349,13 +1349,13 @@ static void lpc313x_mci_detect_change(unsigned long slot_data)
 	}
 }
 
-static irqreturn_t lpc313x_mci_detect_interrupt(int irq, void *dev_id)
+static irqreturn_t lpc31xx_mci_detect_interrupt(int irq, void *dev_id)
 {
 	int level;
-	struct lpc313x_mci_slot	*slot = dev_id;
+	struct lpc31xx_mci_slot	*slot = dev_id;
 
 	/* select the opposite level sensitivity */
-	level =  lpc313x_mci_get_cd(slot) ? IRQ_TYPE_LEVEL_HIGH : IRQ_TYPE_LEVEL_LOW;
+	level =  lpc31xx_mci_get_cd(slot) ? IRQ_TYPE_LEVEL_HIGH : IRQ_TYPE_LEVEL_LOW;
 	irq_set_irq_type(slot->irq, level);
 
 	/*
@@ -1370,16 +1370,16 @@ static irqreturn_t lpc313x_mci_detect_interrupt(int irq, void *dev_id)
 }
 
 static int __init
-lpc313x_mci_init_slot(struct lpc313x_mci *host, struct device_node *np)
+lpc31xx_mci_init_slot(struct lpc31xx_mci *host, struct device_node *np)
 {
 	struct mmc_host			*mmc;
-	struct lpc313x_mci_slot		*slot;
+	struct lpc31xx_mci_slot		*slot;
 	const u32 *voltage_ranges;
 	const int *width;
 	int i, ret, num_ranges, level;
 	enum of_gpio_flags flags;
 
-	mmc = mmc_alloc_host(sizeof(struct lpc313x_mci_slot), &host->pdev->dev);
+	mmc = mmc_alloc_host(sizeof(struct lpc31xx_mci_slot), &host->pdev->dev);
 
 	if (!mmc)
 		return -ENOMEM;
@@ -1411,7 +1411,7 @@ lpc313x_mci_init_slot(struct lpc313x_mci *host, struct device_node *np)
 		gpio_direction_input(slot->gpio_select);
 	}
 
-	mmc->ops = &lpc313x_mci_ops;
+	mmc->ops = &lpc31xx_mci_ops;
 	mmc->f_min = DIV_ROUND_UP(host->bus_hz, 510);
 	mmc->f_max = host->bus_hz/2; //max f is clock to mmc_clk/2
 
@@ -1450,32 +1450,32 @@ lpc313x_mci_init_slot(struct lpc313x_mci *host, struct device_node *np)
 	mmc->max_seg_size = mmc->max_req_size;
 
 	/* Create card detect handler thread for the slot */
-	setup_timer(&slot->detect_timer, lpc313x_mci_detect_change,
+	setup_timer(&slot->detect_timer, lpc31xx_mci_detect_change,
 			(unsigned long)slot);
 
 	slot->irq = irq_of_parse_and_map(np, 0);
 	/* select the opposite level sensitivity */
-	level =  lpc313x_mci_get_cd(slot) ? IRQ_TYPE_LEVEL_HIGH : IRQ_TYPE_LEVEL_LOW;
+	level =  lpc31xx_mci_get_cd(slot) ? IRQ_TYPE_LEVEL_HIGH : IRQ_TYPE_LEVEL_LOW;
 
-	if(lpc313x_mci_get_cd(slot)) {
-		lpc313x_mci_set_power(slot, 1);
-		set_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
-		set_bit(LPC313x_MMC_CARD_NEED_INIT, &slot->flags);
+	if(lpc31xx_mci_get_cd(slot)) {
+		lpc31xx_mci_set_power(slot, 1);
+		set_bit(LPC31xx_MMC_CARD_PRESENT, &slot->flags);
+		set_bit(LPC31xx_MMC_CARD_NEED_INIT, &slot->flags);
 	} else {
-		lpc313x_mci_set_power(slot, 0);
-		clear_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
+		lpc31xx_mci_set_power(slot, 0);
+		clear_bit(LPC31xx_MMC_CARD_PRESENT, &slot->flags);
 	}
 
 	host->slot[host->slot_count++] = slot;
 	mmc_add_host(mmc);
 
 #if defined (CONFIG_DEBUG_FS)
-	lpc313x_mci_init_debugfs(slot);
+	lpc31xx_mci_init_debugfs(slot);
 #endif
 	/* set card detect irq info */
 	irq_set_irq_type(slot->irq, level);
 	ret = request_irq(slot->irq,
-			lpc313x_mci_detect_interrupt,
+			lpc31xx_mci_detect_interrupt,
 			level,
 			"mmc-cd",
 			slot);
@@ -1487,7 +1487,7 @@ err_ocr:
 	return ret;
 }
 
-static void lpc313x_mci_cleanup_slot(struct lpc313x_mci_slot *slot,
+static void lpc31xx_mci_cleanup_slot(struct lpc31xx_mci_slot *slot,
 		unsigned int id)
 {
 	/* Shutdown detect IRQ and kill detect thread */
@@ -1496,24 +1496,24 @@ static void lpc313x_mci_cleanup_slot(struct lpc313x_mci_slot *slot,
 	del_timer_sync(&slot->detect_timer);
 
 	/* Debugfs stuff is cleaned up by mmc core */
-	set_bit(LPC313x_MMC_SHUTDOWN, &slot->flags);
+	set_bit(LPC31xx_MMC_SHUTDOWN, &slot->flags);
 	smp_wmb();
 	mmc_remove_host(slot->mmc);
 	slot->host->slot[id] = NULL;
 	mmc_free_host(slot->mmc);
 }
 
-static const struct of_device_id lpc313x_mci_of_match[] = {
+static const struct of_device_id lpc31xx_mci_of_match[] = {
 	{ .compatible = "nxp,lpc31xx-sdmmc" },
 	{},
 };
-MODULE_DEVICE_TABLE(of, lpc313x_mci_of_match);
+MODULE_DEVICE_TABLE(of, lpc31xx_mci_of_match);
 
-static int lpc313x_mci_probe(struct platform_device *pdev)
+static int lpc31xx_mci_probe(struct platform_device *pdev)
 {
 	struct device_node *node;
 	struct device_node *np = pdev->dev.of_node;
-	struct lpc313x_mci *host;
+	struct lpc31xx_mci *host;
 	struct resource *regs;
 	struct clk *clk;
 	int irq;
@@ -1527,7 +1527,7 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 	if (irq < 0)
 		return irq;
 
-	host = kzalloc(sizeof(struct lpc313x_mci), GFP_KERNEL);
+	host = kzalloc(sizeof(struct lpc31xx_mci), GFP_KERNEL);
 	if (!host)
 		return -ENOMEM;
 	host->pdev = pdev;
@@ -1558,7 +1558,7 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 	CGU_CFG->resetn_soft[SD_MMC_PNRES_SOFT] = CGU_CONFIG_SOFT_RESET;
 
 #ifdef USE_DMA
-	host->dma_chn = dma_request_sg_channel("MCI",  lpc313x_mci_dma_complete, host,
+	host->dma_chn = dma_request_sg_channel("MCI",  lpc31xx_mci_dma_complete, host,
 			0, 0, 1);
 	if(host->dma_chn < 0) {
 		dev_err(&pdev->dev, "Failed to allocate DMA SG channel\n");
@@ -1616,8 +1616,8 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 	mci_writel(host, SDMMC_CLKENA,0);
 	mci_writel(host, SDMMC_CLKSRC,0);
 
-	tasklet_init(&host->tasklet, lpc313x_mci_tasklet_func, (unsigned long)host);
-	ret = request_irq(irq, lpc313x_mci_interrupt, 0, dev_name(&pdev->dev), host);
+	tasklet_init(&host->tasklet, lpc31xx_mci_tasklet_func, (unsigned long)host);
+	ret = request_irq(irq, lpc31xx_mci_interrupt, 0, dev_name(&pdev->dev), host);
 	if (ret)
 	    goto err_dmaunmap;
 
@@ -1625,18 +1625,18 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 
 	// enable interrupt for command done, data over, data empty, receive ready and error such as transmit, receive timeout, crc error
 	mci_writel(host, SDMMC_RINTSTS, 0xFFFFFFFF);
-	mci_writel(host, SDMMC_INTMASK,SDMMC_INT_CMD_DONE | SDMMC_INT_DATA_OVER | SDMMC_INT_TXDR | SDMMC_INT_RXDR | LPC313x_MCI_ERROR_FLAGS);
+	mci_writel(host, SDMMC_INTMASK,SDMMC_INT_CMD_DONE | SDMMC_INT_DATA_OVER | SDMMC_INT_TXDR | SDMMC_INT_RXDR | LPC31xx_MCI_ERROR_FLAGS);
 	mci_writel(host, SDMMC_CTRL,SDMMC_CTRL_INT_ENABLE); // enable mci interrupt
 
 	for_each_child_of_node(np, node) {
-		ret = lpc313x_mci_init_slot(host, node);
+		ret = lpc31xx_mci_init_slot(host, node);
 		if (ret) {
 			ret = -ENODEV;
 			goto err_init_slot;
 		}
 	}
 
-	dev_info(&pdev->dev, "LPC313x MMC controller at irq %d\n", irq);
+	dev_info(&pdev->dev, "LPC31xx MMC controller at irq %d\n", irq);
 
 	return 0;
 
@@ -1644,7 +1644,7 @@ err_init_slot:
 	/* De-init any initialized slots */
 	while (host->slot_count > 0) {
 		if (host->slot[host->slot_count])
-			lpc313x_mci_cleanup_slot(host->slot[host->slot_count], host->slot_count);
+			lpc31xx_mci_cleanup_slot(host->slot[host->slot_count], host->slot_count);
 		host->slot_count--;
 	}
 	free_irq(irq, host);
@@ -1662,9 +1662,9 @@ err_freehost:
 
 
 
-static int __exit lpc313x_mci_remove(struct platform_device *pdev)
+static int __exit lpc31xx_mci_remove(struct platform_device *pdev)
 {
-	struct lpc313x_mci *host = platform_get_drvdata(pdev);
+	struct lpc31xx_mci *host = platform_get_drvdata(pdev);
 	struct clk *clk;
 	int i;
 
@@ -1676,7 +1676,7 @@ static int __exit lpc313x_mci_remove(struct platform_device *pdev)
 	for (i = 0; i < host->slot_count; i++) {
 		dev_dbg(&pdev->dev, "remove slot %d\n", i);
 		if (host->slot[i])
-			lpc313x_mci_cleanup_slot(host->slot[i], i);
+			lpc31xx_mci_cleanup_slot(host->slot[i], i);
 	}
 
 	/* disable clock to CIU */
@@ -1702,10 +1702,10 @@ static int __exit lpc313x_mci_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static int lpc313x_mci_suspend(struct platform_device *pdev, pm_message_t state)
+static int lpc31xx_mci_suspend(struct platform_device *pdev, pm_message_t state)
 {
 #ifdef CONFIG_PM
-	struct lpc313x_mci *host = platform_get_drvdata(pdev);
+	struct lpc31xx_mci *host = platform_get_drvdata(pdev);
 	struct clk *clk;
 
 	/* Disable Card clock */
@@ -1722,10 +1722,10 @@ static int lpc313x_mci_suspend(struct platform_device *pdev, pm_message_t state)
 	return 0;
 }
 
-static int lpc313x_mci_resume(struct platform_device *pdev)
+static int lpc31xx_mci_resume(struct platform_device *pdev)
 {
 #ifdef CONFIG_PM
-	struct lpc313x_mci *host = platform_get_drvdata(pdev);
+	struct lpc31xx_mci *host = platform_get_drvdata(pdev);
 	struct clk *clk;
 	int ret;
 
@@ -1743,32 +1743,32 @@ static int lpc313x_mci_resume(struct platform_device *pdev)
 	return 0;
 }
 
-static struct platform_driver lpc313x_mci_driver = {
-	.suspend    = lpc313x_mci_suspend,
-	.resume     = lpc313x_mci_resume,
-	.remove		= __exit_p(lpc313x_mci_remove),
+static struct platform_driver lpc31xx_mci_driver = {
+	.suspend    = lpc31xx_mci_suspend,
+	.resume     = lpc31xx_mci_resume,
+	.remove		= __exit_p(lpc31xx_mci_remove),
 	.driver		= {
-		.name	= "lpc313x_mmc",
+		.name	= "lpc31xx_mmc",
 		.owner	= THIS_MODULE,
 #ifdef CONFIG_OF
-		.of_match_table = lpc313x_mci_of_match,
+		.of_match_table = lpc31xx_mci_of_match,
 #endif
 	},
 };
 
-static int __init lpc313x_mci_init(void)
+static int __init lpc31xx_mci_init(void)
 {
-	return platform_driver_probe(&lpc313x_mci_driver, lpc313x_mci_probe);
+	return platform_driver_probe(&lpc31xx_mci_driver, lpc31xx_mci_probe);
 }
 
-static void __exit lpc313x_mci_exit(void)
+static void __exit lpc31xx_mci_exit(void)
 {
-	platform_driver_unregister(&lpc313x_mci_driver);
+	platform_driver_unregister(&lpc31xx_mci_driver);
 }
 
-module_init(lpc313x_mci_init);
-module_exit(lpc313x_mci_exit);
+module_init(lpc31xx_mci_init);
+module_exit(lpc31xx_mci_exit);
 
-MODULE_DESCRIPTION("LPC313x Multimedia Card Interface driver");
+MODULE_DESCRIPTION("LPC31xx Multimedia Card Interface driver");
 MODULE_AUTHOR("NXP Semiconductor VietNam");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/mmc/host/lpc31xx_mmc.h b/drivers/mmc/host/lpc31xx_mmc.h
index f1e9ce9..cbc9a90 100644
--- a/drivers/mmc/host/lpc31xx_mmc.h
+++ b/drivers/mmc/host/lpc31xx_mmc.h
@@ -1,4 +1,4 @@
-/* LPC313x MultiMedia Card Interface driver
+/* LPC31xx MultiMedia Card Interface driver
  *
  * Copyright (C)2009 NXP Semiconductors
  *
@@ -6,8 +6,8 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-#ifndef __DRIVERS_MMC_LPC313x_MCI_H__
-#define __DRIVERS_MMC_LPC313x_MCI_H__
+#ifndef __DRIVERS_MMC_LPC31xx_MCI_H__
+#define __DRIVERS_MMC_LPC31xx_MCI_H__
 
 #define MCI_SLOT 0
 
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index a43b3d1..8eb7161 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -568,11 +568,11 @@ config MTD_NAND_SH_FLCTL
 	  Several Renesas SuperH CPU has FLCTL. This option enables support
 	  for NAND Flash using FLCTL.
 	  
-config MTD_NAND_LPC313X
-	tristate "Support for NAND Controller on NXP LPC313x"
+config MTD_NAND_LPC31XX
+	tristate "Support for NAND Controller on NXP LPC31xx"
 	depends on ARCH_LPC31XX
 	help
-	  This enables the NAND flash controller on the LPC313x
+	  This enables the NAND flash controller on the LPC31xx
 
 config MTD_NAND_DAVINCI
         tristate "Support NAND on DaVinci SoC"
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 53b1cfa..a1efadd 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -51,6 +51,6 @@ obj-$(CONFIG_MTD_NAND_MPC5121_NFC)	+= mpc5121_nfc.o
 obj-$(CONFIG_MTD_NAND_RICOH)		+= r852.o
 obj-$(CONFIG_MTD_NAND_JZ4740)		+= jz4740_nand.o
 obj-$(CONFIG_MTD_NAND_GPMI_NAND)	+= gpmi-nand/
-obj-$(CONFIG_MTD_NAND_LPC313X)		+= lpc31xx_nand.o
+obj-$(CONFIG_MTD_NAND_LPC31XX)		+= lpc31xx_nand.o
 
 nand-objs := nand_base.o nand_bbt.o
diff --git a/drivers/mtd/nand/lpc31xx_nand.c b/drivers/mtd/nand/lpc31xx_nand.c
index bd2680a..f7090b5 100644
--- a/drivers/mtd/nand/lpc31xx_nand.c
+++ b/drivers/mtd/nand/lpc31xx_nand.c
@@ -1,7 +1,7 @@
 /*
- * LPC313x NAND Controller Interface driver
+ * LPC31xx NAND Controller Interface driver
  *
- * drivers/mtd/nand/lpc313x_nand.c
+ * drivers/mtd/nand/lpc31xx_nand.c
  *
  * Copyright (C) 2009 NXP Semiconductors
  *
@@ -223,17 +223,17 @@
 //#define HUGE_BLOCK_SUPPORT
 
 /* Device specific MTD structure, 1 per chip select */
-struct lpc313x_nand_mtd {
+struct lpc31xx_nand_mtd {
 	struct mtd_info mtd;
 	struct nand_chip chip;
-	struct lpc313x_nand_info *host;
+	struct lpc31xx_nand_info *host;
 };
 
 /* Local driver data structure */
-struct lpc313x_nand_info {
+struct lpc31xx_nand_info {
 	struct nand_hw_control controller;
-	struct lpc313x_nand_cfg *platform;
-	struct lpc313x_nand_mtd *mtds;
+	struct lpc31xx_nand_cfg *platform;
+	struct lpc31xx_nand_mtd *mtds;
 	void __iomem		*regs;
 	struct device *dev;
 	uint32_t nandconfig;
@@ -277,12 +277,12 @@ static const uint32_t nand_buff_phys_addr[2] = {
 #endif
 
 /* Register access macros */
-static inline uint32_t nand_readl(struct lpc313x_nand_info *host, uint32_t reg)
+static inline uint32_t nand_readl(struct lpc31xx_nand_info *host, uint32_t reg)
 {
 	return __raw_readl(host->regs + reg);
 }
 
-static inline void nand_writel(struct lpc313x_nand_info *host, uint32_t reg, uint32_t value)
+static inline void nand_writel(struct lpc31xx_nand_info *host, uint32_t reg, uint32_t value)
 {
 	__raw_writel(value, host->regs + reg);
 }
@@ -365,7 +365,7 @@ static struct nand_ecclayout nand_hw_eccoob_128 = {
 static uint8_t bbt_pattern[] = { 'B', 'b', 't', '0' };
 static uint8_t mirror_pattern[] = { '1', 't', 'b', 'B' };
 
-static struct nand_bbt_descr lpc313x_bbt_main_descr = {
+static struct nand_bbt_descr lpc31xx_bbt_main_descr = {
 	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
 		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
 	.offs = 32,
@@ -375,7 +375,7 @@ static struct nand_bbt_descr lpc313x_bbt_main_descr = {
 	.pattern = bbt_pattern
 };
 
-static struct nand_bbt_descr lpc313x_bbt_mirror_descr = {
+static struct nand_bbt_descr lpc31xx_bbt_mirror_descr = {
 	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
 		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
 	.offs = 32,
@@ -388,7 +388,7 @@ static struct nand_bbt_descr lpc313x_bbt_mirror_descr = {
 // Dummies bytes for bad block ( just for HARDWARE ECC: inaccurate )
 static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
 
-static struct nand_bbt_descr lpc313x_largepage_flashbased = {
+static struct nand_bbt_descr lpc31xx_largepage_flashbased = {
 	.options = NAND_BBT_SCAN2NDPAGE,
 	.offs = 50,
 	.len = 2,
@@ -402,10 +402,10 @@ static struct nand_bbt_descr lpc313x_largepage_flashbased = {
  * @ type: Interrupt type
  * @ arg: Function argument
  */
-static void lpc313x_nand_dma_irq(int chn, dma_irq_type_t type,
+static void lpc31xx_nand_dma_irq(int chn, dma_irq_type_t type,
 		void *arg)
 {
-	struct lpc313x_nand_info *host = (struct lpc313x_nand_info *)arg;
+	struct lpc31xx_nand_info *host = (struct lpc31xx_nand_info *)arg;
 
 	/* SG Table ended */
 	if (type == DMA_IRQ_FINISHED)
@@ -432,11 +432,11 @@ static void lpc313x_nand_dma_irq(int chn, dma_irq_type_t type,
  * oob_data : OOB data buffer physical address
  * rd : read flag (1: read operation 0: write operation)
  */
-static void lpc313x_nand_dma_sg_tfr(struct mtd_info *mtd,
+static void lpc31xx_nand_dma_sg_tfr(struct mtd_info *mtd,
 		struct nand_chip *chip, int bufrdy,	uint32_t pay_load, uint32_t oob_data, int rd)
 {
-	struct lpc313x_nand_mtd *nmtd;
-	struct lpc313x_nand_info *host;
+	struct lpc31xx_nand_mtd *nmtd;
+	struct lpc31xx_nand_info *host;
 	int eccsize = chip->ecc.size;
 	int oob_size = rd ? chip->ecc.bytes : OOB_FREE_OFFSET;
 
@@ -497,7 +497,7 @@ static void lpc313x_nand_dma_sg_tfr(struct mtd_info *mtd,
  */
 
 /* Enable or disable NAND controller clocks */
-static void lpc313x_nand_clocks_enable(void) {
+static void lpc31xx_nand_clocks_enable(void) {
 	struct clk *clk;
 	int ret;
 
@@ -522,7 +522,7 @@ static void lpc313x_nand_clocks_enable(void) {
 }
 
 /* Enable or disable NAND controller clocks */
-static void lpc313x_nand_clocks_disable(void) {
+static void lpc31xx_nand_clocks_disable(void) {
 	struct clk *clk;
 
 	/* Enable or disable clocks for NAND Controller */
@@ -548,7 +548,7 @@ static void lpc313x_nand_clocks_disable(void) {
 /*
  * Setup NAND interface timing
  */
-static void lpc313x_nand_setrate(struct lpc313x_nand_info *host, struct lpc313x_nand_timing *timing) {
+static void lpc31xx_nand_setrate(struct lpc31xx_nand_info *host, struct lpc31xx_nand_timing *timing) {
 	uint32_t tmp, timing1, timing2, srcclk;
 	struct clk *clk;
 
@@ -620,7 +620,7 @@ static void lpc313x_nand_setrate(struct lpc313x_nand_info *host, struct lpc313x_
 /*
  * Initialize the NAND interface
  */
-static int lpc313x_nand_inithw(struct lpc313x_nand_info *host) {
+static int lpc31xx_nand_inithw(struct lpc31xx_nand_info *host) {
 	unsigned long reg;
 
 	/* Disable all NAND interrupts */
@@ -628,7 +628,7 @@ static int lpc313x_nand_inithw(struct lpc313x_nand_info *host) {
 	nand_writel(host, NAND_IRQMASK2, ~0);
 
 	/* Setup device and controller timing */
-	lpc313x_nand_setrate(host, host->platform->timing);
+	lpc31xx_nand_setrate(host, host->platform->timing);
 
 	/* enable the controller and de-assert nFCE */
 	reg = nand_readl(host, NAND_CONFIG) | host->nandconfig;
@@ -640,7 +640,7 @@ static int lpc313x_nand_inithw(struct lpc313x_nand_info *host) {
 /*
  * Enable NAND interrupts
  */
-static inline void lpc313x_nand_int_en(struct lpc313x_nand_info *host, uint32_t mask) {
+static inline void lpc31xx_nand_int_en(struct lpc31xx_nand_info *host, uint32_t mask) {
 #if !defined(STATUS_POLLING)
 	uint32_t tmp = nand_readl(host, NAND_IRQMASK1) & ~mask;
 
@@ -651,7 +651,7 @@ static inline void lpc313x_nand_int_en(struct lpc313x_nand_info *host, uint32_t
 /*
  * Disable NAND interrupts
  */
-static inline void lpc313x_nand_int_dis(struct lpc313x_nand_info *host, uint32_t mask) {
+static inline void lpc31xx_nand_int_dis(struct lpc31xx_nand_info *host, uint32_t mask) {
 #if !defined(STATUS_POLLING)
 	uint32_t tmp = nand_readl(host, NAND_IRQMASK1) | mask;
 
@@ -662,42 +662,42 @@ static inline void lpc313x_nand_int_dis(struct lpc313x_nand_info *host, uint32_t
 /*
  * Clear NAND interrupts
  */
-static inline void lpc313x_nand_int_clear(struct lpc313x_nand_info *host, uint32_t mask) {
+static inline void lpc31xx_nand_int_clear(struct lpc31xx_nand_info *host, uint32_t mask) {
 	nand_writel(host, NAND_IRQSTATUSRAW1, mask);
 }
 
 /*
  * Return pending NAND interrupts status
  */
-static inline uint32_t lpc313x_nand_int_get(struct lpc313x_nand_info *host) {
+static inline uint32_t lpc31xx_nand_int_get(struct lpc31xx_nand_info *host) {
 	return nand_readl(host, NAND_IRQSTATUS1);
 }
 
 /*
  * Return raw NAND interrupts status
  */
-static inline uint32_t lpc313x_nand_raw_get(struct lpc313x_nand_info *host) {
+static inline uint32_t lpc31xx_nand_raw_get(struct lpc31xx_nand_info *host) {
 	return nand_readl(host, NAND_IRQSTATUSRAW1);
 }
 
 /*
  * Wait for NAND event
  */
-static inline void lpc313x_wait_irq(struct lpc313x_nand_info *host) {
+static inline void lpc31xx_wait_irq(struct lpc31xx_nand_info *host) {
 	wait_event(host->irq_waitq, host->intspending);
 }
 
 /*
  * Handle the NAND interrupt
  */
-static irqreturn_t lpc313x_nandc_irq(int irq, void *dev_id)
+static irqreturn_t lpc31xx_nandc_irq(int irq, void *dev_id)
 {
 	/* IRQs not working yet */
-	struct lpc313x_nand_info *host = (struct lpc313x_nand_info *) dev_id;
+	struct lpc31xx_nand_info *host = (struct lpc31xx_nand_info *) dev_id;
 
 	/* Disable interrupts for now, but don't clear status yet */
-	host->intspending = lpc313x_nand_int_get(host);
-	lpc313x_nand_int_dis(host, ~0);
+	host->intspending = lpc31xx_nand_int_get(host);
+	lpc31xx_nand_int_dis(host, ~0);
 
 	/* Wakeup pending request */
 	wake_up(&host->irq_waitq);
@@ -708,7 +708,7 @@ static irqreturn_t lpc313x_nandc_irq(int irq, void *dev_id)
 /*
  * Start a RAM read operation on RAM0 or RAM1
  */
-static inline void lpc313x_ram_read(struct lpc313x_nand_info *host, int bufnum) {
+static inline void lpc31xx_ram_read(struct lpc31xx_nand_info *host, int bufnum) {
 	if (bufnum == 0) {
 		/* Use RAM buffer 0 */
 		nand_writel(host, NAND_CONTROLFLOW, NAND_CTRL_RD_RAM0);
@@ -718,13 +718,13 @@ static inline void lpc313x_ram_read(struct lpc313x_nand_info *host, int bufnum)
 		nand_writel(host, NAND_CONTROLFLOW, NAND_CTRL_RD_RAM1);
 	}
 
-	lpc313x_nand_int_en(host, nand_buff_dec_mask[bufnum]);
+	lpc31xx_nand_int_en(host, nand_buff_dec_mask[bufnum]);
 }
 
 /*
  * Start a RAM write operation on RAM0 or RAM1
  */
-static inline void lpc313x_ram_write(struct lpc313x_nand_info *host, int bufnum) {
+static inline void lpc31xx_ram_write(struct lpc31xx_nand_info *host, int bufnum) {
 	if (bufnum == 0) {
 		/* Use RAM buffer 0 */
 		nand_writel(host, NAND_CONTROLFLOW, NAND_CTRL_WR_RAM0);
@@ -734,7 +734,7 @@ static inline void lpc313x_ram_write(struct lpc313x_nand_info *host, int bufnum)
 		nand_writel(host, NAND_CONTROLFLOW, NAND_CTRL_WR_RAM1);
 	}
 
-	lpc313x_nand_int_en(host, nand_buff_wr_mask[bufnum]);
+	lpc31xx_nand_int_en(host, nand_buff_wr_mask[bufnum]);
 }
 
 /*
@@ -746,10 +746,10 @@ static inline void lpc313x_ram_write(struct lpc313x_nand_info *host, int bufnum)
 /*
  * Asserts and deasserts chip selects (callback)
  */
-static void lpc313x_nand_select_chip(struct mtd_info *mtd, int chip_sel) {
+static void lpc31xx_nand_select_chip(struct mtd_info *mtd, int chip_sel) {
 	struct nand_chip *chip = mtd->priv;
-	struct lpc313x_nand_mtd *nmtd;
-	struct lpc313x_nand_info *host;
+	struct lpc31xx_nand_mtd *nmtd;
+	struct lpc31xx_nand_info *host;
 	int i = 0, cssel = -1;
 
 	nmtd = chip->priv;
@@ -783,10 +783,10 @@ static void lpc313x_nand_select_chip(struct mtd_info *mtd, int chip_sel) {
 /*
  * Issue command and address cycles to the chip (callback)
  */
-static void lpc313x_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl) {
+static void lpc31xx_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl) {
 	struct nand_chip *chip = mtd->priv;
-	struct lpc313x_nand_mtd *nmtd;
-	struct lpc313x_nand_info *host;
+	struct lpc31xx_nand_mtd *nmtd;
+	struct lpc31xx_nand_info *host;
 
 	nmtd = chip->priv;
 	host = nmtd->host;
@@ -807,10 +807,10 @@ static void lpc313x_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int c
  * Returns NAND busy(0)/ready(!0) status callback
  */
 
-static int lpc313x_nand_devready(struct mtd_info *mtd) {
+static int lpc31xx_nand_devready(struct mtd_info *mtd) {
 	struct nand_chip *chip = mtd->priv;
-	struct lpc313x_nand_mtd *nmtd;
-	struct lpc313x_nand_info *host;
+	struct lpc31xx_nand_mtd *nmtd;
+	struct lpc31xx_nand_info *host;
 
 	nmtd = chip->priv;
 	host = nmtd->host;
@@ -821,7 +821,7 @@ static int lpc313x_nand_devready(struct mtd_info *mtd) {
 /*
  * MTD hardware ECC enable callback
  */
-static void lpc313x_nand_enable_hwecc(struct mtd_info *mtd, int mode) {
+static void lpc31xx_nand_enable_hwecc(struct mtd_info *mtd, int mode) {
 	(void) mtd;
 	(void) mode;
 
@@ -831,12 +831,12 @@ static void lpc313x_nand_enable_hwecc(struct mtd_info *mtd, int mode) {
 /*
  * MTD ECC data correction callback
  */
-static int lpc313x_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+static int lpc31xx_nand_correct_data(struct mtd_info *mtd, u_char *dat,
 				     u_char *read_ecc, u_char *calc_ecc)
 {
 	struct nand_chip *chip = mtd->priv;
-	struct lpc313x_nand_mtd *nmtd;
-	struct lpc313x_nand_info *host;
+	struct lpc31xx_nand_mtd *nmtd;
+	struct lpc31xx_nand_info *host;
 	uint32_t tmp;
 	int errs_corrected = 0;
 
@@ -853,7 +853,7 @@ static int lpc313x_nand_correct_data(struct mtd_info *mtd, u_char *dat,
 	}
 
 	/* Generate correction statistics */
-	tmp = lpc313x_nand_raw_get(host);
+	tmp = lpc31xx_nand_raw_get(host);
 	if (!(tmp & (NAND_NANDIRQSTATUS1_NOERR_RAM0 | NAND_NANDIRQSTATUS1_NOERR_RAM1))) {
 		if (tmp & (NAND_NANDIRQSTATUS1_ERR1_RAM0 | NAND_NANDIRQSTATUS1_ERR1_RAM1)) {
 			errs_corrected = 1;
@@ -883,7 +883,7 @@ static int lpc313x_nand_correct_data(struct mtd_info *mtd, u_char *dat,
 /*
  * MTD calculate ECC callback
  */
-static int lpc313x_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+static int lpc31xx_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
 {
 	(void) mtd;
 	(void) dat;
@@ -896,11 +896,11 @@ static int lpc313x_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u
 /*
  * Verify a buffer written to hardware against the passed buffer (callback)
  */
-static int lpc313x_nand_verify_hwecc(struct mtd_info *mtd, const uint8_t *buf, int len)
+static int lpc31xx_nand_verify_hwecc(struct mtd_info *mtd, const uint8_t *buf, int len)
 {
 	struct nand_chip *chip = mtd->priv;
-	struct lpc313x_nand_mtd *nmtd;
-	struct lpc313x_nand_info *host;
+	struct lpc31xx_nand_mtd *nmtd;
+	struct lpc31xx_nand_info *host;
 	int i, status = 0, curbuf = 0, bufrdy = -1;
 
 	nmtd = chip->priv;
@@ -909,13 +909,13 @@ static int lpc313x_nand_verify_hwecc(struct mtd_info *mtd, const uint8_t *buf, i
 	/* Read back the data stored in the hardware and check it against the buffer */
 	for (i = 0; i < len; i += chip->ecc.size) {
 		/* Clear all current statuses */
-		lpc313x_nand_int_clear(host, ~0);
+		lpc31xx_nand_int_clear(host, ~0);
 
 		/* Start read into RAM0 or RAM1 */
 #if !defined(STATUS_POLLING)
 		host->intspending = 0;
 #endif
-		lpc313x_ram_read(host, curbuf);
+		lpc31xx_ram_read(host, curbuf);
 
 		/* Compare current buffer while next buffer is loading */
 		if (bufrdy >= 0) {
@@ -932,7 +932,7 @@ static int lpc313x_nand_verify_hwecc(struct mtd_info *mtd, const uint8_t *buf, i
 
 #else
 		/* Interrupt based wait operation */
-		lpc313x_wait_irq(host);
+		lpc31xx_wait_irq(host);
 #endif
 
 		bufrdy = curbuf;
@@ -945,7 +945,7 @@ static int lpc313x_nand_verify_hwecc(struct mtd_info *mtd, const uint8_t *buf, i
 	}
 
 	/* Disable all interrupts */
-	lpc313x_nand_int_dis(host, ~0);
+	lpc31xx_nand_int_dis(host, ~0);
 
 	return status;
 }
@@ -953,7 +953,7 @@ static int lpc313x_nand_verify_hwecc(struct mtd_info *mtd, const uint8_t *buf, i
 /*
  * 8-bit direct NAND interface read callback
  */
-static void lpc313x_nand_read_buf8(struct mtd_info *mtd, u_char *buf, int len) {
+static void lpc31xx_nand_read_buf8(struct mtd_info *mtd, u_char *buf, int len) {
 	struct nand_chip *chip = mtd->priv;
 
 	__raw_readsb(chip->IO_ADDR_R, buf, len);
@@ -962,7 +962,7 @@ static void lpc313x_nand_read_buf8(struct mtd_info *mtd, u_char *buf, int len) {
 /*
  * 16-bit direct NAND interface read callback
  */
-static void lpc313x_nand_read_buf16(struct mtd_info *mtd, u_char *buf, int len) {
+static void lpc31xx_nand_read_buf16(struct mtd_info *mtd, u_char *buf, int len) {
 	struct nand_chip *chip = mtd->priv;
 
 	len >>= 1;
@@ -972,7 +972,7 @@ static void lpc313x_nand_read_buf16(struct mtd_info *mtd, u_char *buf, int len)
 /*
  * 8-bit direct NAND interface write callback
  */
-static void lpc313x_nand_write_buf8(struct mtd_info *mtd, const u_char *buf,
+static void lpc31xx_nand_write_buf8(struct mtd_info *mtd, const u_char *buf,
 		int len) {
 	struct nand_chip *chip = mtd->priv;
 
@@ -982,7 +982,7 @@ static void lpc313x_nand_write_buf8(struct mtd_info *mtd, const u_char *buf,
 /*
  * 16-bit direct NAND interface write callback
  */
-static void lpc313x_nand_write_buf16(struct mtd_info *mtd, const u_char *buf,
+static void lpc31xx_nand_write_buf16(struct mtd_info *mtd, const u_char *buf,
 		int len) {
 	struct nand_chip *chip = mtd->priv;
 
@@ -993,7 +993,7 @@ static void lpc313x_nand_write_buf16(struct mtd_info *mtd, const u_char *buf,
 /*
  * Read the payload and OOB data from the device in the hardware storage format
  */
-static int lpc313x_nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
+static int lpc31xx_nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
 				   uint8_t *buf, int page)
 {
 	int i, curbuf = 0, bufrdy = -1, eccsize = chip->ecc.size;
@@ -1008,8 +1008,8 @@ static int lpc313x_nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chi
 #endif
 
 #if !defined(STATUS_POLLING)
-	struct lpc313x_nand_mtd *nmtd;
-	struct lpc313x_nand_info *host;
+	struct lpc31xx_nand_mtd *nmtd;
+	struct lpc31xx_nand_info *host;
 
 	nmtd = chip->priv;
 	host = nmtd->host;
@@ -1038,13 +1038,13 @@ static int lpc313x_nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chi
 
 	for (i = eccsteps; i > 0; i--) {
 		/* Clear all current statuses */
-		lpc313x_nand_int_clear(host, ~0);
+		lpc31xx_nand_int_clear(host, ~0);
 
 		/* Start read into RAM0 or RAM1 */
 #if !defined(STATUS_POLLING)
 		host->intspending = 0;
 #endif
-		lpc313x_ram_read(host, curbuf);
+		lpc31xx_ram_read(host, curbuf);
 
 		/* Read current buffer while next buffer is loading */
 		if (bufrdy >= 0) {
@@ -1055,7 +1055,7 @@ static int lpc313x_nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chi
 			 * */
 			if(use_dma) {
 				/* Read payload & oob using DMA */
-				lpc313x_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 1);
+				lpc31xx_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 1);
 
 				/* Update buffers offsets */
 				p1 += eccsize;
@@ -1080,7 +1080,7 @@ static int lpc313x_nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chi
 
 #else
 		/* Interrupt based wait operation */
-		lpc313x_wait_irq(host);
+		lpc31xx_wait_irq(host);
 #endif
 
 		bufrdy = curbuf;
@@ -1092,7 +1092,7 @@ static int lpc313x_nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chi
 #ifdef USE_DMA
 	if(use_dma) {
 		/* Transfer payload & oob using DMA */
-		lpc313x_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 1);
+		lpc31xx_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 1);
 
 		/* Unmap DMA mappings */
 		dma_unmap_single(host->dev, pmapped, (eccsize * eccsteps),
@@ -1111,7 +1111,7 @@ static int lpc313x_nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chi
 	}
 
 	/* Disable all interrupts */
-	lpc313x_nand_int_dis(host, ~0);
+	lpc31xx_nand_int_dis(host, ~0);
 
 	return 0;
 }
@@ -1119,7 +1119,7 @@ static int lpc313x_nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chi
 /*
  * Read the OOB data from the device in the hardware storage format
  */
-static int lpc313x_nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
+static int lpc31xx_nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
 				  int page, int sndcmd)
 {
 	uint8_t *buf = chip->oob_poi;
@@ -1156,7 +1156,7 @@ static int lpc313x_nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip
 /*
  * Write the payload and OOB data to the device in the hardware storage format
  */
-static void lpc313x_nand_write_page_syndrome(struct mtd_info *mtd,
+static void lpc31xx_nand_write_page_syndrome(struct mtd_info *mtd,
 				    struct nand_chip *chip, const uint8_t *buf)
 {
 	int i, curbuf = 0, bufrdy = 0, eccsize = chip->ecc.size;
@@ -1171,8 +1171,8 @@ static void lpc313x_nand_write_page_syndrome(struct mtd_info *mtd,
 #endif
 
 #if !defined(STATUS_POLLING)
-	struct lpc313x_nand_mtd *nmtd;
-	struct lpc313x_nand_info *host;
+	struct lpc31xx_nand_mtd *nmtd;
+	struct lpc31xx_nand_info *host;
 
 	nmtd = chip->priv;
 	host = nmtd->host;
@@ -1200,14 +1200,14 @@ static void lpc313x_nand_write_page_syndrome(struct mtd_info *mtd,
 #endif
 
 	/* Clear all current statuses */
-	lpc313x_nand_int_clear(host, ~0);
+	lpc31xx_nand_int_clear(host, ~0);
 #ifdef USE_DMA
 	/* If DMA mapping successful, use DMA for transfer.
 	 * Else use memcpy for transfer
 	 * */
 	if(use_dma) {
 		/* Transfer pay load & OOB using DMA */
-		lpc313x_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 0);
+		lpc31xx_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 0);
 
 		/* Update buffer offsets */
 		p1 += eccsize;
@@ -1231,11 +1231,11 @@ static void lpc313x_nand_write_page_syndrome(struct mtd_info *mtd,
 		bufrdy = 1 - bufrdy;
 
 		/* Start the transfer to the device */
-		lpc313x_nand_int_clear(host, ~0);
+		lpc31xx_nand_int_clear(host, ~0);
 #if !defined(STATUS_POLLING)
 		host->intspending = 0;
 #endif
-		lpc313x_ram_write(host, curbuf);
+		lpc31xx_ram_write(host, curbuf);
 
 		/* Copy next payload and OOB data to the buffer while current
 		   buffer is transferring */
@@ -1247,7 +1247,7 @@ static void lpc313x_nand_write_page_syndrome(struct mtd_info *mtd,
 			 * */
 			if(use_dma) {
 				/* Transfer pay load & OOB using DMA */
-				lpc313x_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 0);
+				lpc31xx_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 0);
 
 				/* Update buffer offsets */
 				p1 += eccsize;
@@ -1270,7 +1270,7 @@ static void lpc313x_nand_write_page_syndrome(struct mtd_info *mtd,
 
 #else
 		/* Interrupt based wait operation */
-		lpc313x_wait_irq(host);
+		lpc31xx_wait_irq(host);
 #endif
 	}
 
@@ -1290,13 +1290,13 @@ static void lpc313x_nand_write_page_syndrome(struct mtd_info *mtd,
 #endif
 
 	/* Disable all interrupts */
-	lpc313x_nand_int_dis(host, ~0);
+	lpc31xx_nand_int_dis(host, ~0);
 }
 
 /*
  * Write the OOB data to the device in the hardware storage format
  */
-static int lpc313x_nand_write_oob_syndrome(struct mtd_info *mtd,
+static int lpc31xx_nand_write_oob_syndrome(struct mtd_info *mtd,
 				   struct nand_chip *chip, int page)
 {
 	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
@@ -1344,8 +1344,8 @@ static int lpc313x_nand_write_oob_syndrome(struct mtd_info *mtd,
 /*
  * Add MTD partitions and a single MTD device
  */
-static int lpc313x_nand_add_partition(struct lpc313x_nand_info *host,
-		struct lpc313x_nand_mtd *bmtd, struct lpc313x_nand_dev_info *device)
+static int lpc31xx_nand_add_partition(struct lpc31xx_nand_info *host,
+		struct lpc31xx_nand_mtd *bmtd, struct lpc31xx_nand_dev_info *device)
 {
 	struct mtd_info *mtd = &bmtd->mtd;
 
@@ -1358,7 +1358,7 @@ static int lpc313x_nand_add_partition(struct lpc313x_nand_info *host,
 
 	/* Check for partitions from the CMDLINE first, these will override the
 	   board specific partitions */
-	mtd->name = "lpc313x_nand";
+	mtd->name = "lpc31xx_nand";
 	num_partitions = parse_mtd_partitions(mtd, part_probes,
 					      &partitions, 0);
 #endif
@@ -1385,26 +1385,26 @@ static int lpc313x_nand_add_partition(struct lpc313x_nand_info *host,
 /*
  * Init a single instance of an chip
  */
-static void lpc313x_nand_init_chip(struct lpc313x_nand_info *host,
-				struct lpc313x_nand_mtd *nmtd) {
+static void lpc31xx_nand_init_chip(struct lpc31xx_nand_info *host,
+				struct lpc31xx_nand_mtd *nmtd) {
 	struct nand_chip *chip = &nmtd->chip;
 
 	if (host->platform->support_16bit) {
-		chip->write_buf = lpc313x_nand_write_buf16;
-		chip->read_buf = lpc313x_nand_read_buf16;
+		chip->write_buf = lpc31xx_nand_write_buf16;
+		chip->read_buf = lpc31xx_nand_read_buf16;
 	}
 	else {
-		chip->write_buf = lpc313x_nand_write_buf8;
-		chip->read_buf = lpc313x_nand_read_buf8;
+		chip->write_buf = lpc31xx_nand_write_buf8;
+		chip->read_buf = lpc31xx_nand_read_buf8;
 	}
-	chip->select_chip = lpc313x_nand_select_chip;
+	chip->select_chip = lpc31xx_nand_select_chip;
 	chip->chip_delay = 20;
 	chip->priv = nmtd;
 	chip->controller = &host->controller;
 
 	chip->IO_ADDR_W = host->regs + NAND_WRITEDATA;
-	chip->cmd_ctrl = lpc313x_nand_hwcontrol;
-	chip->dev_ready = lpc313x_nand_devready;
+	chip->cmd_ctrl = lpc31xx_nand_hwcontrol;
+	chip->dev_ready = lpc31xx_nand_devready;
 	chip->IO_ADDR_R = host->regs + NAND_READDATA;
 
 	nmtd->host = host;
@@ -1412,16 +1412,16 @@ static void lpc313x_nand_init_chip(struct lpc313x_nand_info *host,
 	nmtd->mtd.owner = THIS_MODULE;
 
 	chip->ecc.mode = NAND_ECC_HW_SYNDROME;
-	chip->ecc.read_page_raw = lpc313x_nand_read_page_syndrome;
-	chip->ecc.read_page = lpc313x_nand_read_page_syndrome;
-	chip->ecc.write_page = lpc313x_nand_write_page_syndrome;
-	chip->ecc.write_oob = lpc313x_nand_write_oob_syndrome;
-	chip->ecc.read_oob = lpc313x_nand_read_oob_syndrome;
-	chip->ecc.calculate = lpc313x_nand_calculate_ecc;
-	chip->ecc.correct   = lpc313x_nand_correct_data;
-	chip->ecc.hwctl = lpc313x_nand_enable_hwecc;
-
-	chip->verify_buf = lpc313x_nand_verify_hwecc;
+	chip->ecc.read_page_raw = lpc31xx_nand_read_page_syndrome;
+	chip->ecc.read_page = lpc31xx_nand_read_page_syndrome;
+	chip->ecc.write_page = lpc31xx_nand_write_page_syndrome;
+	chip->ecc.write_oob = lpc31xx_nand_write_oob_syndrome;
+	chip->ecc.read_oob = lpc31xx_nand_read_oob_syndrome;
+	chip->ecc.calculate = lpc31xx_nand_calculate_ecc;
+	chip->ecc.correct   = lpc31xx_nand_correct_data;
+	chip->ecc.hwctl = lpc31xx_nand_enable_hwecc;
+
+	chip->verify_buf = lpc31xx_nand_verify_hwecc;
 	chip->options |= NAND_BBT_USE_FLASH;
 	if (host->platform->support_16bit) {
 		chip->options |= NAND_BUSWIDTH_16;
@@ -1435,12 +1435,12 @@ static void lpc313x_nand_init_chip(struct lpc313x_nand_info *host,
  * Post-probe chip update, to change any items, such as the
  * layout for large page nand
  */
-static void lpc313x_nand_update_chip(struct lpc313x_nand_info *info,
-		struct lpc313x_nand_mtd *nmtd) {
+static void lpc31xx_nand_update_chip(struct lpc31xx_nand_info *info,
+		struct lpc31xx_nand_mtd *nmtd) {
 	struct nand_chip *chip = &nmtd->chip;
 
-	chip->bbt_td = &lpc313x_bbt_main_descr;
-	chip->bbt_md = &lpc313x_bbt_mirror_descr;
+	chip->bbt_td = &lpc31xx_bbt_main_descr;
+	chip->bbt_md = &lpc31xx_bbt_mirror_descr;
 
 	/* Select bad block algorithm and ECC layout based on whether
 	   small, large, or hig block FLASH is used */
@@ -1459,9 +1459,9 @@ static void lpc313x_nand_update_chip(struct lpc313x_nand_info *info,
 	else {
 		/* Large block FLASH */
 		chip->ecc.layout = &nand_hw_eccoob_64;
-		chip->bbt_td = &lpc313x_bbt_main_descr;
-		chip->bbt_md = &lpc313x_bbt_mirror_descr;
-		chip->badblock_pattern = &lpc313x_largepage_flashbased;
+		chip->bbt_td = &lpc31xx_bbt_main_descr;
+		chip->bbt_md = &lpc31xx_bbt_mirror_descr;
+		chip->badblock_pattern = &lpc31xx_largepage_flashbased;
 	}
 
 	/* These sizes remain the same regardless of page/block size */
@@ -1481,13 +1481,13 @@ static struct mtd_partition ea313x_nand0_partitions[] = {
 	16M:  Blocks 38  - 165  - Ramdisk image (if used)
 	???:  Blocks 166 - end  - Root file system/storage */
 	{
-		.name	= "lpc313x-rootfs",
+		.name	= "lpc31xx-rootfs",
 		.offset	= (BLK_SIZE * 166),
 		.size	= MTDPART_SIZ_FULL
 	},
 };
 
-static struct lpc313x_nand_timing ea313x_nanddev_timing = {
+static struct lpc31xx_nand_timing ea313x_nanddev_timing = {
 	.ns_trsd	= 36,
 	.ns_tals	= 36,
 	.ns_talh	= 12,
@@ -1503,7 +1503,7 @@ static struct lpc313x_nand_timing ea313x_nanddev_timing = {
 	.ns_twp		= 36
 };
 
-static struct lpc313x_nand_dev_info ea313x_ndev[] = {
+static struct lpc31xx_nand_dev_info ea313x_ndev[] = {
 	{
 		.name		= "nand0",
 		.nr_partitions	= ARRAY_SIZE(ea313x_nand0_partitions),
@@ -1511,7 +1511,7 @@ static struct lpc313x_nand_dev_info ea313x_ndev[] = {
 	}
 };
 
-static struct lpc313x_nand_cfg ea313x_plat_nand = {
+static struct lpc31xx_nand_cfg ea313x_plat_nand = {
 	.nr_devices	= ARRAY_SIZE(ea313x_ndev),
 	.devices	= ea313x_ndev,
 	.timing		= &ea313x_nanddev_timing,
@@ -1526,9 +1526,9 @@ static struct lpc313x_nand_cfg ea313x_plat_nand = {
  * it can allocate all necessary resources then calls the
  * nand layer to look for devices.
  */
-static int lpc313x_nand_probe(struct platform_device *pdev) {
-	struct lpc313x_nand_info *host = NULL;
-	struct lpc313x_nand_cfg *plat = pdev->dev.platform_data;
+static int lpc31xx_nand_probe(struct platform_device *pdev) {
+	struct lpc31xx_nand_info *host = NULL;
+	struct lpc31xx_nand_cfg *plat = pdev->dev.platform_data;
 	int irq, scan_res, mtdsize, i, err = 0;
 	struct resource *regs;
 
@@ -1539,7 +1539,7 @@ static int lpc313x_nand_probe(struct platform_device *pdev) {
 		return -ENXIO;
 	}
 
-	host = kmalloc(sizeof (struct lpc313x_nand_info), GFP_KERNEL);
+	host = kmalloc(sizeof (struct lpc31xx_nand_info), GFP_KERNEL);
 	if (host == NULL) {
 		dev_err(&pdev->dev, "No memory for flash info\n");
 		err = -ENOMEM;
@@ -1580,7 +1580,7 @@ static int lpc313x_nand_probe(struct platform_device *pdev) {
 	init_waitqueue_head(&host->controller.wq);
 
 	/* Enable clocks for NAND Controller */
-	lpc313x_nand_clocks_enable();
+	lpc31xx_nand_clocks_enable();
 
 	/* Reset NAND controller */
 	cgu_soft_reset_module(NANDFLASH_CTRL_NAND_RESET_N_SOFT);
@@ -1605,12 +1605,12 @@ static int lpc313x_nand_probe(struct platform_device *pdev) {
 	}
 
 	/* Initialize the hardware */
-	err = lpc313x_nand_inithw(host);
+	err = lpc31xx_nand_inithw(host);
 	if (err != 0)
 		goto exit_error;
 
 	/* Attach interrupt handler */
-	err = request_irq(host->irq, lpc313x_nandc_irq,
+	err = request_irq(host->irq, lpc31xx_nandc_irq,
 		IRQF_DISABLED, "nandirq", host);
 	if (err)
 	{
@@ -1621,7 +1621,7 @@ static int lpc313x_nand_probe(struct platform_device *pdev) {
 	init_waitqueue_head(&host->irq_waitq);
 
 	/* Allocate space for the MTD data */
-	mtdsize = sizeof(struct lpc313x_nand_mtd) * host->platform->nr_devices;
+	mtdsize = sizeof(struct lpc31xx_nand_mtd) * host->platform->nr_devices;
 	host->mtds = kmalloc(mtdsize, GFP_KERNEL);
 	if (host->mtds == NULL) {
 		dev_err(&pdev->dev, "Failed to allocate MTD storage\n");
@@ -1633,7 +1633,7 @@ static int lpc313x_nand_probe(struct platform_device *pdev) {
 #ifdef USE_DMA
 	/* Allocate sg channel for DMA transfers */
 	host->dma_chn = dma_request_sg_channel("NAND", 0, 0,
-			lpc313x_nand_dma_irq, host, 0);
+			lpc31xx_nand_dma_irq, host, 0);
 	if(host->dma_chn < 0) {
 		dev_err(&pdev->dev, "Failed to allocate DMA SG channel\n");
 		err = host->dma_chn;
@@ -1658,7 +1658,7 @@ static int lpc313x_nand_probe(struct platform_device *pdev) {
 			i, host->platform->devices[i].name);
 
 		/* Populate device callbacks used by MTD driver */
-		lpc313x_nand_init_chip(host, &host->mtds[i]);
+		lpc31xx_nand_init_chip(host, &host->mtds[i]);
 
 		/* Scan NAND flash device */
 		scan_res = nand_scan_ident(&host->mtds[i].mtd, 1, NULL);
@@ -1666,13 +1666,13 @@ static int lpc313x_nand_probe(struct platform_device *pdev) {
 		/* Continue if a device is found */
 		if (scan_res == 0) {
 			/* Update callbacks based on NAND sizing data */
-			lpc313x_nand_update_chip(host, &host->mtds[i]);
+			lpc31xx_nand_update_chip(host, &host->mtds[i]);
 
 			/* Post architecture MTD init */
 			nand_scan_tail(&host->mtds[i].mtd);
 
 			/* Add partitions and MTD device */
-			if (lpc313x_nand_add_partition(host, &host->mtds[i],
+			if (lpc31xx_nand_add_partition(host, &host->mtds[i],
 				(plat->devices + i)) < 0) {
 				nand_release(&host->mtds[i].mtd);
 			}
@@ -1705,7 +1705,7 @@ exit_error:
 		kfree(host);
 
 	/* Disable clocks for NAND Controller */
-	lpc313x_nand_clocks_disable();
+	lpc31xx_nand_clocks_disable();
 
 	return err;
 }
@@ -1713,8 +1713,8 @@ exit_error:
 /*
  * Device removal
  */
-static int lpc313x_nand_remove(struct platform_device *pdev) {
-	struct lpc313x_nand_info *host = platform_get_drvdata(pdev);
+static int lpc31xx_nand_remove(struct platform_device *pdev) {
+	struct lpc31xx_nand_info *host = platform_get_drvdata(pdev);
 	int i;
 
 	platform_set_drvdata(pdev, NULL);
@@ -1730,7 +1730,7 @@ static int lpc313x_nand_remove(struct platform_device *pdev) {
 	}
 
 	/* Disable clocks for NAND Controller */
-	lpc313x_nand_clocks_disable();
+	lpc31xx_nand_clocks_disable();
 
 #ifdef USE_DMA
 	/* Release memory allocated for SG table */
@@ -1751,64 +1751,64 @@ static int lpc313x_nand_remove(struct platform_device *pdev) {
 }
 
 #if defined(CONFIG_PM)
-static int lpc313x_nand_resume(struct platform_device *pdev)
+static int lpc31xx_nand_resume(struct platform_device *pdev)
 {
 	/* Enables clocks for NAND Controller */
-	lpc313x_nand_clocks_enable();
+	lpc31xx_nand_clocks_enable();
 
 	return 0;
 }
 
-static int lpc313x_nand_suspend(struct platform_device *pdev, pm_message_t pm)
+static int lpc31xx_nand_suspend(struct platform_device *pdev, pm_message_t pm)
 {
 	/* Disable clocks for NAND Controller */
-	lpc313x_nand_clocks_disable();
+	lpc31xx_nand_clocks_disable();
 
 	return 0;
 }
 
 #else
-#define lpc313x_nand_resume NULL
-#define lpc313x_nand_suspend NULL
+#define lpc31xx_nand_resume NULL
+#define lpc31xx_nand_suspend NULL
 #endif
 
 #if defined(CONFIG_OF)
-static const struct of_device_id lpc313x_nand_of_match[] = {
+static const struct of_device_id lpc31xx_nand_of_match[] = {
 	{ .compatible = "nxp,lpc31xx-nand" },
 	{},
 };
-MODULE_DEVICE_TABLE(of, lpc313x_nand_of_match);
+MODULE_DEVICE_TABLE(of, lpc31xx_nand_of_match);
 #endif
 
 
-static struct platform_driver lpc313x_nand_driver = {
-	.probe		= lpc313x_nand_probe,
-	.remove		= lpc313x_nand_remove,
-	.resume		= lpc313x_nand_resume,
-	.suspend	= lpc313x_nand_suspend,
+static struct platform_driver lpc31xx_nand_driver = {
+	.probe		= lpc31xx_nand_probe,
+	.remove		= lpc31xx_nand_remove,
+	.resume		= lpc31xx_nand_resume,
+	.suspend	= lpc31xx_nand_suspend,
 	.driver = {
-		.name = "lpc313x_nand",
+		.name = "lpc31xx_nand",
 		.owner = THIS_MODULE,
 #ifdef CONFIG_OF
-		.of_match_table = lpc313x_nand_of_match,
+		.of_match_table = lpc31xx_nand_of_match,
 #endif
 	},
 };
 
-static int __init lpc313x_nand_init(void)
+static int __init lpc31xx_nand_init(void)
 {
-	return platform_driver_register(&lpc313x_nand_driver);
+	return platform_driver_register(&lpc31xx_nand_driver);
 }
 
-static void __exit lpc313x_nand_exit(void)
+static void __exit lpc31xx_nand_exit(void)
 {
-	platform_driver_unregister(&lpc313x_nand_driver);
+	platform_driver_unregister(&lpc31xx_nand_driver);
 }
 
-module_init( lpc313x_nand_init);
-module_exit( lpc313x_nand_exit);
+module_init( lpc31xx_nand_init);
+module_exit( lpc31xx_nand_exit);
 
-MODULE_DESCRIPTION("LPC313x NAND Controller driver");
+MODULE_DESCRIPTION("LPC31xx NAND Controller driver");
 MODULE_AUTHOR("NXP Semiconductor VietNam");
 MODULE_LICENSE("GPL v2");
 
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index ff3e482..c83e75e 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -403,11 +403,11 @@ config SPI_NUC900
 	help
 	  SPI driver for Nuvoton NUC900 series ARM SoCs
 
-config SPI_LPC313X
-	tristate "LPC313X SPI controller"
+config SPI_LPC31XX
+	tristate "LPC31XX SPI controller"
 	depends on SPI_MASTER && ARCH_LPC31XX
 	help
-	  SPI controller for the LPC313X device with DMA support
+	  SPI controller for the LPC31XX device with DMA support
 
 #
 # Add new SPI master controllers in alphabetical order above this line
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 6bf1c3d..a454b19 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -32,7 +32,7 @@ obj-$(CONFIG_SPI_FSL_SPI)		+= spi-fsl-spi.o
 obj-$(CONFIG_SPI_GPIO)			+= spi-gpio.o
 obj-$(CONFIG_SPI_IMX)			+= spi-imx.o
 obj-$(CONFIG_SPI_LM70_LLP)		+= spi-lm70llp.o
-obj-$(CONFIG_SPI_LPC313X)		+= spi-lpc31xx.o
+obj-$(CONFIG_SPI_LPC31XX)		+= spi-lpc31xx.o
 obj-$(CONFIG_SPI_MPC512x_PSC)		+= spi-mpc512x-psc.o
 obj-$(CONFIG_SPI_MPC52xx_PSC)		+= spi-mpc52xx-psc.o
 obj-$(CONFIG_SPI_MPC52xx)		+= spi-mpc52xx.o
diff --git a/drivers/spi/spi-lpc31xx.c b/drivers/spi/spi-lpc31xx.c
index 3234c0a..c003f24 100644
--- a/drivers/spi/spi-lpc31xx.c
+++ b/drivers/spi/spi-lpc31xx.c
@@ -982,7 +982,7 @@ static void lpc31xx_spi_process_transfer(struct lpc31xx_spi *espi,
 /*
  * Flush the TX and RX FIFOs
  */
-static int lpc313x_fifo_flush(struct lpc31xx_spi *espi)
+static int lpc31xx_fifo_flush(struct lpc31xx_spi *espi)
 {
 	unsigned long timeout;
 	volatile uint32_t tmp;
@@ -1031,7 +1031,7 @@ static void lpc31xx_spi_process_message(struct lpc31xx_spi *espi,
 		msg->status = err;
 		return;
 	}
-	err = lpc313x_fifo_flush(espi);
+	err = lpc31xx_fifo_flush(espi);
 	if (err)
 		return;
 	/*
@@ -1234,12 +1234,12 @@ static void lpc31xx_spi_prep(struct lpc31xx_spi *espi)
 {
 	uint32_t tmp;
 
-	jds_printk("JDS - lpc313x_spi_prep\n");
+	jds_printk("JDS - lpc31xx_spi_prep\n");
 	/* Reset SPI block */
 	lpc31xx_spi_write(espi, SPI_CONFIG_REG, SPI_CFG_SW_RESET);
 
 	/* Clear FIFOs */
-	lpc313x_fifo_flush(espi);
+	lpc31xx_fifo_flush(espi);
 
 	/* Clear latched interrupts */
 	lpc31xx_int_dis(espi, SPI_ALL_INTS);
@@ -1510,7 +1510,7 @@ static int lpc31xx_spi_resume(struct platform_device *pdev)
 {
 #ifdef CONFIG_PM
 	//struct spi_master *master = spi_master_get(platform_get_drvdata(pdev));
-	//struct lpc313xspi *spidat = spi_master_get_devdata(master);
+	//struct lpc31xxspi *spidat = spi_master_get_devdata(master);
 
 	/* Switch on the clocks */
 	lpc31xx_spi_clks_enable();
@@ -1519,11 +1519,11 @@ static int lpc31xx_spi_resume(struct platform_device *pdev)
 }
 
 #if defined(CONFIG_OF)
-static const struct of_device_id lpc313x_spi_of_match[] = {
+static const struct of_device_id lpc31xx_spi_of_match[] = {
 	{ .compatible = "nxp,lpc31xx-spi" },
 	{},
 };
-MODULE_DEVICE_TABLE(of, lpc313x_spi_of_match);
+MODULE_DEVICE_TABLE(of, lpc31xx_spi_of_match);
 #endif
 
 static struct platform_driver lpc31xx_spi_driver = {
@@ -1532,10 +1532,10 @@ static struct platform_driver lpc31xx_spi_driver = {
 	.suspend	= lpc31xx_spi_suspend,
 	.resume		= lpc31xx_spi_resume,
 	.driver		= {
-		.name	= "spi_lpc313x",
+		.name	= "spi_lpc31xx",
 		.owner	= THIS_MODULE,
 #ifdef CONFIG_OF
-		.of_match_table = lpc313x_spi_of_match,
+		.of_match_table = lpc31xx_spi_of_match,
 #endif
 	},
 };
diff --git a/drivers/usb/gadget/fsl_lpc_udc.c b/drivers/usb/gadget/fsl_lpc_udc.c
index 68d862b..362b757 100644
--- a/drivers/usb/gadget/fsl_lpc_udc.c
+++ b/drivers/usb/gadget/fsl_lpc_udc.c
@@ -3,7 +3,7 @@
  *  Copyright (C) 2009 NXP semiconductors
  *
  * Description:
- * Helper routines for LPC313x/4x/5x SoCs from NXP, needed by the fsl_udc_core.c
+ * Helper routines for LPC31xx SoCs from NXP, needed by the fsl_udc_core.c
  * driver to function correctly on these systems.
  *
  * This program is free software; you can redistribute it and/or modify
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index 7e803d4..71f59b6 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -38,7 +38,7 @@
 #define gadget_is_imx(g)		(!strcmp("imx_udc", (g)->name))
 #define gadget_is_langwell(g)		(!strcmp("langwell_udc", (g)->name))
 #define gadget_is_lpc32xx(g)		(!strcmp("lpc32xx_udc", (g)->name))
-#define gadget_is_lpc313x(g)		(!strcmp("lpc313x_udc", (g)->name))
+#define gadget_is_lpc31xx(g)		(!strcmp("lpc31xx_udc", (g)->name))
 #define gadget_is_m66592(g)		(!strcmp("m66592_udc", (g)->name))
 #define gadget_is_musbhdrc(g)		(!strcmp("musb-hdrc", (g)->name))
 #define gadget_is_net2272(g)		(!strcmp("net2272", (g)->name))
@@ -121,10 +121,14 @@ static inline int usb_gadget_controller_number(struct usb_gadget *gadget)
 	else if (gadget_is_dwc3(gadget))
 		return 0x32;
 <<<<<<< current
+<<<<<<< current
 	else if (gadget_is_lpc32xx(gadget))
 =======
 	else if (gadget_is_lpc313x(gadget))
 >>>>>>> patched
+=======
+	else if (gadget_is_lpc31xx(gadget))
+>>>>>>> patched
 		return 0x33;
 
 	return -ENOENT;
diff --git a/drivers/usb/host/ehci-lpc.c b/drivers/usb/host/ehci-lpc.c
index 6fb09c5..fd51f01 100644
--- a/drivers/usb/host/ehci-lpc.c
+++ b/drivers/usb/host/ehci-lpc.c
@@ -1,5 +1,5 @@
 /*
- * LPC313x & LPC315x EHCI Host Controller Driver
+ * LPC31xx EHCI Host Controller Driver
  *
  * Author: Durgesh Pattamatta <durgesh.pattamatta@nxp.com>
  *
@@ -46,7 +46,7 @@ static int lpc_ehci_init(struct usb_hcd *hcd)
 
 	ehci_port_power(ehci, 0);
 	/* board vbus power */
-	//lpc313x_vbus_power(0);
+	//lpc31xx_vbus_power(0);
 
 	return retval;
 }
@@ -77,7 +77,7 @@ static const struct hc_driver lpc_ehci_hc_driver = {
 	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
 };
 
-struct fsl_usb2_platform_data lpc313x_fsl_config = {
+struct fsl_usb2_platform_data lpc31xx_fsl_config = {
 #if defined(CONFIG_USB_OTG) || (defined(CONFIG_USB_EHCI_HCD) && defined(CONFIG_USB_GADGET_FSL_USB2))
 	.operating_mode = FSL_USB2_DR_OTG,
 #elif defined(CONFIG_USB_GADGET_FSL_USB2) && !defined(CONFIG_USB_EHCI_HCD)
@@ -101,7 +101,7 @@ static int lpc_ehci_probe(struct platform_device *pdev)
 		return -ENODEV;
 
 	/* Need platform data for setup */
-	pdata = &lpc313x_fsl_config;
+	pdata = &lpc31xx_fsl_config;
 	if (!pdata) {
 		dev_err(&pdev->dev,
 			"No platform data for %s.\n", dev_name(&pdev->dev));
@@ -267,7 +267,7 @@ static int lpc_ehci_suspend(struct device *dev, pm_message_t state)
 	/* put the device in idele mode */
 	writel(0, (hcd->regs + 0x1a8));
 	/* board vbus power */
-	//lpc313x_vbus_power(0);
+	//lpc31xx_vbus_power(0);
 
 	return 0;
 }
@@ -299,7 +299,7 @@ static int lpc_ehci_resume(struct device *dev)
 	ehci_writel(ehci, tmp, &ehci->regs->command);
 
 	/* board vbus power */
-	//lpc313x_vbus_power(1);
+	//lpc31xx_vbus_power(1);
 
 
 	usb_hcd_resume_root_hub(hcd);
@@ -309,17 +309,17 @@ static int lpc_ehci_resume(struct device *dev)
 #endif				/* CONFIG_USB_OTG */
 /**
  * FIXME: This should get into a common header
- * currently declared in arch/arm/mach-lpc313x/usb.c
+ * currently declared in arch/arm/mach-lpc31xx/usb.c
  **/
 #define USB_DEV_PORTSC1			__REG(USBOTG_PHYS + 0x184)
 #define USBPRTS_PLPSCD	_BIT(23)
-static int lpc313x_ehci_suspend(struct platform_device *pdev, pm_message_t state)
+static int lpc31xx_ehci_suspend(struct platform_device *pdev, pm_message_t state)
 {
 #ifdef CONFIG_PM
 #define IRQ_VBUS_OVRC  32  /* Detect VBUS over current - Host mode */
 	disable_irq(IRQ_VBUS_OVRC);
 	/* Shutoff vbus power */
-	lpc313x_vbus_power(0);
+	lpc31xx_vbus_power(0);
 	/* Bring PHY to low power state */
 	USB_DEV_PORTSC1 |= USBPRTS_PLPSCD;
 	/* Bring PLL to low power state */
@@ -334,7 +334,7 @@ static int lpc313x_ehci_suspend(struct platform_device *pdev, pm_message_t state
 #define EVT_GET_BANK(evt)	(((evt) >> 5) & 0x3)
 #define EVT_usb_atx_pll_lock	0x79
 
-static int lpc313x_ehci_resume(struct platform_device * pdev)
+static int lpc31xx_ehci_resume(struct platform_device * pdev)
 {
 #ifdef CONFIG_PM
 	u32 bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
@@ -353,7 +353,7 @@ static int lpc313x_ehci_resume(struct platform_device * pdev)
 	}
 	/* Bring PHY to active state */
 	USB_DEV_PORTSC1 &= ~USBPRTS_PLPSCD;
-	lpc313x_vbus_power(1);
+	lpc31xx_vbus_power(1);
 	enable_irq(IRQ_VBUS_OVRC);
 #endif
 	return 0;
@@ -370,8 +370,8 @@ MODULE_DEVICE_TABLE(of, ehci_lpc_of_match);
 static struct platform_driver ehci_lpc_driver = {
 	.probe = lpc_ehci_probe,
 	.remove = lpc_ehci_remove,
-	.suspend = lpc313x_ehci_suspend,
-	.resume = lpc313x_ehci_resume,
+	.suspend = lpc31xx_ehci_suspend,
+	.resume = lpc31xx_ehci_resume,
 	.driver = {
 		.name = "lpc-ehci",
 #ifdef CONFIG_USB_OTG
diff --git a/drivers/usb/host/lpc-ehset.c b/drivers/usb/host/lpc-ehset.c
index 6a0e669..aa76b7e5 100644
--- a/drivers/usb/host/lpc-ehset.c
+++ b/drivers/usb/host/lpc-ehset.c
@@ -1,4 +1,4 @@
-/* linux/arch/arm/mach-lpc313x/usb.c -- platform level USB initialization
+/* linux/arch/arm/mach-lpc31xx/usb.c -- platform level USB initialization
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index a8bff0b..55a7800 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -358,7 +358,7 @@ config LPC31XX_WATCHDOG
 	  Say Y here if to include support for the watchdog timer
 	  for the NXP's LPC31xx uC SoC.
 	  To compile this driver as a module, choose M here: the
-	  module will be called lpc313x_wdt.
+	  module will be called lpc31xx_wdt.
 
 # AVR32 Architecture
 
diff --git a/sound/soc/lpc31xx/Kconfig b/sound/soc/lpc31xx/Kconfig
index 321517a..91bddac 100644
--- a/sound/soc/lpc31xx/Kconfig
+++ b/sound/soc/lpc31xx/Kconfig
@@ -1,8 +1,8 @@
-config SND_LPC313X_SOC
-        tristate "SoC Audio for the NXP LPC313X System-on-a-Chip"
+config SND_LPC31XX_SOC
+        tristate "SoC Audio for the NXP LPC31XX System-on-a-Chip"
 				depends on ARCH_LPC31XX && SND_SOC && MACH_EA313X
         help
-          Say Y or M if you want to add audio support for the LPC313X.
+          Say Y or M if you want to add audio support for the LPC31XX.
           You will also need to to select the audio interfaces to
 	  support below.
 
@@ -10,19 +10,19 @@ config SND_LPC315X_SOC
 	tristate "SoC Audio for the NXP LPC315X System-on-a-Chip"
 	depends on ARCH_LPC31XX && SND_SOC && MACH_EA3152
 	help
-	Say Y or M if you want to add audio support for the LPC313X.
+	Say Y or M if you want to add audio support for the LPC31XX.
 	You will also need to to select the audio interfaces to
 	support below.
 
-config SND_LPC313X_SOC_I2S
+config SND_LPC31XX_SOC_I2S
         bool
 
 config SND_EA3131_SOC_I2S_UDA1380
         bool "EA3131 SoC Audio for the UDA1380 CODEC using I2S/I2C"
-        depends on SND_LPC313X_SOC
+        depends on SND_LPC31XX_SOC
         depends on MACH_EA313X
         select I2C_PNX
-        select SND_LPC313X_SOC_I2S
+        select SND_LPC31XX_SOC_I2S
         select SND_SOC_UDA1380
         help
           Say Y here if you want to add support for SoC audio on the
@@ -32,7 +32,7 @@ config SND_LPC315X_SOC_I2S_LPC315X_CODEC
 	bool "SoC Audio for the Analog Die CODEC using I2S/I2C in 315X SoC"
 	depends on SND_LPC315X_SOC
 	select I2C_PNX
-	select SND_LPC313X_SOC_I2S
+	select SND_LPC31XX_SOC_I2S
 	select SND_SOC_LPC315X_CODEC
 	help
 		Say Y here if you want to add support for SoC audio on the
@@ -42,7 +42,7 @@ config SND_LPC315X_SOC_I2S_LPC315X_CODEC
 
 config SND_USE_EA3131
         bool "Enable audio configuration for the EA3131 board"
-        depends on SND_LPC313X_SOC
+        depends on SND_LPC31XX_SOC
 	select SND_EA3131_SOC_I2S_UDA1380
 	select SND_I2C1_CHANNEL_UDA1380
 	select SND_I2S_RX1_MASTER
@@ -82,7 +82,7 @@ config SND_I2C1_CHANNEL_LPC315X_CODEC
 
 choice
 	prompt "I2S RX channel configuration"
-	depends on SND_LPC313X_SOC_I2S
+	depends on SND_LPC31XX_SOC_I2S
 	help
 	  This menu selects the I2S RX (record) channel configurations
 
@@ -114,7 +114,7 @@ endchoice
 
 choice
 	prompt "I2S TX channel configuration"
-	depends on SND_LPC313X_SOC_I2S
+	depends on SND_LPC31XX_SOC_I2S
 	help
 	  This menu selects the I2S TX (playback) channel configurations
 
@@ -134,10 +134,10 @@ endchoice
 
 choice
 	prompt "WS clock divider"
-	depends on SND_LPC313X_SOC_I2S && SND_LPC313X_SOC
+	depends on SND_LPC31XX_SOC_I2S && SND_LPC31XX_SOC
 	help
 	  This divider is used to generate the WS rate from the CODEC
-	  clock. The CODEC clock may or may not be generated by the LPC313x.
+	  clock. The CODEC clock may or may not be generated by the LPC31xx.
 	  If it is, it is generated on the CLK_256FS pin. This divider is
 	  usually a factor of 256, 384, 512, 768, or 1024 times the sample
 	  frequency. Selected the correct multiplier here to have the audio
@@ -162,7 +162,7 @@ endchoice
 
 choice
 	prompt "WS clock divider"
-	depends on SND_LPC313X_SOC_I2S && SND_LPC315X_SOC
+	depends on SND_LPC31XX_SOC_I2S && SND_LPC315X_SOC
 	help
 	  This divider is used to generate the WS rate from the CODEC
 	  clock. The CODEC clock is generated by LPC315x digital Die.
@@ -178,16 +178,16 @@ endchoice
 
 config SND_CODEC_NO_FS256_NEEDED
         bool "Disable the CLK_FS256 signals"
-				depends on SND_LPC313X_SOC || SND_LPC315X_SOC
+	depends on SND_LPC31XX_SOC || SND_LPC315X_SOC
         help
           For audio CODECs that do not need the FS256 clock, enable this
 	  option. These CODECs usually generate internal clocking based
-	  on the BCK and ES signals from the LPC313X I2S signals.
+	  on the BCK and ES signals from the LPC31XX I2S signals.
 
 config SND_USE_DMA_LINKLIST
         bool "Use a DMA linked list instead of a circular buffer"
 	default y
-				depends on SND_LPC313X_SOC || SND_LPC315X_SOC
+	depends on SND_LPC31XX_SOC || SND_LPC315X_SOC
         help
           The audio driver supports 2 DMA mode: circular buffer mode and
 	  DMA linked list mode. This option lets you choose which mode to
diff --git a/sound/soc/lpc31xx/Makefile b/sound/soc/lpc31xx/Makefile
index 799d1c4..a9c8ca5 100644
--- a/sound/soc/lpc31xx/Makefile
+++ b/sound/soc/lpc31xx/Makefile
@@ -1,10 +1,10 @@
-# LPC313X Platform Support
+# LPC31XX Platform Support
 snd-soc-lpc31xx-objs := lpc31xx-pcm.o
 snd-soc-lpc31xx-i2s-objs := lpc31xx-i2s.o
 
-obj-$(CONFIG_SND_LPC313X_SOC) += snd-soc-lpc31xx.o
+obj-$(CONFIG_SND_LPC31XX_SOC) += snd-soc-lpc31xx.o
 obj-$(CONFIG_SND_LPC315X_SOC) += snd-soc-lpc31xx.o
-obj-$(CONFIG_SND_LPC313X_SOC_I2S) += snd-soc-lpc31xx-i2s.o lpc31xx-i2s-clocking.o
+obj-$(CONFIG_SND_LPC31XX_SOC_I2S) += snd-soc-lpc31xx-i2s.o lpc31xx-i2s-clocking.o
 
 # LPC3XXX Machine Support
 snd-soc-ea3131-uda1380-objs := ea3131-uda1380.o
diff --git a/sound/soc/lpc31xx/ea3131-uda1380.c b/sound/soc/lpc31xx/ea3131-uda1380.c
index 11a9adf..601fafc 100644
--- a/sound/soc/lpc31xx/ea3131-uda1380.c
+++ b/sound/soc/lpc31xx/ea3131-uda1380.c
@@ -1,5 +1,5 @@
 /*
- * sound/soc/lpc313x/lpc313x-uda1380.c
+ * sound/soc/lpc31xx/lpc31xx-uda1380.c
  *
  * Author: Kevin Wells <kevin.wells@nxp.com>
  *
@@ -43,7 +43,7 @@
 #include "lpc31xx-i2s.h"
 #include "lpc31xx-i2s-clocking.h"
 
-#define SND_MODNAME "lpc313x_uda1380"
+#define SND_MODNAME "lpc31xx_uda1380"
 
 static int ea3131_uda1380_hw_params(struct snd_pcm_substream *substream,
 			      struct snd_pcm_hw_params *params)
@@ -148,7 +148,7 @@ static struct snd_soc_dai_link ea3131_uda1380_dai[] = {
 };
 
 static struct snd_soc_card snd_soc_machine_ea3131 = {
-	.name = "lpc313x-i2s-uda1380",
+	.name = "lpc31xx-i2s-uda1380",
 	.dai_link = &ea3131_uda1380_dai[0],
 	.num_links = ARRAY_SIZE(ea3131_uda1380_dai),
 };
@@ -170,7 +170,7 @@ static int __devinit ea3131_asoc_probe(struct platform_device *pdev)
 	/*
 	 * Enable CODEC clock first or I2C will fail to the CODEC
 	 */
-	lpc313x_main_clk_rate(48000);
+	lpc31xx_main_clk_rate(48000);
 
 	snd_dev = platform_device_alloc("soc-audio", -1);
 	if (!snd_dev) {
@@ -214,7 +214,7 @@ err:
 static int __devexit ea3131_asoc_remove(struct platform_device *pdev)
 {
 	platform_device_unregister(ea3131_snd_device);
-	lpc313x_main_clk_rate(0);
+	lpc31xx_main_clk_rate(0);
 	ea3131_snd_device = NULL;
 	return 0;
 }
diff --git a/sound/soc/lpc31xx/lpc315x-codec.c b/sound/soc/lpc31xx/lpc315x-codec.c
index 63f7053..2bcc11d 100644
--- a/sound/soc/lpc31xx/lpc315x-codec.c
+++ b/sound/soc/lpc31xx/lpc315x-codec.c
@@ -1,5 +1,5 @@
 /*
- * sound/soc/lpc313x/lpc315x-codec.c
+ * sound/soc/lpc31xx/lpc315x-codec.c
  *
  * Author: Kevin Wells <kevin.wells@nxp.com>
  *
@@ -34,9 +34,9 @@
 #include <sound/soc-dapm.h>
 
 #include "../codecs/lpc315x_codec.h"
-#include "lpc313x-pcm.h"
-#include "lpc313x-i2s.h"
-#include "lpc313x-i2s-clocking.h"
+#include "lpc31xx-pcm.h"
+#include "lpc31xx-i2s.h"
+#include "lpc31xx-i2s-clocking.h"
 
 #include <linux/io.h>
 #include <mach/cgu.h>
@@ -135,7 +135,7 @@ static struct snd_soc_dai_link ea315x_lpc315x_codec_dai[] = {
 	{
 		.name = "LPC315X_CODEC",
 		.stream_name = "LPC315X_CODEC",
-		.cpu_dai = &lpc313x_i2s_dai,
+		.cpu_dai = &lpc31xx_i2s_dai,
 		.codec_dai = &lpc315x_codec_dais[0],
 		.init = ea315x_lpc315x_codec_init,
 		.ops = &ea315x_lpc315x_codec_ops,
@@ -144,7 +144,7 @@ static struct snd_soc_dai_link ea315x_lpc315x_codec_dai[] = {
 
 static struct snd_soc_card snd_soc_machine_ea315x = {
 	.name = "LPC315X_CODEC",
-	.platform = &lpc313x_soc_platform,
+	.platform = &lpc31xx_soc_platform,
 	.dai_link = &ea315x_lpc315x_codec_dai[0],
 	.num_links = ARRAY_SIZE(ea315x_lpc315x_codec_dai),
 };
@@ -164,7 +164,7 @@ static int __init ea315x_asoc_init(void)
 	int ret = 0;
 
 	/* Enable CODEC clock first or I2C will fail to the CODEC */
-	lpc313x_main_clk_rate(48000);
+	lpc31xx_main_clk_rate(48000);
 
 	/* Analog Die is added as I2C device in EA3131 Board file.
 	 * So no need to add the I2C device again
@@ -194,7 +194,7 @@ static int __init ea315x_asoc_init(void)
 err_device_add:
 	if (ea315x_snd_device != NULL) {
 		platform_device_put(ea315x_snd_device);
-		lpc313x_main_clk_rate(0);
+		lpc31xx_main_clk_rate(0);
 		ea315x_snd_device = NULL;
 	}
 
@@ -204,7 +204,7 @@ err_device_add:
 static void __exit ea315x_asoc_exit(void)
 {
 	platform_device_unregister(ea315x_snd_device);
-	lpc313x_main_clk_rate(0);
+	lpc31xx_main_clk_rate(0);
 	ea315x_snd_device = NULL;
 }
 
diff --git a/sound/soc/lpc31xx/lpc31xx-i2s-clocking.c b/sound/soc/lpc31xx/lpc31xx-i2s-clocking.c
index 4d7f1fe..5251ec3 100644
--- a/sound/soc/lpc31xx/lpc31xx-i2s-clocking.c
+++ b/sound/soc/lpc31xx/lpc31xx-i2s-clocking.c
@@ -1,5 +1,5 @@
 /*
- * sound/soc/lpc313x/lpc313x-i2s-clocking.c
+ * sound/soc/lpc31xx/lpc31xx-i2s-clocking.c
  *
  * Author: Kevin Wells <kevin.wells@nxp.com>
  *
@@ -193,7 +193,7 @@ static const u32 fsdiv =
 #endif
 #endif
 
-#if defined(CONFIG_SND_LPC313X_SOC)
+#if defined(CONFIG_SND_LPC31XX_SOC)
 static const u32 fsdiv =
 #if defined (CONFIG_SND_CODEC_FS256)
 	256;
@@ -208,7 +208,7 @@ static const u32 fsdiv =
 #endif
 #endif
 
-static u32 lpc313x_set_best_rate(u32 freq)
+static u32 lpc31xx_set_best_rate(u32 freq)
 {
 	CGU_FDIV_SETUP_T clk_div;
 	u32 diff;
@@ -252,7 +252,7 @@ static u32 lpc313x_set_best_rate(u32 freq)
  * Sets up the audio PLL to generate a frequency as close as possible to
  * the target clkrate frequency
  */
-static u32 lpc313x_set_codec_freq(u32 freq)
+static u32 lpc31xx_set_codec_freq(u32 freq)
 {
 	if (freq == 0)
 	{
@@ -266,7 +266,7 @@ static u32 lpc313x_set_codec_freq(u32 freq)
 		cgu_clk_en_dis(CGU_SB_CLK_256FS_ID, 0);
 		cgu_clk_en_dis(CGU_SB_I2S_EDGE_DETECT_CLK_ID, 0);
 
-		freq = lpc313x_set_best_rate(freq);
+		freq = lpc31xx_set_best_rate(freq);
 		if (freq > 0)
 		{
 #if !defined (CONFIG_SND_CODEC_NO_FS256_NEEDED)
@@ -285,7 +285,7 @@ static u32 lpc313x_set_codec_freq(u32 freq)
 /*
  * Start or stop a channel's clocks
  */
-static void lpc313x_ch_clk_disen(enum i2s_supp_clks chclk, int en)
+static void lpc31xx_ch_clk_disen(enum i2s_supp_clks chclk, int en)
 {
 	int i = 0;
 	P_CGU_CLOCK_ID_T pclks = (P_CGU_CLOCK_ID_T) clkarray[chclk];
@@ -301,20 +301,20 @@ static void lpc313x_ch_clk_disen(enum i2s_supp_clks chclk, int en)
  * Sets up the channel bit clock to generate a rate as close as possible
  * to the target clkrate frequency
  */
-static u32 lpc313x_set_ch_freq(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq)
+static u32 lpc31xx_set_ch_freq(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq)
 {
 	CGU_FDIV_SETUP_T ch_div;
 
 	if (ws_freq == 0)
 	{
 		/* Turn channel clock off */
-		lpc313x_ch_clk_disen(chclk, 0);
+		lpc31xx_ch_clk_disen(chclk, 0);
 		bit_freq = 0;
 	}
 	else
 	{
 		/* Stop channel clocks for the change */
-		lpc313x_ch_clk_disen(chclk, 0);
+		lpc31xx_ch_clk_disen(chclk, 0);
 
 		ch_div.stretch = 1;
 		ch_div.n = 1;
@@ -334,7 +334,7 @@ static u32 lpc313x_set_ch_freq(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_fr
 		}
 
 		/* Enable channel clock */
-		lpc313x_ch_clk_disen(chclk, 1);
+		lpc31xx_ch_clk_disen(chclk, 1);
 	}
 
 	return ws_freq;
@@ -345,13 +345,13 @@ static u32 lpc313x_set_ch_freq(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_fr
  * the actual programmed clock rate. The programmed rate is generated on
  * the FS256 pin has a rate of (256 * clkrate).
  */
-u32 lpc313x_main_clk_rate(u32 freq)
+u32 lpc31xx_main_clk_rate(u32 freq)
 {
 	u32 ret = 0;
 	/* Compute and set proper divider */
-	ret = lpc313x_set_codec_freq(freq);
+	ret = lpc31xx_set_codec_freq(freq);
 #if defined (CONFIG_SND_DEBUG_VERBOSE)
-	pr_info("LPC313x ASOC main clock : %d (%d)\n",
+	pr_info("LPC31xx ASOC main clock : %d (%d)\n",
 		i2s_clk_state.target_codec_rate,
 		i2s_clk_state.real_fs_codec_rate);
 #endif
@@ -363,9 +363,9 @@ u32 lpc313x_main_clk_rate(u32 freq)
  * to the channel's WS and BCLK signals. Returns the actual programmed
  * WS clock rate.
  */
-u32 lpc313x_chan_clk_enable(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq)
+u32 lpc31xx_chan_clk_enable(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq)
 {
 	/* Compute and set proper divider */
-	return lpc313x_set_ch_freq(chclk, ws_freq, bit_freq);
+	return lpc31xx_set_ch_freq(chclk, ws_freq, bit_freq);
 }
 
diff --git a/sound/soc/lpc31xx/lpc31xx-i2s-clocking.h b/sound/soc/lpc31xx/lpc31xx-i2s-clocking.h
index d00103a..9241a2a 100644
--- a/sound/soc/lpc31xx/lpc31xx-i2s-clocking.h
+++ b/sound/soc/lpc31xx/lpc31xx-i2s-clocking.h
@@ -1,5 +1,5 @@
 /*
- * sound/soc/lpc313x/lpc313x-i2s-clocking.h
+ * sound/soc/lpc31xx/lpc31xx-i2s-clocking.h
  *
  * Author: Kevin Wells <kevin.wells@nxp.com>
  *
@@ -23,7 +23,7 @@
 
 /*
  * This file provides the necessary clocking and control functions for the
- * sound drivers on the LPC313X. These functions include clock enable and
+ * sound drivers on the LPC31XX. These functions include clock enable and
  * disable, and clock frequency setup on the WS, BCLK, and SYSCLK pins.
  *
  * Pin mapping is as follows:
@@ -39,8 +39,8 @@
  *     I2STX_BCK1               I2S TX channel 1 serial data bit clock
  */
 
-#ifndef __LPC313X_I2S_CLOCKING_H
-#define __LPC313X_I2S_CLOCKING_H
+#ifndef __LPC31XX_I2S_CLOCKING_H
+#define __LPC31XX_I2S_CLOCKING_H
 
 #include <linux/types.h>
 
@@ -54,13 +54,13 @@ enum i2s_supp_clks {CLK_RX_0, CLK_TX_0, CLK_RX_1, CLK_TX_1};
  * the actual programmed clock rate. The programmed rate is generated on
  * the FS256 pin has a rate of (256 * clkrate).
  */
-u32 lpc313x_main_clk_rate(u32 clkrate);
+u32 lpc31xx_main_clk_rate(u32 clkrate);
 
 /*
  * Set a specific channel's bit clock and word select rates. his applies
  * to the channel's WS and BCLK signals. Returns the actual programmed
  * WS clock rate.
  */
-u32 lpc313x_chan_clk_enable(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq);
+u32 lpc31xx_chan_clk_enable(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq);
 
-#endif /* __LPC313X_I2S_CLOCKING */
+#endif /* __LPC31XX_I2S_CLOCKING */
diff --git a/sound/soc/lpc31xx/lpc31xx-i2s.c b/sound/soc/lpc31xx/lpc31xx-i2s.c
index c79f2c9..00e8b4d 100644
--- a/sound/soc/lpc31xx/lpc31xx-i2s.c
+++ b/sound/soc/lpc31xx/lpc31xx-i2s.c
@@ -1,5 +1,5 @@
 /*
- * sound/soc/lpc313x/lpc313x-i2s.c
+ * sound/soc/lpc31xx/lpc31xx-i2s.c
  *
  * Author: Kevin Wells <kevin.wells@nxp.com>
  *
@@ -43,20 +43,20 @@
 #include "lpc31xx-pcm.h"
 #include "lpc31xx-i2s.h"
 
-#define I2S_NAME "lpc313x-i2s"
+#define I2S_NAME "lpc31xx-i2s"
 
 /* All major audio rates are support and 16-bit I2S data is supported */
-#define LPC313X_I2S_RATES \
+#define LPC31XX_I2S_RATES \
     (SNDRV_PCM_RATE_8000  | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
      SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
      SNDRV_PCM_RATE_48000)
-#define LPC313X_I2S_FORMATS (SNDRV_PCM_FMTBIT_S16)
+#define LPC31XX_I2S_FORMATS (SNDRV_PCM_FMTBIT_S16)
 
 #define CH_PLAY 0
 #define CH_REC  1
 
 /* Structure that keeps I2S direction data */
-struct lpc313x_i2s_ch_info {
+struct lpc31xx_i2s_ch_info {
 	char *name;                 /* Name of this channel */
 	unsigned short ch_on;       /* Flag used to indicate if clocks are on */
 	unsigned short daifmt;
@@ -66,15 +66,15 @@ struct lpc313x_i2s_ch_info {
 };
 
 /* Common I2S structure data */
-struct lpc313x_i2s_info {
+struct lpc31xx_i2s_info {
 	spinlock_t lock;
 	unsigned short initialized;
-	struct lpc313x_i2s_ch_info ch_info[2];
+	struct lpc31xx_i2s_ch_info ch_info[2];
 	u32 freq;
 };
 
 /* Common I2S structure data */
-static struct lpc313x_i2s_info i2s_info =
+static struct lpc31xx_i2s_info i2s_info =
 {
 	.lock = __SPIN_LOCK_UNLOCKED(i2s_info.lock),
 	.initialized = 0,
@@ -123,20 +123,20 @@ static struct lpc313x_i2s_info i2s_info =
 };
 
 static inline void
-lpc31xx_i2s_write(const struct lpc31xx_i2s_info *info, uint32_t reg, uint32_t value)
+lpc31xx_i2s_write(const struct lpc31xx_i2s_res_info *info, uint32_t reg, uint32_t value)
 {
 	__raw_writel(value, info->regs + reg);
 }
 
 static inline uint32_t
-lpc31xx_i2s_read(const struct lpc31xx_i2s_info *info, uint32_t reg)
+lpc31xx_i2s_read(const struct lpc31xx_i2s_res_info *info, uint32_t reg)
 {
 	uint32_t value;
 	value = __raw_readl(info->regs + reg);
 	return value;
 }
 
-static inline int lpc313x_get_ch_dir(struct snd_pcm_substream *substream)
+static inline int lpc31xx_get_ch_dir(struct snd_pcm_substream *substream)
 {
 	int dir = CH_REC;
 
@@ -147,10 +147,10 @@ static inline int lpc313x_get_ch_dir(struct snd_pcm_substream *substream)
 	return dir;
 }
 
-static void lpc313x_i2s_shutdown(struct snd_pcm_substream *substream,
+static void lpc31xx_i2s_shutdown(struct snd_pcm_substream *substream,
 									struct snd_soc_dai *dai)
 {
-	int dir = lpc313x_get_ch_dir(substream);
+	int dir = lpc31xx_get_ch_dir(substream);
 
 	if (i2s_info.ch_info[dir].ch_on == 0) {
 		/* This channel is not enabled! */
@@ -159,7 +159,7 @@ static void lpc313x_i2s_shutdown(struct snd_pcm_substream *substream,
 	}
 
 	/* Channel specific shutdown */
-	lpc313x_chan_clk_enable(i2s_info.ch_info[dir].chclk, 0, 0);
+	lpc31xx_chan_clk_enable(i2s_info.ch_info[dir].chclk, 0, 0);
 	i2s_info.ch_info[dir].ch_on = 0;
 
 	/* Can we shutdown I2S interface to save some power? */
@@ -183,11 +183,11 @@ static void lpc313x_i2s_shutdown(struct snd_pcm_substream *substream,
 	i2s_info.initialized = 0;
 }
 
-static int lpc313x_i2s_startup(struct snd_pcm_substream *substream,
+static int lpc31xx_i2s_startup(struct snd_pcm_substream *substream,
 								struct snd_soc_dai *dai)
 {
-	struct lpc31xx_i2s_info *info = snd_soc_dai_get_drvdata(dai);
-	int dir = lpc313x_get_ch_dir(substream);
+	struct lpc31xx_i2s_res_info *info = snd_soc_dai_get_drvdata(dai);
+	int dir = lpc31xx_get_ch_dir(substream);
 
 	/* Select master/slave mode for RX channel */
 	if (dir == CH_REC) {
@@ -219,7 +219,7 @@ static int lpc313x_i2s_startup(struct snd_pcm_substream *substream,
 
 	/* Channel specific init, ok to leave the clocks off for now */
 	i2s_info.ch_info[dir].ch_on = 1;
-	lpc313x_chan_clk_enable(i2s_info.ch_info[dir].chclk, 0, 0);
+	lpc31xx_chan_clk_enable(i2s_info.ch_info[dir].chclk, 0, 0);
 
 	/* Mask all interrupts for the I2S channel */
 	lpc31xx_i2s_write(info, I2S_CH_INT_MASK(i2s_info.ch_info[dir].i2s_ch), I2S_FIFO_ALL_MASK);
@@ -227,7 +227,7 @@ static int lpc313x_i2s_startup(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-static int lpc313x_i2s_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+static int lpc31xx_i2s_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
 				      int clk_id, unsigned int freq, int dir)
 {
 	/* Will use in HW params later */
@@ -237,7 +237,7 @@ static int lpc313x_i2s_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
 	return 0;
 }
 
-static int lpc313x_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,
+static int lpc31xx_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,
 				   unsigned int fmt)
 {
 	/* Will use in HW params later */
@@ -248,7 +248,7 @@ static int lpc313x_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,
 	return 0;
 }
 
-static int lpc313x_i2s_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,
+static int lpc31xx_i2s_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,
 				      int div_id, int div)
 {
 	/* This function isn't used */
@@ -259,12 +259,12 @@ static int lpc313x_i2s_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,
 	return 0;
 }
 
-static int lpc313x_i2s_hw_params(struct snd_pcm_substream *substream,
+static int lpc31xx_i2s_hw_params(struct snd_pcm_substream *substream,
 			         struct snd_pcm_hw_params *params,
 					 struct snd_soc_dai *dai)
 {
-	struct lpc31xx_i2s_info *info = snd_soc_dai_get_drvdata(dai);
-	int dir = lpc313x_get_ch_dir(substream);
+	struct lpc31xx_i2s_res_info *info = snd_soc_dai_get_drvdata(dai);
+	int dir = lpc31xx_get_ch_dir(substream);
 	u32 tmp;
 
 	/* Setup the I2S data format */
@@ -295,7 +295,7 @@ static int lpc313x_i2s_hw_params(struct snd_pcm_substream *substream,
 	/* The playback and record rates are shared, so just set the CODEC clock
 	   to the selected rate (will actually generate 256 * rate) */
 	i2s_info.freq = i2s_info.ch_info[dir].ws_freq;
-	if (lpc313x_main_clk_rate(i2s_info.freq) == 0)
+	if (lpc31xx_main_clk_rate(i2s_info.freq) == 0)
 	{
 		pr_warning("Unsupported audio data rate (%d)\n",
 			i2s_info.freq);
@@ -303,7 +303,7 @@ static int lpc313x_i2s_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	/* Now setup the selected channel clocks (WS and BCK) */
-	if (lpc313x_chan_clk_enable(i2s_info.ch_info[dir].chclk, i2s_info.freq,
+	if (lpc31xx_chan_clk_enable(i2s_info.ch_info[dir].chclk, i2s_info.freq,
 		(i2s_info.freq * 32)) == 0)
 	{
 		pr_warning("Unsupported channel data rates (ws=%d, bck=%d)\n",
@@ -314,7 +314,7 @@ static int lpc313x_i2s_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-static int lpc313x_i2s_trigger(struct snd_pcm_substream *substream, int cmd, struct snd_soc_dai *dai)
+static int lpc31xx_i2s_trigger(struct snd_pcm_substream *substream, int cmd, struct snd_soc_dai *dai)
 {
 	int ret = 0;
 
@@ -328,7 +328,7 @@ static int lpc313x_i2s_trigger(struct snd_pcm_substream *substream, int cmd, str
 		break;
 
 	default:
-		pr_warning("lpc313x_i2s_triggers: Unsupported cmd: %d\n",
+		pr_warning("lpc31xx_i2s_triggers: Unsupported cmd: %d\n",
 				cmd);
 		ret = -EINVAL;
 	}
@@ -337,40 +337,40 @@ static int lpc313x_i2s_trigger(struct snd_pcm_substream *substream, int cmd, str
 }
 
 #ifdef CONFIG_PM
-static int lpc313x_i2s_suspend(struct snd_soc_dai *cpu_dai)
+static int lpc31xx_i2s_suspend(struct snd_soc_dai *cpu_dai)
 {
 	/* Shutdown active clocks */
 	if (i2s_info.ch_info[CH_PLAY].ch_on != 0) {
-		lpc313x_chan_clk_enable(i2s_info.ch_info[CH_PLAY].chclk, 0, 0);
+		lpc31xx_chan_clk_enable(i2s_info.ch_info[CH_PLAY].chclk, 0, 0);
 	}
 	if (i2s_info.ch_info[CH_REC].ch_on != 0) {
-		lpc313x_chan_clk_enable(i2s_info.ch_info[CH_REC].chclk, 0, 0);
+		lpc31xx_chan_clk_enable(i2s_info.ch_info[CH_REC].chclk, 0, 0);
 	}
 
 	/* Disable I2S register access clock */
 	cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 0);
 	cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 0);
 	/* shutdown main clocks */
-	lpc313x_main_clk_rate(0);
+	lpc31xx_main_clk_rate(0);
 
 	return 0;
 }
 
-static int lpc313x_i2s_resume(struct snd_soc_dai *cpu_dai)
+static int lpc31xx_i2s_resume(struct snd_soc_dai *cpu_dai)
 {
 	/* resume main clocks */
-	lpc313x_main_clk_rate(i2s_info.freq);
+	lpc31xx_main_clk_rate(i2s_info.freq);
 	/* Enable I2S register access clock */
 	cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 1);
 	cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 1);
 
 	/* resume active clocks */
 	if (i2s_info.ch_info[CH_PLAY].ch_on != 0) {
-		lpc313x_chan_clk_enable(i2s_info.ch_info[CH_PLAY].chclk,
+		lpc31xx_chan_clk_enable(i2s_info.ch_info[CH_PLAY].chclk,
 		i2s_info.ch_info[CH_PLAY].ws_freq, (i2s_info.freq * 32));
 	}
 	if (i2s_info.ch_info[CH_REC].ch_on != 0) {
-		lpc313x_chan_clk_enable(i2s_info.ch_info[CH_REC].chclk,
+		lpc31xx_chan_clk_enable(i2s_info.ch_info[CH_REC].chclk,
 		i2s_info.ch_info[CH_REC].ws_freq, (i2s_info.freq * 32));
 	}
 
@@ -378,45 +378,45 @@ static int lpc313x_i2s_resume(struct snd_soc_dai *cpu_dai)
 }
 
 #else
-#define lpc313x_i2s_suspend	NULL
-#define lpc313x_i2s_resume	NULL
+#define lpc31xx_i2s_suspend	NULL
+#define lpc31xx_i2s_resume	NULL
 #endif
 
-static struct snd_soc_dai_ops lpc313x_i2s_dai_ops = {
-		.startup = lpc313x_i2s_startup,
-		.shutdown = lpc313x_i2s_shutdown,
-		.trigger = lpc313x_i2s_trigger,
-		.hw_params = lpc313x_i2s_hw_params,
-		.set_sysclk = lpc313x_i2s_set_dai_sysclk,
-		.set_fmt = lpc313x_i2s_set_dai_fmt,
-		.set_clkdiv = lpc313x_i2s_set_dai_clkdiv,		
+static struct snd_soc_dai_ops lpc31xx_i2s_dai_ops = {
+		.startup = lpc31xx_i2s_startup,
+		.shutdown = lpc31xx_i2s_shutdown,
+		.trigger = lpc31xx_i2s_trigger,
+		.hw_params = lpc31xx_i2s_hw_params,
+		.set_sysclk = lpc31xx_i2s_set_dai_sysclk,
+		.set_fmt = lpc31xx_i2s_set_dai_fmt,
+		.set_clkdiv = lpc31xx_i2s_set_dai_clkdiv,
 };
 
-struct snd_soc_dai_driver lpc313x_i2s_dai = {
+struct snd_soc_dai_driver lpc31xx_i2s_dai = {
 	 .name = I2S_NAME,
 	 .id = 0,
-	 .suspend = lpc313x_i2s_suspend,
-	 .resume = lpc313x_i2s_resume,
+	 .suspend = lpc31xx_i2s_suspend,
+	 .resume = lpc31xx_i2s_resume,
 	 .playback = {
 		      .channels_min = 2,
 		      .channels_max = 2,
-		      .rates = LPC313X_I2S_RATES,
-		      .formats = LPC313X_I2S_FORMATS,
+		      .rates = LPC31XX_I2S_RATES,
+		      .formats = LPC31XX_I2S_FORMATS,
 		      },
 	 .capture = {
 		     .channels_min = 2,
 		     .channels_max = 2,
-		     .rates = LPC313X_I2S_RATES,
-		     .formats = LPC313X_I2S_FORMATS,
+		     .rates = LPC31XX_I2S_RATES,
+		     .formats = LPC31XX_I2S_FORMATS,
 		     },
-	 .ops = &lpc313x_i2s_dai_ops,
+	 .ops = &lpc31xx_i2s_dai_ops,
 	.symmetric_rates = 1,
 };
-EXPORT_SYMBOL_GPL(lpc313x_i2s_dai);
+EXPORT_SYMBOL_GPL(lpc31xx_i2s_dai);
 
-static __devinit int lpc313x_i2s_dev_probe(struct platform_device *pdev)
+static __devinit int lpc31xx_i2s_dev_probe(struct platform_device *pdev)
 {
-	struct lpc31xx_i2s_info *info;
+	struct lpc31xx_i2s_res_info *info;
 	struct resource *res;
 	int err;
 
@@ -447,7 +447,7 @@ static __devinit int lpc313x_i2s_dev_probe(struct platform_device *pdev)
 		goto fail_release_mem;
 	}
 
-	err = snd_soc_register_dai(&pdev->dev, &lpc313x_i2s_dai);
+	err = snd_soc_register_dai(&pdev->dev, &lpc31xx_i2s_dai);
 	if (err)
 		goto fail_unmap_mem;
 
@@ -463,47 +463,47 @@ fail:
 	return err;
 }
 
-static __devexit int lpc313x_i2s_dev_remove(struct platform_device *pdev)
+static __devexit int lpc31xx_i2s_dev_remove(struct platform_device *pdev)
 {
 	snd_soc_unregister_dai(&pdev->dev);
 	return 0;
 }
 
 #if defined(CONFIG_OF)
-static const struct of_device_id lpc313x_i2s_of_match[] = {
+static const struct of_device_id lpc31xx_i2s_of_match[] = {
 	{ .compatible = "nxp,lpc31xx-i2s" },
 	{},
 };
-MODULE_DEVICE_TABLE(of, lpc313x_i2s_of_match);
+MODULE_DEVICE_TABLE(of, lpc31xx_i2s_of_match);
 #endif
 
-static struct platform_driver lpc313x_i2s_driver = {
-	.probe  = lpc313x_i2s_dev_probe,
-	.remove = lpc313x_i2s_dev_remove,
+static struct platform_driver lpc31xx_i2s_driver = {
+	.probe  = lpc31xx_i2s_dev_probe,
+	.remove = lpc31xx_i2s_dev_remove,
 	.driver = {
 		.name = I2S_NAME,
 		.owner = THIS_MODULE,
 #ifdef CONFIG_OF
-		.of_match_table = lpc313x_i2s_of_match,
+		.of_match_table = lpc31xx_i2s_of_match,
 #endif
 	},
 };
 
-static int __init lpc313x_i2s_init(void)
+static int __init lpc31xx_i2s_init(void)
 {
-	return platform_driver_register(&lpc313x_i2s_driver);
+	return platform_driver_register(&lpc31xx_i2s_driver);
 }
-module_init(lpc313x_i2s_init);
+module_init(lpc31xx_i2s_init);
 
-static void __exit lpc313x_i2s_exit(void)
+static void __exit lpc31xx_i2s_exit(void)
 {
-	platform_driver_unregister(&lpc313x_i2s_driver);
+	platform_driver_unregister(&lpc31xx_i2s_driver);
 }
-module_exit(lpc313x_i2s_exit);
+module_exit(lpc31xx_i2s_exit);
 
 /* Module information */
 MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
-MODULE_DESCRIPTION("ASoC LPC313X I2S interface");
+MODULE_DESCRIPTION("ASoC LPC31XX I2S interface");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:" I2S_NAME);
 
diff --git a/sound/soc/lpc31xx/lpc31xx-i2s.h b/sound/soc/lpc31xx/lpc31xx-i2s.h
index 001bd6e..61ef01f 100644
--- a/sound/soc/lpc31xx/lpc31xx-i2s.h
+++ b/sound/soc/lpc31xx/lpc31xx-i2s.h
@@ -1,5 +1,5 @@
 /*
- * sound/soc/lpc313x/lpc313x-i2s.h
+ * sound/soc/lpc31xx/lpc31xx-i2s.h
  *
  * Author: Kevin Wells <kevin.wells@nxp.com>
  *
@@ -20,14 +20,14 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifndef __SOUND_SOC_LPC313X_I2S_H
-#define __SOUND_SOC_LPC313X_I2S_H
+#ifndef __SOUND_SOC_LPC31XX_I2S_H
+#define __SOUND_SOC_LPC31XX_I2S_H
 
 #include <linux/types.h>
 
-extern struct snd_soc_dai_driver lpc313x_i2s_dai;
+extern struct snd_soc_dai_driver lpc31xx_i2s_dai;
 
-struct lpc31xx_i2s_info {
+struct lpc31xx_i2s_res_info {
 	struct resource			*mem;
 	void __iomem			*regs;
 };
diff --git a/sound/soc/lpc31xx/lpc31xx-pcm.c b/sound/soc/lpc31xx/lpc31xx-pcm.c
index 63187f1..fff64dc 100644
--- a/sound/soc/lpc31xx/lpc31xx-pcm.c
+++ b/sound/soc/lpc31xx/lpc31xx-pcm.c
@@ -1,5 +1,5 @@
 /*
- * sound/soc/lpc313x/lpc313x-pcm.c
+ * sound/soc/lpc31xx/lpc31xx-pcm.c
  *
  * Author: Kevin Wells <kevin.wells@nxp.com>
  *
@@ -35,7 +35,7 @@
 #include "lpc31xx-pcm.h"
 
 #define SND_NAME "lpc31xx-pcm-audio"
-static u64 lpc313x_pcm_dmamask = DMA_BIT_MASK(32);
+static u64 lpc31xx_pcm_dmamask = DMA_BIT_MASK(32);
 
 #if defined (CONFIG_SND_USE_DMA_LINKLIST)
 /* The DMA controller in the LPC31XX has limited interrupt support
@@ -70,7 +70,7 @@ static u64 lpc313x_pcm_dmamask = DMA_BIT_MASK(32);
 #define RX_DMA_CHCFG DMA_SLV_I2SRX1_L
 #endif
 
-static const struct snd_pcm_hardware lpc313x_pcm_hardware = {
+static const struct snd_pcm_hardware lpc31xx_pcm_hardware = {
 	.info = (SNDRV_PCM_INFO_MMAP |
 		 SNDRV_PCM_INFO_MMAP_VALID |
 		 SNDRV_PCM_INFO_INTERLEAVED |
@@ -84,7 +84,7 @@ static const struct snd_pcm_hardware lpc313x_pcm_hardware = {
 	.buffer_bytes_max = (MAX_PERIODS * MAX_BYTES_PERIOD)
 };
 
-struct lpc313x_dma_data {
+struct lpc31xx_i2sdma_data {
 	dma_addr_t dma_buffer;	/* physical address of DMA buffer */
 	dma_addr_t dma_buffer_end; /* first address beyond DMA buffer */
 	size_t period_size;
@@ -105,10 +105,10 @@ struct lpc313x_dma_data {
 /*
  * DMA ISR - occurs when a new DMA buffer is needed
  */
-static void lpc313x_pcm_dma_irq(int ch, dma_irq_type_t dtype, void *handle) {
+static void lpc31xx_pcm_dma_irq(int ch, dma_irq_type_t dtype, void *handle) {
 	struct snd_pcm_substream *substream = (struct snd_pcm_substream *) handle;
 	struct snd_pcm_runtime *rtd = substream->runtime;
-	struct lpc313x_dma_data *prtd = rtd->private_data;
+	struct lpc31xx_i2sdma_data *prtd = rtd->private_data;
 
 	(void) dtype;
 	(void) ch;
@@ -123,10 +123,10 @@ static void lpc313x_pcm_dma_irq(int ch, dma_irq_type_t dtype, void *handle) {
 }
 
 #if defined (CONFIG_SND_USE_DMA_LINKLIST)
-static void lpc313x_check_dmall(unsigned long data) {
+static void lpc31xx_check_dmall(unsigned long data) {
 	struct snd_pcm_substream *substream = (struct snd_pcm_substream *) data;
 	struct snd_pcm_runtime *rtd = substream->runtime;
-	struct lpc313x_dma_data *prtd = rtd->private_data;
+	struct lpc31xx_i2sdma_data *prtd = rtd->private_data;
 
 	/* Determine buffer position from current DMA position. We don't need
 	   the exact address, just the last finished period */
@@ -144,11 +144,11 @@ static void lpc313x_check_dmall(unsigned long data) {
 }
 #endif
 
-static int lpc313x_pcm_allocate_dma_buffer(struct snd_pcm *pcm, int stream)
+static int lpc31xx_pcm_allocate_dma_buffer(struct snd_pcm *pcm, int stream)
 {
 	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
 	struct snd_dma_buffer *dmabuf = &substream->dma_buffer;
-	size_t size = lpc313x_pcm_hardware.buffer_bytes_max;
+	size_t size = lpc31xx_pcm_hardware.buffer_bytes_max;
 
 	dmabuf->dev.type = SNDRV_DMA_TYPE_DEV;
 	dmabuf->dev.dev = pcm->card->dev;
@@ -156,7 +156,7 @@ static int lpc313x_pcm_allocate_dma_buffer(struct snd_pcm *pcm, int stream)
 	dmabuf->area = dma_alloc_coherent(pcm->card->dev, size,
 					  &dmabuf->addr, GFP_KERNEL);
 
-	pr_debug("lpc313x-pcm:"
+	pr_debug("lpc31xx-pcm:"
 		"preallocate_dma_buffer: area=%p, addr=%p, size=%d\n",
 		(void *) dmabuf->area,
 		(void *) dmabuf->addr,
@@ -173,11 +173,11 @@ static int lpc313x_pcm_allocate_dma_buffer(struct snd_pcm *pcm, int stream)
 /*
  * PCM operations
  */
-static int lpc313x_pcm_hw_params(struct snd_pcm_substream *substream,
+static int lpc31xx_pcm_hw_params(struct snd_pcm_substream *substream,
 			         struct snd_pcm_hw_params *params)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct lpc313x_dma_data *prtd = runtime->private_data;
+	struct lpc31xx_i2sdma_data *prtd = runtime->private_data;
 
 	/* this may get called several times by oss emulation
 	 * with different params
@@ -193,9 +193,9 @@ static int lpc313x_pcm_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-static int lpc313x_pcm_hw_free(struct snd_pcm_substream *substream)
+static int lpc31xx_pcm_hw_free(struct snd_pcm_substream *substream)
 {
-	struct lpc313x_dma_data *prtd = substream->runtime->private_data;
+	struct lpc31xx_i2sdma_data *prtd = substream->runtime->private_data;
 
 	/* Return the DMA channel */
 	if (prtd->dmach != -1) {
@@ -215,16 +215,16 @@ static int lpc313x_pcm_hw_free(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static int lpc313x_pcm_prepare(struct snd_pcm_substream *substream)
+static int lpc31xx_pcm_prepare(struct snd_pcm_substream *substream)
 {
-	struct lpc313x_dma_data *prtd = substream->runtime->private_data;
+	struct lpc31xx_i2sdma_data *prtd = substream->runtime->private_data;
 
 	/* Setup DMA channel */
 	if (prtd->dmach == -1) {
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 #if defined (CONFIG_SND_USE_DMA_LINKLIST)
 			prtd->dmach = dma_request_sg_channel("I2STX",
-				lpc313x_pcm_dma_irq, substream, 0, 0, 0);
+				lpc31xx_pcm_dma_irq, substream, 0, 0, 0);
 			prtd->dma_cfg_base = DMA_CFG_TX_WORD |
 				DMA_CFG_RD_SLV_NR(0) | DMA_CFG_CMP_CH_EN |
 				DMA_CFG_WR_SLV_NR(TX_DMA_CHCFG) |
@@ -232,7 +232,7 @@ static int lpc313x_pcm_prepare(struct snd_pcm_substream *substream)
 
 #else
 			prtd->dmach = dma_request_channel("I2STX",
-				lpc313x_pcm_dma_irq, substream);
+				lpc31xx_pcm_dma_irq, substream);
 			prtd->dma_cfg_base = DMA_CFG_TX_WORD |
 				DMA_CFG_RD_SLV_NR(0) | DMA_CFG_CIRC_BUF |
 				DMA_CFG_WR_SLV_NR(TX_DMA_CHCFG);
@@ -241,7 +241,7 @@ static int lpc313x_pcm_prepare(struct snd_pcm_substream *substream)
 		else {
 #if defined (CONFIG_SND_USE_DMA_LINKLIST)
 			prtd->dmach = dma_request_sg_channel("I2SRX",
-				lpc313x_pcm_dma_irq, substream, 0, 0, 0);
+				lpc31xx_pcm_dma_irq, substream, 0, 0, 0);
 			prtd->dma_cfg_base = DMA_CFG_TX_WORD |
 				DMA_CFG_WR_SLV_NR(0) | DMA_CFG_CMP_CH_EN |
 				DMA_CFG_RD_SLV_NR(RX_DMA_CHCFG) |
@@ -249,7 +249,7 @@ static int lpc313x_pcm_prepare(struct snd_pcm_substream *substream)
 
 #else
 			prtd->dmach = dma_request_channel("I2SRX",
-				lpc313x_pcm_dma_irq, substream);
+				lpc31xx_pcm_dma_irq, substream);
 			prtd->dma_cfg_base = DMA_CFG_TX_WORD |
 				DMA_CFG_WR_SLV_NR(0) | DMA_CFG_CIRC_BUF |
 				DMA_CFG_RD_SLV_NR(RX_DMA_CHCFG);
@@ -281,10 +281,10 @@ static int lpc313x_pcm_prepare(struct snd_pcm_substream *substream)
 
 int dma_stop_channel_sg (unsigned int chn);
 
-static int lpc313x_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+static int lpc31xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	struct snd_pcm_runtime *rtd = substream->runtime;
-	struct lpc313x_dma_data *prtd = rtd->private_data;
+	struct lpc31xx_i2sdma_data *prtd = rtd->private_data;
 	int ret = 0;
 
 #if defined (CONFIG_SND_USE_DMA_LINKLIST)
@@ -334,7 +334,7 @@ static int lpc313x_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		/* Add and start audio data position timer */
 		init_timer(&prtd->timer[tch]);
 		prtd->timer[tch].data = (unsigned long) substream;
-		prtd->timer[tch].function = lpc313x_check_dmall;
+		prtd->timer[tch].function = lpc31xx_check_dmall;
 		prtd->timer[tch].expires = jiffies + MINTICKINC;
 		add_timer(&prtd->timer[tch]);
 
@@ -390,7 +390,7 @@ static int lpc313x_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		break;
 
 	default:
-		pr_warning("lpc313x_pcm_trigger: Unsupported cmd: %d\n",
+		pr_warning("lpc31xx_pcm_trigger: Unsupported cmd: %d\n",
 				cmd);
 		ret = -EINVAL;
 	}
@@ -398,10 +398,10 @@ static int lpc313x_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	return ret;
 }
 
-static snd_pcm_uframes_t lpc313x_pcm_pointer(struct snd_pcm_substream *substream)
+static snd_pcm_uframes_t lpc31xx_pcm_pointer(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct lpc313x_dma_data *prtd = runtime->private_data;
+	struct lpc31xx_i2sdma_data *prtd = runtime->private_data;
 	snd_pcm_uframes_t x;
 
 	/* Return an offset into the DMA buffer for the next data */
@@ -412,13 +412,13 @@ static snd_pcm_uframes_t lpc313x_pcm_pointer(struct snd_pcm_substream *substream
 	return x;
 }
 
-static int lpc313x_pcm_open(struct snd_pcm_substream *substream)
+static int lpc31xx_pcm_open(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct lpc313x_dma_data *prtd;
+	struct lpc31xx_i2sdma_data *prtd;
 	int ret = 0;
 
-	snd_soc_set_runtime_hwparams(substream, &lpc313x_pcm_hardware);
+	snd_soc_set_runtime_hwparams(substream, &lpc31xx_pcm_hardware);
 
 	/* ensure that buffer size is a multiple of period size */
 	ret = snd_pcm_hw_constraint_integer(runtime,
@@ -438,15 +438,15 @@ out:
 	return ret;
 }
 
-static int lpc313x_pcm_close(struct snd_pcm_substream *substream)
+static int lpc31xx_pcm_close(struct snd_pcm_substream *substream)
 {
-	struct lpc313x_dma_data *prtd = substream->runtime->private_data;
+	struct lpc31xx_dma_data *prtd = substream->runtime->private_data;
 
 	kfree(prtd);
 	return 0;
 }
 
-static int lpc313x_pcm_mmap(struct snd_pcm_substream *substream,
+static int lpc31xx_pcm_mmap(struct snd_pcm_substream *substream,
 			    struct vm_area_struct *vma)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -457,22 +457,22 @@ static int lpc313x_pcm_mmap(struct snd_pcm_substream *substream,
 				     runtime->dma_bytes);
 }
 
-static struct snd_pcm_ops lpc313x_pcm_ops = {
-	.open = lpc313x_pcm_open,
-	.close = lpc313x_pcm_close,
+static struct snd_pcm_ops lpc31xx_pcm_ops = {
+	.open = lpc31xx_pcm_open,
+	.close = lpc31xx_pcm_close,
 	.ioctl = snd_pcm_lib_ioctl,
-	.hw_params = lpc313x_pcm_hw_params,
-	.hw_free = lpc313x_pcm_hw_free,
-	.prepare = lpc313x_pcm_prepare,
-	.trigger = lpc313x_pcm_trigger,
-	.pointer = lpc313x_pcm_pointer,
-	.mmap = lpc313x_pcm_mmap,
+	.hw_params = lpc31xx_pcm_hw_params,
+	.hw_free = lpc31xx_pcm_hw_free,
+	.prepare = lpc31xx_pcm_prepare,
+	.trigger = lpc31xx_pcm_trigger,
+	.pointer = lpc31xx_pcm_pointer,
+	.mmap = lpc31xx_pcm_mmap,
 };
 
 /*
  * ASoC platform driver
  */
-static int lpc313x_pcm_new(struct snd_soc_pcm_runtime *rtd)
+static int lpc31xx_pcm_new(struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_card *card = rtd->card->snd_card;
 	struct snd_soc_dai *dai = rtd->cpu_dai;
@@ -480,12 +480,12 @@ static int lpc313x_pcm_new(struct snd_soc_pcm_runtime *rtd)
 	int ret = 0;
 
 	if (!card->dev->dma_mask)
-		card->dev->dma_mask = &lpc313x_pcm_dmamask;
+		card->dev->dma_mask = &lpc31xx_pcm_dmamask;
 	if (!card->dev->coherent_dma_mask)
 		card->dev->coherent_dma_mask = 0xffffffff;
 
 	if (dai->driver->playback.channels_min) {
-		ret = lpc313x_pcm_allocate_dma_buffer(
+		ret = lpc31xx_pcm_allocate_dma_buffer(
 			  pcm, SNDRV_PCM_STREAM_PLAYBACK);
 		if (ret)
 			goto out;
@@ -493,7 +493,7 @@ static int lpc313x_pcm_new(struct snd_soc_pcm_runtime *rtd)
 
 	if (dai->driver->capture.channels_min) {
 		pr_debug("%s: Allocating PCM capture DMA buffer\n", SND_NAME);
-		ret = lpc313x_pcm_allocate_dma_buffer(
+		ret = lpc31xx_pcm_allocate_dma_buffer(
 			  pcm, SNDRV_PCM_STREAM_CAPTURE);
 		if (ret)
 			goto out;
@@ -503,7 +503,7 @@ out:
 	return ret;
 }
 
-static void lpc313x_pcm_free_dma_buffers(struct snd_pcm *pcm)
+static void lpc31xx_pcm_free_dma_buffers(struct snd_pcm *pcm)
 {
 	struct snd_pcm_substream *substream;
 	struct snd_dma_buffer *buf;
@@ -525,48 +525,48 @@ static void lpc313x_pcm_free_dma_buffers(struct snd_pcm *pcm)
 	}
 }
 
-struct snd_soc_platform_driver lpc313x_asoc_platform = {
-	.ops = &lpc313x_pcm_ops,
-	.pcm_new = lpc313x_pcm_new,
-	.pcm_free = lpc313x_pcm_free_dma_buffers,
+struct snd_soc_platform_driver lpc31xx_asoc_platform = {
+	.ops = &lpc31xx_pcm_ops,
+	.pcm_new = lpc31xx_pcm_new,
+	.pcm_free = lpc31xx_pcm_free_dma_buffers,
 };
-EXPORT_SYMBOL_GPL(lpc313x_asoc_platform);
+EXPORT_SYMBOL_GPL(lpc31xx_asoc_platform);
 
 
-static int __devinit lpc313x_asoc_platform_probe(struct platform_device *pdev)
+static int __devinit lpc31xx_asoc_platform_probe(struct platform_device *pdev)
 {
-	return snd_soc_register_platform(&pdev->dev, &lpc313x_asoc_platform);
+	return snd_soc_register_platform(&pdev->dev, &lpc31xx_asoc_platform);
 }
 
-static int __devexit lpc313x_asoc_platform_remove(struct platform_device *pdev)
+static int __devexit lpc31xx_asoc_platform_remove(struct platform_device *pdev)
 {
 	snd_soc_unregister_platform(&pdev->dev);
 	return 0;
 }
 
-static struct platform_driver lpc313x_dma_driver = {
+static struct platform_driver lpc31xx_dma_driver = {
 	.driver = {
 		.name = SND_NAME,
 		.owner = THIS_MODULE,
 	},
 
-	.probe = lpc313x_asoc_platform_probe,
-	.remove = __devexit_p(lpc313x_asoc_platform_remove),
+	.probe = lpc31xx_asoc_platform_probe,
+	.remove = __devexit_p(lpc31xx_asoc_platform_remove),
 };
 
-static int __init lpc313x_asoc_init(void)
+static int __init lpc31xx_asoc_init(void)
 {
-	return platform_driver_register(&lpc313x_dma_driver);
+	return platform_driver_register(&lpc31xx_dma_driver);
 }
-module_init(lpc313x_asoc_init);
+module_init(lpc31xx_asoc_init);
 
-static void __exit lpc313x_asoc_exit(void)
+static void __exit lpc31xx_asoc_exit(void)
 {
-	platform_driver_unregister(&lpc313x_dma_driver);
+	platform_driver_unregister(&lpc31xx_dma_driver);
 }
-module_exit(lpc313x_asoc_exit);
+module_exit(lpc31xx_asoc_exit);
 
 MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
-MODULE_DESCRIPTION("NXP LPC313X PCM module");
+MODULE_DESCRIPTION("NXP LPC31XX PCM module");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:lpc323x-audio");
diff --git a/sound/soc/lpc31xx/lpc31xx-pcm.h b/sound/soc/lpc31xx/lpc31xx-pcm.h
index 0591a30..ddd1462 100644
--- a/sound/soc/lpc31xx/lpc31xx-pcm.h
+++ b/sound/soc/lpc31xx/lpc31xx-pcm.h
@@ -1,5 +1,5 @@
 /*
- * sound/soc/lpc313x/lpc313x-pcm.h
+ * sound/soc/lpc31xx/lpc31xx-pcm.h
  *
  * Author: Kevin Wells <kevin.wells@nxp.com>
  *
@@ -20,10 +20,10 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifndef __SOUND_SOC_LPC313X_PCM_H
-#define __SOUND_SOC_LPC313X_PCM_H
+#ifndef __SOUND_SOC_LPC31XX_PCM_H
+#define __SOUND_SOC_LPC31XX_PCM_H
 
-extern struct snd_soc_platform_driver lpc313x_asoc_platform;
+extern struct snd_soc_platform_driver lpc31xx_asoc_platform;
 
 #endif
