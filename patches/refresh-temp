Bottom: 3877d0fb505bce9c681935666b5a4872dbe825dd
Top:    fca9a5c076d1173c46837b905e7974f113998e7c
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-04-23 07:30:41 -0400

Refresh of clean-val315x

---

diff --git a/arch/arm/mach-lpc31xx/Kconfig b/arch/arm/mach-lpc31xx/Kconfig
index 7b0478d..04fb90a 100644
--- a/arch/arm/mach-lpc31xx/Kconfig
+++ b/arch/arm/mach-lpc31xx/Kconfig
@@ -16,17 +16,6 @@ config MACH_EA3152
 	help
 	  Say Y here if you are using Embedded Artist's EA3152 board
 	  
-config MACH_VAL3153
-	bool "val3153 board"
-	help
-	  Say Y here if you are using the NXP val3153 board
-
-config MACH_VAL3154
-	bool "val3154 board"
-	select LPC3152_AD
-	help
-	  Say Y here if you are using the NXP val3154 board
-	  
 endchoice
 
 config LPC3152_AD
diff --git a/arch/arm/mach-lpc31xx/Makefile b/arch/arm/mach-lpc31xx/Makefile
index 12522c0..d307a1a 100644
--- a/arch/arm/mach-lpc31xx/Makefile
+++ b/arch/arm/mach-lpc31xx/Makefile
@@ -9,10 +9,8 @@ obj-$(CONFIG_OF) += dt.o
 
 
 # Specific board support
-obj-$(CONFIG_MACH_VAL3153) += board-val3153.o leds.o
 obj-$(CONFIG_MACH_EA313X) += board-ea313x.o
 obj-$(CONFIG_MACH_EA3152) += board-ea313x.o
-obj-$(CONFIG_MACH_VAL3154) += board-val3154.o leds.o
 obj-$(CONFIG_LPC3152_AD) += psu.o
 
 # Power Management
diff --git a/arch/arm/mach-lpc31xx/dma.c b/arch/arm/mach-lpc31xx/dma.c
index e4bdcc1..389418d 100644
--- a/arch/arm/mach-lpc31xx/dma.c
+++ b/arch/arm/mach-lpc31xx/dma.c
@@ -324,7 +324,7 @@ int dma_read_counter (unsigned int chn, unsigned int * pcnt)
 	return 0;
 }
 
-int dma_write_counter (unsigned int chn, u32 cnt)
+int dma_write_counter (unsigned int chn, uint32_t cnt)
 {
 	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
 		return -EINVAL;
@@ -458,9 +458,9 @@ int dma_request_specific_sg_channel (int chn, char *name, dma_cb_t cb,
 	return sg_higher_channel[chn];
 }
 
-int dma_prog_sg_channel(int chn, u32 dma_sg_list)
+int dma_prog_sg_channel(int chn, uint32_t dma_sg_list)
 {
-	u32 dma_config;
+	uint32_t dma_config;
 
 	if (chn >= DMA_MAX_CHANNELS)
 		return -EINVAL;
@@ -553,9 +553,9 @@ int dma_release_sg_channel (unsigned int chn){return 0;}
 int dma_prog_channel (unsigned int chn, dma_setup_t *dma_setup){return 0;}
 int dma_start_channel (unsigned int chn){return 0;}
 int dma_stop_channel (unsigned int chn){return 0;}
-int dma_prog_sg_channel(int chn, u32 dma_sg_list){return 0;}
+int dma_prog_sg_channel(int chn, uint32_t dma_sg_list){return 0;}
 int dma_set_irq_mask(unsigned int chn, int half_int, int fin_int){return 0;}
-int dma_write_counter (unsigned int chn, u32 cnt){return 0;}
+int dma_write_counter (unsigned int chn, uint32_t cnt){return 0;}
 int dma_stop_channel_sg (unsigned int chn){return 0;}
 int dma_channel_enabled(unsigned int chn){return 0;}
 int dma_current_state (unsigned int   chn, unsigned int * psrc, unsigned int * pdst, unsigned int * plen, unsigned int * pcfg, unsigned int * pena, unsigned int * pcnt){return 0;}
diff --git a/arch/arm/mach-lpc31xx/include/mach/registers.h b/arch/arm/mach-lpc31xx/include/mach/registers.h
index 4f4757e2..33b3f1d 100644
--- a/arch/arm/mach-lpc31xx/include/mach/registers.h
+++ b/arch/arm/mach-lpc31xx/include/mach/registers.h
@@ -69,95 +69,6 @@
 #define UART_ICR_REG      __REG (UART_PHYS + 0x24)
 #define UART_FDR_REG      __REG (UART_PHYS + 0x28)
 
-#if 0
-/***********************************************************************
- * SPI register definitions
- **********************************************************************/
-#define SPI_CONFIG_REG    __REG (SPI_PHYS + 0x00)
-#define SPI_SLV_ENAB_REG  __REG (SPI_PHYS + 0x04)
-#define SPI_TXF_FLUSH_REG __REG (SPI_PHYS + 0x08)
-#define SPI_FIFO_DATA_REG __REG (SPI_PHYS + 0x0C)
-#define SPI_NHP_POP_REG   __REG (SPI_PHYS + 0x10)
-#define SPI_NHP_MODE_REG  __REG (SPI_PHYS + 0x14)
-#define SPI_DMA_SET_REG   __REG (SPI_PHYS + 0x18)
-#define SPI_STS_REG       __REG (SPI_PHYS + 0x1C)
-#define SPI_HWINFO_REG    __REG (SPI_PHYS + 0x20)
-#define SPI_SLV_SET1_REG(slv) __REG (SPI_PHYS + 0x24 + (8 * slv))
-#define SPI_SLV_SET2_REG(slv) __REG (SPI_PHYS + 0x28 + (8 * slv))
-#define SPI_INT_TRSH_REG  __REG (SPI_PHYS + 0xFD4)
-#define SPI_INT_CLRE_REG  __REG (SPI_PHYS + 0xFD8)
-#define SPI_INT_SETE_REG  __REG (SPI_PHYS + 0xFDC)
-#define SPI_INT_STS_REG   __REG (SPI_PHYS + 0xFE0)
-#define SPI_INT_ENAB_REG  __REG (SPI_PHYS + 0xFE4)
-#define SPI_INT_CLRS_REG  __REG (SPI_PHYS + 0xFE8)
-#define SPI_INT_SETS_REG  __REG (SPI_PHYS + 0xFEC)
-#define SPI_MOD_ID_REG    __REG (SPI_PHYS + 0xFFC)
-
-/* SPI device contants */
-#define SPI_FIFO_DEPTH  64 /* 64 words (16bit) deep */
-#define SPI_NUM_SLAVES  3  /* number of slaves supported */
-#define SPI_MAX_DIV2    254
-#define SPI_MAX_DIVIDER 65024 /* = 254 * (255 + 1) */
-#define SPI_MIN_DIVIDER 2
-
-/* SPI Configuration register definitions (SPI_CONFIG_REG) */
-#define SPI_CFG_INTER_DLY(n)      _SBF(16, ((n) & 0xFFFF))
-#define SPI_CFG_INTER_DLY_GET(n)  (((n) >> 16) & 0xFFFF)
-#define SPI_CFG_UPDATE_EN         _BIT(7)
-#define SPI_CFG_SW_RESET          _BIT(6)
-#define SPI_CFG_SLAVE_DISABLE     _BIT(4)
-#define SPI_CFG_MULTI_SLAVE       _BIT(3)
-#define SPI_CFG_LOOPBACK          _BIT(2)
-#define SPI_CFG_SLAVE_MODE        _BIT(1)
-#define SPI_CFG_ENABLE            _BIT(0)
-
-/* SPI slave_enable register definitions (SPI_SLV_ENAB_REG) */
-#define SPI_SLV_EN(n)             _SBF(((n) << 1), 0x1)
-#define SPI_SLV_SUSPEND(n)        _SBF(((n) << 1), 0x3)
-
-/* SPI tx_fifo_flush register definitions (SPI_TXF_FLUSH_REG) */
-#define SPI_TXFF_FLUSH            _BIT(1)
-
-/* SPI dma_settings register definitions (SPI_DMA_SET_REG) */
-#define SPI_DMA_TX_EN             _BIT(1)
-#define SPI_DMA_RX_EN             _BIT(0)
-
-/* SPI status register definitions (SPI_STS_REG) */
-#define SPI_ST_SMS_BUSY           _BIT(5)
-#define SPI_ST_BUSY               _BIT(4)
-#define SPI_ST_RX_FF              _BIT(3)
-#define SPI_ST_RX_EMPTY           _BIT(2)
-#define SPI_ST_TX_FF              _BIT(1)
-#define SPI_ST_TX_EMPTY           _BIT(0)
-
-/* SPI slv_setting registers definitions (SPI_SLV_SET1_REG) */
-#define SPI_SLV1_INTER_TX_DLY(n)  _SBF(24, ((n) & 0xFF))
-#define SPI_SLV1_NUM_WORDS(n)     _SBF(16, ((n) & 0xFF))
-#define SPI_SLV1_CLK_PS(n)        _SBF(8, ((n) & 0xFF))
-#define SPI_SLV1_CLK_PS_GET(n)    (((n) >> 8) & 0xFF)
-#define SPI_SLV1_CLK_DIV1(n)      ((n) & 0xFF)
-#define SPI_SLV1_CLK_DIV1_GET(n)  ((n) & 0xFF)
-
-/* SPI slv_setting registers definitions (SPI_SLV_SET2_REG) */
-#define SPI_SLV2_PPCS_DLY(n)      _SBF(9, ((n) & 0xFF))
-#define SPI_SLV2_CS_HIGH          _BIT(8)
-#define SPI_SLV2_SSI_MODE         _BIT(7)
-#define SPI_SLV2_SPO              _BIT(6)
-#define SPI_SLV2_SPH              _BIT(5)
-#define SPI_SLV2_WD_SZ(n)         ((n) & 0x1F)
-
-/* SPI int_threshold registers definitions (SPI_INT_TRSH_REG) */
-#define SPI_INT_TSHLD_TX(n)       _SBF(8, ((n) & 0xFF))
-#define SPI_INT_TSHLD_RX(n)       ((n) & 0xFF)
-
-/* SPI intterrupt registers definitions ( SPI_INT_xxx) */
-#define SPI_SMS_INT               _BIT(4)
-#define SPI_TX_INT                _BIT(3)
-#define SPI_RX_INT                _BIT(2)
-#define SPI_TO_INT                _BIT(1)
-#define SPI_OVR_INT               _BIT(0)
-#define SPI_ALL_INTS              (SPI_SMS_INT | SPI_TX_INT | SPI_RX_INT | SPI_TO_INT | SPI_OVR_INT)
-#endif
 
 /***********************************************************************
  * ADC_REG register definitions
@@ -197,24 +108,6 @@
 #define SYS_MUX_GPIO_MCI    __REG (SYS_PHYS + 0x94)
 #define SYS_MUX_NAND_MCI    __REG (SYS_PHYS + 0x98)
 
-/***********************************************************************
- * GPIO register definitions
- **********************************************************************/
-#if 0
-#define GPIO_STATE(port)     __REG (GPIO_PHYS + (port) + 0x00)
-#define GPIO_STATE_M0(port)  __REG (GPIO_PHYS + (port) + 0x10)
-#define GPIO_M0_SET(port)    __REG (GPIO_PHYS + (port) + 0x14)
-#define GPIO_M0_RESET(port)  __REG (GPIO_PHYS + (port) + 0x18)
-#define GPIO_STATE_M1(port)  __REG (GPIO_PHYS + (port) + 0x20)
-#define GPIO_M1_SET(port)    __REG (GPIO_PHYS + (port) + 0x24)
-#define GPIO_M1_RESET(port)  __REG (GPIO_PHYS + (port) + 0x28)
-#endif
-
-#define GPIO_OUT_LOW(port, pin)  do { GPIO_M1_SET(port) = pin; GPIO_M0_RESET(port) = pin;} while(0)
-#define GPIO_OUT_HIGH(port, pin) do { GPIO_M1_SET(port) = pin; GPIO_M0_SET(port) = pin;} while(0)
-#define GPIO_IN(port, pin)       do { GPIO_M1_RESET(port) = pin; GPIO_M0_RESET(port) = pin;} while(0)
-#define GPIO_DRV_IP(port, pin)   do { GPIO_M1_RESET(port) = pin; GPIO_M0_SET(port) = pin;} while(0)
-
 #define IOCONF_EBI_MCI       (0x000)
 #define IOCONF_EBI_I2STX_0   (0x040)
 #define IOCONF_CGU           (0x080)
diff --git a/arch/arm/mach-lpc31xx/leds.c b/arch/arm/mach-lpc31xx/leds.c
deleted file mode 100644
index 26ab4ca..0000000
--- a/arch/arm/mach-lpc31xx/leds.c
+++ /dev/null
@@ -1,102 +0,0 @@
-/*  linux/arch/arm/mach-lpc31xx/leds.c
- *
- *  Author:	Durgesh Pattamatta
- *  Copyright (C) 2009 NXP semiconductors
- *
- * LED driver for val3153-based boards.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-
-#include <asm/leds.h>
-#include <mach/gpio.h>
-
-
-static inline void val3153_led_on(unsigned int led)
-{
-	gpio_set_value(led, 0);
-}
-
-static inline void val3153_led_off(unsigned int led)
-{
-	gpio_set_value(led, 1);
-}
-
-static inline void val3153_led_toggle(unsigned int led)
-{
-	unsigned long is_off = gpio_get_value(led);
-	if (is_off)
-		val3153_led_on(led);
-	else
-		val3153_led_off(led);
-}
-
-
-/*
- * Handle LED events.
- */
-static void val3153_leds_event(led_event_t evt)
-{
-	unsigned long flags;
-
-	local_irq_save(flags);
-
-	switch(evt) {
-	case led_start:		/* System startup */
-		val3153_led_on(GPIO_GPIO0);
-		break;
-
-	case led_stop:		/* System stop / suspend */
-		val3153_led_off(GPIO_GPIO0);
-		break;
-
-#ifdef CONFIG_LEDS_TIMER
-	case led_timer:		/* Every 50 timer ticks */
-		val3153_led_toggle(GPIO_GPIO2);
-		break;
-#endif
-
-#ifdef CONFIG_LEDS_CPU
-	case led_idle_start:	/* Entering idle state */
-		val3153_led_off(GPIO_GPIO0);
-		break;
-
-	case led_idle_end:	/* Exit idle state */
-		val3153_led_on(GPIO_GPIO0);
-		break;
-#endif
-
-	default:
-		break;
-	}
-
-	local_irq_restore(flags);
-}
-
-
-int __init leds_init(void)
-{
-	leds_event = val3153_leds_event;
-
-	leds_event(led_start);
-	return 0;
-}
-
-__initcall(leds_init);
diff --git a/arch/arm/mach-lpc31xx/psu.c b/arch/arm/mach-lpc31xx/psu.c
index 5385fea..b8a8bff 100644
--- a/arch/arm/mach-lpc31xx/psu.c
+++ b/arch/arm/mach-lpc31xx/psu.c
@@ -1,4 +1,4 @@
-/*  linux/arch/arm/mach-lpc31xx/leds.c
+/*  linux/arch/arm/mach-lpc31xx/psu.c
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
@@ -63,9 +63,9 @@ static struct psu_data g_pca_data;
  */
 struct i2c_client *lpc315x_ad_get_i2c_client_struct(void)
 {
-	/* Check if psu_data structure is initialised */
+	/* Check if psu_data structure is initialized */
 	if(!g_pca_data.client) {
-		printk(KERN_ERR "I2C not initialised \r\n");
+		printk(KERN_ERR "I2C not initialized \r\n");
 		return NULL;
 	}
 
@@ -80,7 +80,7 @@ static ssize_t psu_show(struct device *dev, struct device_attribute *attr,
 	struct sensor_device_attribute *psa = to_sensor_dev_attr(attr);
 	struct i2c_client *client = to_i2c_client(dev);
 	char reg_adr[2];
-	u32 reg_val = 0;
+	uint32_t reg_val = 0;
 
 	reg_adr[0] = (psa->index >> 8) & 0xFF;
 	reg_adr[1] = psa->index & 0xFF;
diff --git a/arch/arm/mach-lpc31xx/time.c b/arch/arm/mach-lpc31xx/time.c
index d17779d..b36894c 100644
--- a/arch/arm/mach-lpc31xx/time.c
+++ b/arch/arm/mach-lpc31xx/time.c
@@ -78,7 +78,7 @@ static struct irqaction lpc31xx_timer_irq = {
  */
 static unsigned long lpc31xx_gettimeoffset(void)
 {
-	u32 elapsed = LATCH - timer_read(TIMER_VALUE);
+	uint32_t elapsed = LATCH - timer_read(TIMER_VALUE);
 	return ((elapsed * 100) / (XTAL_CLOCK / 20000));
 }
 
diff --git a/arch/arm/mach-lpc31xx/usb.c b/arch/arm/mach-lpc31xx/usb.c
index 4596c65..45ad7e6 100644
--- a/arch/arm/mach-lpc31xx/usb.c
+++ b/arch/arm/mach-lpc31xx/usb.c
@@ -102,8 +102,8 @@
 #if defined(CONFIG_USB_GADGET_FSL_USB2) || defined(CONFIG_USB_OTG)
 static struct resource lpc31xx_usb_resource[] = {
 	[0] = {
-		.start = (u32) (USBOTG_PHYS),
-		.end   = (u32) (USBOTG_PHYS + SZ_4K),
+		.start = (uint32_t) (USBOTG_PHYS),
+		.end   = (uint32_t) (USBOTG_PHYS + SZ_4K),
 		.flags = IORESOURCE_MEM,
 	},
 	[1] = {
@@ -188,8 +188,8 @@ static void lpc31xx_vbusen_timer(unsigned long data)
 int __init usbotg_init(void)
 {
 	int over;
-	u32 bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
-	u32 bit_pos = EVT_usb_atx_pll_lock & 0x1F;
+	uint32_t bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
+	uint32_t bit_pos = EVT_usb_atx_pll_lock & 0x1F;
 	int retval = 0;
 
 	/* enable USB to AHB clock */
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 6e4e0a5..e60254e 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1206,8 +1206,6 @@ elite_ulk		MACH_ELITE_ULK		ELITE_ULK		3888
 pov2			MACH_POV2		POV2			3889
 ipod_touch_2g		MACH_IPOD_TOUCH_2G	IPOD_TOUCH_2G		3890
 da850_pqab		MACH_DA850_PQAB		DA850_PQAB		3891
-val3153			MACH_VAL3153		VAL3153			9999
-val3154			MACH_VAL3154		VAL3154			9997
 ea3152			MACH_EA3152		EA3152			9996
 
 
diff --git a/drivers/net/ethernet/cirrus/cs89x0.c b/drivers/net/ethernet/cirrus/cs89x0.c
index f7e0595..08ea950 100644
--- a/drivers/net/ethernet/cirrus/cs89x0.c
+++ b/drivers/net/ethernet/cirrus/cs89x0.c
@@ -321,12 +321,6 @@ struct net_device * __init cs89x0_probe(int unit)
 	if (net_debug)
 		printk("cs89x0:cs89x0_probe(0x%x)\n", io);
 
-#ifdef CONFIG_MACH_VAL3153
-	if(unit > 0) {
-		err = -ENODEV;
-		goto out;
-	}
-#endif
 	if (io > 0x1ff)	{	/* Check a single specified location. */
 		err = cs89x0_probe1(dev, io, 0);
 	} else if (io != 0) {	/* Don't probe at all. */
@@ -387,25 +381,6 @@ writeword(unsigned long base_addr, int portno, u16 value)
 {
 	outw(value, base_addr + (portno << 1));
 }
-#elif defined(CONFIG_MACH_VAL3153)
-static u16
-readword(unsigned long base_addr, int portno)
-{
-	u16 v;
-	CS8900_IOBARRIER;
-	v = inw(base_addr + portno);
-	CS8900_IOBARRIER;
-	return v;
-}
-
-static void
-writeword(unsigned long base_addr, int portno, u16 value)
-{
-	CS8900_IOBARRIER;
-	outw(value, base_addr + portno);
-	CS8900_IOBARRIER;
-}
-
 #else
 static u16
 readword(unsigned long base_addr, int portno)
@@ -578,12 +553,6 @@ cs89x0_probe1(struct net_device *dev, unsigned long ioaddr, int modular)
 		goto out1;
 	}
 
-#if defined(CONFIG_MACH_VAL3153)
-	/* truely reset the chip */
-	writeword(ioaddr, ADD_PORT, 0x0114);
-	writeword(ioaddr, DATA_PORT, 0x0040);
-#endif
-
 	/* if they give us an odd I/O address, then do ONE write to
            the address port, to get it back to address zero, where we
            expect to find the EISA signature word. An IO with a base of 0x3
@@ -649,11 +618,6 @@ cs89x0_probe1(struct net_device *dev, unsigned long ioaddr, int modular)
 	   the driver will always do *something* instead of complain that
 	   adapter_cnf is 0. */
 
-/* quick hack for VAL3153 boards to reuse the mac address set by boot loader */
-#if !defined(CONFIG_MACH_VAL3153)
-        if ((readreg(dev, PP_SelfST) & (EEPROM_OK | EEPROM_PRESENT)) ==
-	      (EEPROM_OK|EEPROM_PRESENT)) 
-#endif
 	{
 	        /* Load the MAC. */
 		for (i=0; i < ETH_ALEN/2; i++) {
