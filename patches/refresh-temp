Bottom: c0fd7a79b4f7ab41a7e949ccf0441a3667cd6ec2
Top:    99fad5003a0b4a0b86d8a49261e78e73711468dc
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-07-02 13:03:29 -0400

Refresh of initial-sound-driver-port

---

diff --git a/sound/soc/sunxi/codec_new.c b/sound/soc/sunxi/codec_new.c
deleted file mode 100644
index 4070bfe..0000000
--- a/sound/soc/sunxi/codec_new.c
+++ /dev/null
@@ -1,687 +0,0 @@
-/*
- *
- * Licensed under the GPL-2.
- */
-
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/of.h>
-#include <linux/of_irq.h>
-#include <linux/of_platform.h>
-#include <linux/of_address.h>
-#include <linux/clk.h>
-#include <linux/regmap.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/initval.h>
-#include <sound/dmaengine_pcm.h>
-
-//Codec Register
-#define SUNXI_DAC_DPC                (0x00)
-#define SUNXI_DAC_FIFOC              (0x04)
-#define SUNXI_DAC_FIFOS              (0x08)
-#define SUNXI_DAC_TXDATA             (0x0c)
-#define SUNXI_DAC_ACTL               (0x10)
-#define SUNXI_DAC_TUNE               (0x14)
-#define SUNXI_DAC_DEBUG              (0x18)
-#define SUNXI_ADC_FIFOC              (0x1c)
-#define SUNXI_ADC_FIFOS              (0x20)
-#define SUNXI_ADC_RXDATA             (0x24)
-#define SUNXI_ADC_ACTL               (0x28)
-#define SUNXI_ADC_DEBUG              (0x2c)
-#define SUNXI_DAC_TXCNT              (0x30)
-#define SUNXI_ADC_RXCNT              (0x34)
-#define SUNXI_BIAS_CRT               (0x38)
-#define SUNXI_MIC_CRT                (0x3c)
-#define SUNXI_CODEC_REGS_NUM         (13)
-
-#define DAIFMT_16BITS             (16)
-#define DAIFMT_20BITS             (20)
-
-#define DAIFMT_BS_MASK            (~(1<<16))  	//FIFO big small mode mask
-#define DAIFMT_BITS_MASK          (~(1<<5))		//FIFO Bits select mask,not used yet.
-#define SAMPLE_RATE_MASK          (~(7<<29))  	//Sample Rate slect mask
-
-#define DAC_EN                    (31)
-#define DIGITAL_VOL               (12)
-//For CODEC OLD VERSION
-#define DAC_VERSION               (23)
-
-#define DAC_CHANNEL		  (6)
-#define LAST_SE                   (26)
-#define TX_FIFO_MODE              (24)
-#define DRA_LEVEL                 (21)
-#define TX_TRI_LEVEL              (8)
-#define DAC_MODE                  (6)			//not used yet
-#define TASR                      (5)			//not used yet
-#define DAC_DRQ                   (4)
-#define DAC_FIFO_FLUSH            (0)
-
-#define VOLUME                    (0)
-#define PA_MUTE                   (6)
-#define MIXPAS                    (7)
-#define DACPAS                    (8)
-#define MIXEN                     (29)
-#define DACAEN_L                  (30)
-#define DACAEN_R                  (31)
-
-#define ADC_DIG_EN                (28)
-#define RX_FIFO_MODE              (24)
-#define RX_TRI_LEVEL              (8)
-#define ADC_MODE                  (7)
-#define RASR                      (6)
-#define ADC_DRQ                   (4)
-#define ADC_FIFO_FLUSH            (0)
-
-#define  ADC_LF_EN                (31)
-#define  ADC_RI_EN                (30)
-#define  ADC_EN                   (30)
-#define  MIC1_EN                  (29)
-#define  MIC2_EN                  (28)
-#define  VMIC_EN                  (27)
-#define  MIC_GAIN                 (25)
-#define  ADC_SELECT               (17)
-#define  PA_ENABLE                (4)
-#define  HP_DIRECT                (3)
-
-
-enum sunxi_device_id {SUN4A, SUN4I, SUN5I, SUN7I}; 
-
-struct sunxi_priv {
-	struct regmap *regmap;
-	int irq;
-	struct clk *clk_apb, *clk_pll2, *clk_module;
-
-	enum sunxi_device_id id;
-
-	struct snd_dmaengine_dai_dma_data playback_dma_data;
-	struct snd_dmaengine_dai_dma_data capture_dma_data;
-};
-
-static int codec_play_start(struct sunxi_priv *priv)
-{
-#ifdef JDS
-	if (gpio_pa_shutdown)
-		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
-#endif
-	//flush TX FIFO
-	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_FIFO_FLUSH, 0x1 << DAC_FIFO_FLUSH);
-	//enable dac drq
-	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_DRQ, 0x1 << DAC_DRQ);
-	return 0;
-}
-
-static int codec_play_stop(struct sunxi_priv *priv)
-{
-	//pa mute
-#ifdef JDS
-	if (gpio_pa_shutdown)
-		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
-#endif
-	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
-	mdelay(5);
-	//disable dac drq
-	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_DRQ, 0x0 << DAC_DRQ);
-	//pa mute
-	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
-	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_L, 0x0 << DACAEN_L);
-	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_R, 0x0 << DACAEN_R);
-	return 0;
-}
-
-static int codec_capture_start(struct sunxi_priv *priv)
-{
-	//enable adc drq
-#ifdef JDS
-	if (gpio_pa_shutdown)
-		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
-#endif
-	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DRQ, 0x1 << ADC_DRQ);
-	return 0;
-}
-
-static int codec_capture_stop(struct sunxi_priv *priv)
-{
-	//disable adc drq
-	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DRQ, 0x0 << ADC_DRQ);
-	//enable mic1 pa
-	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << MIC1_EN, 0x0 << MIC1_EN);
-	//enable VMIC
-	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << VMIC_EN, 0x0 << VMIC_EN);
-	if (priv->id == SUN7I) {
-		regmap_update_bits(priv->regmap, SUNXI_DAC_TUNE, 0x3 << 8, 0x0 << 8);
-	}
-	//enable adc digital
-	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DIG_EN, 0x0 << ADC_DIG_EN);
-	//set RX FIFO mode
-	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << RX_FIFO_MODE, 0x0 << RX_FIFO_MODE);
-	//flush RX FIFO
-	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_FIFO_FLUSH, 0x0 << ADC_FIFO_FLUSH);
-	//enable adc1 analog
-	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << ADC_EN, 0x0 << ADC_EN);
-	return 0;
-}
-
-static int sunxi_codec_trigger(struct snd_pcm_substream *substream, int cmd,
-	struct snd_soc_dai *dai)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct snd_soc_card *card = codec->card;
-	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
-
-	printk("JDS - sunxi_codec_trigger cmd %d\n", cmd);
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-			codec_capture_start(priv);
-		else
-			codec_play_start(priv);
-		break;		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-			codec_capture_stop(priv);
-		else
-			codec_play_stop(priv);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int sunxi_codec_prepare(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct snd_soc_card *card = codec->card;
-	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
-
-	printk("JDS - sunxi_codec_prepare\n");
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1 << DAC_EN, 0x1 << DAC_EN);
-		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_FIFO_FLUSH, 0x1 << DAC_FIFO_FLUSH);
-		//set TX FIFO send drq level
-		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0xf << TX_TRI_LEVEL, 0xf << TX_TRI_LEVEL);
-		if (substream->runtime->rate > 32000) {
-			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << 28, 0x0 << 28);
-		} else {
-			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << 28, 0x1 << 28);
-		}
-		//set TX FIFO MODE
-		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << TX_FIFO_MODE, 0x1 << TX_FIFO_MODE);
-		//send last sample when dac fifo under run
-		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << LAST_SE, 0x0 << LAST_SE);
-		//enable dac analog
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_L, 0x1 << DACAEN_L);
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_R, 0x1 << DACAEN_R);
-		//enable dac to pa
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACPAS, 0x1 << DACPAS);
-	} else {
-		//enable mic1 pa
-		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << MIC1_EN, 0x1 << MIC1_EN);
-		//mic1 gain 32dB
-		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << 25, 0x1 << 25);
-		//enable VMIC
-		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << VMIC_EN, 0x1 << VMIC_EN);
-
-		if (priv->id == SUN7I) {
-			/* boost up record effect */
-			regmap_update_bits(priv->regmap, SUNXI_DAC_TUNE, 0x3 << 8, 0x1 << 8);
-		}
-
-		//enable adc digital
-		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DIG_EN, 0x1 << ADC_DIG_EN);
-		//set RX FIFO mode
-		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << RX_FIFO_MODE, 0x1 << RX_FIFO_MODE);
-		//flush RX FIFO
-		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_FIFO_FLUSH, 0x1 << ADC_FIFO_FLUSH);
-		//set RX FIFO rec drq level
-		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0xf << RX_TRI_LEVEL, 0x7 << RX_TRI_LEVEL);
-		//enable adc1 analog
-		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << ADC_EN, 0x3 << ADC_EN);
-	}
-	return 0;
-}
-
-static int sunxi_codec_hw_params(struct snd_pcm_substream *substream,
-	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct snd_soc_card *card = codec->card;
-	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
-	unsigned int rate = params_rate(params);
-
-	printk("CLK - sunxi_codec_hw_params substream %p runtime %p\n", substream, rtd);
-	switch (params_rate(params)) {
-	case 44100:
-	case 22050:
-	case 11025:
-	default:
-		clk_set_rate(priv->clk_pll2, 22579200);
-		clk_set_rate(priv->clk_module, 22579200);
-		break;
-	case 192000:
-	case 96000:
-	case 48000:
-	case 32000:
-	case 24000:
-	case 16000:
-	case 12000:
-	case 8000:
-		clk_set_rate(priv->clk_pll2, 24576000);
-		clk_set_rate(priv->clk_module, 24576000);
-		break;
-	}
-
-	switch (params_rate(params)) {
-	default:
-	case 44100:
-		rate = 0;
-		break;
-	case 22050:
-		rate = 2;
-		break;
-	case 11025:
-		rate = 4;
-		break;
-	case 192000:
-		rate = 6;
-		break;
-	case 96000:
-		rate = 7;
-		break;
-	case 48000:
-		rate = 0;
-		break;
-	case 32000:
-		rate = 1;
-		break;
-	case 24000:
-		rate = 2;
-		break;
-	case 16000:
-		rate = 3;
-		break;
-	case 12000:
-		rate = 4;
-		break;
-	case 8000:
-		rate = 5;
-		break;
-	}
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 7 << 29, rate << 29);
-		if (substream->runtime->channels == 1)
-			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << 6, 1 << 6);
-		else
-			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << 6, 0 << 6);
-	} else  {
-		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 7 << 29, rate << 29);
-		if (substream->runtime->channels == 1)
-			regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 1 << 7, 1 << 7);
-		else
-			regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 1 << 7, 0 << 7);
-	}
-	return 0;
-}
-
-static const struct snd_kcontrol_new sun7i_dac_ctls[] = {
-	/*SUNXI_DAC_ACTL = 0x10,PAVOL*/
-	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
-	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
-	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
-	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
-	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
-	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
-	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
-	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
-	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0), 
-	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
-	SOC_SINGLE("MIC output volume", SUNXI_DAC_ACTL, 20, 7, 0),
-	/*	FM Input to output mixer Gain Control
-	* 	From -4.5db to 6db,1.5db/step,default is 0db
-	*	-4.5db:0x0,-3.0db:0x1,-1.5db:0x2,0db:0x3
-	*	1.5db:0x4,3.0db:0x5,4.5db:0x6,6db:0x7
-	*/
-	SOC_SINGLE("Fm output Volume", SUNXI_DAC_ACTL, 23, 7, 0),
-	/*	Line-in gain stage to output mixer Gain Control
-	*	0:-1.5db,1:0db
-	*/
-	SOC_SINGLE("Line output Volume", SUNXI_DAC_ACTL, 26, 1, 0),
-
-	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
-	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
-	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0), 
-	SOC_SINGLE("Linein Pre-AMP", SUNXI_ADC_ACTL, 13, 7, 0), 
-	SOC_SINGLE("LINEIN APM Volume", SUNXI_MIC_CRT, 13, 0x7, 0),
-	/* ADC Input Gain Control, capture volume
-	* 000:-4.5db,001:-3db,010:-1.5db,011:0db,100:1.5db,101:3db,110:4.5db,111:6db
-	*/
-	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0),
-	/*
-	*	MIC2 pre-amplifier Gain Control
-	*	00:0db,01:35db,10:38db,11:41db
-	*/
-	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
-	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
-	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
-	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
-	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
-	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
-	SOC_SINGLE("Mic2 gain Volume", SUNXI_MIC_CRT, 26, 7, 0),
-	/*
-	*	MIC1 pre-amplifier Gain Control
-	*	00:0db,01:35db,10:38db,11:41db
-	*/
-	SOC_SINGLE("Mic1 gain Volume", SUNXI_MIC_CRT, 29, 3, 0), 
-};
-
-
-static int sunxi_codec_dai_probe(struct snd_soc_dai *dai)
-{
-	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
-	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
-
-	printk("CLK - sunxi_codec_dai_probe %p\n", priv);
-	snd_soc_dai_init_dma_data(dai, &priv->playback_dma_data, &priv->capture_dma_data);
-
-	return 0;
-}
-
-static int sunxi_codec_startup(struct snd_pcm_substream *substream,
-	struct snd_soc_dai *dai)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct snd_soc_card *card = codec->card;
-	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
-
-	int ret;
-	printk("JDS - CLK sunxi_codec_startup %p %p\n", codec, priv->clk_module);
-	ret = clk_prepare_enable(priv->clk_module);
-	if (ret)
-		return ret;
-
-	printk("JDS - sunxi_codec_startup - ok\n");
-	return 0;
-}
-
-static void sunxi_codec_shutdown(struct snd_pcm_substream *substream,
-	struct snd_soc_dai *dai)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct snd_soc_card *card = codec->card;
-	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
-
-	printk("JDS - sunxi_codec_shutdown\n");
-	clk_disable_unprepare(priv->clk_module);
-}
-
-static const struct snd_soc_dai_ops sunxi_codec_dai_ops = {
-	.startup = sunxi_codec_startup,
-	.shutdown = sunxi_codec_shutdown,
-	.trigger = sunxi_codec_trigger,
-	.hw_params = sunxi_codec_hw_params,
-	.prepare = sunxi_codec_prepare,
-};
-
-static struct snd_soc_dai_driver sunxi_codec_dai = {
-	.probe = sunxi_codec_dai_probe,
-	.playback = {
-		.channels_min = 1,
-		.channels_max = 2,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
-
-		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_11025 |\
-			 SNDRV_PCM_RATE_22050| SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\
-			 SNDRV_PCM_RATE_48000 |SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000 |\
-			 SNDRV_PCM_RATE_KNOT),
-		.rate_min = 8000,
-		.rate_max = 192000,
-	},
-	.ops = &sunxi_codec_dai_ops,
-};
-
-static const struct snd_soc_component_driver sunxi_codec_component = {
-	.name = "sunxi-codec",
-};
-
-static const struct regmap_config sunxi_codec_regmap_config = {
-	.reg_bits = 32,
-	.reg_stride = 4,
-	.val_bits = 32,
-	.max_register = SUNXI_MIC_CRT,
-};
-
-static const struct snd_soc_dapm_widget codec_dapm_widgets[] = {
-	SND_SOC_DAPM_OUTPUT("Mic Bias"),
-	SND_SOC_DAPM_OUTPUT("HP_OUT"),
-	SND_SOC_DAPM_INPUT("MIC_IN"),
-	SND_SOC_DAPM_INPUT("LINE_IN"),
-};
-
-static struct snd_soc_dai_link cdc_dai = {
-	.name = "cdc",
-	.stream_name = "CDC PCM",
-	.codec_dai_name = "sunxi-codec-dai",
-	.cpu_dai_name = "1c22c00.codec",
-	.codec_name = "1c22c00.codec",
-	//.init = tegra_wm8903_init,
-	//.ops = &tegra_wm8903_ops,
-	.dai_fmt = SND_SOC_DAIFMT_I2S,
-};
-
-static struct snd_soc_card snd_soc_sunxi_codec = {
-	.name = "sunxi-codec",
-	.owner = THIS_MODULE,
-	.dai_link = &cdc_dai,
-	.num_links = 1,
-
-	.fully_routed = true,
-};
-
-static struct snd_soc_codec_driver dummy_codec = {
-	.controls = sun7i_dac_ctls,
-	.num_controls = ARRAY_SIZE(sun7i_dac_ctls),
-	.dapm_widgets = codec_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(codec_dapm_widgets),
-};
-
-#define STUB_RATES	SNDRV_PCM_RATE_8000_192000
-#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S8 | \
-			SNDRV_PCM_FMTBIT_U8 | \
-			SNDRV_PCM_FMTBIT_S16_LE | \
-			SNDRV_PCM_FMTBIT_U16_LE | \
-			SNDRV_PCM_FMTBIT_S24_LE | \
-			SNDRV_PCM_FMTBIT_U24_LE | \
-			SNDRV_PCM_FMTBIT_S32_LE | \
-			SNDRV_PCM_FMTBIT_U32_LE | \
-			SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE)
-static struct snd_soc_dai_driver dummy_dai = {
-	.name = "sunxi-codec-dai",
-	.playback = {
-		.stream_name	= "Playback",
-		.channels_min	= 1,
-		.channels_max	= 2,
-		.rates		= STUB_RATES,
-		.formats	= STUB_FORMATS,
-	},
-	.capture = {
-		.stream_name	= "Capture",
-		.channels_min	= 1,
-		.channels_max	= 2,
-		.rates = STUB_RATES,
-		.formats = STUB_FORMATS,
-	 },
-};
-
-static const struct of_device_id sunxi_codec_of_match[] = {
-	{ .compatible = "allwinner,sun4i-a10a-codec", .data = (void *)SUN4A},
-	{ .compatible = "allwinner,sun4i-a10-codec", .data = (void *)SUN4I},
-	{ .compatible = "allwinner,sun5i-a13-codec", .data = (void *)SUN5I},
-	{ .compatible = "allwinner,sun7i-a20-codec", .data = (void *)SUN7I},
-	{}
-};
-MODULE_DEVICE_TABLE(of, sunxi_codec_of_match);
-
-static int sunxi_codec_probe(struct platform_device *pdev)
-{
-	struct device_node *np = pdev->dev.of_node;
-	struct snd_soc_card *card = &snd_soc_sunxi_codec;
-	const struct of_device_id *of_id;
-	struct device *dev = &pdev->dev;
-	struct sunxi_priv *priv;
-	struct resource *res;
-	void __iomem *base;
-	int ret;
-
-	if (!of_device_is_available(np))
-		return -ENODEV;
-
-	of_id = of_match_device(sunxi_codec_of_match, dev);
-	if (!of_id)
-		return -EINVAL;
-
-	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	card->dev = &pdev->dev;
-	platform_set_drvdata(pdev, card);
-	snd_soc_card_set_drvdata(card, priv);
-
-	priv->id = (int)of_id->data;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(base))
-		return PTR_ERR(base);
-
-	priv->regmap = devm_regmap_init_mmio(&pdev->dev, base,
-					    &sunxi_codec_regmap_config);
-	if (IS_ERR(priv->regmap))
-		return PTR_ERR(priv->regmap);
-
-	priv->irq = irq_of_parse_and_map(np, 0);
-	if (!priv->irq) {
-		dev_err(dev, "no irq for node %s\n", np->full_name);
-		return -ENXIO;
-	}
-
-	/* Clock */
-	priv->clk_apb = devm_clk_get(dev, "apb");
-	if (IS_ERR(priv->clk_apb)) {
-		dev_err(dev, "failed to get apb clock.\n");
-		return PTR_ERR(priv->clk_apb);
-	}
-	priv->clk_pll2 = devm_clk_get(dev, "pll2");
-	if (IS_ERR(priv->clk_pll2)) {
-		dev_err(dev, "failed to get pll2 clock.\n");
-		return PTR_ERR(priv->clk_pll2);
-	}
-	priv->clk_module = devm_clk_get(dev, "codec");
-	if (IS_ERR(priv->clk_module)) {
-		dev_err(dev, "failed to get codec clock.\n");
-		return PTR_ERR(priv->clk_module);
-	}
-	printk("CLK = card %p priv %p priv->clk_module %p\n", card, priv, priv->clk_module);
-
-	ret = clk_set_rate(priv->clk_pll2, 24576000);
-	if (ret) {
-		dev_err(dev, "set codec base clock rate failed!\n");
-		return ret;
-	}
-	if (clk_prepare_enable(priv->clk_pll2)) {
-		dev_err(dev, "try to enable clk_pll2 failed\n");
-		return -EINVAL;
-	}
-	if (clk_prepare_enable(priv->clk_apb)) {
-		dev_err(dev, "try to enable clk_apb failed\n");
-		return -EINVAL;
-	}
-
-	priv->playback_dma_data.addr = res->start + SUNXI_DAC_TXDATA;
-	priv->playback_dma_data.maxburst = 4;
-	priv->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-
-	priv->capture_dma_data.addr = res->start + SUNXI_ADC_RXDATA;
-	priv->capture_dma_data.maxburst = 4;
-	priv->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-
-	ret = snd_soc_register_codec(&pdev->dev, &dummy_codec, &dummy_dai, 1);
-
-	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_codec_component, &sunxi_codec_dai, 1);
-	if (ret)
-		goto err_clk_disable;
-
-	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
-	if (ret)
-		goto err_clk_disable;
-
-	ret = snd_soc_of_parse_audio_routing(card, "routing");
-	if (ret)
-		goto err;
-
-	ret = snd_soc_register_card(card);
-	if (ret) {
-		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
-		goto err_fini_utils;
-	}
-
-	return 0;
-
-err_fini_utils:
-err:
-err_clk_disable:
-	clk_disable_unprepare(priv->clk_module);
-	clk_disable_unprepare(priv->clk_apb);
-	clk_disable_unprepare(priv->clk_pll2);
-	return ret;
-}
-
-static int sunxi_codec_dev_remove(struct platform_device *pdev)
-{
-	struct sunxi_priv *priv = platform_get_drvdata(pdev);
-
-	clk_disable_unprepare(priv->clk_module);
-	clk_disable_unprepare(priv->clk_apb);
-	clk_disable_unprepare(priv->clk_pll2);
-
-	return 0;
-}
-
-static struct platform_driver sunxi_codec_driver = {
-	.driver = {
-		.name = "sunxi-codec",
-		.owner = THIS_MODULE,
-		.of_match_table = sunxi_codec_of_match,
-	},
-	.probe = sunxi_codec_probe,
-	.remove = sunxi_codec_dev_remove,
-};
-module_platform_driver(sunxi_codec_driver);
-
-MODULE_ALIAS("platform:sunxi-codec");
-MODULE_DESCRIPTION("sunxi CODEC ALSA codec driver");
-MODULE_AUTHOR("software");
-MODULE_LICENSE("GPL v2");
-
diff --git a/sound/soc/sunxi/codec_old.c b/sound/soc/sunxi/codec_old.c
deleted file mode 100644
index 5143b42..0000000
--- a/sound/soc/sunxi/codec_old.c
+++ /dev/null
@@ -1,752 +0,0 @@
-/*
- * ALSA SoC codec Out Audio Layer for spear processors
- *
- * Copyright (C) 2012 ST Microelectronics
- * Vipin Kumar <vipin.kumar@st.com>
- *
- * This file is licensed under the terms of the GNU General Public
- * License version 2. This program is licensed "as is" without any
- * warranty of any kind, whether express or implied.
- */
-
-#include <linux/clk.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/of_irq.h>
-#include <linux/of_platform.h>
-#include <linux/of_address.h>
-#include <linux/regmap.h>
-#include <sound/dmaengine_pcm.h>
-#include <sound/core.h>
-#include <sound/soc.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/control.h>
-#include <sound/initval.h>
-#include "sunxi-codec.h"
-
-static void codec_resume_events(struct work_struct *work);
-struct workqueue_struct *resume_work_queue;
-static DECLARE_WORK(codec_resume_work, codec_resume_events);
-
-static void sunxi_configure(struct card_data *priv)
-{
-#ifdef JDS
-	writel(sunxi_RESET, priv->io_base + sunxi_SOFT_RST);
-	mdelay(1);
-	writel(readl(priv->io_base + sunxi_SOFT_RST) & ~sunxi_RESET,
-			priv->io_base + sunxi_SOFT_RST);
-
-	writel(sunxi_FDMA_TRIG_16 | sunxi_MEMFMT_16_16 |
-			sunxi_VALID_HW | sunxi_USER_HW |
-			sunxi_CHNLSTA_HW | sunxi_PARITY_HW,
-			priv->io_base + sunxi_CFG);
-
-	writel(0x7F, priv->io_base + sunxi_INT_STA_CLR);
-	writel(0x7F, priv->io_base + sunxi_INT_EN_CLR);
-#endif 
-}
-
-static int sunxi_startup(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *cpu_dai)
-{
-	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
-	int ret;
-
-	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
-		return -EINVAL;
-
-	ret = clk_enable(priv->codec_moduleclk);
-	if (ret)
-		return ret;
-
-	priv->running = true;
-	sunxi_configure(priv);
-
-	return 0;
-}
-
-static void sunxi_shutdown(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
-{
-	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
-
-	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
-		return;
-
-	clk_disable(priv->codec_moduleclk);
-	priv->running = false;
-}
-
-static void sunxi_clock(struct card_data *priv, u32 core_freq,
-		u32 rate)
-{
-#ifdef JDS
-	u32 divider, ctrl;
-	clk_set_rate(priv->clk, core_freq);
-	divider = DIV_ROUND_CLOSEST(clk_get_rate(priv->clk), (rate * 128));
-
-	ctrl = readl(priv->io_base + sunxi_CTRL);
-	ctrl &= ~codec_DIVIDER_MASK;
-	ctrl |= (divider << codec_DIVIDER_SHIFT) & codec_DIVIDER_MASK;
-	writel(ctrl, priv->io_base + sunxi_CTRL);
-#endif
-}
-
-static int sunxi_hw_params(struct snd_pcm_substream *substream,
-		struct snd_pcm_hw_params *params,
-		struct snd_soc_dai *dai)
-{
-	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
-	u32 rate, core_freq;
-
-	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
-		return -EINVAL;
-
-	rate = params_rate(params);
-
-	switch (rate) {
-	case 8000:
-	case 16000:
-	case 32000:
-	case 64000:
-		/*
-		 * The clock is multiplied by 10 to bring it to feasible range
-		 * of frequencies for sscg
-		 */
-		core_freq = 64000 * 128 * 10;	/* 81.92 MHz */
-		break;
-	case 5512:
-	case 11025:
-	case 22050:
-	case 44100:
-	case 88200:
-	case 176400:
-		core_freq = 176400 * 128;	/* 22.5792 MHz */
-		break;
-	case 48000:
-	case 96000:
-	case 192000:
-	default:
-		core_freq = 192000 * 128;	/* 24.576 MHz */
-		break;
-	}
-
-	sunxi_clock(priv, core_freq, rate);
-	priv->saved_params.core_freq = core_freq;
-	priv->saved_params.rate = rate;
-
-	return 0;
-}
-
-static int sunxi_trigger(struct snd_pcm_substream *substream, int cmd,
-		struct snd_soc_dai *dai)
-{
-#ifdef JDS
-	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
-	u32 ctrl;
-#endif
-	int ret = 0;
-
-	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
-		return -EINVAL;
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-#ifdef JDS		
-			ctrl = readl(priv->io_base + sunxi_CTRL);
-			ctrl &= ~codec_OPMODE_MASK;
-			if (!priv->saved_params.mute)
-				ctrl |= codec_OPMODE_AUD_DATA |
-					codec_STATE_NORMAL;
-			else
-				ctrl |= codec_OPMODE_MUTE_PCM;
-			writel(ctrl, priv->io_base + sunxi_CTRL);
-#endif
-		break;
-
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-#ifdef JDS		
-		ctrl = readl(priv->io_base + sunxi_CTRL);
-		ctrl &= ~codec_OPMODE_MASK;
-		ctrl |= codec_OPMODE_OFF;
-		writel(ctrl, priv->io_base + sunxi_CTRL);
-#endif
-		break;
-
-	default:
-		ret = -EINVAL;
-		break;
-	}
-	return ret;
-}
-
-static int sunxi_digital_mute(struct snd_soc_dai *dai, int mute)
-{
-#ifdef JDS
-	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
-	u32 val;
-
-	priv->saved_params.mute = mute;
-	val = readl(priv->io_base + sunxi_CTRL);
-	val &= ~codec_OPMODE_MASK;
-
-	if (mute)
-		val |= codec_OPMODE_MUTE_PCM;
-	else {
-		if (priv->running)
-			val |= codec_OPMODE_AUD_DATA | codec_STATE_NORMAL;
-		else
-			val |= codec_OPMODE_OFF;
-	}
-
-	writel(val, priv->io_base + sunxi_CTRL);
-#endif
-	return 0;
-}
-
-static int codec_mute_get(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
-	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
-
-	ucontrol->value.integer.value[0] = priv->saved_params.mute;
-	return 0;
-}
-
-static int codec_mute_put(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
-	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
-
-	if (priv->saved_params.mute == ucontrol->value.integer.value[0])
-		return 0;
-
-	sunxi_digital_mute(cpu_dai, ucontrol->value.integer.value[0]);
-
-	return 1;
-}
-
-#ifdef JDS
-static void codec_resume_events(struct work_struct *work)
-{
-	printk("%s,%d\n", __func__, __LINE__);
-
-	if (priv->id == SUN7I) {
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
-	else
-		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1, DAC_EN, 0x1);
-
-	msleep(20);
-	//enable PA
-	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x1);
-	msleep(550);
-	//enable dac analog
-
-	if (priv->id == SUN7I) {
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x1);
-		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1, 8, 0x0);
-	} else {
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x1);
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x1);
-
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACPAS, 0x1);
-	}
-	if (gpio_pa_shutdown) {
-		msleep(50);
-		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
-	}
-}
-#endif
-
-
-
-/**
- *	codec_reset - reset the codec
- * @codec	SoC Audio Codec
- * Reset the codec, set the register of codec default value
- * Return 0 for success
- */
-static int codec_init(struct card_data *priv)
-{
-	//enable dac digital
-	regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1 << DAC_EN, 0x1 << DAC_EN);
-
-	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << 28, 0x1 << 28);
-	//set digital volume to maximum
-	if (priv->id == SUN4A)
-		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x6 << DIGITAL_VOL, 0x0 << DIGITAL_VOL);
-
-	//pa mute
-	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
-	//enable PA
-	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << PA_ENABLE, 0x1 << PA_ENABLE);
-	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x3 << DRA_LEVEL, 0x3 << DRA_LEVEL);
-	//set volume
-	if ((priv->id == SUN4A) || (priv->id == SUN4I)) {
-		int device_lr_change = 0;
-		if (priv->id == SUN4A)
-			regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x01 << VOLUME);
-		else 
-			regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x3b << VOLUME);
-#ifdef JDS
-		rc = script_parser_fetch("audio_para", "audio_lr_change", &device_lr_change, 1);
-		if (rc != SCRIPT_AUDIO_OK) {
-			pr_err("No audio_lr_change in fex audio_para\n");
-			return -1;
-		}
-#endif
-		if (device_lr_change)
-			regmap_update_bits(priv->regmap, SUNXI_DAC_DEBUG, 0x1 << DAC_CHANNEL, 0x1 << DAC_CHANNEL);
-	} else {
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x3b << VOLUME);
-	}
-	return 0;
-}
-
-
-/*	对sunxi-codec.c各寄存器的各种设定，或读取。主要实现函数有三个.
- * 	.info = snd_codec_info_volsw, .get = snd_codec_get_volsw,\.put = snd_codec_put_volsw,
- * It should be noted that the only difference between sunxi and sun5i is the Master Playback Volume
- */
-static const struct snd_kcontrol_new sun4i_dac[] = {
-	//FOR B C VERSION
-	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
-	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
-	SOC_SINGLE("Fm Volume", SUNXI_DAC_ACTL, 23, 7, 0), //Fm 音量
-	SOC_SINGLE("Line Volume", SUNXI_DAC_ACTL, 26, 1, 0), //Line音量
-	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
-	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
-	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
-	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
-	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
-	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
-	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
-	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
-};
-
-static const struct snd_kcontrol_new sun4a_dac[] = {
-	//For A VERSION
-	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_DPC, 12, 0x3f, 0), //62 steps, 3e + 1 = 3f 主音量控制
-	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
-	SOC_SINGLE("Fm Volume", SUNXI_DAC_ACTL, 23, 7, 0), //Fm 音量
-	SOC_SINGLE("Line Volume", SUNXI_DAC_ACTL, 26, 1, 0), //Line音量
-	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
-	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
-	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
-	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
-	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
-	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
-	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
-	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
-};
-
-static const struct snd_kcontrol_new sunxi_adc_controls[] = { 
-	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
-	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
-	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0),
-	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0), //录音音量
-	SOC_SINGLE("Line Capture Volume", SUNXI_ADC_ACTL, 13, 7, 0), 
-	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
-	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
-	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
-	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
-	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
-	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
-};
-
-static const struct snd_kcontrol_new sun7i_dac_ctls[] = {
-	/*SUNXI_DAC_ACTL = 0x10,PAVOL*/
-	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
-	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
-	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
-	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
-	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
-	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
-	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
-	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
-	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0), 
-	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
-	SOC_SINGLE("MIC output volume", SUNXI_DAC_ACTL, 20, 7, 0),
-	/*	FM Input to output mixer Gain Control
-	* 	From -4.5db to 6db,1.5db/step,default is 0db
-	*	-4.5db:0x0,-3.0db:0x1,-1.5db:0x2,0db:0x3
-	*	1.5db:0x4,3.0db:0x5,4.5db:0x6,6db:0x7
-	*/
-	SOC_SINGLE("Fm output Volume", SUNXI_DAC_ACTL, 23, 7, 0),
-	/*	Line-in gain stage to output mixer Gain Control
-	*	0:-1.5db,1:0db
-	*/
-	SOC_SINGLE("Line output Volume", SUNXI_DAC_ACTL, 26, 1, 0),
-};
-
-static const struct snd_kcontrol_new sun7i_adc_ctls[] = { 
-	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
-	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
-	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0), 
-	SOC_SINGLE("Linein Pre-AMP", SUNXI_ADC_ACTL, 13, 7, 0), 
-	SOC_SINGLE("LINEIN APM Volume", SUNXI_MIC_CRT, 13, 0x7, 0),
-	/* ADC Input Gain Control, capture volume
-	* 000:-4.5db,001:-3db,010:-1.5db,011:0db,100:1.5db,101:3db,110:4.5db,111:6db
-	*/
-	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0),
-	/*
-	*	MIC2 pre-amplifier Gain Control
-	*	00:0db,01:35db,10:38db,11:41db
-	*/
-	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
-	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
-	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
-	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
-	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
-	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
-	SOC_SINGLE("Mic2 gain Volume", SUNXI_MIC_CRT, 26, 7, 0),
-	/*
-	*	MIC1 pre-amplifier Gain Control
-	*	00:0db,01:35db,10:38db,11:41db
-	*/
-	SOC_SINGLE("Mic1 gain Volume", SUNXI_MIC_CRT, 29, 3, 0), 
-};
-
-
-
-static int sunxi_soc_dai_probe(struct snd_soc_dai *dai)
-{
-	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
-	struct snd_dmaengine_dai_dma_data *playback_dma_data;
-	struct snd_dmaengine_dai_dma_data *capture_dma_data;
-
-	playback_dma_data = devm_kzalloc(dai->dev,
-					 sizeof(*playback_dma_data),
-					 GFP_KERNEL);
-	if (!playback_dma_data)
-		return -ENOMEM;
-
-	capture_dma_data = devm_kzalloc(dai->dev,
-					sizeof(*capture_dma_data),
-					GFP_KERNEL);
-	if (!capture_dma_data)
-		return -ENOMEM;
-
-	playback_dma_data->addr = priv->codec_phys + SUNXI_DAC_TXDATA;
-	capture_dma_data->addr = priv->codec_phys + SUNXI_ADC_RXDATA;
-
-	playback_dma_data->maxburst = 4;
-	capture_dma_data->maxburst = 4;
-
-	playback_dma_data->addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-	playback_dma_data->addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-
-	snd_soc_dai_init_dma_data(dai, playback_dma_data, capture_dma_data);
-	return 0;
-}
-
-static const struct snd_soc_dai_ops sunxi_dai_ops = {
-	.digital_mute	= sunxi_digital_mute,
-	.startup	= sunxi_startup,
-	.shutdown	= sunxi_shutdown,
-	.trigger	= sunxi_trigger,
-	.hw_params	= sunxi_hw_params,
-};
-
-static struct snd_soc_dai_driver sunxi_dai = {
-	.name		= "cat",
-	.playback = {
-		.channels_min = 2,
-		.channels_max = 2,
-		.rates = (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
-				 SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | \
-				 SNDRV_PCM_RATE_192000),
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
-	},
-	.probe = sunxi_soc_dai_probe,
-	.ops = &sunxi_dai_ops,
-};
-
-static const struct snd_soc_component_driver sunxi_component = {
-	.name		= "horse",
-};
-
-#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
-#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
-			SNDRV_PCM_FMTBIT_S20_3LE | \
-			SNDRV_PCM_FMTBIT_S24_LE)
-
-unsigned int read(struct snd_soc_codec *codec, unsigned int reg);
-int write(struct snd_soc_codec *, unsigned int reg, unsigned int);
-
-
-static struct snd_soc_codec_driver soc_codec_sun4a_codec = {
-	.controls = sun4a_dac,
-	.num_controls = ARRAY_SIZE(sun4a_dac),
-};
-
-static struct snd_soc_codec_driver soc_codec_sun4i_codec = {
-	.controls = sun4i_dac,
-	.num_controls = ARRAY_SIZE(sun4i_dac),
-};
-
-static struct snd_soc_codec_driver soc_codec_sun7i_codec = {
-	.controls = sun7i_dac_ctls,
-	.num_controls = ARRAY_SIZE(sun7i_dac_ctls),
-};
-
-static struct snd_soc_dai_driver dit_stub_dai = {
-	.name		= "dog",
-	.playback 	= {
-		.stream_name	= "Playback",
-		.channels_min	= 1,
-		.channels_max	= 384,
-		.rates		= STUB_RATES,
-		.formats	= STUB_FORMATS,
-	},
-};
-
-static const struct regmap_config sunxi_regmap_config = {
-	.reg_bits = 32,
-	.reg_stride = 4,
-	.val_bits = 32,
-	.max_register = SUNXI_MIC_CRT,
-};
-
-static const struct of_device_id snd_sunxi_codec_ids[] = {
-	{ .compatible = "allwinner,sun4i-a10a-codec", .data = (void *)SUN4A},
-	{ .compatible = "allwinner,sun4i-a10-codec", .data = (void *)SUN4I},
-	{ .compatible = "allwinner,sun5i-a13-codec", .data = (void *)SUN5I},
-	{ .compatible = "allwinner,sun7i-a20-codec", .data = (void *)SUN7I},
-	{}
-};
-MODULE_DEVICE_TABLE(of, snd_sunxi_codec_ids);
-
-static int sunxi_codec_probe(struct platform_device *pdev)
-{
-	struct device_node *np = pdev->dev.of_node;
-	const struct of_device_id *of_id;
-	struct device *dev = &pdev->dev;
-	struct card_data *priv;
-	struct resource res;
-	int ret;
-
-	if (!of_device_is_available(np))
-		return -ENODEV;
-
-	of_id = of_match_device(snd_sunxi_codec_ids, &pdev->dev);
-	if (!of_id)
-		return -EINVAL;
-
-	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
-		dev_err(&pdev->dev, "could not allocate DAI object\n");
-		return -ENOMEM;
-	}
-	
-	priv->id = (int)of_id->data;
-
-	/* Get the addresses and IRQ */
-	ret = of_address_to_resource(np, 0, &res);
-	if (ret) {
-		dev_err(&pdev->dev, "could not determine device resources\n");
-		return ret;
-	}
-	priv->baseaddr = of_iomap(np, 0);
-	if (!priv->baseaddr) {
-		dev_err(&pdev->dev, "could not map device resources\n");
-		return -ENOMEM;
-	}
-	priv->codec_phys = res.start;
-
-	priv->regmap = devm_regmap_init_mmio(&pdev->dev, priv->baseaddr, &sunxi_regmap_config);
-	if (IS_ERR(priv->regmap))
-		return PTR_ERR(priv->regmap);
-
-	priv->irq = irq_of_parse_and_map(np, 0);
-	if (!priv->irq) {
-		dev_err(&pdev->dev, "no irq for node %s\n", np->full_name);
-		return -ENXIO;
-	}
-
-	/* Clock */
-	priv->codec_apbclk = devm_clk_get(dev, "apb");
-	if (IS_ERR(priv->codec_apbclk)) {
-		dev_err(dev, "failed to get apb clock.\n");
-		return PTR_ERR(priv->codec_apbclk);
-	}
-	priv->codec_pll2clk = devm_clk_get(dev, "pll2");
-	if (IS_ERR(priv->codec_pll2clk)) {
-		dev_err(dev, "failed to get pll2 clock.\n");
-		return PTR_ERR(priv->codec_pll2clk);
-	}
-	priv->codec_moduleclk = devm_clk_get(dev, "codec");
-	if (IS_ERR(priv->codec_moduleclk)) {
-		dev_err(dev, "failed to get codec clock.\n");
-		return PTR_ERR(priv->codec_moduleclk);
-	}
-	ret = clk_set_rate(priv->codec_pll2clk, 24576000);
-	if (ret) {
-		dev_err(dev, "set codec base clock failed!\n");
-		return ret;
-	}
-	if (clk_prepare_enable(priv->codec_pll2clk)) {
-		dev_err(dev, "try to enable codec_pll2clk failed\n");
-		return -EINVAL;
-	}
-	if (clk_prepare_enable(priv->codec_apbclk)) {
-		dev_err(dev, "try to enable apb_codec_clk failed\n");
-		return -EINVAL;
-	}
-	if (clk_prepare_enable(priv->codec_moduleclk)) {
-		dev_err(dev, "try to enable codec failed\n");
-		ret = -EINVAL;
-		goto exit_clkdisable_apb_clk;
-	}
-	dev_set_drvdata(&pdev->dev, priv);
-
-	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_component, &sunxi_dai, 1);
-	if (ret)
-		return ret;
-
-	switch (priv->id) {
-	case SUN4A:
-		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun4a_codec, &dit_stub_dai, 1);
-	case SUN4I:
-	case SUN5I:
-		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun4i_codec, &dit_stub_dai, 1);
-	case SUN7I:
-		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun7i_codec, &dit_stub_dai, 1);
-	}
-	if (ret)
-		return ret;
-
-	snd_dmaengine_pcm_register(&pdev->dev, NULL, SND_DMAENGINE_PCM_FLAG_NO_RESIDUE);
-
-	codec_init(priv);
-#ifdef JDS
-	if (gpio_pa_shutdown)
-		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
-
-	resume_work_queue = create_singlethread_workqueue("codec_resume");
-	if (resume_work_queue == NULL) {
-		printk("[su4i-codec] try to create workqueue for codec failed!\n");
-		ret = -ENOMEM;
-		goto err_resume_work_queue;
-	}
-#endif
-	printk("JDS - codec driver success registered\n");
-	return ret;
-
-err_resume_work_queue:
-exit_clkdisable_apb_clk:
-	return ret;
-}
-
-#ifdef CONFIG_PM
-static int snd_sunxi_codec_suspend(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct card_data *priv = dev_get_drvdata(&pdev->dev);
-
-	if (priv->running)
-		clk_disable(priv->codec_moduleclk);
-
-	return 0;
-}
-
-static int snd_sunxi_codec_resume(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct card_data *priv = dev_get_drvdata(&pdev->dev);
-
-	if (priv->running) {
-		clk_enable(priv->codec_moduleclk);
-		sunxi_configure(priv);
-		sunxi_clock(priv, priv->saved_params.core_freq,
-				priv->saved_params.rate);
-	}
-	return 0;
-}
-
-static SIMPLE_DEV_PM_OPS(sunxi_dev_pm_ops, snd_sunxi_codec_suspend, \
-		snd_sunxi_codec_resume);
-
-#define sunxi_DEV_PM_OPS (&sunxi_dev_pm_ops)
-
-#else
-#define sunxi_DEV_PM_OPS NULL
-
-#endif
-
-static int sunxi_codec_remove(struct platform_device *pdev)
-{
-#ifdef JDS
-	clk_disable(codec_moduleclk);
-	//释放codec_pll2clk时钟句柄
-	clk_put(codec_pll2clk);
-	//释放codec_apbclk时钟句柄
-	clk_put(codec_apbclk);
-
-	snd_card_free(platform_get_drvdata(devptr));
-	platform_set_drvdata(devptr, NULL);
-#endif
-	return 0;
-	snd_dmaengine_pcm_unregister(&pdev->dev);
-}
-
-static void sunxi_codec_shutdown(struct platform_device *devptr)
-{
-#ifdef JDS
-	if (gpio_pa_shutdown) {
-//JDS		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
-		mdelay(50);
-	}
-	regmap_update_bits(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x0);
-	mdelay(100);
-	//pa mute
-	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
-	mdelay(500);
-	//disable dac analog
-	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x0);
-	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x0);
-
-	//disable dac to pa
-	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x0);
-	regmap_update_bits(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x0);
-
-	clk_disable(codec_moduleclk);
-#endif
-}
-
-/*method relating*/
-static struct platform_driver sunxi_codec_driver =
-{
-	.probe = sunxi_codec_probe,
-	.remove = sunxi_codec_remove,
-	.shutdown = sunxi_codec_shutdown,
-#ifdef CONFIG_PM
-//JDS	.suspend = snd_sunxi_codec_suspend,
-//JDS	.resume = snd_sunxi_codec_resume,
-#endif
-	.driver = {
-		.name = "sunxi-codec",
-		.of_match_table = snd_sunxi_codec_ids,
-	},
-};
-
-module_platform_driver(sunxi_codec_driver);
-
-MODULE_ALIAS("platform:sunxi-codec-dai");
-MODULE_DESCRIPTION("sunxi CODEC ALSA codec driver");
-MODULE_AUTHOR("software");
-MODULE_LICENSE("GPL v2");
-
diff --git a/sound/soc/sunxi/stub.c b/sound/soc/sunxi/stub.c
deleted file mode 100644
index 8b2c634..0000000
--- a/sound/soc/sunxi/stub.c
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * ALSA SoC SPDIF DIT driver
- *
- *  This driver is used by controllers which can operate in DIT (SPDI/F) where
- *  no codec is needed.  This file provides stub codec that can be used
- *  in these configurations. TI DaVinci Audio controller uses this driver.
- *
- * Author:      Steve Chen,  <schen@mvista.com>
- * Copyright:   (C) 2009 MontaVista Software, Inc., <source@mvista.com>
- * Copyright:   (C) 2009  Texas Instruments, India
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/slab.h>
-#include <sound/soc.h>
-#include <sound/pcm.h>
-#include <sound/initval.h>
-#include <linux/of.h>
-#include "sunxi-codec.h"
-
-#define DRV_NAME "awstub"
-
-#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
-#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
-			SNDRV_PCM_FMTBIT_S20_3LE | \
-			SNDRV_PCM_FMTBIT_S24_LE)
-
-
-
-static const struct snd_soc_dapm_widget dit_widgets[] = {
-	SND_SOC_DAPM_OUTPUT("Mic Bias"),
-	SND_SOC_DAPM_OUTPUT("HP_OUT"),
-	SND_SOC_DAPM_INPUT("MIC_IN"),
-	SND_SOC_DAPM_INPUT("LINE_IN"),
-};
-
-static struct snd_soc_codec_driver soc_codec_stub = {
-	.dapm_widgets = dit_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(dit_widgets),
-};
-
-#ifdef JDS
-static struct snd_soc_codec_driver soc_codec_sun4a_codec = {
-	.controls = sun4a_dac,
-	.num_controls = ARRAY_SIZE(sun4a_dac),
-};
-
-static struct snd_soc_codec_driver soc_codec_sun4i_codec = {
-	.controls = sun4i_dac,
-	.num_controls = ARRAY_SIZE(sun4i_dac),
-};
-#endif
-
-static struct snd_soc_dai_driver awstub_dai = {
-	.name		= "awstub",
-	.playback 	= {
-		.stream_name	= "Playback",
-		.channels_min	= 1,
-		.channels_max	= 384,
-		.rates		= STUB_RATES,
-		.formats	= STUB_FORMATS,
-	},
-};
-
-static int stub_probe(struct platform_device *pdev)
-{
-	return snd_soc_register_codec(&pdev->dev, &soc_codec_stub, &awstub_dai, 1);
-}
-
-static int stub_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_codec(&pdev->dev);
-	return 0;
-}
-
-#ifdef CONFIG_OF
-static const struct of_device_id stub_dt_ids[] = {
-	{ .compatible = "allwinner,stub", },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, stub_dt_ids);
-#endif
-
-static struct platform_driver stub_driver = {
-	.probe		= stub_probe,
-	.remove		= stub_remove,
-	.driver		= {
-		.name	= DRV_NAME,
-		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(stub_dt_ids),
-	},
-};
-
-module_platform_driver(stub_driver);
-
-MODULE_AUTHOR("Steve Chen <schen@mvista.com>");
-MODULE_DESCRIPTION("AWStub codec driver");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:" DRV_NAME);
