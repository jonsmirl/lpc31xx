Bottom: f679691b0b34cf408795c40bf9cc70febef8c257
Top:    0b2651f850769ca2177b2f429233761b8a4f64b7
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-03-31 18:08:38 -0400

Refresh of device-trees

---

diff --git a/arch/arm/mach-lpc31xx/Makefile b/arch/arm/mach-lpc31xx/Makefile
index 2e02523..e6aec70 100644
--- a/arch/arm/mach-lpc31xx/Makefile
+++ b/arch/arm/mach-lpc31xx/Makefile
@@ -4,7 +4,7 @@
 
 # Object file lists.
 
-obj-y			+= irq.o time.o generic.o i2c.o dma.o usb.o wdt.o clock.o
+obj-y			+= irq.o time.o generic.o dma.o usb.o wdt.o clock.o
 obj-$(CONFIG_OF) += dt.o
 
 
diff --git a/arch/arm/mach-lpc31xx/board-ea313x.c b/arch/arm/mach-lpc31xx/board-ea313x.c
index 57161a8..fc51b32 100644
--- a/arch/arm/mach-lpc31xx/board-ea313x.c
+++ b/arch/arm/mach-lpc31xx/board-ea313x.c
@@ -183,77 +183,7 @@ static int __init lpc313x_spidev_register(void)
 arch_initcall(lpc313x_spidev_register);
 #endif
 
-#if defined(CONFIG_MTD_DATAFLASH)
-/* MTD Data FLASH driver registration */
-static int __init lpc313x_spimtd_register(void)
-{
-	struct spi_board_info info =
-	{
-		.modalias = "mtd_dataflash",
-		.max_speed_hz = 30000000,
-		.bus_num = 0,
-		.chip_select = 0,
-	};
-
-	return spi_register_board_info(&info, 1);
-}
-arch_initcall(lpc313x_spimtd_register);
-#endif
-
-
-#define PCA9532_GPIO_BASE 0x340
-#define VBUS_PWR_EN	(6 + PCA9532_GPIO_BASE)
-#define START_STOP_LED	8  /*led5 */
-#define IDLE_LED	9  /*led6 */
-
-static struct pca9532_platform_data ea313x_leds = {
-	.gpio_base = PCA9532_GPIO_BASE,
-	.leds = {
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 1 */
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 2 */
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 3 */
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 4 */
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 5 */
-	{	.type = PCA9532_TYPE_GPIO }, /* OTP gpio */
-	{	.type = PCA9532_TYPE_GPIO }, /* V_BUS_EN gpio */
-	{	.type = PCA9532_TYPE_GPIO }, /* V_PWR_CTRL gpio */
 
-	{	.name = "ea313x:red:led5",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led6",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led7",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led8",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led9",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led10",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led11",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led12",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	},
-	.psc = { 0, 0 },
-	.pwm = { 0, 0 },
-};
 
 #if defined(CONFIG_MACH_EA3152)
 static struct i2c_board_info ea3152_i2c1_devices[] __initdata = {
@@ -266,7 +196,7 @@ static struct i2c_board_info ea3152_i2c1_devices[] __initdata = {
 void lpc313x_vbus_power(int enable)
 {
 	printk (KERN_INFO "enabling USB host vbus_power %d\n", enable);
-	gpio_set_value(VBUS_PWR_EN, enable);
+	//gpio_set_value(VBUS_PWR_EN, enable);
 }
 
 struct of_dev_auxdata ea3131_auxdata_lookup[] __initdata = {
@@ -284,10 +214,10 @@ static void __init ea3131_dt_init(void)
 #if defined(CONFIG_USB_EHCI_HCD)
 static int __init ea_usb_power(void)
 {
-	int ret;
+	int ret = 0;
 
-	ret = gpio_request(VBUS_PWR_EN, "vbus power");
-	ret = gpio_direction_output(VBUS_PWR_EN, 1);
+	//ret = gpio_request(VBUS_PWR_EN, "vbus power");
+	//ret = gpio_direction_output(VBUS_PWR_EN, 1);
 	return ret;
 }
 late_initcall(ea_usb_power);
diff --git a/arch/arm/mach-lpc31xx/i2c.c b/arch/arm/mach-lpc31xx/i2c.c
deleted file mode 100644
index 2971635..0000000
--- a/arch/arm/mach-lpc31xx/i2c.c
+++ /dev/null
@@ -1,166 +0,0 @@
-/*  linux/arch/arm/mach-lpc313x/i2c.c
- *
- *  Author:	Durgesh Pattamatta
- *  Copyright (C) 2009 NXP semiconductors
- *
- * I2C initialization for LPC313x.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#include <linux/delay.h>
-#include <linux/clk.h>
-#include <linux/i2c.h>
-#include <linux/i2c-pnx.h>
-#include <linux/platform_device.h>
-#include <linux/err.h>
-#include <linux/slab.h>
-#include <mach/hardware.h>
-#include <mach/i2c.h>
-#include <mach/gpio.h>
-#include <mach/irqs.h>
-
-#define LPC313x_I2C0_SLV_ADDR            __REG (I2C0_PHYS + 0x014)
-#define LPC313x_I2C1_SLV_ADDR            __REG (I2C1_PHYS + 0x014)
-
-static int set_clock_run(struct platform_device *pdev)
-{
-	if (pdev->id == 0)
-		cgu_clk_en_dis( CGU_SB_I2C0_PCLK_ID, 1);
-	else
-		cgu_clk_en_dis( CGU_SB_I2C1_PCLK_ID, 1);
-
-	udelay(2);
-	return 0;
-}
-
-static int set_clock_stop(struct platform_device *pdev)
-{
-	if (pdev->id == 0)
-		cgu_clk_en_dis( CGU_SB_I2C0_PCLK_ID, 0);
-	else
-		cgu_clk_en_dis( CGU_SB_I2C1_PCLK_ID, 0);
-
-	return 0;
-}
-
-static int i2c_lpc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	int retval = 0;
-#ifdef CONFIG_PM
-	retval = set_clock_stop(pdev);
-#endif
-	return retval;
-}
-
-static int i2c_lpc_resume(struct platform_device *pdev)
-{
-	int retval = 0;
-#ifdef CONFIG_PM
-	retval = set_clock_run(pdev);
-#endif
-	return retval;
-}
-
-static u32 calculate_input_freq(struct platform_device *pdev)
-{
-	return (FFAST_CLOCK/1000000);
-}
-
-static struct i2c_pnx_algo_data i2c0_algo_data;
-static struct i2c_pnx_algo_data i2c1_algo_data;
-
-static struct i2c_pnx_algo_data i2c0_algo_data = {
-	.adapter = {
-		.name = I2C_CHIP_NAME "0",
-		.algo_data = &i2c0_algo_data,
-	},
-};
-
-static struct i2c_pnx_algo_data i2c1_algo_data = {
-	.adapter = {
-		.name = I2C_CHIP_NAME "1",
-		.algo_data = &i2c1_algo_data,
-	},
-};
-
-static struct resource i2c0_resource[] = {
-	[0] = {
-		.start = I2C0_PHYS,
-		.end   = I2C0_PHYS + 0x400,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_I2C0,
-		.end	= IRQ_I2C0,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device i2c0_device = {
-	.name = "pnx-i2c",
-	.id = 0,
-	.num_resources	= ARRAY_SIZE(i2c0_resource),
-	.resource	= i2c0_resource,
-};
-
-static struct resource i2c1_resource[] = {
-	[0] = {
-		.start = I2C1_PHYS,
-		.end   = I2C1_PHYS + 0x400,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_I2C1,
-		.end	= IRQ_I2C1,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device i2c1_device = {
-	.name = "pnx-i2c",
-	.id = 1,
-	.num_resources	= ARRAY_SIZE(i2c1_resource),
-	.resource	= i2c1_resource,
-};
-
-static struct platform_device *devices[] __initdata = {
-	&i2c0_device,
-	&i2c1_device,
-};
-
-void __init lpc313x_register_i2c_devices(void)
-{
-	cgu_clk_en_dis( CGU_SB_I2C0_PCLK_ID, 1);
-	cgu_clk_en_dis( CGU_SB_I2C1_PCLK_ID, 1);
-
-	/* Enable I2C1 signals */
-	GPIO_DRV_IP(IOCONF_I2C1, 0x3);
-
-#if defined (CONFIG_MACH_VAL3153) || defined (CONFIG_MACH_EA313X)
-	/* on EA and VAL boards UDA1380 is connected to I2C1
-	 * whose slave address is same as LPC313x's default slave
-	 * adress causing bus contention errors. So change the
-	 * deafult slave address register value of LPC313x here.
-	 */
-	LPC313x_I2C0_SLV_ADDR = 0x06E;
-	LPC313x_I2C1_SLV_ADDR = 0x06E;
-#endif
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-}
-
-
diff --git a/drivers/leds/leds-pca9532.c b/drivers/leds/leds-pca9532.c
index ceccab4..611f6ff 100644
--- a/drivers/leds/leds-pca9532.c
+++ b/drivers/leds/leds-pca9532.c
@@ -444,6 +444,34 @@ exit:
 	return err;
 }
 
+#ifdef CONFIG_OF
+/* for now make everything into a GPIO under OF */
+/* LED support needs to be integrated with OF gpio-leds */
+static struct pca9532_platform_data of_gpios = {
+	.gpio_base = -1,
+	.leds = {
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	{	.type = PCA9532_TYPE_GPIO },
+	},
+	.psc = { 0, 0 },
+	.pwm = { 0, 0 },
+};
+#endif
+
 static int pca9532_probe(struct i2c_client *client,
 	const struct i2c_device_id *id)
 {
@@ -451,8 +479,12 @@ static int pca9532_probe(struct i2c_client *client,
 	struct pca9532_platform_data *pca9532_pdata = client->dev.platform_data;
 	int err;
 
+#ifdef CONFIG_OF
+	pca9532_pdata = &of_gpios;
+#else
 	if (!pca9532_pdata)
 		return -EIO;
+#endif
 
 	if (!i2c_check_functionality(client->adapter,
 		I2C_FUNC_SMBUS_BYTE_DATA))
