Bottom: e82caff3771ecdc051fa6c1163f0e0a12088ce10
Top:    ef6707d46db9d7dfb9da68df3c0dc99a78289c59
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-03-23 18:11:39 -0400

Refresh of devicetree

---

diff --git a/arch/arm/boot/dts/ea3131.dts b/arch/arm/boot/dts/ea3131.dts
index eee902e..5aaf2e7 100644
--- a/arch/arm/boot/dts/ea3131.dts
+++ b/arch/arm/boot/dts/ea3131.dts
@@ -20,11 +20,14 @@
 		compatible = "ssd,ssd1289";
 		reg = <0x20000000 0x10000 0x20010000 0x10000>;
 	};
-
+	dm9000@20000000 {
+		compatible = "davicom,dm9000";
+		reg = <0x20020000 0x100 0x20030000 0x100>;
+		interrupts = <37>;
+	};
 	memory@30000000 {
 		reg = <0x30000000 0x4000000>;
 	};
-
 	ahb {
 		sdmmc@18000000 {
 			cd-gpio = <&gpio 0x87 0>;
diff --git a/arch/arm/mach-lpc31xx/board-ea313x.c b/arch/arm/mach-lpc31xx/board-ea313x.c
index 7a24b9f..19bfaae 100644
--- a/arch/arm/mach-lpc31xx/board-ea313x.c
+++ b/arch/arm/mach-lpc31xx/board-ea313x.c
@@ -106,6 +106,7 @@ static void __init ea_add_device_ssd1289(void) {}
  * DM9000 ethernet device
  */
 #if defined(CONFIG_DM9000)
+#ifndef CONFIG_OF
 static struct resource dm9000_resource[] = {
 	[0] = {
 		.start	= EXT_SRAM1_PHYS,
@@ -123,6 +124,7 @@ static struct resource dm9000_resource[] = {
 		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
 	}
 };
+#endif
 /* ARM MPMC contoller as part of low power design doesn't de-assert nCS and nOE for consecutive 
 reads but just changes address. But DM9000 requires nCS and nOE change between address. So access
 other chip select area (nCS0) to force de-assertion of nCS1 and nOE1. Or else wait for long time 
@@ -165,6 +167,7 @@ static struct dm9000_plat_data dm9000_platdata = {
 	.inblk = dm9000_inblk,
 };
 
+#ifndef CONFIG_OF
 static struct platform_device dm9000_device = {
 	.name		= "dm9000",
 	.id		= 0,
@@ -174,6 +177,8 @@ static struct platform_device dm9000_device = {
 		.platform_data	= &dm9000_platdata,
 	}
 };
+#endif
+
 static void __init ea_add_device_dm9000(void)
 {
 	/*
@@ -191,6 +196,7 @@ static void __init ea_add_device_dm9000(void)
 	/* enable oe toggle between consec reads */
 	SYS_MPMC_WTD_DEL1 = _BIT(5) | 4;
 
+#ifndef CONFIG_OF
 	/* Configure Interrupt pin as input, no pull-up */
 	if (gpio_request(GPIO_MNAND_RYBN3, "dm9000 interrupt"))
 		return;
@@ -198,6 +204,7 @@ static void __init ea_add_device_dm9000(void)
 	gpio_direction_input(GPIO_MNAND_RYBN3);
 
 	platform_device_register(&dm9000_device);
+#endif
 }
 #else
 static void __init ea_add_device_dm9000(void) {}
@@ -580,10 +587,16 @@ void lpc313x_vbus_power(int enable)
 }
 
 #ifdef CONFIG_OF
+struct of_dev_auxdata ea3131_auxdata_lookup[] __initdata = {
+	OF_DEV_AUXDATA("davicom,dm9000", EXT_SRAM1_PHYS, "dm9000", &dm9000_platdata),
+	{}
+};
+
 static void __init ea3131_dt_init(void)
 {
-	lpc31xx_dt_init();
+	lpc31xx_dt_init_common(ea3131_auxdata_lookup);
 	ea_add_device_ssd1289();
+	ea_add_device_dm9000();
 }
 #else
 static void __init ea313x_init(void)
diff --git a/arch/arm/mach-lpc31xx/dt.c b/arch/arm/mach-lpc31xx/dt.c
index 774d6ba..7c3d7cb 100644
--- a/arch/arm/mach-lpc31xx/dt.c
+++ b/arch/arm/mach-lpc31xx/dt.c
@@ -29,12 +29,18 @@
 #include <mach/hardware.h>
 #include <mach/board.h>
 #include <mach/clock.h>
+#include <mach/dt.h>
 
-void __init lpc31xx_dt_init(void)
+static void __init lpc31xx_dt_init(void)
+{
+	lpc31xx_dt_init_common(NULL);
+}
+
+void __init lpc31xx_dt_init_common(struct of_dev_auxdata* auxdata)
 {
 	lpc313x_init();
 	of_platform_populate(NULL, of_default_bus_match_table,
-			     NULL, NULL);
+			     auxdata, NULL);
 }
 
 void __init lpc31xx_init_early(void)
diff --git a/arch/arm/mach-lpc31xx/include/mach/dt.h b/arch/arm/mach-lpc31xx/include/mach/dt.h
index 198ee69..f4eb877 100644
--- a/arch/arm/mach-lpc31xx/include/mach/dt.h
+++ b/arch/arm/mach-lpc31xx/include/mach/dt.h
@@ -1,7 +1,7 @@
 #ifndef LPC31XX_DT
 #define LPC31XX_DT
 
-void lpc31xx_dt_init(void);
+void lpc31xx_dt_init_common(struct of_dev_auxdata* auxdata);
 void lpc31xx_init_early(void);
 void lpc31xx_restart(char mode, const char *cmd);
 
diff --git a/drivers/net/ethernet/davicom/dm9000.c b/drivers/net/ethernet/davicom/dm9000.c
index f7ca4cc..f8fd607 100644
--- a/drivers/net/ethernet/davicom/dm9000.c
+++ b/drivers/net/ethernet/davicom/dm9000.c
@@ -1679,11 +1679,22 @@ dm9000_drv_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id dm9000_of_match[] = {
+	{ .compatible = "davicom,dm9000" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, dm9000_of_match);
+#endif
+
 static struct platform_driver dm9000_driver = {
 	.driver	= {
 		.name    = "dm9000",
 		.owner	 = THIS_MODULE,
 		.pm	 = &dm9000_drv_pm_ops,
+#ifdef CONFIG_OF
+		.of_match_table = dm9000_of_match,
+#endif
 	},
 	.probe   = dm9000_probe,
 	.remove  = __devexit_p(dm9000_drv_remove),
diff --git a/drivers/video/ssd1289.c b/drivers/video/ssd1289.c
index 928ec27..327cfb1 100644
--- a/drivers/video/ssd1289.c
+++ b/drivers/video/ssd1289.c
@@ -376,7 +376,6 @@ static int __init ssd1289_probe(struct platform_device *dev)
 	dev_set_drvdata(&dev->dev, item);
 
 	ctrl_res = platform_get_resource(dev, IORESOURCE_MEM, 0);
-printk("JDS ctrl %p %p\n", ctrl_res->end, ctrl_res->start);
 	if (!ctrl_res) {
 		dev_err(&dev->dev,
 			"%s: unable to platform_get_resource for ctrl_res\n",
@@ -403,7 +402,6 @@ printk("JDS ctrl %p %p\n", ctrl_res->end, ctrl_res->start);
 	}
 
 	data_res = platform_get_resource(dev, IORESOURCE_MEM, 1);
-printk("JDS data %p %p\n", data_res->end, data_res->start);
 	if (!data_res) {
 		dev_err(&dev->dev,
 			"%s: unable to platform_get_resource for data_res\n",
