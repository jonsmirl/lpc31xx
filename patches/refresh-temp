Bottom: 8110332559132fe91e28878a6c0169695ec3de2d
Top:    967444b14e734f1635c924c76b631ce1cf63c1df
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-04-21 23:26:36 -0400

Refresh of intc

---

diff --git a/arch/arm/mach-lpc31xx/generic.c b/arch/arm/mach-lpc31xx/generic.c
index d257d47..88553e2 100644
--- a/arch/arm/mach-lpc31xx/generic.c
+++ b/arch/arm/mach-lpc31xx/generic.c
@@ -90,7 +90,8 @@ static struct plat_serial8250_port platform_serial_ports[] = {
 	{
 		.membase = (void *)io_p2v(UART_PHYS),
 		.mapbase = (unsigned long)UART_PHYS,
-		.irq = IRQ_UART,
+		//.irq = IRQ_UART,
+		.irq = 13,
 		.uartclk = XTAL_CLOCK,
 		.regshift = 2,
 		.iotype = UPIO_MEM,
@@ -266,7 +267,8 @@ static int __init lpc31xx_init_console(void)
 
 	up.membase = (char *) io_p2v(UART_PHYS);
 	up.mapbase = (unsigned long)UART_PHYS,
-	up.irq = IRQ_UART;
+//	up.irq = IRQ_UART;
+	up.irq = 13;
 	up.uartclk = XTAL_CLOCK;
 	/* check what FDR bootloader is using */
 	mul = (UART_FDR_REG >> 4) & 0xF;
diff --git a/arch/arm/mach-lpc31xx/irq.c b/arch/arm/mach-lpc31xx/irq.c
index 749a18a..8727e9f 100644
--- a/arch/arm/mach-lpc31xx/irq.c
+++ b/arch/arm/mach-lpc31xx/irq.c
@@ -110,7 +110,7 @@ static int intc_irq_map(struct irq_domain *h, unsigned int virq, irq_hw_number_t
 				 handle_level_irq);
 	set_irq_flags(virq, IRQF_VALID);
 
-	printk("intc hw=%ld virq=%d", hw, virq);
+	printk("intc hw=%ld virq=%d\n", hw, virq);
 	return 0;
 }
 
diff --git a/arch/arm/mach-lpc31xx/time.c b/arch/arm/mach-lpc31xx/time.c
index 7fc7ecc..559ee67 100644
--- a/arch/arm/mach-lpc31xx/time.c
+++ b/arch/arm/mach-lpc31xx/time.c
@@ -3,7 +3,7 @@
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- *  Timer driver for LPC31xx
+ *  Timer driver for LPC31xx & LPC315x.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,21 +25,43 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/time.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 
-#include <mach/hardware.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/leds.h>
-
 #include <asm/mach/time.h>
+
+#include <mach/hardware.h>
 #include <mach/gpio.h>
 #include <mach/board.h>
-//#include <mach/cgu.h>
 
+/***********************************************************************
+ * Timer register definitions
+ **********************************************************************/
+#define TIMER_LOAD      0x00
+#define TIMER_VALUE     0x04
+#define TIMER_CONTROL   0x08
+#define TIMER_CLEAR     0x0c
+
+#define TM_CTRL_ENABLE    _BIT(7)
+#define TM_CTRL_MODE      _BIT(6)
+#define TM_CTRL_PERIODIC  _BIT(6)
+#define TM_CTRL_PS1       _SBF(2, 0)
+#define TM_CTRL_PS16      _SBF(2, 1)
+#define TM_CTRL_PS256     _SBF(2, 2)
+#define TM_CTRL_PS_MASK   _SBF(2, 0x3)
+
+static void __iomem *timer_regs;
+#define timer_read(reg) \
+	__raw_readl(timer_regs + reg)
+#define timer_write(reg, value) \
+	__raw_writel(value, timer_regs + reg);
 
 static irqreturn_t lpc31xx_timer_interrupt(int irq, void *dev_id)
 {
-	TIMER_CLEAR(TIMER0_PHYS) = 0;
+	timer_write(TIMER_CLEAR, 0);
 	timer_tick();
 	return IRQ_HANDLED;
 }
@@ -50,43 +72,75 @@ static struct irqaction lpc31xx_timer_irq = {
 	.handler	= lpc31xx_timer_interrupt,
 };
 
-static void __init lpc31xx_timer_init (void)
-{
-	/* Switch on needed Timer clocks & switch off others*/
-	cgu_clk_en_dis(CGU_SB_TIMER0_PCLK_ID, 1);
-	cgu_clk_en_dis(CGU_SB_TIMER1_PCLK_ID, 0);
-	cgu_clk_en_dis(CGU_SB_TIMER2_PCLK_ID, 0);
-	cgu_clk_en_dis(CGU_SB_TIMER3_PCLK_ID, 0);
-
-	/* Stop/disable all timers */
-	TIMER_CONTROL(TIMER0_PHYS) = 0;
-
-	TIMER_LOAD(TIMER0_PHYS) = LATCH;
-	TIMER_CONTROL(TIMER0_PHYS) = (TM_CTRL_ENABLE | TM_CTRL_PERIODIC);
-	TIMER_CLEAR(TIMER0_PHYS) = 0;
-	setup_irq (IRQ_TIMER0, &lpc31xx_timer_irq);
-}
-
 /*!
  * Returns number of us since last clock interrupt.  Note that interrupts
  * will have been disabled by do_gettimeoffset()
  */
 static unsigned long lpc31xx_gettimeoffset(void)
 {
-	u32 elapsed = LATCH - TIMER_VALUE(TIMER0_PHYS);
+	u32 elapsed = LATCH - timer_read(TIMER_VALUE);
 	return ((elapsed * 100) / (XTAL_CLOCK / 20000));
 }
 
 static void lpc31xx_timer_suspend(void)
 {
-	TIMER_CONTROL(TIMER0_PHYS) &= ~TM_CTRL_ENABLE;	/* disable timers */
+	timer_write(TIMER_CONTROL, timer_read(TIMER_CONTROL) & ~TM_CTRL_ENABLE); /* disable timers */
 }
 
 static void lpc31xx_timer_resume(void)
 {
-	TIMER_CONTROL(TIMER0_PHYS) |= TM_CTRL_ENABLE;	/* enable timers */
+	timer_write(TIMER_CONTROL, timer_read(TIMER_CONTROL) | TM_CTRL_ENABLE);	/* enable timers */
 }
 
+static struct of_device_id timer_ids[] = {
+	{ .compatible = "nxp,lpc31xx-timer" },
+	{ /* sentinel */ }
+};
+
+static void __init lpc31xx_timer_init(void)
+{
+	struct device_node *node;
+	int ret;
+
+	node = of_find_matching_node(NULL, timer_ids);
+	if (!node)
+		goto err;
+
+	timer_regs = of_iomap(node, 0);
+	if (!timer_regs)
+		goto node_err;
+
+	/* Get the interrupts property */
+	ret = irq_of_parse_and_map(node, 0);
+	if (!ret) {
+		pr_crit("LPC31xx: Timer -  unable to get IRQ from DT\n");
+		goto ioremap_err;
+	}
+	of_node_put(node);
+
+	/* Switch on needed Timer clocks & switch off others*/
+	cgu_clk_en_dis(CGU_SB_TIMER0_PCLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_TIMER1_PCLK_ID, 0);
+	cgu_clk_en_dis(CGU_SB_TIMER2_PCLK_ID, 0);
+	cgu_clk_en_dis(CGU_SB_TIMER3_PCLK_ID, 0);
+
+	/* Stop/disable all timers */
+	timer_write(TIMER_CONTROL, 0);
+
+	timer_write(TIMER_LOAD, LATCH);
+	timer_write(TIMER_CONTROL, (TM_CTRL_ENABLE | TM_CTRL_PERIODIC));
+	timer_write(TIMER_CLEAR, 0);
+	setup_irq (IRQ_TIMER0, &lpc31xx_timer_irq);
+
+	return;
+
+ioremap_err:
+	iounmap(timer_regs);
+node_err:
+	of_node_put(node);
+err:
+	return;
+}
 
 struct sys_timer lpc31xx_timer = {
 	.init = lpc31xx_timer_init,
@@ -94,3 +148,4 @@ struct sys_timer lpc31xx_timer = {
 	.suspend = lpc31xx_timer_suspend,
 	.resume = lpc31xx_timer_resume,
 };
+
