Bottom: 2bdefaabf5d24e15a716af2cb3d252ebab9394ee
Top:    02982b8f53314dbeff967e01b61a60305a29affc
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-06-23 21:54:55 -0400

Refresh of foobar

---

diff --git a/arch/arm/boot/dts/sun7i-a20.dtsi b/arch/arm/boot/dts/sun7i-a20.dtsi
index 30231a9..a07fa08 100644
--- a/arch/arm/boot/dts/sun7i-a20.dtsi
+++ b/arch/arm/boot/dts/sun7i-a20.dtsi
@@ -870,7 +870,7 @@
 			interrupts = <0 13 4>;
 			clocks = <&pll2>, <&apb0_gates 1>, <&spdif_clk>;
 			clock-names = "pll2", "apb", "spdif";
-			dmas = <&dma 1 2>, <&dma 1 2>;
+			dmas = <&dma 0 2>, <&dma 0 2>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
@@ -881,7 +881,7 @@
 			interrupts = <0 14 4>;
 			clocks = <&pll2>, <&apb0_gates 2>, <&ac97_clk>;
 			clock-names = "pll2", "apb", "ac97";
-			dmas = <&dma 1 5>, <&dma 1 5>;
+			dmas = <&dma 0 5>, <&dma 0 5>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
@@ -892,7 +892,7 @@
 			interrupts = <0 16 4>;
 			clocks = <&pll2>, <&apb0_gates 3>, <&i2s0_clk>;
 			clock-names = "pll2", "apb", "i2s";
-			dmas = <&dma 1 3>, <&dma 1 3>;
+			dmas = <&dma 0 3>, <&dma 0 3>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
@@ -903,7 +903,7 @@
 			interrupts = <0 87 4>;
 			clocks = <&pll2>, <&apb0_gates 4>, <&i2s1_clk>;
 			clock-names = "pll2", "apb", "i2s";
-			dmas = <&dma 1 4>, <&dma 1 4>;
+			dmas = <&dma 0 4>, <&dma 0 4>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
@@ -914,7 +914,7 @@
 			interrupts = <0 90 4>;
 			clocks = <&pll2>, <&apb0_gates 8>, <&i2s2_clk>;
 			clock-names = "pll2", "apb", "i2s";
-			dmas = <&dma 1 6>, <&dma 1 6>;
+			dmas = <&dma 0 6>, <&dma 0 6>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
@@ -926,7 +926,7 @@
 			interrupts = <0 30 4>;
 			clocks = <&pll2>, <&apb0_gates 0>, <&codec_clk>;
 			clock-names = "pll2", "apb", "codec";
-			dmas = <&dma 1 19>, <&dma 1 19>;
+			dmas = <&dma 0 19>, <&dma 0 19>;
 			dma-names = "rx", "tx";
 		};
 
diff --git a/drivers/dma/sun4i-dma.c b/drivers/dma/sun4i-dma.c
index 5c8cdd7..21b62a2 100644
--- a/drivers/dma/sun4i-dma.c
+++ b/drivers/dma/sun4i-dma.c
@@ -645,6 +645,73 @@ sun4i_dma_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest,
 	return vchan_tx_prep(&vchan->vc, &contract->vd, flags);
 }
 
+static struct dma_async_tx_descriptor *sun4i_dma_prep_dma_cyclic(
+		struct dma_chan *chan, dma_addr_t buf, size_t len,
+		size_t period_len, enum dma_transfer_direction dir,
+		unsigned long flags, void *context) {
+	struct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);
+	struct dma_slave_config *sconfig = &vchan->cfg;
+	struct sun4i_ddma_promise *promise;
+	struct sun4i_ddma_contract *contract;
+	dma_addr_t src, dest;
+
+	printk("JDS - sun4i_dma_prep_dma_cyclic\n");
+	if (!is_slave_direction(dir)) {
+		dev_err(chan2dev(chan), "Invalid DMA direction\n");
+		return NULL;
+	}
+
+	contract = generate_ddma_contract();
+	if (!contract)
+		return NULL;
+
+	/* Figure out addresses */
+	if (dir == DMA_MEM_TO_DEV) {
+		src = buf;
+		dest = sconfig->dst_addr;
+	} else {
+		src = sconfig->src_addr;
+		dest = buf;
+	}
+
+	if (vchan->is_dedicated)
+		promise = generate_ddma_promise(chan, src, dest, len, sconfig);
+	else
+		promise = generate_ndma_promise(chan, src, dest, len, sconfig);
+
+	if (!promise) {
+		kfree(contract);
+		return NULL;
+	}
+
+	/* Figure out endpoints */
+	if (vchan->is_dedicated && dir == DMA_MEM_TO_DEV) {
+		promise->cfg |= DDMA_CFG_CONT_MODE | DDMA_CFG_SRC_DRQ_TYPE(DDMA_DRQ_TYPE_SDRAM) |
+			    DDMA_CFG_SRC_ADDR_MODE(DDMA_ADDR_MODE_LINEAR) |
+			    DDMA_CFG_DEST_DRQ_TYPE(vchan->endpoint) |
+			    DDMA_CFG_DEST_ADDR_MODE(DDMA_ADDR_MODE_IO);
+	} else if (!vchan->is_dedicated && dir == DMA_MEM_TO_DEV) {
+		promise->cfg |= NDMA_CFG_CONT_MODE | NDMA_CFG_SRC_DRQ_TYPE(NDMA_DRQ_TYPE_SDRAM) |
+			    NDMA_CFG_DEST_DRQ_TYPE(vchan->endpoint) |
+			    NDMA_CFG_DEST_FIXED_ADDR;
+	} else if (vchan->is_dedicated) {
+		promise->cfg |= DDMA_CFG_CONT_MODE | DDMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |
+			    DDMA_CFG_SRC_ADDR_MODE(DDMA_ADDR_MODE_IO) |
+			    DDMA_CFG_DEST_DRQ_TYPE(DDMA_DRQ_TYPE_SDRAM) |
+			    DDMA_CFG_DEST_ADDR_MODE(DDMA_ADDR_MODE_LINEAR);
+	} else {
+		promise->cfg |= NDMA_CFG_CONT_MODE | NDMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |
+			    NDMA_CFG_SRC_FIXED_ADDR |
+			    NDMA_CFG_DEST_DRQ_TYPE(NDMA_DRQ_TYPE_SDRAM);
+	}
+
+	/* Fill the contract with our only promise */
+	list_add_tail(&promise->list, &contract->demands);
+
+	/* And add it to the vchan */
+	return vchan_tx_prep(&vchan->vc, &contract->vd, flags);
+}
+
 static struct dma_async_tx_descriptor *
 sun4i_dma_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 			unsigned int sg_len, enum dma_transfer_direction dir,
@@ -732,6 +799,7 @@ static void sun4i_ddma_terminate_all(struct sun4i_dma_vchan *vchan)
 	u32 n_busy = NDMA_CFG_LOADING;
 
 
+	printk("sun4i_ddma_terminate_all\n");
 	spin_lock_irqsave(&vchan->vc.lock, flags);
 	vchan_get_all_descriptors(&vchan->vc, &head);
 	spin_unlock_irqrestore(&vchan->vc.lock, flags);
@@ -974,6 +1042,7 @@ static int sun4i_dma_probe(struct platform_device *pdev)
 	priv->slave.device_issue_pending	= sun4i_dma_issue_pending;
 	priv->slave.device_prep_slave_sg	= sun4i_dma_prep_slave_sg;
 	priv->slave.device_prep_dma_memcpy	= sun4i_dma_prep_dma_memcpy;
+	priv->slave.device_prep_dma_cyclic	= sun4i_dma_prep_dma_cyclic;
 	priv->slave.device_control		= sun4i_dma_control;
 	priv->slave.chancnt			= DDMA_NR_MAX_VCHANS;
 
diff --git a/sound/core/pcm_dmaengine.c b/sound/core/pcm_dmaengine.c
index 76cbb9e..fd420af 100644
--- a/sound/core/pcm_dmaengine.c
+++ b/sound/core/pcm_dmaengine.c
@@ -148,10 +148,12 @@ static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 	enum dma_transfer_direction direction;
 	unsigned long flags = DMA_CTRL_ACK;
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit\n");
 	direction = snd_pcm_substream_to_dma_direction(substream);
 
 	if (!substream->runtime->no_period_wakeup)
 		flags |= DMA_PREP_INTERRUPT;
+	printk("JDS - dmaengine_pcm_prepare_and_submit a\n");
 
 	prtd->pos = 0;
 	desc = dmaengine_prep_dma_cyclic(chan,
@@ -159,13 +161,16 @@ static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 		snd_pcm_lib_buffer_bytes(substream),
 		snd_pcm_lib_period_bytes(substream), direction, flags);
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit b\n");
 	if (!desc)
 		return -ENOMEM;
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit c\n");
 	desc->callback = dmaengine_pcm_dma_complete;
 	desc->callback_param = substream;
 	prtd->cookie = dmaengine_submit(desc);
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit d\n");
 	return 0;
 }
 
@@ -185,12 +190,17 @@ int snd_dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int ret;
 
+	printk("JDS = snd_dmaengine_pcm_trigger cmd %d prtd %p runtime %p\n", cmd, prtd, runtime);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
+	printk("JDS = snd_dmaengine_pcm_trigger a\n");
 		ret = dmaengine_pcm_prepare_and_submit(substream);
+	printk("JDS = snd_dmaengine_pcm_trigger b\n");
 		if (ret)
 			return ret;
+	printk("JDS = snd_dmaengine_pcm_trigger c\n");
 		dma_async_issue_pending(prtd->dma_chan);
+	printk("JDS = snd_dmaengine_pcm_trigger d\n");
 		break;
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
@@ -212,6 +222,7 @@ int snd_dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		return -EINVAL;
 	}
 
+	printk("JDS = snd_dmaengine_pcm_trigger f\n");
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_dmaengine_pcm_trigger);
diff --git a/sound/soc/soc-generic-dmaengine-pcm.c b/sound/soc/soc-generic-dmaengine-pcm.c
index 4440d49..f64f2f4 100644
--- a/sound/soc/soc-generic-dmaengine-pcm.c
+++ b/sound/soc/soc-generic-dmaengine-pcm.c
@@ -68,13 +68,16 @@ int snd_dmaengine_pcm_prepare_slave_config(struct snd_pcm_substream *substream,
 	printk("JDS - snd_dmaengine_pcm_prepare_slave_config\n");
 	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config 1\n");
 	ret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);
 	if (ret)
 		return ret;
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config 2\n");
 	snd_dmaengine_pcm_set_config_from_dai_data(substream, dma_data,
 		slave_config);
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config 3\n");
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_dmaengine_pcm_prepare_slave_config);
@@ -91,7 +94,7 @@ static int dmaengine_pcm_hw_params(struct snd_pcm_substream *substream,
 	struct dma_slave_config slave_config;
 	int ret;
 
-	printk("JDS - dmaengine_pcm_hw_params\n");
+	printk("JDS - dmaengine_pcm_hw_params pcm %p\n", pcm);
 	memset(&slave_config, 0, sizeof(slave_config));
 
 	if (!pcm->config)
@@ -109,6 +112,7 @@ static int dmaengine_pcm_hw_params(struct snd_pcm_substream *substream,
 			return ret;
 	}
 
+	printk("JDS - dmaengine_pcm_hw_params ret\n");
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
 }
 
@@ -123,13 +127,14 @@ static int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substrea
 	struct snd_pcm_hardware hw;
 	int ret;
 
-	printk("JDS - dmaengine_pcm_set_runtime_hwparams\n");
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams pcm %p\n", pcm);
 	if (pcm->config && pcm->config->pcm_hardware)
 		return snd_soc_set_runtime_hwparams(substream,
 				pcm->config->pcm_hardware);
 
 	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams dma_data %p\n", dma_data);
 	memset(&hw, 0, sizeof(hw));
 	hw.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
 			SNDRV_PCM_INFO_INTERLEAVED;
@@ -140,6 +145,7 @@ static int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substrea
 	hw.buffer_bytes_max = SIZE_MAX;
 	hw.fifo_size = dma_data->fifo_size;
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams dma_data 2  %p\n", dma_data);
 	if (pcm->flags & SND_DMAENGINE_PCM_FLAG_NO_RESIDUE)
 		hw.info |= SNDRV_PCM_INFO_BATCH;
 
@@ -151,6 +157,7 @@ static int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substrea
 			hw.info |= SNDRV_PCM_INFO_BATCH;
 	}
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams dma_data 3 %p\n", dma_data);
 	return snd_soc_set_runtime_hwparams(substream, &hw);
 }
 
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
index 86f7223..c15cb8b 100644
--- a/sound/soc/sunxi/Makefile
+++ b/sound/soc/sunxi/Makefile
@@ -1,4 +1,4 @@
 obj-$(CONFIG_SND_SUNXI_SOC_CODEC) += sunxi-codec.o
-obj-$(CONFIG_SND_SUNXI_SOC_CODEC_JDS) += sunxi_codec_main.o sunxi_codec_dma.o
+obj-$(CONFIG_SND_SUNXI_SOC_CODEC_JDS) += sunxi_codec_main.o
 
 
diff --git a/sound/soc/sunxi/sunxi-codec.h b/sound/soc/sunxi/sunxi-codec.h
index 78380dc..7a0a898 100644
--- a/sound/soc/sunxi/sunxi-codec.h
+++ b/sound/soc/sunxi/sunxi-codec.h
@@ -144,18 +144,15 @@ enum sunxi_device_id {SUN4A, SUN4I, SUN5I, SUN7I};
 
 extern int devm_sunxi_pcm_platform_register(struct platform_device *pdev);
 
+struct sunxi_params {
+	u32 rate;
+	u32 core_freq;
+	u32 mute;
+};
+
 /* Structure/enum declaration ------------------------------- */
 struct card_data {
-//	struct device *dev; /* parent device */
-//	struct resource *codec_base_res; /* resources found */
-//	struct resource *codec_base_req; /* resources found */
-
-//	spinlock_t lock;
-
-//	long samplerate;
-//	struct snd_card *card;
-//	struct snd_pcm *pcm;
-	
+	struct sunxi_params saved_params;
 	enum sunxi_device_id id;
 	struct dma_chan		*rx_dma_chan;
 	struct dma_chan		*tx_dma_chan;
@@ -163,6 +160,7 @@ struct card_data {
 	unsigned int codec_phys;
 	void  __iomem *baseaddr;
 	struct clk *codec_apbclk, *codec_pll2clk, *codec_moduleclk;
+	u32 running;
 };
 
 #endif
diff --git a/sound/soc/sunxi/sunxi_codec_codec.c b/sound/soc/sunxi/sunxi_codec_codec.c
deleted file mode 100644
index a078aa3..0000000
--- a/sound/soc/sunxi/sunxi_codec_codec.c
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * ALSA SoC SPDIF DIT driver
- *
- *  This driver is used by controllers which can operate in DIT (SPDI/F) where
- *  no codec is needed.  This file provides stub codec that can be used
- *  in these configurations. TI DaVinci Audio controller uses this driver.
- *
- * Author:      Steve Chen,  <schen@mvista.com>
- * Copyright:   (C) 2009 MontaVista Software, Inc., <source@mvista.com>
- * Copyright:   (C) 2009  Texas Instruments, India
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/slab.h>
-#include <sound/soc.h>
-#include <sound/pcm.h>
-#include <sound/initval.h>
-#include <linux/of.h>
-
-#define DRV_NAME "spdif-dit"
-
-#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
-#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
-			SNDRV_PCM_FMTBIT_S20_3LE | \
-			SNDRV_PCM_FMTBIT_S24_LE)
-
-static const struct snd_soc_dapm_widget dit_widgets[] = {
-	SND_SOC_DAPM_OUTPUT("spdif-out"),
-};
-
-static const struct snd_soc_dapm_route dit_routes[] = {
-	{ "spdif-out", NULL, "Playback" },
-};
-
-static struct snd_soc_codec_driver soc_codec_spdif_dit = {
-	.dapm_widgets = dit_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(dit_widgets),
-	.dapm_routes = dit_routes,
-	.num_dapm_routes = ARRAY_SIZE(dit_routes),
-};
-
-static struct snd_soc_dai_driver dit_stub_dai = {
-	.name		= "dit-hifi",
-	.playback 	= {
-		.stream_name	= "Playback",
-		.channels_min	= 1,
-		.channels_max	= 384,
-		.rates		= STUB_RATES,
-		.formats	= STUB_FORMATS,
-	},
-};
-
-static int spdif_dit_probe(struct platform_device *pdev)
-{
-	return snd_soc_register_codec(&pdev->dev, &soc_codec_spdif_dit,
-			&dit_stub_dai, 1);
-}
-
-static int spdif_dit_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_codec(&pdev->dev);
-	return 0;
-}
-
-#ifdef CONFIG_OF
-static const struct of_device_id spdif_dit_dt_ids[] = {
-	{ .compatible = "linux,spdif-dit", },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, spdif_dit_dt_ids);
-#endif
-
-static struct platform_driver spdif_dit_driver = {
-	.probe		= spdif_dit_probe,
-	.remove		= spdif_dit_remove,
-	.driver		= {
-		.name	= DRV_NAME,
-		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(spdif_dit_dt_ids),
-	},
-};
-
-module_platform_driver(spdif_dit_driver);
-
-MODULE_AUTHOR("Steve Chen <schen@mvista.com>");
-MODULE_DESCRIPTION("SPDIF dummy codec driver");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/sunxi/sunxi_codec_dma.c b/sound/soc/sunxi/sunxi_codec_dma.c
deleted file mode 100644
index f633535..0000000
--- a/sound/soc/sunxi/sunxi_codec_dma.c
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * Copyright (C) ST-Ericsson SA 2012
- *
- * Author: Ola Lilja <ola.o.lilja@stericsson.com>,
- *         Roger Nilsson <roger.xr.nilsson@stericsson.com>
- *         for ST-Ericsson.
- *
- * License terms:
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- */
-
-#include <asm/page.h>
-
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-#include <linux/dmaengine.h>
-#include <linux/slab.h>
-#include <linux/platform_data/dma-ste-dma40.h>
-
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/dmaengine_pcm.h>
-
-#include "sunxi-codec.h"
-
-#define SUNXI_PLATFORM_PERIODS_BYTES_MIN	128
-#define SUNXI_PLATFORM_PERIODS_BYTES_MAX	(64 * PAGE_SIZE)
-#define SUNXI_PLATFORM_PERIODS_MIN		2
-#define SUNXI_PLATFORM_PERIODS_MAX		48
-#define SUNXI_PLATFORM_BUFFER_BYTES_MAX		(2048 * PAGE_SIZE)
-
-static const struct snd_pcm_hardware sunxi_pcm_hw = {
-	.info = SNDRV_PCM_INFO_INTERLEAVED |
-		SNDRV_PCM_INFO_MMAP |
-		SNDRV_PCM_INFO_RESUME |
-		SNDRV_PCM_INFO_PAUSE,
-	.buffer_bytes_max = SUNXI_PLATFORM_BUFFER_BYTES_MAX,
-	.period_bytes_min = SUNXI_PLATFORM_PERIODS_BYTES_MIN,
-	.period_bytes_max = SUNXI_PLATFORM_PERIODS_BYTES_MAX,
-	.periods_min = SUNXI_PLATFORM_PERIODS_MIN,
-	.periods_max = SUNXI_PLATFORM_PERIODS_MAX,
-};
-
-static struct dma_chan *sunxi_pcm_request_chan(struct snd_soc_pcm_runtime *rtd,
-	struct snd_pcm_substream *substream)
-{
-	struct snd_soc_dai *dai = rtd->cpu_dai;
-	u16 per_data_width, mem_data_width;
-//jds	struct stedma40_chan_cfg *dma_cfg;
-	struct sunxi_codec_dma_params *dma_params;
-
-	printk("JDS - sunxi_pcm_request_chan\n");
-
-#ifdef JDS
-	/* DMA */
-	priv->tx_dma_chan = dma_request_slave_channel_reason(&pdev->dev, "tx");
-	if (IS_ERR(priv->tx_dma_chan)) {
-		dev_err(dev, "Unable to acquire DMA channel TX\n");
-		ret = PTR_ERR(priv->tx_dma_chan);
-		goto err_free_master;
-	}
-
-	dma_sconfig.direction = DMA_MEM_TO_DEV;
-	dma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-	dma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-	dma_sconfig.dst_addr = priv->codec_phys + SUNXI_DAC_TXDATA;
-	dma_sconfig.src_maxburst = 1;
-	dma_sconfig.dst_maxburst = 1;
-
-	ret = dmaengine_slave_config(priv->tx_dma_chan, &dma_sconfig);
-	if (ret) {
-		dev_err(dev, "Unable to configure TX DMA slave\n");
-		goto err_tx_dma_release;
-	}
-
-	priv->rx_dma_chan = dma_request_slave_channel_reason(&pdev->dev, "rx");
-	if (IS_ERR(priv->rx_dma_chan)) {
-		dev_err(dev, "Unable to acquire DMA channel RX\n");
-		ret = PTR_ERR(priv->rx_dma_chan);
-		goto err_tx_dma_release;
-	}
-
-	dma_sconfig.direction = DMA_DEV_TO_MEM;
-	dma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-	dma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-	dma_sconfig.src_addr = priv->codec_phys + SUNXI_ADC_RXDATA;
-	dma_sconfig.src_maxburst = 1;
-	dma_sconfig.dst_maxburst = 1;
-
-	ret = dmaengine_slave_config(priv->rx_dma_chan, &dma_sconfig);
-	if (ret) {
-		dev_err(dev, "Unable to configure RX DMA slave\n");
-		goto err_rx_dma_release;
-	}
-#endif
-	dma_params = snd_soc_dai_get_dma_data(dai, substream);
-//JDS	dma_cfg = dma_params->dma_cfg;
-
-	mem_data_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-
-	switch (dma_params->data_size) {
-	case 32:
-		per_data_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-		break;
-	case 16:
-		per_data_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-		break;
-	case 8:
-		per_data_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
-		break;
-	default:
-		per_data_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	}
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-//JDS		dma_cfg->src_info.data_width = mem_data_width;
-//JDS		dma_cfg->dst_info.data_width = per_data_width;
-	} else {
-//JDS		dma_cfg->src_info.data_width = per_data_width;
-//JDS		dma_cfg->dst_info.data_width = mem_data_width;
-	}
-
-//JDS	return snd_dmaengine_pcm_request_channel(stedma40_filter, dma_cfg);
-	printk("JDS - sunxi_pcm_request_chan ret\n");
-	return 0;
-}
-
-static int sunxi_pcm_prepare_slave_config(struct snd_pcm_substream *substream,
-		struct snd_pcm_hw_params *params,
-		struct dma_slave_config *slave_config)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct card_data *priv = rtd->cpu_dai->dev->platform_data;
-	struct snd_dmaengine_dai_dma_data *snd_dma_params;
-	struct sunxi_msp_dma_params *ste_dma_params;
-	dma_addr_t dma_addr;
-	int ret;
-
-	printk("JDS - sunxi_pcm_prepare_slave_config\n");
-	ret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);
-	if (ret)
-		return ret;
-	
-	slave_config->src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-	slave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-	slave_config->src_maxburst = 1;
-	slave_config->dst_maxburst = 1;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		slave_config->direction = DMA_MEM_TO_DEV;
-		slave_config->dst_addr = priv->codec_phys + SUNXI_DAC_TXDATA;
-	} else {
-		slave_config->direction = DMA_DEV_TO_MEM;
-		slave_config->src_addr = priv->codec_phys + SUNXI_ADC_RXDATA;
-	}
-
-	printk("JDS - sunxi_pcm_prepare_slave_config ret\n");
-	return 0;
-}
-
-static const struct snd_dmaengine_pcm_config sunxi_dmaengine_pcm_config = {
-	.pcm_hardware = &sunxi_pcm_hw,
-	.compat_request_channel = sunxi_pcm_request_chan,
-	.prealloc_buffer_size = 128 * 1024,
-	.prepare_slave_config = sunxi_pcm_prepare_slave_config,
-};
-
-static const struct snd_dmaengine_pcm_config sunxi_dmaengine_of_pcm_config = {
-	.compat_request_channel = sunxi_pcm_request_chan,
-	.prepare_slave_config = sunxi_pcm_prepare_slave_config,
-};
-
-int devm_sunxi_pcm_platform_register(struct platform_device *pdev)
-{
-	const struct snd_dmaengine_pcm_config *pcm_config;
-	struct device_node *np = pdev->dev.of_node;
-	int ret;
-
-	printk("JDS - devm_sunxi_pcm_platform_register\n");
-	if (np)
-		pcm_config = &sunxi_dmaengine_of_pcm_config;
-	else
-		pcm_config = &sunxi_dmaengine_pcm_config;
-
-	ret = snd_dmaengine_pcm_register(&pdev->dev, pcm_config,
-					 SND_DMAENGINE_PCM_FLAG_NO_RESIDUE);
-	if (ret < 0) {
-		dev_err(&pdev->dev,
-			"%s: ERROR: Failed to register platform '%s' (%d)!\n",
-			__func__, pdev->name, ret);
-		return ret;
-	}
-
-	printk("JDS - devm_sunxi_pcm_platform_register ret\n");
-	return 0;
-}
-EXPORT_SYMBOL_GPL(devm_sunxi_pcm_platform_register);
-
-int sunxi_pcm_unregister_platform(struct platform_device *pdev)
-{
-	snd_dmaengine_pcm_unregister(&pdev->dev);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(sunxi_pcm_unregister_platform);
diff --git a/sound/soc/sunxi/sunxi_codec_main.c b/sound/soc/sunxi/sunxi_codec_main.c
index 00a5f98..a0df55d 100644
--- a/sound/soc/sunxi/sunxi_codec_main.c
+++ b/sound/soc/sunxi/sunxi_codec_main.c
@@ -25,56 +25,40 @@
 #include <sound/soc.h>
 #include "sunxi-codec.h"
 
-struct sunxi_params {
-	u32 rate;
-	u32 core_freq;
-	u32 mute;
-};
-
-struct sunxi_dev {
-	struct clk *clk;
-	struct sunxi_codec_dma_params dma_params;
-	struct sunxi_params saved_params;
-	u32 running;
-	void __iomem *io_base;
-	struct snd_dmaengine_dai_dma_data dma_params_tx;
-	struct snd_dmaengine_pcm_config config;
-};
 
-
-static void sunxi_configure(struct sunxi_dev *host)
+static void sunxi_configure(struct card_data *priv)
 {
 #ifdef JDS
-	writel(sunxi_RESET, host->io_base + sunxi_SOFT_RST);
+	writel(sunxi_RESET, priv->io_base + sunxi_SOFT_RST);
 	mdelay(1);
-	writel(readl(host->io_base + sunxi_SOFT_RST) & ~sunxi_RESET,
-			host->io_base + sunxi_SOFT_RST);
+	writel(readl(priv->io_base + sunxi_SOFT_RST) & ~sunxi_RESET,
+			priv->io_base + sunxi_SOFT_RST);
 
 	writel(sunxi_FDMA_TRIG_16 | sunxi_MEMFMT_16_16 |
 			sunxi_VALID_HW | sunxi_USER_HW |
 			sunxi_CHNLSTA_HW | sunxi_PARITY_HW,
-			host->io_base + sunxi_CFG);
+			priv->io_base + sunxi_CFG);
 
-	writel(0x7F, host->io_base + sunxi_INT_STA_CLR);
-	writel(0x7F, host->io_base + sunxi_INT_EN_CLR);
+	writel(0x7F, priv->io_base + sunxi_INT_STA_CLR);
+	writel(0x7F, priv->io_base + sunxi_INT_EN_CLR);
 #endif 
 }
 
 static int sunxi_startup(struct snd_pcm_substream *substream,
 		struct snd_soc_dai *cpu_dai)
 {
-	struct sunxi_dev *host = snd_soc_dai_get_drvdata(cpu_dai);
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
 	int ret;
 
 	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
 		return -EINVAL;
 
-	ret = clk_enable(host->clk);
+	ret = clk_enable(priv->codec_moduleclk);
 	if (ret)
 		return ret;
 
-	host->running = true;
-	sunxi_configure(host);
+	priv->running = true;
+	sunxi_configure(priv);
 
 	return 0;
 }
@@ -82,27 +66,27 @@ static int sunxi_startup(struct snd_pcm_substream *substream,
 static void sunxi_shutdown(struct snd_pcm_substream *substream,
 		struct snd_soc_dai *dai)
 {
-	struct sunxi_dev *host = snd_soc_dai_get_drvdata(dai);
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
 
 	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
 		return;
 
-	clk_disable(host->clk);
-	host->running = false;
+	clk_disable(priv->codec_moduleclk);
+	priv->running = false;
 }
 
-static void sunxi_clock(struct sunxi_dev *host, u32 core_freq,
+static void sunxi_clock(struct card_data *priv, u32 core_freq,
 		u32 rate)
 {
 #ifdef JDS
 	u32 divider, ctrl;
-	clk_set_rate(host->clk, core_freq);
-	divider = DIV_ROUND_CLOSEST(clk_get_rate(host->clk), (rate * 128));
+	clk_set_rate(priv->clk, core_freq);
+	divider = DIV_ROUND_CLOSEST(clk_get_rate(priv->clk), (rate * 128));
 
-	ctrl = readl(host->io_base + sunxi_CTRL);
+	ctrl = readl(priv->io_base + sunxi_CTRL);
 	ctrl &= ~codec_DIVIDER_MASK;
 	ctrl |= (divider << codec_DIVIDER_SHIFT) & codec_DIVIDER_MASK;
-	writel(ctrl, host->io_base + sunxi_CTRL);
+	writel(ctrl, priv->io_base + sunxi_CTRL);
 #endif
 }
 
@@ -110,7 +94,7 @@ static int sunxi_hw_params(struct snd_pcm_substream *substream,
 		struct snd_pcm_hw_params *params,
 		struct snd_soc_dai *dai)
 {
-	struct sunxi_dev *host = snd_soc_dai_get_drvdata(dai);
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
 	u32 rate, core_freq;
 
 	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
@@ -145,9 +129,9 @@ static int sunxi_hw_params(struct snd_pcm_substream *substream,
 		break;
 	}
 
-	sunxi_clock(host, core_freq, rate);
-	host->saved_params.core_freq = core_freq;
-	host->saved_params.rate = rate;
+	sunxi_clock(priv, core_freq, rate);
+	priv->saved_params.core_freq = core_freq;
+	priv->saved_params.rate = rate;
 
 	return 0;
 }
@@ -156,7 +140,7 @@ static int sunxi_trigger(struct snd_pcm_substream *substream, int cmd,
 		struct snd_soc_dai *dai)
 {
 #ifdef JDS
-	struct sunxi_dev *host = snd_soc_dai_get_drvdata(dai);
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
 	u32 ctrl;
 #endif
 	int ret = 0;
@@ -169,14 +153,14 @@ static int sunxi_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 #ifdef JDS		
-			ctrl = readl(host->io_base + sunxi_CTRL);
+			ctrl = readl(priv->io_base + sunxi_CTRL);
 			ctrl &= ~codec_OPMODE_MASK;
-			if (!host->saved_params.mute)
+			if (!priv->saved_params.mute)
 				ctrl |= codec_OPMODE_AUD_DATA |
 					codec_STATE_NORMAL;
 			else
 				ctrl |= codec_OPMODE_MUTE_PCM;
-			writel(ctrl, host->io_base + sunxi_CTRL);
+			writel(ctrl, priv->io_base + sunxi_CTRL);
 #endif
 		break;
 
@@ -184,10 +168,10 @@ static int sunxi_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 #ifdef JDS		
-		ctrl = readl(host->io_base + sunxi_CTRL);
+		ctrl = readl(priv->io_base + sunxi_CTRL);
 		ctrl &= ~codec_OPMODE_MASK;
 		ctrl |= codec_OPMODE_OFF;
-		writel(ctrl, host->io_base + sunxi_CTRL);
+		writel(ctrl, priv->io_base + sunxi_CTRL);
 #endif
 		break;
 
@@ -201,23 +185,23 @@ static int sunxi_trigger(struct snd_pcm_substream *substream, int cmd,
 static int sunxi_digital_mute(struct snd_soc_dai *dai, int mute)
 {
 #ifdef JDS
-	struct sunxi_dev *host = snd_soc_dai_get_drvdata(dai);
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
 	u32 val;
 
-	host->saved_params.mute = mute;
-	val = readl(host->io_base + sunxi_CTRL);
+	priv->saved_params.mute = mute;
+	val = readl(priv->io_base + sunxi_CTRL);
 	val &= ~codec_OPMODE_MASK;
 
 	if (mute)
 		val |= codec_OPMODE_MUTE_PCM;
 	else {
-		if (host->running)
+		if (priv->running)
 			val |= codec_OPMODE_AUD_DATA | codec_STATE_NORMAL;
 		else
 			val |= codec_OPMODE_OFF;
 	}
 
-	writel(val, host->io_base + sunxi_CTRL);
+	writel(val, priv->io_base + sunxi_CTRL);
 #endif
 	return 0;
 }
@@ -226,9 +210,9 @@ static int codec_mute_get(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
-	struct sunxi_dev *host = snd_soc_dai_get_drvdata(cpu_dai);
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
 
-	ucontrol->value.integer.value[0] = host->saved_params.mute;
+	ucontrol->value.integer.value[0] = priv->saved_params.mute;
 	return 0;
 }
 
@@ -236,9 +220,9 @@ static int codec_mute_put(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
-	struct sunxi_dev *host = snd_soc_dai_get_drvdata(cpu_dai);
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
 
-	if (host->saved_params.mute == ucontrol->value.integer.value[0])
+	if (priv->saved_params.mute == ucontrol->value.integer.value[0])
 		return 0;
 
 	sunxi_digital_mute(cpu_dai, ucontrol->value.integer.value[0]);
@@ -252,10 +236,32 @@ static const struct snd_kcontrol_new sunxi_controls[] = {
 
 static int sunxi_soc_dai_probe(struct snd_soc_dai *dai)
 {
-	struct sunxi_dev *host = snd_soc_dai_get_drvdata(dai);
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	struct snd_dmaengine_dai_dma_data *playback_dma_data;
+	struct snd_dmaengine_dai_dma_data *capture_dma_data;
+
+	playback_dma_data = devm_kzalloc(dai->dev,
+					 sizeof(*playback_dma_data),
+					 GFP_KERNEL);
+	if (!playback_dma_data)
+		return -ENOMEM;
+
+	capture_dma_data = devm_kzalloc(dai->dev,
+					sizeof(*capture_dma_data),
+					GFP_KERNEL);
+	if (!capture_dma_data)
+		return -ENOMEM;
+
+	playback_dma_data->addr = priv->codec_phys + SUNXI_DAC_TXDATA;
+	capture_dma_data->addr = priv->codec_phys + SUNXI_ADC_RXDATA;
+
+	playback_dma_data->maxburst = 4;
+	capture_dma_data->maxburst = 4;
+
+	playback_dma_data->addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	playback_dma_data->addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 
-	host->dma_params_tx.filter_data = &host->dma_params;
-	dai->playback_dma_data = &host->dma_params_tx;
+	snd_soc_dai_init_dma_data(dai, playback_dma_data, capture_dma_data);
 
 	return snd_soc_add_dai_controls(dai, sunxi_controls,
 				ARRAY_SIZE(sunxi_controls));
@@ -414,7 +420,7 @@ static int sunxi_codec_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	ret =  devm_sunxi_pcm_platform_register(pdev);
+	snd_dmaengine_pcm_register(&pdev->dev, NULL, SND_DMAENGINE_PCM_FLAG_NO_RESIDUE);
 	printk("JDS - codec driver success registered\n");
 	return ret;
 
@@ -426,10 +432,10 @@ exit_clkdisable_apb_clk:
 static int snd_sunxi_codec_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct sunxi_dev *host = dev_get_drvdata(&pdev->dev);
+	struct card_data *priv = dev_get_drvdata(&pdev->dev);
 
-	if (host->running)
-		clk_disable(host->clk);
+	if (priv->running)
+		clk_disable(priv->codec_moduleclk);
 
 	return 0;
 }
@@ -437,13 +443,13 @@ static int snd_sunxi_codec_suspend(struct device *dev)
 static int snd_sunxi_codec_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct sunxi_dev *host = dev_get_drvdata(&pdev->dev);
+	struct card_data *priv = dev_get_drvdata(&pdev->dev);
 
-	if (host->running) {
-		clk_enable(host->clk);
-		sunxi_configure(host);
-		sunxi_clock(host, host->saved_params.core_freq,
-				host->saved_params.rate);
+	if (priv->running) {
+		clk_enable(priv->codec_moduleclk);
+		sunxi_configure(priv);
+		sunxi_clock(priv, priv->saved_params.core_freq,
+				priv->saved_params.rate);
 	}
 	return 0;
 }
@@ -458,7 +464,7 @@ static SIMPLE_DEV_PM_OPS(sunxi_dev_pm_ops, snd_sunxi_codec_suspend, \
 
 #endif
 
-static int sunxi_codec_remove(struct platform_device *devptr)
+static int sunxi_codec_remove(struct platform_device *pdev)
 {
 #ifdef JDS
 	clk_disable(codec_moduleclk);
@@ -471,6 +477,7 @@ static int sunxi_codec_remove(struct platform_device *devptr)
 	platform_set_drvdata(devptr, NULL);
 #endif
 	return 0;
+	snd_dmaengine_pcm_unregister(&pdev->dev);
 }
 
 static void sunxi_codec_shutdown(struct platform_device *devptr)
