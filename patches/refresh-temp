Bottom: db303d9f333cd93ee88ae7b680e325ddc00531fa
Top:    0b6979bf5a2206487589eed63b5eb44cbfa10ebe
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-07-03 15:14:06 -0400

Refresh of initial-sound-driver-port

---

diff --git a/drivers/dma/sun4i-dma.c b/drivers/dma/sun4i-dma.c
index a23b176..e6b6196 100644
--- a/drivers/dma/sun4i-dma.c
+++ b/drivers/dma/sun4i-dma.c
@@ -8,6 +8,8 @@
  * (at your option) any later version.
  */
 
+#define DEBUG
+
 #include <linux/bitmap.h>
 #include <linux/bitops.h>
 #include <linux/clk.h>
@@ -22,6 +24,9 @@
 
 #include "virt-dma.h"
 
+#define writel_relaxedx(x, y) {printk("JDS DMA - reg %p val %08lx\n", y, (long)x);writel_relaxed(x, y);}
+#define writelx(x, y) {printk("JDS DMA - reg %p val %08lx\n", y, (long)x);writel(x, y);}
+
 /** General DMA register values **/
 
 /* DMA source/destination burst length values */
@@ -298,12 +303,14 @@ static struct sun4i_dma_pchan *find_and_use_pchan(struct sun4i_ddma_dev *priv,
 		max = NDMA_NR_MAX_CHANNELS;
 	}
 
+	printk("JDS DMA find_and_use_pchan\n");
 	for_each_clear_bit_from(i, &priv->pchans_used, max) {
 		pchan = &pchans[i];
 		pchan->vchan = vchan;
 		set_bit(i, priv->pchans_used);
 		break;
 	}
+	printk("JDS DMA find_and_use_pchan %p\n", pchan);
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 
@@ -329,25 +336,25 @@ static void configure_pchan(struct sun4i_dma_pchan *pchan,
 {
 	if (pchan->is_dedicated) {
 		/* Configure addresses and misc parameters */
-		writel_relaxed(d->src, pchan->base + DDMA_SRC_ADDR_REG);
-		writel_relaxed(d->dst, pchan->base + DDMA_DEST_ADDR_REG);
-		writel_relaxed(d->len, pchan->base + DDMA_BYTE_COUNT_REG);
-		writel_relaxed(d->para, pchan->base + DDMA_PARA_REG);
+		writel_relaxedx(d->src, pchan->base + DDMA_SRC_ADDR_REG);
+		writel_relaxedx(d->dst, pchan->base + DDMA_DEST_ADDR_REG);
+		writel_relaxedx(d->len, pchan->base + DDMA_BYTE_COUNT_REG);
+		writel_relaxedx(d->para, pchan->base + DDMA_PARA_REG);
 
 		/* We use a writel here because CFG_LOADING may be set,
 		 * and it requires that the rest of the configuration
 		 * takes place before the engine is started */
-		writel(d->cfg, pchan->base + DDMA_CFG_REG);
+		writelx(d->cfg, pchan->base + DDMA_CFG_REG);
 	} else {
 		/* Configure addresses and misc parameters */
-		writel_relaxed(d->src, pchan->base + NDMA_SRC_ADDR_REG);
-		writel_relaxed(d->dst, pchan->base + NDMA_DEST_ADDR_REG);
-		writel_relaxed(d->len, pchan->base + NDMA_BYTE_COUNT_REG);
+		writel_relaxedx(d->src, pchan->base + NDMA_SRC_ADDR_REG);
+		writel_relaxedx(d->dst, pchan->base + NDMA_DEST_ADDR_REG);
+		writel_relaxedx(d->len, pchan->base + NDMA_BYTE_COUNT_REG);
 
 		/* We use a writel here because CFG_LOADING may be set,
 		 * and it requires that the rest of the configuration
 		 * takes place before the engine is started */
-		writel(d->cfg, pchan->base + NDMA_CFG_REG);
+		writelx(d->cfg, pchan->base + NDMA_CFG_REG);
 	}
 }
 
@@ -370,7 +377,7 @@ static void set_pchan_interrupt(struct sun4i_ddma_dev *priv,
 	else
 		reg &= ~BIT(pchan_number*2 + 1);
 
-	writel(reg, priv->base + DMA_IRQ_ENABLE_REG);
+	writelx(reg, priv->base + DMA_IRQ_ENABLE_REG);
 }
 
 static int execute_vchan_pending(struct sun4i_ddma_dev *priv,
@@ -404,8 +411,8 @@ static int execute_vchan_pending(struct sun4i_ddma_dev *priv,
 		/* Figure out which contract we're working with today */
 		vd = vchan_next_desc(&vchan->vc);
 		if (!vd) {
-			dev_dbg(chan2dev(&vchan->vc.chan),
-				"No pending contract found");
+//			dev_dbg(chan2dev(&vchan->vc.chan),
+//				"No pending contract found");
 			ret = 0;
 			goto release_pchan;
 		}
@@ -420,6 +427,8 @@ static int execute_vchan_pending(struct sun4i_ddma_dev *priv,
 		}
 	} while (list_empty(&contract->demands));
 
+	printk("JDS DMA execute_vchan_pending\n");
+
 	/* Now find out what we need to do */
 	promise = list_first_entry(&contract->demands, struct sun4i_ddma_promise, list);
 	vchan->processing = promise;
@@ -427,6 +436,7 @@ static int execute_vchan_pending(struct sun4i_ddma_dev *priv,
 
 	/* ... and make it reality */
 	if (promise) {
+		printk("JDS DMA execute_vchan_pending reality %p\n", vchan->pchan);
 		vchan->contract = contract;
 		set_pchan_interrupt(priv, pchan, 0, 1);
 		configure_pchan(pchan, promise);
@@ -787,20 +797,25 @@ static void sun4i_ddma_terminate_all(struct sun4i_dma_vchan *vchan)
 	unsigned long flags;
 	u32 d_busy = DDMA_CFG_LOADING | DDMA_CFG_BUSY;
 	u32 n_busy = NDMA_CFG_LOADING;
-
+	size_t bytes = 0;
 
 	spin_lock_irqsave(&vchan->vc.lock, flags);
 	vchan_get_all_descriptors(&vchan->vc, &head);
 	spin_unlock_irqrestore(&vchan->vc.lock, flags);
 
+	printk("JDS DMA -sun4i_ddma_terminate_all pchan %p\n", pchan); 
 	/* If this vchan is operating, wait until it's no longer busy */
 	if (pchan) {
 		if (pchan->is_dedicated) {
 			while (readl(pchan->base + DDMA_CFG_REG) & d_busy)
 				;
 		} else {
-			while (readl(pchan->base + NDMA_CFG_REG) & n_busy)
-				;
+			bytes = readl(pchan->base + NDMA_BYTE_COUNT_REG);
+			printk("JDS DMA -sun4i_ddma_terminate_all %x\n", bytes); 
+			while (readl(pchan->base + NDMA_CFG_REG) & n_busy) {
+				bytes = readl(pchan->base + NDMA_BYTE_COUNT_REG);
+				printk("JDS DMA -sun4i_ddma_terminate_all loop %x\n", bytes); 
+			};
 		}
 	}
 
@@ -883,6 +898,8 @@ static enum dma_status sun4i_dma_tx_status(struct dma_chan *chan,
 	enum dma_status ret;
 	size_t bytes = 0;
 
+
+	printk("JDS DMA sun4i_dma_tx_status\n");
 	ret = dma_cookie_status(chan, cookie, state);
 	if (ret == DMA_COMPLETE)
 		return ret;
@@ -941,6 +958,7 @@ static irqreturn_t sun4i_ddma_interrupt(int irq, void *dev_id)
 	unsigned long pendirq, irqs;
 	int bit;
 
+	printk("JDS - sun4i_ddma_interrupt\n");
 	pendirq = readl_relaxed(priv->base + DMA_IRQ_PENDING_STATUS_REG);
 	irqs = readl_relaxed(priv->base + DMA_IRQ_ENABLE_REG);
 
@@ -966,10 +984,10 @@ static irqreturn_t sun4i_ddma_interrupt(int irq, void *dev_id)
 		}
 	}
 
-	writel_relaxed(irqs, priv->base + DMA_IRQ_ENABLE_REG);
+	writel_relaxedx(irqs, priv->base + DMA_IRQ_ENABLE_REG);
 
 	/* Writing 1 to the pending field will clear the pending interrupt */
-	writel(pendirq, priv->base + DMA_IRQ_PENDING_STATUS_REG);
+	writelx(pendirq, priv->base + DMA_IRQ_PENDING_STATUS_REG);
 
 	tasklet_schedule(&priv->tasklet);
