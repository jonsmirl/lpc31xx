Bottom: 554f64a33f842e136c0d4cdf8740a970f3d80584
Top:    600fcef64230102ed3ce5979f8f8edf258d760c0
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-08-16 14:53:03 -0400

Refresh of pwm

---

diff --git a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
index d68500c..186f862 100644
--- a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
+++ b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
@@ -157,7 +157,7 @@
 			sgtl5000: sgtl5000@a {
 				compatible = "fsl,sgtl5000";
 				reg = <0x0a>;
-				clocks = <&pwm 0>;
+				pwms = <&pwm 0 100 0>;
 
 				#sound-dai-cells = <0>;
 				VDDA-supply = <&reg_vcc3v3>;
@@ -195,6 +195,7 @@
 		};
 
 		dailink0_master: simple-audio-card,codec {
+			system-clock-frequency = <24000000>;
 			sound-dai = <&sgtl5000>;
 		};
 	};
diff --git a/drivers/pwm/pwm-sunxi.c b/drivers/pwm/pwm-sunxi.c
index 72f040e..240d01e 100644
--- a/drivers/pwm/pwm-sunxi.c
+++ b/drivers/pwm/pwm-sunxi.c
@@ -34,6 +34,8 @@
  * MA 02111-1307 USA
  */
 
+#define DEBUG
+
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/err.h>
@@ -148,6 +150,7 @@
 #define SUNXI_PWM_CYCLES_ACTIVE_WIDTH	16
 
 #define MAX_CYCLES 0x0ffff /* max cycle count possible for period active and entire */
+#define OSC24 24L /* 24Mhz system oscillator */
 
 /* Supported SoC families - used for quirks */
 enum sunxi_soc_family {
@@ -160,42 +163,14 @@ enum sunxi_soc_family {
  * structure that defines the pwm control register
  */
 
-enum sun4i_pwm_prescale {
-	PRESCALE_DIV120  = 0x00,  /* Divide 24mhz clock by 120 */
-	PRESCALE_DIV180  = 0x01,
-	PRESCALE_DIV240  = 0x02,
-	PRESCALE_DIV360  = 0x03,
-	PRESCALE_DIV480  = 0x04,
-	PRESCALE_INVx05  = 0x05,
-	PRESCALE_INVx06  = 0x06,
-	PRESCALE_INVx07  = 0x07,
-	PRESCALE_DIV12k  = 0x08,
-	PRESCALE_DIV24k  = 0x09,
-	PRESCALE_DIV36k  = 0x0a,
-	PRESCALE_DIV48k  = 0x0b,
-	PRESCALE_DIV72k  = 0x0c
+static const unsigned int prescale_divisor[] = {
+	120, 180, 240, 360, 480, 480, 480, 480,
+	12000, 24000, 36000, 48000, 72000, 72000, 72000, 1
 };
 
-static const unsigned int prescale_divisor[] = {120,
-						  180,
-						  240,
-						  360,
-						  480,
-						  480, /* Invalid Option */
-						  480, /* Invalid Option */
-						  480, /* Invalid Option */
-						  12000,
-						  24000,
-						  36000,
-						  48000,
-						  72000};
-
-
 struct sunxi_pwm_chip {
 	struct pwm_chip chip;
-	struct clk *clk, *clk_pwm[SUNXI_PWM_CHANNEL_MAX];
-	struct clk_divider pwmclk_div;
-	struct clk_onecell_data clk_data;
+	struct clk *clk;
 	struct regmap *regmap;
 };
 
@@ -204,7 +179,6 @@ static inline struct sunxi_pwm_chip *to_sunxi_chip(struct pwm_chip *chip)
 	return container_of(chip, struct sunxi_pwm_chip, chip);
 }
 
-
 /*
  * Find the best prescale value for the period
  * We want to get the highest period cycle count possible, so we look
@@ -212,89 +186,89 @@ static inline struct sunxi_pwm_chip *to_sunxi_chip(struct pwm_chip *chip)
  * min_optimal_period_cycles.  If none are found then root though again
  * taking anything that works
  */
-enum sun4i_pwm_prescale pwm_get_best_prescale(unsigned long long period_in) 
+int pwm_get_best_prescale(int period_in) 
 {
 	int i;
-	unsigned long period = period_in;
+	unsigned long period = period_in * 1000; /* convert to picoseconds */
+	unsigned long int clk_pico;
 	const unsigned long min_optimal_period_cycles = MAX_CYCLES / 2;
 	const unsigned long min_period_cycles = 0x02;
-	enum sun4i_pwm_prescale best_prescale = 0;
+	int best_prescale = 0;
 
 	best_prescale = -1;
 	for(i = 0 ; i < ARRAY_SIZE(prescale_divisor) ; i++) {
-		unsigned long int check_value = (prescale_divisor[i] / 24);
-		if(check_value < 1 || check_value > period) {
-			break;
+
+		clk_pico = 1000000L * prescale_divisor[i] / OSC24;
+		if(clk_pico < 1 || clk_pico > period) {
+			continue;
 		}
-		if(((period / check_value) >= min_optimal_period_cycles) &&
-			((period / check_value) <= MAX_CYCLES)) {
+		if(((period / clk_pico) >= min_optimal_period_cycles) &&
+			((period / clk_pico) <= MAX_CYCLES)) {
 			best_prescale = i;
-			break;
 		}
 	}
 
 	if(best_prescale > ARRAY_SIZE(prescale_divisor)) {
 		for(i = 0 ; i < ARRAY_SIZE(prescale_divisor) ; i++) {
-			unsigned long int check_value = (prescale_divisor[i] / 24);
-			if(check_value < 1 || check_value > period) {
-				break;
+			clk_pico = 1000000L * prescale_divisor[i] / OSC24;
+			if(clk_pico < 1 || clk_pico > period) {
+				continue;
 			}
-			if(((period / check_value) >= min_period_cycles) &&
-				((period / check_value) <= MAX_CYCLES)) {
+			printk("JDS - period %ld check %ld\n", period, clk_pico);
+			if(((period / clk_pico) >= min_period_cycles) &&
+				((period / clk_pico) <= MAX_CYCLES)) {
 				best_prescale = i;
-				break;
 			}
 		}
 	}
-	if(best_prescale > ARRAY_SIZE(prescale_divisor)) {
-		best_prescale = PRESCALE_DIV480;  /* Something that's not zero - use invalid prescale value */
-	}
+
+	if(best_prescale > ARRAY_SIZE(prescale_divisor))
+		return -EINVAL;
 
 	return best_prescale;
 }
 
 /*
- * return the number of cycles for the channel period computed from the microseconds
+ * return the number of cycles for the channel period computed from the nanoseconds
  * for the period.  Allwinner docs call this "entire" cycles
  */
-unsigned int get_entire_cycles(struct pwm_chip *chip, unsigned int prescale, unsigned int period) 
+unsigned int get_entire_cycles(struct sunxi_pwm_chip *priv, int prescale, int period) 
 {
-	unsigned int entire_cycles = 0x01;
+	unsigned long int clk_pico;
+	unsigned int entire_cycles;
 
-	if ((2 * prescale_divisor[prescale] * MAX_CYCLES) > 0) {
-		entire_cycles = period / (prescale_divisor[prescale] / 24);
-	}
-	if (entire_cycles == 0) {
-		entire_cycles = MAX_CYCLES;
-	}
-	if (entire_cycles > MAX_CYCLES) {
+	clk_pico = 1000000L * prescale_divisor[prescale] / OSC24;
+	entire_cycles = DIV_ROUND_CLOSEST(period * 1000L, clk_pico);
+	if (entire_cycles > MAX_CYCLES)
 		entire_cycles = MAX_CYCLES;
-	}
-	dev_dbg(chip->dev, "Best prescale was %d, entire cycles was %u\n", prescale, entire_cycles);
+	if (entire_cycles < 2)
+		entire_cycles = 2;
+
+	dev_dbg(priv->chip.dev, "Best prescale was %d, entire cycles was %u\n", prescale, entire_cycles);
 
 	return entire_cycles;
 }
 
 /*
- * return the number of cycles for the channel duty computed from the microseconds
+ * return the number of cycles for the channel duty computed from the nanoseconds
  * for the duty.  Allwinner docs call this "active" cycles
  */
-unsigned int get_active_cycles(struct pwm_chip *chip, unsigned int entire_cycles, 
-		unsigned int prescale, unsigned int period) 
+unsigned int get_active_cycles(struct sunxi_pwm_chip *priv, unsigned int entire_cycles, 
+		unsigned int prescale, int duty) 
 {
-	unsigned int active_cycles = 0x01;
-
-	if ((2 * prescale_divisor[prescale] * MAX_CYCLES) > 0) {
-		active_cycles = period / (prescale_divisor[prescale] / 24);
-	}
-	dev_dbg(chip->dev, "Best prescale was %d, active cycles was %u (before entire check)\n", prescale, active_cycles);
+	unsigned long int clk_pico;
+	unsigned int active_cycles;
 
-	if(active_cycles > MAX_CYCLES) {
+	clk_pico = 1000000L * prescale_divisor[prescale] / OSC24;
+	active_cycles = DIV_ROUND_CLOSEST(duty * 1000L, clk_pico);
+	if (active_cycles >= entire_cycles)
 		active_cycles = entire_cycles - 1;
-	}
-	dev_dbg(chip->dev, "Best prescale was %d, active cycles was %u (after  entire check)\n", prescale, active_cycles);
+	if (active_cycles == 0)
+		active_cycles = 1;
 
-	return active_cycles;
+	dev_dbg(priv->chip.dev, "Best prescale was %d, active cycles was %u\n", prescale, active_cycles);
+
+	return entire_cycles;
 }
 
 static int sunxi_pwm_busy(struct sunxi_pwm_chip *priv)
@@ -303,10 +277,12 @@ static int sunxi_pwm_busy(struct sunxi_pwm_chip *priv)
 
 	for (i = 0; i < 50; i++) {
 		regmap_read(priv->regmap, SUNXI_PWM_CTRL_REG, &reg_val);
+		printk("JDS - busy %08x\n", reg_val);
 		if ((reg_val & (SUNXI_PWMCTL_PWM1_NOTRDY | SUNXI_PWMCTL_PWM0_NOTRDY)) == 0)
 			return 0;
 		mdelay(1);
 	}
+	dev_dbg(priv->chip.dev, "PWM busy timeout\n");
 	return -EIO;
 }
 
@@ -315,40 +291,35 @@ static int sunxi_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
 			  int duty_ns, int period_ns)
 {
 	struct sunxi_pwm_chip *priv = to_sunxi_chip(chip);
-	unsigned int period, prescale, duty, entire_cycles, active_cycles, reg_val;
-	int ret;
+	unsigned int prescale, entire_cycles, active_cycles, reg_val;
 
-	period = period_ns / 1000;
-	prescale = pwm_get_best_prescale(period);
-	duty = duty_ns / 1000;
+	printk("JDS - sunxi_pwm_config duty %d period %d\n", duty_ns, period_ns);
+	prescale = pwm_get_best_prescale(period_ns);
+	if (prescale < 0)
+		return prescale;
 
-	entire_cycles = get_entire_cycles(chip, prescale, period);
-	active_cycles = get_active_cycles(chip, entire_cycles, prescale, period);
-	if(entire_cycles >= active_cycles && active_cycles) {
-		entire_cycles = MAX_CYCLES;
-		active_cycles = MAX_CYCLES;
-	}
+	entire_cycles = get_entire_cycles(priv, prescale, period_ns);
+	active_cycles = get_active_cycles(priv, entire_cycles, prescale, duty_ns);
 
-	reg_val = (entire_cycles << SUNXI_PWM_CYCLES_ACTIVE_SHIFT) & SUNXI_PWM_CYCLES_ACTIVE_MASK;
+	reg_val = (entire_cycles << SUNXI_PWM_CYCLES_TOTAL_SHIFT) & SUNXI_PWM_CYCLES_TOTAL_MASK;
 	reg_val = (active_cycles << SUNXI_PWM_CYCLES_ACTIVE_SHIFT) & SUNXI_PWM_CYCLES_ACTIVE_MASK;
 
 	switch (pwm->hwpwm) {
 	case 0:
-		regmap_update_bits(priv->regmap, SUNXI_PWM_CTRL_REG, SUNXI_PWMCTL_PWM0_PRE_MASK, prescale);
+		regmap_update_bits(priv->regmap, SUNXI_PWM_CTRL_REG,
+				SUNXI_PWMCTL_PWM0_PRE_MASK | SUNXI_PWMCTL_PWM0_EN_MASK,
+				prescale << SUNXI_PWMCTL_PWM0_PRE_SHIFT | SUNXI_PWMCTL_PWM0_EN);
 		regmap_write(priv->regmap, SUNXI_PWM_CH0_PERIOD, reg_val);
 		break;
 	case 1:
-		regmap_update_bits(priv->regmap, SUNXI_PWM_CTRL_REG, SUNXI_PWMCTL_PWM1_PRE_MASK, prescale);
+		regmap_update_bits(priv->regmap, SUNXI_PWM_CTRL_REG,
+				SUNXI_PWMCTL_PWM1_PRE_MASK | SUNXI_PWMCTL_PWM1_EN_MASK,
+				prescale << SUNXI_PWMCTL_PWM1_PRE_SHIFT | SUNXI_PWMCTL_PWM1_EN);
 		regmap_write(priv->regmap, SUNXI_PWM_CH1_PERIOD, reg_val);
 		break;
 	default:
 		return -EINVAL;
 	}
-
-	ret = sunxi_pwm_busy(priv);
-	if (ret)
-		return ret;
-
 	return 0;
 }
 
@@ -357,15 +328,14 @@ static int sunxi_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
 	struct sunxi_pwm_chip *priv = to_sunxi_chip(chip);
 	int ret;
 	
-	ret = sunxi_pwm_busy(priv);
-	if (ret)
-		return ret;
-
 	switch (pwm->hwpwm) {
 	case 0:
+		regmap_write(priv->regmap, SUNXI_PWM_CTRL_REG, SUNXI_PWMCTL_PWM0_GATE | SUNXI_PWMCTL_PWM0_EN | SUNXI_PWMCTL_PWM0_BYPASS);
+#ifdef JDS
 		regmap_update_bits(priv->regmap, SUNXI_PWM_CTRL_REG,
 			SUNXI_PWMCTL_PWM0_GATE_MASK | SUNXI_PWMCTL_PWM0_EN_MASK,
 			SUNXI_PWMCTL_PWM0_GATE | SUNXI_PWMCTL_PWM0_EN);
+#endif
 		break;
 	case 1:
 		regmap_update_bits(priv->regmap, SUNXI_PWM_CTRL_REG,
@@ -375,17 +345,18 @@ static int sunxi_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
 	default:
 		return -EINVAL;
 	}
+
+	ret = sunxi_pwm_busy(priv);
+	if (ret)
+		return ret;
 	return 0;
 }
 
 static void sunxi_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
 {
 	struct sunxi_pwm_chip *priv = to_sunxi_chip(chip);
-	int ret;
 
-	ret = sunxi_pwm_busy(priv);
-	if (ret)
-		return;
+	printk("JDS = sunxi_pwm_disable\n");
 
 	switch (pwm->hwpwm) {
 	case 0:
@@ -406,11 +377,8 @@ static int sunxi_pwm_polarity(struct pwm_chip *chip, struct pwm_device *pwm,
 			       enum pwm_polarity polarity)
 {
 	struct sunxi_pwm_chip *priv = to_sunxi_chip(chip);
-	int ret;
 
-	ret = sunxi_pwm_busy(priv);
-	if (ret)
-		return ret;
+	printk("JDS = sunxi_pwm_polarity\n");
 
 	switch (pwm->hwpwm) {
 	case 0:
@@ -437,67 +405,6 @@ static const struct pwm_ops sunxi_pwm_ops = {
 	.owner = THIS_MODULE,
 };
 
-static int sunxi_pwm_clk_init(struct platform_device *pdev, struct sunxi_pwm_chip *priv, void __iomem *base)
-{
-	struct device_node *np = pdev->dev.of_node;
-	struct clk_init_data init;
-	const char *clk_name = NULL;
-	const char *clk_parent = __clk_get_name(priv->clk);
-	int i, ret = 0;
-	int flags = 0;
-
-	init.ops = &clk_divider_ops;
-	init.flags = flags | CLK_IS_BASIC;
-	init.parent_names = &clk_parent;
-	init.num_parents = 1;
-
-	/* struct clk_divider assignments */
-	priv->pwmclk_div.reg = base;
-	priv->pwmclk_div.shift = 0;
-	priv->pwmclk_div.width = 0;
-	priv->pwmclk_div.flags = 0;
-	priv->pwmclk_div.lock = NULL;
-	priv->pwmclk_div.hw.init = &init;
-	priv->pwmclk_div.table = NULL;
-
-	ret = of_property_read_string_index(np, "clock-output-names", 0, &clk_name);
-	if (ret)
-		return ret;
-
-	printk("JDS - sunxi_pwm_pwmclk_init %s\n", clk_name);
-
-	init.name = clk_name;
-
-	/* register the clock */
-	priv->clk_pwm[0] = clk_register(&pdev->dev, &priv->pwmclk_div.hw);
-	if (IS_ERR(priv->clk_pwm[i])) {
-		dev_err(&pdev->dev, "failed to register pwmclk: %ld\n", PTR_ERR(priv->clk_pwm[i]));
-		return PTR_ERR(priv->clk_pwm[i]);
-	}
-
-	ret = of_property_read_string_index(np, "clock-output-names", 1, &clk_name);
-	if (ret)
-		return ret;
-
-	printk("JDS - sunxi_pwm_pwmclk_init %s\n", clk_name);
-
-	init.name = clk_name;
-
-	/* register the clock */
-	priv->clk_pwm[1] = clk_register(&pdev->dev, &priv->pwmclk_div.hw);
-	if (IS_ERR(priv->clk_pwm[i])) {
-		dev_err(&pdev->dev, "failed to register pwmclk: %ld\n", PTR_ERR(priv->clk_pwm[i]));
-		return PTR_ERR(priv->clk_pwm[i]);
-	}
-
-	priv->clk_data.clks = priv->clk_pwm;
-	priv->clk_data.clk_num = 2;
-	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &priv->clk_data);
-	if (ret)
-		return ret;
-	return 0;
-}
-
 static const struct regmap_range sunxi_pwm_volatile_regs_range[] = {
 	regmap_reg_range(SUNXI_PWM_CTRL_REG, SUNXI_PWM_CTRL_REG),
 };
@@ -556,12 +463,6 @@ static int sunxi_pwm_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	ret = sunxi_pwm_clk_init(pdev, priv, base);
-	if (ret) {
-		dev_err(&pdev->dev, "failed to create PWM clocks: %d\n", ret);
-		return ret;
-	}
-
 	platform_set_drvdata(pdev, priv);
 
 	printk("JDS pwm initialized\n");
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index dd09d05..50934ee 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -16,6 +16,7 @@
 #include <linux/pm.h>
 #include <linux/i2c.h>
 #include <linux/clk.h>
+#include <linux/pwm.h>
 #include <linux/regmap.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
@@ -130,6 +131,7 @@ struct sgtl5000_priv {
 	struct ldo_regulator *ldo;
 	struct regmap *regmap;
 	struct clk *mclk;
+	struct pwm_device *pwm;
 	int revision;
 };
 
@@ -614,7 +616,7 @@ static int sgtl5000_set_clock(struct snd_soc_codec *codec, int frame_rate)
 	 * calculate the divider of mclk/sample_freq,
 	 * factor of freq =96k can only be 256, since mclk in range (12m,27m)
 	 */
-	switch (DIV_ROUND_UP(sgtl5000->sysclk, sys_fs)) {
+	switch (DIV_ROUND_CLOSEST(sgtl5000->sysclk, sys_fs)) {
 	case 256:
 		clk_ctl |= SGTL5000_MCLK_FREQ_256FS <<
 			SGTL5000_MCLK_FREQ_SHIFT;
@@ -1446,8 +1448,9 @@ static int sgtl5000_fill_defaults(struct sgtl5000_priv *sgtl5000)
 static int sgtl5000_i2c_probe(struct i2c_client *client,
 			      const struct i2c_device_id *id)
 {
+	struct device_node *np = client->dev.of_node;
 	struct sgtl5000_priv *sgtl5000;
-	int ret, reg, rev;
+	int ret, reg, rev, period;
 
 	sgtl5000 = devm_kzalloc(&client->dev, sizeof(struct sgtl5000_priv),
 								GFP_KERNEL);
@@ -1464,22 +1467,35 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 	sgtl5000->mclk = devm_clk_get(&client->dev, NULL);
 	if (IS_ERR(sgtl5000->mclk)) {
 		ret = PTR_ERR(sgtl5000->mclk);
-		dev_err(&client->dev, "Failed to get mclock: %d\n", ret);
-		/* Defer the probe to see if the clk will be provided later */
-		if (ret == -ENOENT)
-			return -EPROBE_DEFER;
-		return ret;
+		sgtl5000->pwm = devm_of_pwm_get(&client->dev, np, NULL);
+		if (IS_ERR(sgtl5000->pwm)) {
+			/* Defer the probe to see if the clk will be provided later */
+			dev_err(&client->dev, "Failed to get mclock, defering: %d\n", ret);
+			if (ret == -ENOENT)
+				return -EPROBE_DEFER;
+			return ret;
+		}
+		period = pwm_get_period(sgtl5000->pwm);
+		ret = pwm_config(sgtl5000->pwm, period / 2, period); 
+		if (ret)
+			return ret;
+		ret = pwm_enable(sgtl5000->pwm);
+		if (ret)
+			return ret;
+	} else {
+		ret = clk_prepare_enable(sgtl5000->mclk);
+		if (ret)
+			return ret;
 	}
-
-	ret = clk_prepare_enable(sgtl5000->mclk);
-	if (ret)
-		return ret;
+	printk("JDS sgtl5000_i2c_probe 1\n");
 
 	/* read chip information */
 	ret = regmap_read(sgtl5000->regmap, SGTL5000_CHIP_ID, &reg);
+	printk("JDS sgtl5000_i2c_probe 1a %d\n", ret);
 	if (ret)
 		goto disable_clk;
 
+	printk("JDS sgtl5000_i2c_probe 2\n");
 	if (((reg & SGTL5000_PARTID_MASK) >> SGTL5000_PARTID_SHIFT) !=
 	    SGTL5000_PARTID_PART_ID) {
 		dev_err(&client->dev,
@@ -1488,10 +1504,12 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 		goto disable_clk;
 	}
 
+	printk("JDS sgtl5000_i2c_probe 3\n");
 	rev = (reg & SGTL5000_REVID_MASK) >> SGTL5000_REVID_SHIFT;
 	dev_info(&client->dev, "sgtl5000 revision 0x%x\n", rev);
 	sgtl5000->revision = rev;
 
+	printk("JDS sgtl5000_i2c_probe 4\n");
 	i2c_set_clientdata(client, sgtl5000);
 
 	/* Ensure sgtl5000 will start with sane register values */
