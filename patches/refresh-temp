Bottom: fcbe416da67dae0f15228d3e41f397ec0ea7f4d2
Top:    c81efa5a70cf652856388e565e1c3c7fb452bcd0
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-08-17 16:16:06 -0400

Refresh of pwm

---

diff --git a/drivers/pwm/pwm-sunxi.c b/drivers/pwm/pwm-sunxi.c
index bc89a7c..52f9c95 100644
--- a/drivers/pwm/pwm-sunxi.c
+++ b/drivers/pwm/pwm-sunxi.c
@@ -137,7 +137,7 @@
 
 /* SUNXI_PWM_CH0_PERIOD	0x04	PWM Channel 0 Period Register */
 /* SUNXI_PWM_CH1_PERIOD	0x08	PWM Channel 1 Period Register */
-#define SUNXI_PWM_CYCLES_TOTAL_MASK	(0xFFFF<<16)
+#define SUNXI_PWM_CYCLES_TOTAL_MASK	(0xFFFFL<<16)
 #define SUNXI_PWM_CYCLES_TOTAL_SHIFT	16
 #define SUNXI_PWM_CYCLES_TOTAL_WIDTH	16
 #define SUNXI_PWM_CYCLES_ACTIVE_MASK	(0xFFFF<<0)
@@ -159,7 +159,7 @@ enum sunxi_soc_family {
  * structure that defines the pwm control register
  */
 
-static const unsigned int prescale_divisor[] = {
+static unsigned int prescale_divisor[] = {
 	120, 180, 240, 360, 480, 480, 480, 480,
 	12000, 24000, 36000, 48000, 72000, 72000, 72000, 1
 };
@@ -277,7 +277,7 @@ static int sunxi_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
 	mutex_lock(&priv->lock);
 
 	// If period less than two cycles, just enable the OSC24 clock bypass 
-	if (period_ns < (2 * 1000 / OSC24 + 1)) {
+	if ((priv->revision != SUN4I) && (period_ns < (2 * 1000 / OSC24 + 1))) {
 		switch (pwm->hwpwm) {
 		case 0:
 			regmap_update_bits(priv->regmap, SUNXI_PWM_CTRL_REG,
@@ -300,7 +300,7 @@ static int sunxi_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
 	active_cycles = compute_cycles(priv, prescale, duty_ns);
 
 	reg_val = (entire_cycles << SUNXI_PWM_CYCLES_TOTAL_SHIFT) & SUNXI_PWM_CYCLES_TOTAL_MASK;
-	reg_val = (active_cycles << SUNXI_PWM_CYCLES_ACTIVE_SHIFT) & SUNXI_PWM_CYCLES_ACTIVE_MASK;
+	reg_val |= (active_cycles << SUNXI_PWM_CYCLES_ACTIVE_SHIFT) & SUNXI_PWM_CYCLES_ACTIVE_MASK;
 
 	switch (pwm->hwpwm) {
 	case 0:
@@ -346,6 +346,18 @@ static int sunxi_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
 	}
 	if ((priv->revision == SUN5I) || (priv->revision == SUN7I))
 		ret = sunxi_pwm_busy(priv);
+
+{
+	int reg_val;
+	regmap_read(priv->regmap, SUNXI_PWM_CTRL_REG, &reg_val);
+	printk("JDS - SUNXI_PWM_CTRL_REG %08x\n", reg_val);
+	regmap_read(priv->regmap, SUNXI_PWM_CH0_PERIOD, &reg_val);
+	printk("JDS - SUNXI_PWM_CH0_PERIOD %08x\n", reg_val);
+	regmap_read(priv->regmap, SUNXI_PWM_CH1_PERIOD, &reg_val);
+	printk("JDS - SUNXI_PWM_CH1_PERIOD %08x\n", reg_val);
+	
+}
+
 exit:
 	mutex_unlock(&priv->lock);
 	return ret;
@@ -446,9 +458,10 @@ static int sunxi_pwm_probe(struct platform_device *pdev)
 
 	priv->chip.dev = &pdev->dev;
 	priv->revision = (enum sunxi_soc_family)of_id->data;
-	if (priv->revision == SUN4I)
+	if (priv->revision == SUN4I) {
 		priv->max_cycles = MAX_CYCLES_SUN4I;
-	else
+		prescale_divisor[15] = 72000; //A10 does not support prescale = 1
+	} else
 		priv->max_cycles = MAX_CYCLES;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
