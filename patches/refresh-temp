Bottom: b393f02f203848e06a7acf2372427a20846c9f7f
Top:    7d6613e44d11a71c864b6f1f8d9944aef9258953
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-04-24 10:28:21 -0400

Refresh of uart.patch

---

diff --git a/arch/arm/boot/dts/ea3131.dts b/arch/arm/boot/dts/ea3131.dts
index 636e422..7513231 100644
--- a/arch/arm/boot/dts/ea3131.dts
+++ b/arch/arm/boot/dts/ea3131.dts
@@ -108,10 +108,9 @@
 			reg = <0x20020000 0x100 0x20030000 0x100>;
 			interrupt-parent = <&evtr>;
 			interrupts = <4 4>;
-			gpios = <
-				&gpio_ebi_i2stx_0 2 0 /* main irq, map gpio to irq */
-				0  /* WOL irq, map gpio to irq */
-			>;
+			bits = <16>;
+			no-eeprom;
+			simple-phy;
 		};			
 	};
 	memory@30000000 {
diff --git a/arch/arm/mach-lpc31xx/Makefile b/arch/arm/mach-lpc31xx/Makefile
index d307a1a..48f291b 100644
--- a/arch/arm/mach-lpc31xx/Makefile
+++ b/arch/arm/mach-lpc31xx/Makefile
@@ -9,8 +9,6 @@ obj-$(CONFIG_OF) += dt.o
 
 
 # Specific board support
-obj-$(CONFIG_MACH_EA313X) += board-ea313x.o
-obj-$(CONFIG_MACH_EA3152) += board-ea313x.o
 obj-$(CONFIG_LPC3152_AD) += psu.o
 
 # Power Management
diff --git a/arch/arm/mach-lpc31xx/board-ea313x.c b/arch/arm/mach-lpc31xx/board-ea313x.c
deleted file mode 100644
index cb215ff..0000000
--- a/arch/arm/mach-lpc31xx/board-ea313x.c
+++ /dev/null
@@ -1,151 +0,0 @@
-/*  arch/arm/mach-lpc31xx/ea313x.c
- *
- *  Author:	Durgesh Pattamatta
- *  Copyright (C) 2009 NXP semiconductors
- *
- *  ea313x board init routines.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#include <linux/device.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/dm9000.h>
-#include <linux/spi/ads7846.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/spi/spi.h>
-#include <linux/leds-pca9532.h>
-#include <linux/gpio.h>
-#include <linux/of_platform.h>
-
-#include <asm/system.h>
-#include <asm/irq.h>
-#include <asm/pgtable.h>
-#include <asm/page.h>
-#include <asm/sizes.h>
-#include <asm/mach/map.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-
-#include <mach/hardware.h>
-#include <mach/gpio.h>
-#include <mach/i2c.h>
-#include <mach/board.h>
-#include <mach/system.h>
-#include <mach/dt.h>
-
-
-/*
- * DM9000 Ethernet device
- */
-
-/* ARM MPMC controller as part of low power design doesn't de-assert nCS and nOE for consecutive
-reads but just changes address. But DM9000 requires nCS and nOE change between address. So access
-other chip select area (nCS0) to force de-assertion of nCS1 and nOE1. Or else wait for long time
-such as 80 usecs.
-LPC31xx has external logic outside of MPMC IP to toggle nOE to split consecutive reads.
-The latest Apex bootloader patch makes use of this feature.
-For this to work SYS_MPMC_WTD_DEL0 & SYS_MPMC_WTD_DEL1 should be programmed with MPMC_STWTRD0
-& MPMC_STWTRD1 values. The logic only deactivates the nOE for one clock cycle which is
-11nsec but DM9000 needs 80nsec between nOEs. So lets add some dummy instructions such as
-reading a GPIO register to compensate for extra 70nsec.
-*/
-# define DM_IO_DELAY()	do { gpio_get_value(GPIO_MNAND_RYBN3);} while(0)
-
-static void dm9000_dumpblk(void __iomem *reg, int count)
-{
-	int i;
-	int tmp;
-
-	count = (count + 1) >> 1;
-	for (i = 0; i < count; i++) {
-		DM_IO_DELAY();
-		tmp = readw(reg);
-	}
-}
-
-static void dm9000_inblk(void __iomem *reg, void *data, int count)
-{
-	int i;
-	u16* pdata = (u16*)data;
-	count = (count + 1) >> 1;
-	for (i = 0; i < count; i++) {
-		DM_IO_DELAY();
-		*pdata++ = readw(reg);
-	}
-}
-
-static struct dm9000_plat_data dm9000_platdata = {
-	.flags		= DM9000_PLATF_16BITONLY | DM9000_PLATF_NO_EEPROM | DM9000_PLATF_SIMPLE_PHY,
-	.dumpblk = dm9000_dumpblk,
-	.inblk = dm9000_inblk,
-};
-
-#if defined(CONFIG_MACH_EA3152)
-static struct i2c_board_info ea3152_i2c1_devices[] __initdata = {
-	{
-		I2C_BOARD_INFO("lpc3152-psu", 0x0C),
-	},
-};
-#endif
-
-void lpc31xx_vbus_power(int enable)
-{
-	printk (KERN_INFO "enabling USB host vbus_power %d\n", enable);
-	//gpio_set_value(VBUS_PWR_EN, enable);
-}
-
-struct of_dev_auxdata ea3131_auxdata_lookup[] __initdata = {
-	OF_DEV_AUXDATA("davicom,dm9000", EXT_SRAM1_PHYS, "dm9000", &dm9000_platdata),
-	{}
-};
-
-static void __init ea3131_dt_init(void)
-{
-	lpc31xx_dt_init_common(ea3131_auxdata_lookup);
-}
-
-#if defined(CONFIG_USB_EHCI_HCD)
-static int __init ea_usb_power(void)
-{
-	int ret = 0;
-
-	//ret = gpio_request(VBUS_PWR_EN, "vbus power");
-	//ret = gpio_direction_output(VBUS_PWR_EN, 1);
-	return ret;
-}
-//late_initcall(ea_usb_power);
-#endif
-
-static const char *ea3131_dt_match[] __initconst = {
-	"ea,ea3131",
-	NULL,
-};
-
-DT_MACHINE_START(EA313X, "NXP EA3131 (Device Tree Support)")
-	.map_io		= lpc31xx_map_io,
-	.init_early	= lpc31xx_init_early,
-	.init_irq	= lpc31xx_init_irq,
-	.timer		= &lpc31xx_timer,
-	.init_machine	= ea3131_dt_init,
-	.dt_compat	= ea3131_dt_match,
-	.restart	= lpc31xx_arch_reset,
-MACHINE_END
-
-
diff --git a/arch/arm/mach-lpc31xx/sram.c b/arch/arm/mach-lpc31xx/sram.c
index a272840..485741b 100644
--- a/arch/arm/mach-lpc31xx/sram.c
+++ b/arch/arm/mach-lpc31xx/sram.c
@@ -47,7 +47,7 @@ static int lpc31xx_sram_probe(struct platform_device *pdev)
 	count = len / sizeof(*prop);
 
 	ranges = of_get_property(pdev->dev.of_node, "ranges", &len);
-	if (!prop) {
+	if (!ranges) {
 		dev_err(&pdev->dev, "Ranges property missing on SRAM DT");
 		return -EINVAL;
 	}
diff --git a/drivers/net/ethernet/davicom/dm9000.c b/drivers/net/ethernet/davicom/dm9000.c
index d2e4ad5..8f6dfe9 100644
--- a/drivers/net/ethernet/davicom/dm9000.c
+++ b/drivers/net/ethernet/davicom/dm9000.c
@@ -35,7 +35,6 @@
 #include <linux/platform_device.h>
 #include <linux/irq.h>
 #include <linux/slab.h>
-#include <linux/of_gpio.h>
 
 #include <asm/delay.h>
 #include <asm/irq.h>
@@ -1364,30 +1363,34 @@ static const struct net_device_ops dm9000_netdev_ops = {
 #endif
 };
 
-//# define DM_IO_DELAY()	do { gpio_get_value(GPIO_MNAND_RYBN3);} while(0)
-# define DM_IO_DELAY()	do {} while(0)
-
-static void dm9000_dumpblk(void __iomem *reg, int count)
-{
-	int i;
-	int tmp;
-
-	count = (count + 1) >> 1;
-	for (i = 0; i < count; i++) {
-		DM_IO_DELAY();
-		tmp = readw(reg);
-	}
-}
-
-static void dm9000_inblk(void __iomem *reg, void *data, int count)
+static void  __devinit dm9000_parse_options(struct device_node *node, struct board_info *db)
 {
-	int i;
-	u16* pdata = (u16*)data;
-	count = (count + 1) >> 1;
-	for (i = 0; i < count; i++) {
-		DM_IO_DELAY();
-		*pdata++ = readw(reg);
+#ifdef CONFIG_OF
+	const unsigned int *prop;
+	int len, bits;
+
+	prop = of_get_property(node, "bits", &len);
+	if (prop) {
+		bits = __be32_to_cpup(prop);
+		switch (bits) {
+		case 8:
+			db->flags |= DM9000_PLATF_8BITONLY;
+			break;
+		case 16:
+			db->flags |= DM9000_PLATF_16BITONLY;
+			break;
+		case 32:
+			db->flags |= DM9000_PLATF_32BITONLY;
+			break;
+		}
 	}
+	prop = of_get_property(node, "no_eeprom", &len);
+	if (prop)
+		db->flags |= DM9000_PLATF_NO_EEPROM;
+	prop = of_get_property(node, "simple_phy", &len);
+	if (prop)
+		db->flags |= DM9000_PLATF_SIMPLE_PHY;
+#endif
 }
 
 /*
@@ -1494,8 +1497,6 @@ dm9000_probe(struct platform_device *pdev)
 		ret = -EINVAL;
 		goto out;
 	}
-/* fixme */
-pdata->flags		= DM9000_PLATF_16BITONLY | DM9000_PLATF_NO_EEPROM | DM9000_PLATF_SIMPLE_PHY;
 
 	/* fill in parameters for net-dev structure */
 	ndev->base_addr = (unsigned long)db->io_addr;
@@ -1506,34 +1507,33 @@ pdata->flags		= DM9000_PLATF_16BITONLY | DM9000_PLATF_NO_EEPROM | DM9000_PLATF_S
 
 	/* check to see if anything is being over-ridden */
 	if (pdata != NULL) {
-		/* check to see if the driver wants to over-ride the
-		 * default IO width */
-
-		if (pdata->flags & DM9000_PLATF_8BITONLY)
-			dm9000_set_io(db, 1);
-
-		if (pdata->flags & DM9000_PLATF_16BITONLY)
-			dm9000_set_io(db, 2);
-
-		if (pdata->flags & DM9000_PLATF_32BITONLY)
-			dm9000_set_io(db, 4);
-
 		/* check to see if there are any IO routine
 		 * over-rides */
 
 		if (pdata->inblk != NULL)
-//			db->inblk = pdata->inblk;
-			db->inblk = dm9000_inblk;
+			db->inblk = pdata->inblk;
 
 		if (pdata->outblk != NULL)
 			db->outblk = pdata->outblk;
 
 		if (pdata->dumpblk != NULL)
-//			db->dumpblk = pdata->dumpblk;
-			db->dumpblk = dm9000_dumpblk;
+			db->dumpblk = pdata->dumpblk;
 
 		db->flags = pdata->flags;
-	}
+	} else
+		dm9000_parse_options(pdev->dev.of_node, db);
+
+	/* check to see if the driver wants to over-ride the
+	 * default IO width */
+	if (db->flags & DM9000_PLATF_8BITONLY)
+		dm9000_set_io(db, 1);
+
+	if (db->flags & DM9000_PLATF_16BITONLY)
+		dm9000_set_io(db, 2);
+
+	if (db->flags & DM9000_PLATF_32BITONLY)
+		dm9000_set_io(db, 4);
+
 
 #ifdef CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL
 	db->flags |= DM9000_PLATF_SIMPLE_PHY;
