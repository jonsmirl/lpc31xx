Bottom: a37ea3c2e5f8ae8238c9978e2ad3fbedca70ef8f
Top:    e82caff3771ecdc051fa6c1163f0e0a12088ce10
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-03-23 00:02:29 -0400

Refresh of devicetree

---

diff --git a/arch/arm/boot/dts/ea3131.dts b/arch/arm/boot/dts/ea3131.dts
index 799d5b6..eee902e 100644
--- a/arch/arm/boot/dts/ea3131.dts
+++ b/arch/arm/boot/dts/ea3131.dts
@@ -13,7 +13,12 @@
 	compatible = "ea,ea3131", "nxp,lpc3131";
 
 	chosen {
-		bootargs = "console=ttyS0,115200n8 root=/dev/mmcblk0p3 init=/etc/preinit rw ip=182.168.1.180 loglevel=7";
+		bootargs = "console=ttyS0,115200n8 root=/dev/mmcblk0p3 init=/etc/preinit rw rootwait loglevel=7";
+	};
+
+	ssd1289@20000000 {
+		compatible = "ssd,ssd1289";
+		reg = <0x20000000 0x10000 0x20010000 0x10000>;
 	};
 
 	memory@30000000 {
diff --git a/arch/arm/boot/dts/lpc3131.dtsi b/arch/arm/boot/dts/lpc3131.dtsi
index 0a4ced1..901c469 100644
--- a/arch/arm/boot/dts/lpc3131.dtsi
+++ b/arch/arm/boot/dts/lpc3131.dtsi
@@ -1,18 +1,16 @@
 /*
- * at91sam9g20.dtsi - Device Tree Include file for AT91SAM9G20 family SoC
+ * lpc3131.dtsi - Device Tree Include file for LPC3131 family SoC
  *
- *  Copyright (C) 2011 Atmel,
- *                2011 Nicolas Ferre <nicolas.ferre@atmel.com>,
- *                2011 Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+ *  Copyright (C) 2011 Jon Smirl <jonsmirl@gmail.com>
  *
  * Licensed under GPLv2 or later.
  */
 
-/include/ "skeleton.dtsi"
-
 / {
 	model = "NXP LPC3131 SoC";
 	compatible = "nxp,lpc3131";
+	#address-cells = <1>;
+	#size-cells = <1>;
 	interrupt-parent = <&intc>;
 
 	cpus {
diff --git a/arch/arm/mach-lpc31xx/Makefile b/arch/arm/mach-lpc31xx/Makefile
index 5559f7c..a8ab311 100644
--- a/arch/arm/mach-lpc31xx/Makefile
+++ b/arch/arm/mach-lpc31xx/Makefile
@@ -4,8 +4,9 @@
 
 # Object file lists.
 
-obj-y			+= irq.o time.o generic.o i2c.o gpio.o dma.o usb.o wdt.o clock.o dt.o
+obj-y			+= irq.o time.o generic.o i2c.o gpio.o dma.o usb.o wdt.o clock.o
 obj-$(CONFIG_GPIOLIB) += gpiolib.o
+obj-$(CONFIG_OF) += dt.o
 
 
 # Specific board support
diff --git a/arch/arm/mach-lpc31xx/board-ea313x.c b/arch/arm/mach-lpc31xx/board-ea313x.c
index b7864a4..7a24b9f 100644
--- a/arch/arm/mach-lpc31xx/board-ea313x.c
+++ b/arch/arm/mach-lpc31xx/board-ea313x.c
@@ -32,6 +32,8 @@
 #include <linux/spi/spi.h>
 #include <linux/leds-pca9532.h>
 #include <linux/gpio.h>
+#include <linux/of_platform.h>
+
 
 #include <asm/system.h>
 #include <mach/hardware.h>
@@ -47,123 +49,20 @@
 #include <mach/gpio.h>
 #include <mach/i2c.h>
 #include <mach/board.h>
+#include <mach/dt.h>
 
-static struct lpc313x_mci_irq_data irq_data = {
-	.irq = IRQ_SDMMC_CD,
-};
-
-static int mci_get_cd(u32 slot_id)
-{
-	return gpio_get_value(GPIO_MI2STX_BCK0);
-}
-
-static irqreturn_t ea313x_mci_detect_interrupt(int irq, void *data)
-{
-	struct lpc313x_mci_irq_data	*pdata = data;
-
-	/* select the opposite level senstivity */
-	int level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
-
-	irq_set_irq_type(pdata->irq, level);
-
-	/* change the polarity of irq trigger */
-	return pdata->irq_hdlr(irq, pdata->data);
-}
-
-static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
-{
-	int ret;
-	int level;
-
-	/* enable power to the slot */
-	gpio_request(GPIO_MI2STX_DATA0, "mmc power");
-	gpio_set_value(GPIO_MI2STX_DATA0, 0);
-	/* set cd pins as GPIO pins */
-	gpio_request(GPIO_MI2STX_BCK0, "mmc card detect");
-	gpio_direction_input(GPIO_MI2STX_BCK0);
-
-	/* select the opposite level senstivity */
-	level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
-	/* set card detect irq info */
-	irq_data.data = data;
-	irq_data.irq_hdlr = irqhdlr;
-	irq_set_irq_type(irq_data.irq, level);
-	ret = request_irq(irq_data.irq,
-			ea313x_mci_detect_interrupt,
-			level,
-			"mmc-cd", 
-			&irq_data);
-	/****temporary for PM testing */
-	enable_irq_wake(irq_data.irq);
-
-	return irq_data.irq;
-}
-
-static int mci_get_ro(u32 slot_id)
-{
-	return 0;
-}
-
-static int mci_get_ocr(u32 slot_id)
-{
-	return MMC_VDD_32_33 | MMC_VDD_33_34;
-}
-
-static void mci_setpower(u32 slot_id, u32 volt)
-{
-	/* on current version of EA board the card detect
-	 * pull-up in on switched power side. So can't do
-	 * power management so use the always enable power 
-	 * jumper.
-	 */
-}
-static int mci_get_bus_wd(u32 slot_id)
-{
-	return 4;
-}
-
-static void mci_exit(u32 slot_id)
-{
-	free_irq(irq_data.irq, &irq_data);
-}
-
-static struct resource lpc313x_mci_resources[] = {
-	[0] = {
-		.start  = IO_SDMMC_PHYS,
-		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_MCI,
-		.end	= IRQ_MCI,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-static struct lpc313x_mci_board ea313x_mci_platform_data = {
-	.num_slots		= 1,
-	.detect_delay_ms	= 250,
-	.init 			= mci_init,
-	.get_ro			= mci_get_ro,
-	.get_cd 		= mci_get_cd,
-	.get_ocr		= mci_get_ocr,
-	.get_bus_wd		= mci_get_bus_wd,
-	.setpower 		= mci_setpower,
-	.exit			= mci_exit,
-};
 
 static u64 mci_dmamask = 0xffffffffUL;
 static struct platform_device	lpc313x_mci_device = {
 	.name		= "lpc313x_mmc",
-	.num_resources	= ARRAY_SIZE(lpc313x_mci_resources),
 	.dev		= {
 		.dma_mask		= &mci_dmamask,
 		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &ea313x_mci_platform_data,
 	},
-	.resource	= lpc313x_mci_resources,
 };
 
 #if defined (CONFIG_FB_SSD1289)
+#ifndef CONFIG_OF
 static struct resource ssd1289_resource[] = {
 	[0] = {
 		.start = EXT_SRAM0_PHYS + 0x00000 + 0x0000,
@@ -183,6 +82,7 @@ static struct platform_device ssd1289_device = {
 	.num_resources = ARRAY_SIZE(ssd1289_resource),
 	.resource      = ssd1289_resource,
 };
+#endif
 
 static void __init ea_add_device_ssd1289(void)
 {
@@ -194,7 +94,9 @@ static void __init ea_add_device_ssd1289(void)
 	MPMC_STWTWR0   = 3;
 	MPMC_STWTTURN0 = 0;
 
+#ifndef CONFIG_OF
 	platform_device_register(&ssd1289_device);
+#endif
 }
 #else
 static void __init ea_add_device_ssd1289(void) {}
@@ -677,6 +579,13 @@ void lpc313x_vbus_power(int enable)
 	gpio_set_value(VBUS_PWR_EN, enable);
 }
 
+#ifdef CONFIG_OF
+static void __init ea3131_dt_init(void)
+{
+	lpc31xx_dt_init();
+	ea_add_device_ssd1289();
+}
+#else
 static void __init ea313x_init(void)
 {
 	lpc313x_init();
@@ -699,14 +608,16 @@ static void __init ea313x_init(void)
 		ARRAY_SIZE(ea3152_i2c1_devices));
 #endif
 }
+#endif
 
 #if defined(CONFIG_USB_EHCI_HCD)
-static void __init ea_usb_power(void)
+static int __init ea_usb_power(void)
 {
 	int ret; 
 
 	ret = gpio_request(VBUS_PWR_EN, "vbus power");
 	ret = gpio_direction_output(VBUS_PWR_EN, 1);
+	return ret;
 }
 late_initcall(ea_usb_power);
 #endif
@@ -729,6 +640,7 @@ MACHINE_END
 #endif
 
 #if defined(CONFIG_MACH_EA313X)
+#ifndef CONFIG_OF
 MACHINE_START(EA313X, "NXP EA313X")
 	/* Maintainer: Durgesh Pattamatta, NXP */
 	.map_io		= ea313x_map_io,
@@ -736,6 +648,21 @@ MACHINE_START(EA313X, "NXP EA313X")
 	.timer		= &lpc313x_timer,
 	.init_machine	= ea313x_init,
 MACHINE_END
+#else
+static const char *ea3131_dt_match[] __initconst = {
+	"ea,ea3131",
+	NULL,
+};
+DT_MACHINE_START(EA313X, "NXP EA3131 (Device Tree Support)")
+	.map_io		= lpc313x_map_io,
+	.init_early	= lpc31xx_init_early,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= ea3131_dt_init,
+	.dt_compat	= ea3131_dt_match,
+	.restart	= lpc31xx_restart,
+MACHINE_END
+#endif
 #endif
 
 
diff --git a/arch/arm/mach-lpc31xx/clock.c b/arch/arm/mach-lpc31xx/clock.c
index 69ab97a..281a3f5 100644
--- a/arch/arm/mach-lpc31xx/clock.c
+++ b/arch/arm/mach-lpc31xx/clock.c
@@ -1076,7 +1076,7 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK(NULL, "wdog_pclk", clk_wdog_pclk)
 };
 
-static int __init clk_init(void)
+int __init clk_init(void)
 {
 	int i;
 
@@ -1085,5 +1085,4 @@ static int __init clk_init(void)
 
 	return 0;
 }
-core_initcall(clk_init);
 
diff --git a/arch/arm/mach-lpc31xx/dt.c b/arch/arm/mach-lpc31xx/dt.c
index aa644cb..774d6ba 100644
--- a/arch/arm/mach-lpc31xx/dt.c
+++ b/arch/arm/mach-lpc31xx/dt.c
@@ -26,10 +26,13 @@
 #include <asm/mach/arch.h>
 #include <asm/mach/time.h>
 
+#include <mach/hardware.h>
 #include <mach/board.h>
+#include <mach/clock.h>
 
-static void __init lpc31xx_dt_init(void)
+void __init lpc31xx_dt_init(void)
 {
+	lpc313x_init();
 	of_platform_populate(NULL, of_default_bus_match_table,
 			     NULL, NULL);
 }
diff --git a/arch/arm/mach-lpc31xx/generic.c b/arch/arm/mach-lpc31xx/generic.c
index a3b8e06..1c50945 100644
--- a/arch/arm/mach-lpc31xx/generic.c
+++ b/arch/arm/mach-lpc31xx/generic.c
@@ -173,12 +173,21 @@ static struct map_desc lpc313x_io_desc[] __initdata = {
 		.length		= IO_ISRAM0_SIZE,
 		.type		= MT_DEVICE
 	},
+#ifdef CONFIG_OF
 	{
 		.virtual	= io_p2v(IO_USB_PHYS),
 		.pfn		= __phys_to_pfn(IO_USB_PHYS),
 		.length		= IO_USB_SIZE,
 		.type		= MT_DEVICE
 	},
+
+	{
+		.virtual	= io_p2v(IO_SDMMC_PHYS),
+		.pfn		= __phys_to_pfn(IO_SDMMC_PHYS),
+		.length		= IO_SDMMC_SIZE,
+		.type		= MT_DEVICE
+	},
+#endif
 };
 
 void __init lpc313x_map_io(void)
@@ -200,9 +209,10 @@ void __init lpc313x_uart_init(void)
 	}
 }
 
-int __init lpc313x_init(void)
+void __init lpc313x_init(void)
 {
 	/* cgu init */
+	clk_init();
 	cgu_init("");
 	/* Switch on the UART clocks */
 	cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
@@ -243,7 +253,9 @@ int __init lpc313x_init(void)
 
 	lpc313x_uart_init();
 
+#ifndef CONFIG_OF
 	return platform_add_devices(devices, ARRAY_SIZE(devices));
+#endif
 }
 
 
diff --git a/arch/arm/mach-lpc31xx/include/mach/board.h b/arch/arm/mach-lpc31xx/include/mach/board.h
index 5fe9ac2..2bcd065 100644
--- a/arch/arm/mach-lpc31xx/include/mach/board.h
+++ b/arch/arm/mach-lpc31xx/include/mach/board.h
@@ -32,7 +32,7 @@
 
 extern void __init lpc313x_map_io(void);
 extern void __init lpc313x_init_irq(void);
-extern int __init lpc313x_init(void);
+extern void __init lpc313x_init(void);
 extern int __init lpc313x_register_i2c_devices(void);
 extern void lpc313x_vbus_power(int enable);
 extern int lpc313x_entering_suspend_mem(void);
diff --git a/arch/arm/mach-lpc31xx/include/mach/clock.h b/arch/arm/mach-lpc31xx/include/mach/clock.h
index d7058b6..eb038b3 100644
--- a/arch/arm/mach-lpc31xx/include/mach/clock.h
+++ b/arch/arm/mach-lpc31xx/include/mach/clock.h
@@ -653,4 +653,7 @@ struct clk {
 	CGU_CLOCK_ID_T id;
 };
 
+
+int clk_init(void);
+
 #endif
diff --git a/arch/arm/mach-lpc31xx/include/mach/dt.h b/arch/arm/mach-lpc31xx/include/mach/dt.h
new file mode 100644
index 0000000..198ee69
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/dt.h
@@ -0,0 +1,9 @@
+#ifndef LPC31XX_DT
+#define LPC31XX_DT
+
+void lpc31xx_dt_init(void);
+void lpc31xx_init_early(void);
+void lpc31xx_restart(char mode, const char *cmd);
+
+#endif
+
diff --git a/arch/arm/mach-lpc31xx/irq.c b/arch/arm/mach-lpc31xx/irq.c
index f2c36a9..4ff6533 100644
--- a/arch/arm/mach-lpc31xx/irq.c
+++ b/arch/arm/mach-lpc31xx/irq.c
@@ -83,12 +83,6 @@ static struct irq_chip lpc313x_internal_chip = {
 	.irq_set_wake = intc_set_wake,
 };
 
-static struct irq_domain lpc313x_domain = {
-	.irq_base = 1,
-	.nr_irq = NR_IRQ_CPU,
-	.ops = &irq_domain_simple_ops,
-};
-
 static void evt_mask_irq(struct irq_data *data)
 {
 	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
@@ -355,8 +349,6 @@ void __init lpc313x_init_irq(void)
 	/* on the basis of priority level, for both targets (IRQ/FIQ)    */
 	INTC_IRQ_PRI_MASK = 0;
 	INTC_FIQ_PRI_MASK = 0;
-
-	irq_domain_add(&lpc313x_domain);
 }
 
 
diff --git a/drivers/mmc/host/lpc31xx_mmc.c b/drivers/mmc/host/lpc31xx_mmc.c
index e0a0339..c86b1904 100644
--- a/drivers/mmc/host/lpc31xx_mmc.c
+++ b/drivers/mmc/host/lpc31xx_mmc.c
@@ -39,6 +39,7 @@
 #include <linux/slab.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <linux/gpio.h>
 
 #include "lpc31xx_mmc.h"
 #include <mach/irqs.h>
@@ -1403,6 +1404,112 @@ static void lpc313x_mci_cleanup_slot(struct lpc313x_mci_slot *slot,
 	mmc_free_host(slot->mmc);
 }
 
+static struct lpc313x_mci_irq_data irq_data = {
+	.irq = IRQ_SDMMC_CD,
+};
+
+static int mci_get_cd(u32 slot_id)
+{
+	return gpio_get_value(GPIO_MI2STX_BCK0);
+}
+
+static irqreturn_t ea313x_mci_detect_interrupt(int irq, void *data)
+{
+	struct lpc313x_mci_irq_data	*pdata = data;
+
+	/* select the opposite level senstivity */
+	int level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
+
+	irq_set_irq_type(pdata->irq, level);
+
+	/* change the polarity of irq trigger */
+	return pdata->irq_hdlr(irq, pdata->data);
+}
+
+static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
+{
+	int ret;
+	int level;
+
+	/* enable power to the slot */
+	gpio_request(GPIO_MI2STX_DATA0, "mmc power");
+	gpio_set_value(GPIO_MI2STX_DATA0, 0);
+	/* set cd pins as GPIO pins */
+	gpio_request(GPIO_MI2STX_BCK0, "mmc card detect");
+	gpio_direction_input(GPIO_MI2STX_BCK0);
+
+	/* select the opposite level senstivity */
+	level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
+	/* set card detect irq info */
+	irq_data.data = data;
+	irq_data.irq_hdlr = irqhdlr;
+	irq_set_irq_type(irq_data.irq, level);
+	ret = request_irq(irq_data.irq,
+			ea313x_mci_detect_interrupt,
+			level,
+			"mmc-cd", 
+			&irq_data);
+	/****temporary for PM testing */
+	enable_irq_wake(irq_data.irq);
+
+	return irq_data.irq;
+}
+
+static int mci_get_ro(u32 slot_id)
+{
+	return 0;
+}
+
+static int mci_get_ocr(u32 slot_id)
+{
+	return MMC_VDD_32_33 | MMC_VDD_33_34;
+}
+
+static void mci_setpower(u32 slot_id, u32 volt)
+{
+	/* on current version of EA board the card detect
+	 * pull-up in on switched power side. So can't do
+	 * power management so use the always enable power 
+	 * jumper.
+	 */
+}
+static int mci_get_bus_wd(u32 slot_id)
+{
+	return 4;
+}
+
+static void mci_exit(u32 slot_id)
+{
+	free_irq(irq_data.irq, &irq_data);
+}
+
+#ifndef CONFIG_OF
+static struct resource lpc313x_mci_resources[] = {
+	[0] = {
+		.start  = IO_SDMMC_PHYS,
+		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_MCI,
+		.end	= IRQ_MCI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+#endif
+
+static struct lpc313x_mci_board ea313x_mci_platform_data = {
+	.num_slots		= 1,
+	.detect_delay_ms	= 250,
+	.init 			= mci_init,
+	.get_ro			= mci_get_ro,
+	.get_cd 		= mci_get_cd,
+	.get_ocr		= mci_get_ocr,
+	.get_bus_wd		= mci_get_bus_wd,
+	.setpower 		= mci_setpower,
+	.exit			= mci_exit,
+};
+
 #if defined(CONFIG_OF)
 static const struct of_device_id lpc313x_mci_of_match[] = {
 	{ .compatible = "nxp,lpc31xx-sdmmc" },
@@ -1421,23 +1528,24 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 	int				ret = 0;
 	int i;
 
-printk("JDS - lpc313x_mci_probe\n");
+#ifndef CONFIG_OF
+pdev->num_resources = ARRAY_SIZE(lpc313x_mci_resources);
+pdev->resource = lpc313x_mci_resources;
+#endif
+pdev->dev.platform_data = &ea313x_mci_platform_data;
+
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!regs)
 		return -ENXIO;
 
-
-printk("JDS - lpc313x_mci_probe 1\n");
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
 		return irq;
 
-printk("JDS - lpc313x_mci_probe 2\n");
 	host = kzalloc(sizeof(struct lpc313x_mci), GFP_KERNEL);
 	if (!host)
 		return -ENOMEM;
 
-printk("JDS - lpc313x_mci_probe 3\n");
 	host->pdev = pdev;
 	host->pdata = pdata = pdev->dev.platform_data;
 	if (!pdata) {
@@ -1496,6 +1604,7 @@ printk("JDS - lpc313x_mci_probe 3\n");
 		goto err_freemap;
 	}
 #endif
+
 	clk = clk_get(NULL, "mmc_cclk_in");
 	host->bus_hz = clk_get_rate(clk); //40000000;
 	clk_put(clk);
@@ -1667,7 +1776,9 @@ static struct platform_driver lpc313x_mci_driver = {
 	.driver		= {
 		.name	= "lpc313x_mmc",
 		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
 		.of_match_table = lpc313x_mci_of_match,
+#endif
 	},
 };
 
diff --git a/drivers/video/ssd1289.c b/drivers/video/ssd1289.c
index 21537ce..928ec27 100644
--- a/drivers/video/ssd1289.c
+++ b/drivers/video/ssd1289.c
@@ -376,6 +376,7 @@ static int __init ssd1289_probe(struct platform_device *dev)
 	dev_set_drvdata(&dev->dev, item);
 
 	ctrl_res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+printk("JDS ctrl %p %p\n", ctrl_res->end, ctrl_res->start);
 	if (!ctrl_res) {
 		dev_err(&dev->dev,
 			"%s: unable to platform_get_resource for ctrl_res\n",
@@ -402,6 +403,7 @@ static int __init ssd1289_probe(struct platform_device *dev)
 	}
 
 	data_res = platform_get_resource(dev, IORESOURCE_MEM, 1);
+printk("JDS data %p %p\n", data_res->end, data_res->start);
 	if (!data_res) {
 		dev_err(&dev->dev,
 			"%s: unable to platform_get_resource for data_res\n",
@@ -496,11 +498,23 @@ out:
 	return ret;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id ssd1289_of_match[] = {
+	{ .compatible = "ssd,ssd1289" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ssd1289_of_match);
+#endif
+
 static struct platform_driver ssd1289_driver = {
 	.probe = ssd1289_probe,
-	.driver = {
-		   .name = "ssd1289",
-		   },
+	.driver		= {
+		.name	= "ssd1289",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = ssd1289_of_match,
+#endif
+	},
 };
 
 static int __init ssd1289_init(void)
