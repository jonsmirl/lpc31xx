Bottom: 1b3648d51eaded4fafd93c44073b1e1389ca1f6f
Top:    2eb9f24498e601b2b91037052de9cee7a44850e6
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-05-03 21:28:31 -0400

Refresh of spi-rewrite

---

diff --git a/arch/arm/mach-lpc31xx/clock.c b/arch/arm/mach-lpc31xx/clock.c
index db033c6..4c143bb 100644
--- a/arch/arm/mach-lpc31xx/clock.c
+++ b/arch/arm/mach-lpc31xx/clock.c
@@ -1064,7 +1064,6 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("pnx-i2c.1", NULL, clk_i2c1)
 	_REGISTER_CLOCK("1300a000.i2c", NULL, clk_i2c0)
 	_REGISTER_CLOCK("1300a400.i2c", NULL, clk_i2c1)
-	_REGISTER_CLOCK("15002000.spi", NULL, clk_spi_clk)
 	_REGISTER_CLOCK(NULL, "nand_s0", clk_nand_s0)
 	_REGISTER_CLOCK(NULL, "nand_ecc", clk_nand_ecc)
 	_REGISTER_CLOCK(NULL, "nand_clk", clk_nand_clk)
diff --git a/drivers/gpio/gpio-lpc31xx.c b/drivers/gpio/gpio-lpc31xx.c
index aa51274..9a9d5d0 100644
--- a/drivers/gpio/gpio-lpc31xx.c
+++ b/drivers/gpio/gpio-lpc31xx.c
@@ -193,7 +193,7 @@ static int __devinit lpc31xx_simple_gpiochip_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	chip->index = (res->start >> 6) & 7;
+	chip->index = (res->start >> 6) & 0xF;
 	gpio_evt[chip->index].chip = chip;
 
 	gc = &chip->mmchip.gc;
diff --git a/drivers/spi/spi-lpc31xx.c b/drivers/spi/spi-lpc31xx.c
index 883878a..5a50d05 100644
--- a/drivers/spi/spi-lpc31xx.c
+++ b/drivers/spi/spi-lpc31xx.c
@@ -87,7 +87,7 @@
 #define SPI_SLV_SUSPEND(n)        _SBF(((n) << 1), 0x3)
 
 /* SPI tx_fifo_flush register definitions (SPI_TXF_FLUSH_REG) */
-#define SPI_TXFF_FLUSH            _BIT(1)
+#define SPI_TXFF_FLUSH            _BIT(0)
 
 /* SPI dma_settings register definitions (SPI_DMA_SET_REG) */
 #define SPI_DMA_TX_EN             _BIT(1)
@@ -121,7 +121,7 @@
 #define SPI_INT_TSHLD_TX(n)       _SBF(8, ((n) & 0xFF))
 #define SPI_INT_TSHLD_RX(n)       ((n) & 0xFF)
 
-/* SPI intterrupt registers definitions ( SPI_INT_xxx) */
+/* SPI interrupt registers definitions ( SPI_INT_xxx) */
 #define SPI_SMS_INT               _BIT(4)
 #define SPI_TX_INT                _BIT(3)
 #define SPI_RX_INT                _BIT(2)
@@ -130,6 +130,7 @@
 #define SPI_ALL_INTS              (SPI_SMS_INT | SPI_TX_INT | SPI_RX_INT | SPI_TO_INT | SPI_OVR_INT)
 
 #define SPI_POLLING_TIMEOUT 1000
+#define MAX_CHIP_SELECT 3
 
 /*
  * Message State
@@ -185,12 +186,21 @@ enum spi_tx_level_trig {
 };
 
 /**
+ * enum ssp_mode - SSP mode of operation (Communication modes)
+ */
+enum spi_mode {
+	INTERRUPT_TRANSFER,
+	POLLING_TRANSFER,
+	DMA_TRANSFER
+};
+
+/**
  * enum spi_clock_params - clock parameters, to set SPI clock at a
  * desired freq
  */
 struct spi_clock_params {
-	u8 cpsdvsr; /* value from 2 to 254 (even only!) */
-	u8 scr;	    /* value from 0 to 255 */
+	uint8_t cpsdvsr; /* value from 2 to 254 (even only!) */
+	uint8_t scr;	    /* value from 0 to 255 */
 };
 
 /**
@@ -270,6 +280,8 @@ struct lpc31xx_spi {
 	uint32_t				exp_fifo_level;
 	enum spi_rx_level_trig		rx_lev_trig;
 	enum spi_tx_level_trig		tx_lev_trig;
+	int				gpio[MAX_CHIP_SELECT];
+	int				alow[MAX_CHIP_SELECT];
 	/* DMA settings */
 #ifdef CONFIG_DMA_ENGINE_X
 	struct dma_chan			*dma_rx_channel;
@@ -292,7 +304,6 @@ struct lpc31xx_spi {
  * @enable_dma: Whether to enable DMA or not
  * @read: function ptr to be used to read when doing xfer for this chip
  * @write: function ptr to be used to write when doing xfer for this chip
- * @cs_control: chip select callback provided by chip
  * @xfer_type: polling/interrupt/DMA
  *
  * Runtime state of the SSP controller, maintained per chip,
@@ -300,15 +311,15 @@ struct lpc31xx_spi {
  */
 struct lpc31xx_spi_chip {
 	uint32_t cr0;
-	u16 cr1;
-	u16 dmacr;
-	u16 cpsr;
-	u8 n_bytes;
+	uint16_t cr1;
+	uint16_t dmacr;
+	uint16_t cpsr;
+	uint8_t n_bytes;
 	bool enable_dma;
 	enum spi_reading read;
 	enum spi_writing write;
-	void (*cs_control) (uint32_t command);
 	int xfer_type;
+	int chip_select;
 };
 
 /*
@@ -336,19 +347,9 @@ static inline void lpc31xx_int_en(struct lpc31xx_spi *espi, u32 ints)
 }
 
 /*
- * Set a SPI chip select state
- */
-static inline void spi_force_cs(struct lpc31xx_spi *espi, u8 cs, uint cs_state)
-{
-#ifdef JDS
-	espi->psppcfg->spics_cfg[cs].spi_cs_set((int) cs, (int) cs_state);
-#endif
-}
-
-/*
  * Set data width for the SPI chip select
  */
-static void lpc31xx_set_cs_data_bits(struct lpc31xx_spi *espi, u8 cs, u8 data_width)
+static void lpc31xx_set_cs_data_bits(struct lpc31xx_spi *espi, uint8_t cs, uint8_t data_width)
 {
 #ifdef JDS
 	if (espi->current_bits_wd[cs] != data_width)
@@ -366,7 +367,7 @@ static void lpc31xx_set_cs_data_bits(struct lpc31xx_spi *espi, u8 cs, u8 data_wi
 /*
  * Set clock rate and delays for the SPI chip select
  */
-static void lpc31xx_set_cs_clock(struct lpc31xx_spi *espi, u8 cs, u32 clockrate)
+static void lpc31xx_set_cs_clock(struct lpc31xx_spi *espi, uint8_t cs, u32 clockrate)
 {
 	u32 reg, div, ps, div1;
 
@@ -421,7 +422,7 @@ static int lpc31xx_fifo_flush(struct lpc31xx_spi *espi)
 /*
  * Enable or disable the SPI clocks
  */
-static void lpc31xx_spi_clks_enable(void)
+static void lpc31xx_spi_clks_enable(struct lpc31xx_spi *espi)
 {
 	struct clk *clk;
 	int ret;
@@ -429,6 +430,7 @@ static void lpc31xx_spi_clks_enable(void)
 	clk = clk_get(NULL, "spi_pclk");
 	ret = clk_enable(clk);
 	clk_put(clk);
+	espi->clk = clk;
 	clk = clk_get(NULL, "spi_pclk_gated");
 	ret = clk_enable(clk);
 	clk_put(clk);
@@ -460,21 +462,23 @@ static void lpc31xx_spi_clks_disable(void)
 
 /**
  * null_cs_control - Dummy chip select function
- * @command: select/delect the chip
+ * @command: select/deselect the chip
  *
  * If no chip select function is provided by client this is used as dummy
  * chip select
  */
-static void null_cs_control(uint32_t command)
+static void lpc31xx_cs_control(struct lpc31xx_spi *espi, uint32_t control)
 {
-	pr_debug("lpc31xx: dummy chip select control, CS=0x%x\n", command);
+	dev_dbg(&espi->pdev->dev, "cs_control CS=0x%x gpio %d control 0x%x\n",
+			espi->cur_chip->chip_select, espi->gpio[espi->cur_chip->chip_select], control);
+	gpio_set_value(espi->gpio[espi->cur_chip->chip_select], !control);
 }
 
 /**
  * giveback - current spi_message is over, schedule next message and call
  * callback of this message. Assumes that caller already
  * set message->status; dma and pio irqs are blocked
- * @lpc31xx: SSP driver private data structure
+ * @espi: SPI driver private data structure
  */
 static void giveback(struct lpc31xx_spi *espi)
 {
@@ -517,7 +521,7 @@ static void giveback(struct lpc31xx_spi *espi)
 		if (next_msg && next_msg->spi != espi->cur_msg->spi)
 			next_msg = NULL;
 		if (!next_msg || espi->cur_msg->state == STATE_ERROR)
-			espi->cur_chip->cs_control(SSP_CHIP_DESELECT);
+			lpc31xx_cs_control(espi, false);
 		else
 			espi->next_msg_cs_active = true;
 #endif
@@ -532,7 +536,7 @@ static void giveback(struct lpc31xx_spi *espi)
 
 /**
  * flush - flush the FIFO to reach a clean state
- * @lpc31xx: SSP driver private data structure
+ * @espi: SPI driver private data structure
  */
 static int flush(struct lpc31xx_spi *espi)
 {
@@ -552,7 +556,7 @@ static int flush(struct lpc31xx_spi *espi)
 
 /**
  * restore_state - Load configuration of current chip
- * @lpc31xx: SSP driver private data structure
+ * @espi: SPI driver private data structure
  */
 static void restore_state(struct lpc31xx_spi *espi)
 {
@@ -574,7 +578,7 @@ static void restore_state(struct lpc31xx_spi *espi)
 
 /**
  * This will write to TX and read from RX according to the parameters
- * set in lpc31xx.
+ * set in espi.
  */
 static void readwriter(struct lpc31xx_spi *espi)
 {
@@ -590,73 +594,71 @@ static void readwriter(struct lpc31xx_spi *espi)
 	 * FIFO status flag indicates.
 	 */
 	dev_dbg(&espi->pdev->dev,
-		"%s, rx: %p, rxend: %p, tx: %p, txend: %p\n",
-		__func__, espi->rx, espi->rx_end, espi->tx, espi->tx_end);
+		"%s, rx: %p, rxend: %p, tx: %p, txend: %p bytes %d\n",
+		__func__, espi->rx, espi->rx_end, espi->tx, espi->tx_end, espi->cur_chip->n_bytes);
 
+	/* Set the FIFO trip level to the transfer size */
 #ifdef JDS
-	/* Read as much as you can */
-	while ((readw(SSP_SR(espi->virtbase)) & SSP_SR_MASK_RNE)
-	       && (espi->rx < espi->rx_end)) {
+	spi_writel(INT_TRSH_REG, (SPI_INT_TSHLD_TX(0) | SPI_INT_TSHLD_RX(t->len - 1)));
+#endif
+	spi_writel(DMA_SET_REG, 0);
+
+	/* read as long as RX FIFO has frames in it */
+	while ((!(spi_readl(STS_REG) & SPI_ST_RX_EMPTY)) && (espi->rx < espi->rx_end)) {
 		switch (espi->read) {
 		case READING_NULL:
-			readw(SSP_DR(espi->virtbase));
+			spi_readl(FIFO_DATA_REG);
+			printk("Read1 Null\n");
 			break;
 		case READING_U8:
-			*(u8 *) (espi->rx) =
-				readw(SSP_DR(espi->virtbase)) & 0xFFU;
+			*(uint8_t *)(espi->rx) = spi_readl(FIFO_DATA_REG) & 0xFFU;
+			printk("Read1 %02x\n", *(uint8_t *) (espi->rx));
 			break;
 		case READING_U16:
-			*(u16 *) (espi->rx) =
-				(u16) readw(SSP_DR(espi->virtbase));
+			*(uint16_t *)(espi->rx) = (uint16_t)spi_readl(FIFO_DATA_REG);;
 			break;
 		}
 		espi->rx += (espi->cur_chip->n_bytes);
 		espi->exp_fifo_level--;
 	}
-	/*
-	 * Write as much as possible up to the RX FIFO size
-	 */
-	while ((espi->exp_fifo_level < espi->vendor->fifodepth)
-	       && (espi->tx < espi->tx_end)) {
+
+	/* write as long as TX FIFO has room */
+	while ((espi->exp_fifo_level < SPI_FIFO_DEPTH) && (espi->tx < espi->tx_end)) {
 		switch (espi->write) {
 		case WRITING_NULL:
-			writew(0x0, SSP_DR(espi->virtbase));
+			printk("Write Null\n");
+			spi_writel(FIFO_DATA_REG, -1);
 			break;
 		case WRITING_U8:
-			writew(*(u8 *) (espi->tx), SSP_DR(espi->virtbase));
+			printk("Write %02x\n", *(uint8_t *) (espi->tx));
+			spi_writel(FIFO_DATA_REG, *(uint8_t *) (espi->tx));
 			break;
 		case WRITING_U16:
-			writew((*(u16 *) (espi->tx)), SSP_DR(espi->virtbase));
+			spi_writel(FIFO_DATA_REG, *(uint16_t *) (espi->tx));
 			break;
 		}
 		espi->tx += (espi->cur_chip->n_bytes);
 		espi->exp_fifo_level++;
-		/*
-		 * This inner reader takes care of things appearing in the RX
-		 * FIFO as we're transmitting. This will happen a lot since the
-		 * clock starts running when you put things into the TX FIFO,
-		 * and then things are continuously clocked into the RX FIFO.
-		 */
-		while ((readw(SSP_SR(espi->virtbase)) & SSP_SR_MASK_RNE)
-		       && (espi->rx < espi->rx_end)) {
+		/* read as long as RX FIFO has frames in it */
+		while ((!(spi_readl(STS_REG) & SPI_ST_RX_EMPTY)) && (espi->rx < espi->rx_end)) {
 			switch (espi->read) {
 			case READING_NULL:
-				readw(SSP_DR(espi->virtbase));
+				spi_readl(FIFO_DATA_REG);
+				printk("Read2 Null\n");
 				break;
 			case READING_U8:
-				*(u8 *) (espi->rx) =
-					readw(SSP_DR(espi->virtbase)) & 0xFFU;
+				*(uint8_t *)(espi->rx) = spi_readl(FIFO_DATA_REG) & 0xFFU;
+				printk("Read2 %02x\n", *(uint8_t *) (espi->rx));
 				break;
 			case READING_U16:
-				*(u16 *) (espi->rx) =
-					(u16) readw(SSP_DR(espi->virtbase));
+				*(uint16_t *)(espi->rx) = (uint16_t)spi_readl(FIFO_DATA_REG);;
 				break;
 			}
 			espi->rx += (espi->cur_chip->n_bytes);
 			espi->exp_fifo_level--;
 		}
 	}
-#endif
+
 	/*
 	 * When we exit here the TX FIFO should be full and the RX FIFO
 	 * should be empty
@@ -754,8 +756,7 @@ static void dma_callback(void *data)
 	/* Update total bytes transferred */
 	msg->actual_length += espi->cur_transfer->len;
 	if (espi->cur_transfer->cs_change)
-		espi->cur_chip->
-			cs_control(SSP_CHIP_DESELECT);
+		lpc31xx_cs_control(espi, false);
 
 	/* Move to next transfer */
 	msg->state = next_transfer(espi);
@@ -1109,8 +1110,8 @@ static irqreturn_t lpc31xx_interrupt_handler(int irq, void *dev_id)
 {
 	struct lpc31xx_spi *espi = dev_id;
 	struct spi_message *msg = espi->cur_msg;
-	u16 irq_status = 0;
-	u16 flag = 0;
+	uint16_t irq_status = 0;
+	uint16_t flag = 0;
 
 	dev_dbg(&espi->pdev->dev, "lpc31xx_interrupt_handler\n");
 
@@ -1190,8 +1191,7 @@ static irqreturn_t lpc31xx_interrupt_handler(int irq, void *dev_id)
 		/* Update total bytes transferred */
 		msg->actual_length += espi->cur_transfer->len;
 		if (espi->cur_transfer->cs_change)
-			espi->cur_chip->
-				cs_control(SSP_CHIP_DESELECT);
+			lpc31xx_cs_control(espi, false);
 		/* Move to next transfer */
 		msg->state = next_transfer(espi);
 		tasklet_schedule(&espi->pump_transfers);
@@ -1279,10 +1279,8 @@ static void pump_transfers(unsigned long data)
 			udelay(previous->delay_usecs);
 
 		/* Reselect chip select only if cs_change was requested */
-#ifdef JDS
 		if (previous->cs_change)
-			espi->cur_chip->cs_control(SSP_CHIP_SELECT);
-#endif
+			lpc31xx_cs_control(espi, true);
 	} else {
 		/* STATE_START */
 		message->state = STATE_RUNNING;
@@ -1327,7 +1325,7 @@ static void do_interrupt_dma_transfer(struct lpc31xx_spi *espi)
 
 	/* Enable target chip, if not already active */
 	if (!espi->next_msg_cs_active)
-		espi->cur_chip->cs_control(SSP_CHIP_SELECT);
+		lpc31xx_cs_control(espi, true);
 
 	if (set_up_next_transfer(espi, espi->cur_transfer)) {
 		/* Error path */
@@ -1362,6 +1360,7 @@ static void do_polling_transfer(struct lpc31xx_spi *espi)
 	struct spi_transfer *previous = NULL;
 	struct lpc31xx_spi_chip *chip;
 	unsigned long time, timeout;
+	uint32_t tmp;
 
 	dev_dbg(&espi->pdev->dev, "do_polling_transfer\n");
 
@@ -1374,6 +1373,16 @@ static void do_polling_transfer(struct lpc31xx_spi *espi)
 			break;
 		transfer = espi->cur_transfer;
 
+		/* Setup timing and levels before initial chip select */
+		tmp = spi_readl(SLV_SET2_REG(0)) & ~(SPI_SLV2_SPO | SPI_SLV2_SPH);
+		/* Clock high between transfers */
+#ifdef JDS
+		tmp |= SPI_SLV2_SPO;
+		/* Data captured on 2nd clock edge */
+		tmp |= SPI_SLV2_SPH;
+#endif
+		spi_writel(SLV_SET2_REG(0), tmp);
+
 		/* Delay if requested at end of transfer */
 		if (message->state == STATE_RUNNING) {
 			previous =
@@ -1381,17 +1390,13 @@ static void do_polling_transfer(struct lpc31xx_spi *espi)
 				       struct spi_transfer, transfer_list);
 			if (previous->delay_usecs)
 				udelay(previous->delay_usecs);
-#ifdef JDS
 			if (previous->cs_change)
-				espi->cur_chip->cs_control(SSP_CHIP_SELECT);
-#endif
+				lpc31xx_cs_control(espi, true);
 		} else {
 			/* STATE_START */
 			message->state = STATE_RUNNING;
-#ifdef JDS
 			if (!espi->next_msg_cs_active)
-				espi->cur_chip->cs_control(SSP_CHIP_SELECT);
-#endif
+				lpc31xx_cs_control(espi, true);
 		}
 
 		/* Configuration Changing Per Transfer */
@@ -1400,12 +1405,11 @@ static void do_polling_transfer(struct lpc31xx_spi *espi)
 			message->state = STATE_ERROR;
 			break;
 		}
-		/* Flush FIFOs and enable SSP */
+		/* Flush FIFOs and enable SSI */
 		flush(espi);
-#ifdef JDS
-		writew((readw(SSP_CR1(espi->virtbase)) | SSP_CR1_MASK_SSE),
-		       SSP_CR1(espi->virtbase));
-#endif
+		/* Make sure FIFO is flushed, clear pending interrupts, DMA
+		   initially disabled, and then enable SPI interface */
+		spi_writel(CONFIG_REG, (spi_readl(CONFIG_REG) | SPI_CFG_ENABLE));
 
 		dev_dbg(&espi->pdev->dev, "polling transfer ongoing ...\n");
 
@@ -1424,10 +1428,9 @@ static void do_polling_transfer(struct lpc31xx_spi *espi)
 
 		/* Update total byte transferred */
 		message->actual_length += espi->cur_transfer->len;
-#ifdef JDS
 		if (espi->cur_transfer->cs_change)
-			espi->cur_chip->cs_control(SSP_CHIP_DESELECT);
-#endif
+			lpc31xx_cs_control(espi, false);
+
 		/* Move to next transfer */
 		message->state = next_transfer(espi);
 	}
@@ -1462,12 +1465,10 @@ static int lpc31xx_transfer_one_message(struct spi_master *master,
 	restore_state(espi);
 	flush(espi);
 
-#ifdef JDS
 	if (espi->cur_chip->xfer_type == POLLING_TRANSFER)
 		do_polling_transfer(espi);
 	else
 		do_interrupt_dma_transfer(espi);
-#endif
 
 	return 0;
 }
@@ -1623,7 +1624,7 @@ static int verify_controller_parameters(struct lpc31xx_spi *espi,
 	return 0;
 }
 
-static inline uint32_t spi_rate(uint32_t rate, u16 cpsdvsr, u16 scr)
+static inline uint32_t spi_rate(uint32_t rate, uint16_t cpsdvsr, uint16_t scr)
 {
 	return rate / (cpsdvsr * (1 + scr));
 }
@@ -1634,7 +1635,6 @@ static int calculate_effective_freq(struct lpc31xx_spi *espi, int freq, struct
 	unsigned long spi_clk_rate = clk_get_rate(espi->clk);
 	int cpsr, scr, max_rate, min_rate;
 
-	dev_dbg(&espi->pdev->dev, "calculate_effective_freq\n");
 	/*
 	 * Make sure that max value is between values supported by the
 	 * controller. Note that minimum value is already checked in
@@ -1657,30 +1657,14 @@ static int calculate_effective_freq(struct lpc31xx_spi *espi, int freq, struct
 			if ((spi_clk_rate / (cpsr * (scr + 1))) <= freq) {
 				clk_freq->scr = (uint8_t)scr;
 				clk_freq->cpsdvsr = (uint8_t)cpsr;
+				dev_dbg(&espi->pdev->dev, "calculate_effective_freq %d actual %d\n", freq,
+						spi_rate(spi_clk_rate, clk_freq->cpsdvsr, clk_freq->scr));
 				return 0;
 			}
 		}
 	}
-	return -EINVAL;}
-
-/*
- * A piece of default chip info unless the platform
- * supplies it.
- */
-#ifdef JDS
-static const struct lpc31xx_spi_config_chip lpc31xx_default_chip_info = {
-	.com_mode = POLLING_TRANSFER,
-	.iface = SSP_INTERFACE_MOTOROLA_SPI,
-	.hierarchy = SSP_SLAVE,
-	.slave_tx_disable = DO_NOT_DRIVE_TX,
-	.rx_lev_trig = SSP_RX_1_OR_MORE_ELEM,
-	.tx_lev_trig = SSP_TX_1_OR_MORE_EMPTY_LOC,
-	.ctrl_len = SSP_BITS_8,
-	.wait_state = SSP_MWIRE_WAIT_ZERO,
-	.duplex = SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
-	.cs_control = null_cs_control,
-};
-#endif
+	return -EINVAL;
+}
 
 /**
  * lpc31xx_setup - setup function registered to SPI master framework
@@ -1753,13 +1737,8 @@ static int lpc31xx_setup(struct spi_device *spi)
 
 	/* Now set controller state based on controller data */
 	chip->xfer_type = chip_info->com_mode;
-	if (!chip_info->cs_control) {
-		chip->cs_control = null_cs_control;
-		dev_warn(&spi->dev,
-			 "chip select function is NULL for this chip\n");
-	} else
-		chip->cs_control = chip_info->cs_control;
 #endif
+	chip->xfer_type = POLLING_TRANSFER;
 
 	if (bits <= 3) {
 		/* LPC31xx doesn't support less than 4-bits */
@@ -1875,6 +1854,7 @@ static int lpc31xx_setup(struct spi_device *spi)
 	SSP_WRITE_BITS(chip->cr1, chip_info->slave_tx_disable, SSP_CR1_MASK_SOD,
 		3);
 #endif
+	chip->chip_select = spi->chip_select;
 
 	/* Save controller_state */
 	spi_set_ctldata(spi, chip);
@@ -1957,7 +1937,7 @@ lpc31xx_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct spi_master *master;
 	struct lpc31xx_spi *espi = NULL;	/*Data for this driver */
-	int ngpios, status = 0;
+	int i, ngpios, status = 0;
 	struct resource *res;
 
 	/* Allocate master with space for data */
@@ -2015,24 +1995,7 @@ lpc31xx_probe(struct platform_device *pdev)
 		goto err_no_ioremap;
 	}
 
-	espi->clk = clk_get(&pdev->dev, NULL);
-	if (IS_ERR(espi->clk)) {
-		status = PTR_ERR(espi->clk);
-		dev_err(&pdev->dev, "could not retrieve SPI bus clock\n");
-		goto err_no_clk;
-	}
-
-	status = clk_prepare(espi->clk);
-	if (status) {
-		dev_err(&pdev->dev, "could not prepare SPI bus clock\n");
-		goto  err_clk_prep;
-	}
-
-	status = clk_enable(espi->clk);
-	if (status) {
-		dev_err(&pdev->dev, "could not enable SPI bus clock\n");
-		goto err_no_clk_en;
-	}
+	lpc31xx_spi_clks_enable(espi);
 
 	/* Initialize transfer pump */
 	tasklet_init(&espi->pump_transfers, pump_transfers,
@@ -2062,6 +2025,30 @@ lpc31xx_probe(struct platform_device *pdev)
 			platform_info->enable_dma = 0;
 	}
 #endif
+	for (i = 0; i < ngpios; i++) {
+		int gpio;
+		enum of_gpio_flags flags;
+
+		gpio = of_get_gpio_flags(pdev->dev.of_node, i, &flags);
+		if (!gpio_is_valid(gpio)) {
+			dev_err(&pdev->dev, "invalid gpio #%d: %d\n", i, gpio);
+			status = gpio;
+			goto err_no_irq;
+		}
+		status = gpio_request(gpio, dev_name(&pdev->dev));
+		if (status) {
+			dev_err(&pdev->dev, "can't request gpio #%d: %d\n", i, status);
+			goto err_no_irq;
+		}
+		espi->gpio[i] = gpio;
+		espi->alow[i] = flags & OF_GPIO_ACTIVE_LOW;
+
+		status = gpio_direction_output(gpio, espi->alow[i]);
+		if (status) {
+			dev_err(&pdev->dev, "can't set output direction for gpio #%d: %d\n", i, status);
+			goto err_no_irq;
+		}
+	}
 
 	/* Register with the SPI framework */
 	platform_set_drvdata(pdev, espi);
@@ -2099,12 +2086,7 @@ lpc31xx_probe(struct platform_device *pdev)
 
 	free_irq(espi->irq, espi);
 err_no_irq:
-	clk_disable(espi->clk);
-err_no_clk_en:
-	clk_unprepare(espi->clk);
-err_clk_prep:
-	clk_put(espi->clk);
-err_no_clk:
+	lpc31xx_spi_clks_disable();
 	iounmap(espi->virtbase);
 err_no_ioremap:
 	release_mem_region(res->start, resource_size(res));
