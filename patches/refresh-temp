Bottom: 9728d9b90f27d74f55178253765d3c6e120e0eff
Top:    6f6a75ebb064775ad05ecf21679837e2a55ae4f8
Author: Jon Smirl <jonsmirl@smirl2.(none)>
Date:   2012-06-29 12:30:29 -0400

Refresh of 0038-spi-rewrite.patch

---

diff --git a/drivers/spi/spi-lpc31xx.c b/drivers/spi/spi-lpc31xx.c
index cbf3292..a8de7e7 100644
--- a/drivers/spi/spi-lpc31xx.c
+++ b/drivers/spi/spi-lpc31xx.c
@@ -36,6 +36,8 @@
 #include <linux/pm_runtime.h>
 #include <linux/of_gpio.h>
 
+typedef u32 uint32_t;
+
 //#define d_printk(args...) {printk(args);}
 #define d_printk(args...) {}
 
@@ -84,7 +86,7 @@ _spi_readl(volatile u32 *reg)
 #define SPI_INT_SETS_REG  __REG (SPI_PHYS + 0xFEC)
 #define SPI_MOD_ID_REG    __REG (SPI_PHYS + 0xFFC)
 
-/* SPI device contants */
+/* SPI device constants */
 #define SPI_FIFO_DEPTH  64 /* 64 words (16bit) deep */
 #define SPI_NUM_SLAVES  3  /* number of slaves supported */
 #define SPI_MAX_DIV2    254
@@ -414,31 +416,6 @@ static void lpc31xx_set_cs_clock(struct lpc31xx_spi *espi, uint8_t cs, u32 clock
 }
 
 /*
- * Flush the TX and RX FIFOs
- */
-static int lpc31xx_fifo_flush(struct lpc31xx_spi *espi)
-{
-	unsigned long timeout;
-	volatile uint32_t tmp;
-
-	/* Clear TX FIFO first */
-	spi_writel(TXF_FLUSH_REG, SPI_TXFF_FLUSH);
-
-	/* Clear RX FIFO */
-	timeout = jiffies + msecs_to_jiffies(SPI_POLLING_TIMEOUT);
-	while (!(spi_readl(STS_REG) & SPI_ST_RX_EMPTY)) {
-		if (time_after(jiffies, timeout)) {
-			dev_warn(&espi->pdev->dev,
-				 "timeout while flushing RX FIFO\n");
-			return -ETIMEDOUT;
-		}
-		tmp = spi_readl(FIFO_DATA_REG);
-	}
-	return 0;
-}
-
-
-/*
  * Enable or disable the SPI clocks
  */
 static void lpc31xx_spi_clks_enable(struct lpc31xx_spi *espi)
@@ -558,18 +535,26 @@ static void giveback(struct lpc31xx_spi *espi)
  */
 static int flush(struct lpc31xx_spi *espi)
 {
-	unsigned long limit = loops_per_jiffy << 1;
+	unsigned long timeout;
+	volatile uint32_t tmp;
 
 	dev_dbg(&espi->pdev->dev, "flush\n");
-#ifdef JDS
-	do {
-		while (readw(SSP_SR(espi->virtbase)) & SSP_SR_MASK_RNE)
-			readw(SSP_DR(espi->virtbase));
-	} while ((readw(SSP_SR(espi->virtbase)) & SSP_SR_MASK_BSY) && limit--);
-#endif
-	espi->exp_fifo_level = 0;
 
-	return limit;
+	/* Clear TX FIFO first */
+	spi_writel(TXF_FLUSH_REG, SPI_TXFF_FLUSH);
+
+	/* Clear RX FIFO */
+	timeout = jiffies + msecs_to_jiffies(SPI_POLLING_TIMEOUT);
+	while (!(spi_readl(STS_REG) & SPI_ST_RX_EMPTY)) {
+		if (time_after(jiffies, timeout)) {
+			dev_warn(&espi->pdev->dev,
+				 "timeout while flushing RX FIFO\n");
+			return -ETIMEDOUT;
+		}
+		tmp = spi_readl(FIFO_DATA_REG);
+	}
+	espi->exp_fifo_level = 0;
+	return 0;
 }
 
 /**
@@ -615,10 +600,11 @@ static void readwriter(struct lpc31xx_spi *espi)
 		"%s, rx: %p, rxend: %p, tx: %p, txend: %p bytes %d\n",
 		__func__, espi->rx, espi->rx_end, espi->tx, espi->tx_end, espi->cur_chip->n_bytes);
 
+	dev_dbg(&espi->pdev->dev,
+		"rx_end - rx %d\n", espi->rx_end - espi->rx);
+
 	/* Set the FIFO trip level to the transfer size */
-#ifdef JDS
-	spi_writel(INT_TRSH_REG, (SPI_INT_TSHLD_TX(0) | SPI_INT_TSHLD_RX(t->len - 1)));
-#endif
+	//spi_writel(INT_TRSH_REG, (SPI_INT_TSHLD_TX(0) | SPI_INT_TSHLD_RX(espi->cur_chip->n_bytes)));
 	spi_writel(DMA_SET_REG, 0);
 
 	/* read as long as RX FIFO has frames in it */
@@ -1139,7 +1125,8 @@ static irqreturn_t lpc31xx_interrupt_handler(int irq, void *dev_id)
 	}
 
 	/* Read the Interrupt Status Register */
-	irq_status = readw(SSP_MIS(espi->virtbase));
+	irq_status = spi_readl(INT_STS_REG);
+
 
 	if (unlikely(!irq_status))
 		return IRQ_NONE;
@@ -1149,18 +1136,20 @@ static irqreturn_t lpc31xx_interrupt_handler(int irq, void *dev_id)
 	 * interrupts are flatly ignored, they cannot be
 	 * trusted.
 	 */
-	if (unlikely(irq_status & SSP_MIS_MASK_RORMIS)) {
+	if (unlikely(irq_status & SPI_OVR_INT)) {
 		/*
 		 * Overrun interrupt - bail out since our Data has been
 		 * corrupted
 		 */
 		dev_err(&espi->pdev->dev, "FIFO overrun\n");
+#ifdef JDS
 		if (readw(SSP_SR(espi->virtbase)) & SSP_SR_MASK_RFF)
 			dev_err(&espi->pdev->dev,
 				"RXFIFO is full\n");
 		if (readw(SSP_SR(espi->virtbase)) & SSP_SR_MASK_TNF)
 			dev_err(&espi->pdev->dev,
 				"TXFIFO is full\n");
+#endif
 
 		/*
 		 * Disable and clear interrupts, disable SSP,
@@ -1189,9 +1178,14 @@ static irqreturn_t lpc31xx_interrupt_handler(int irq, void *dev_id)
 	if ((espi->tx == espi->tx_end) && (flag == 0)) {
 		flag = 1;
 		/* Disable Transmit interrupt, enable receive interrupt */
+		lpc31xx_int_dis(espi, SPI_TX_INT);
+		lpc31xx_int_en(espi, SPI_RX_INT);
+		lpc31xx_int_clr(espi, SPI_ALL_INTS);
+#ifdef JDS
 		writew((readw(SSP_IMSC(espi->virtbase)) &
 		       ~SSP_IMSC_MASK_TXIM) | SSP_IMSC_MASK_RXIM,
 		       SSP_IMSC(espi->virtbase));
+#endif
 	}
 
 	/*
@@ -1204,7 +1198,7 @@ static irqreturn_t lpc31xx_interrupt_handler(int irq, void *dev_id)
 		writew(DISABLE_ALL_INTERRUPTS,
 		       SSP_IMSC(espi->virtbase));
 		writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(espi->virtbase));
-#endifm
+#endif
 		lpc31xx_int_dis(espi, SPI_ALL_INTS);
 		lpc31xx_int_clr(espi, SPI_ALL_INTS);
 		if (unlikely(espi->rx > espi->rx_end)) {
@@ -1331,22 +1325,22 @@ static void pump_transfers(unsigned long data)
 
 err_config_dma:
 #ifdef JDS
-	/* enable all interrupts except RX */
 	writew(ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM, SSP_IMSC(espi->virtbase));
 #endif
+	/* enable all interrupts except RX */
+	lpc31xx_int_en(espi, SPI_ALL_INTS & ~SPI_RX_INT);
 	return;
 }
 
 static void do_interrupt_dma_transfer(struct lpc31xx_spi *espi)
 {
-	dev_dbg(&espi->pdev->dev, "do_interrupt_dma_transfer\n");
-
 	/*
 	 * Default is to enable all interrupts except RX -
 	 * this will be enabled once TX is complete
 	 */
-	//uint32_t irqflags = ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM;
-	uint32_t irqflags = SPI_ALL_INTS;
+	uint32_t irqflags = SPI_ALL_INTS & ~SPI_RX_INT;
+
+	dev_dbg(&espi->pdev->dev, "do_interrupt_dma_transfer\n");
 
 	/* Enable target chip, if not already active */
 	if (!espi->next_msg_cs_active)
@@ -1771,7 +1765,8 @@ static int lpc31xx_setup(struct spi_device *spi)
 	/* Now set controller state based on controller data */
 	chip->xfer_type = chip_info->com_mode;
 #endif
-	chip->xfer_type = INTERRUPT_TRANSFER;
+	//chip->xfer_type = INTERRUPT_TRANSFER;
+	chip->xfer_type = POLLING_TRANSFER;
 
 	if (bits <= 3) {
 		/* LPC31xx doesn't support less than 4-bits */
@@ -1909,7 +1904,7 @@ static void lpc31xx_spi_prep(struct lpc31xx_spi *espi)
 	spi_writel(CONFIG_REG, SPI_CFG_SW_RESET);
 
 	/* Clear FIFOs */
-	lpc31xx_fifo_flush(espi);
+	flush(espi);
 
 	/* Clear latched interrupts */
 	lpc31xx_int_dis(espi, SPI_ALL_INTS);
