Bottom: b443acc037cc1abd6f55c29bab2b895393d73983
Top:    7b8e6caef336d3d6d44cffb97bb23e440b0ee9a2
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-04-23 12:09:43 -0400

Refresh of uart.patch

---

diff --git a/drivers/tty/serial/8250/8250_lpc31xx.c b/drivers/tty/serial/8250/8250_lpc31xx.c
deleted file mode 100644
index 1a6e3e2..0000000
--- a/drivers/tty/serial/8250/8250_lpc31xx.c
+++ /dev/null
@@ -1,358 +0,0 @@
-/*  arch/arm/mach-lpc31xx/generic.c
- *
- *  Author:	Durgesh Pattamatta
- *  Copyright (C) 2009 NXP semiconductors
- *
- *  Common code for machines with LPC31xx SoCs.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/console.h>
-#include <linux/serial_8250.h>
-#include <linux/of_address.h>
-#include <linux/of_irq.h>
-
-#include <asm/errno.h>
-#include <asm/pgtable.h>
-
-#include <mach/hardware.h>
-
-#include <mach/gpio.h>
-#include <asm/mach/map.h>
-
-/* local functions */
-
-static struct of_device_id uart_ids[] = {
-	{ .compatible = "nxp,lpc31xx-uart" },
-	{ /* sentinel */ }
-};
-
-static void lpc31xx_uart_pm(struct uart_port * port, unsigned int state,
-			      unsigned int oldstate)
-{
-	switch (state) {
-	case 0:
-		/* Free the pins so that UART IP will take control of it */
-		if (oldstate != -1) {
-			gpio_free(GPIO_UART_RXD);
-			gpio_free(GPIO_UART_TXD);
-		}
-		/*
-		 * Enable the peripheral clock for this serial port.
-		 * This is called on uart_open() or a resume event.
-		 */
-		/* Enable UART base clock */
-		cgu_endis_base_freq(CGU_SB_UARTCLK_BASE_ID, 1);
-
-		/* Enable UART IP clock */
-		cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
-		cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
-		break;
-	case 1:
-		/* we can wake the system in this state. So leave clocks on */
-		printk(KERN_INFO "lpc31xx_uart_pm: UART can wake\n");
-		break;
-	case 3:
-		/*
-		 * Disable the peripheral clock for this serial port.
-		 * This is called on uart_close() or a suspend event.
-		 */
-		/* Disable UART IP clock */
-		cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 0);
-		cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 0);
-
-		/* Disable UART base clock */
-		cgu_endis_base_freq(CGU_SB_UARTCLK_BASE_ID, 0);
-
-		/* Free the pins and let GPIO handle it */
-		gpio_request(GPIO_UART_RXD, "uart_rx");
-		gpio_request(GPIO_UART_TXD, "uart_tx");
-
-		gpio_direction_input(GPIO_UART_RXD);
-		gpio_direction_output(GPIO_UART_TXD, 0);
-		break;
-	default:
-		printk(KERN_ERR "lpc31xx_uart_pm: unknown pm %d\n", state);
-	}
-
-}
-
-static const struct of_device_id wdt_of_match[] __initconst = {
-	{ .compatible = "nxp,lpc31xx-wdt", },
-	{},
-};
-
-#define wdt_read(reg) \
-	__raw_readl(wdt_regs + reg)
-#define wdt_write(reg, value) \
-	__raw_writel(value, wdt_regs + reg);
-
-void lpc31xx_arch_reset(char mode, const char *cmd)
-{
-	struct device_node *node;
-	static void __iomem *wdt_regs;
-
-	printk("arch_reset: attempting watchdog reset\n");
-
-	/* Remap the necessary zones */
-	node = of_find_matching_node(NULL, wdt_of_match);
-	wdt_regs = of_iomap(node, 0);
-
-	/* enable WDT clock */
-	cgu_clk_en_dis(CGU_SB_WDOG_PCLK_ID, 1);
-
-	/* Disable watchdog */
-	wdt_write(WDT_TCR, 0);
-	wdt_write(WDT_MCR, WDT_MCR_STOP_MR1 | WDT_MCR_INT_MR1);
-
-	/*  If TC and MR1 are equal a reset is generated. */
-	wdt_write(WDT_PR, 0x00000002);
-	wdt_write(WDT_TC, 0x00000FF0);
-	wdt_write(WDT_MR0, 0x0000F000);
-	wdt_write(WDT_MR1, 0x00001000);
-	wdt_write(WDT_EMR, WDT_EMR_CTRL1(0x3));
-	/* Enable watchdog timer; assert reset at timer timeout */
-	wdt_write(WDT_TCR, WDT_TCR_CNT_EN);
-	cpu_reset (0);/* loop forever and wait for reset to happen */
-
-	/*NOTREACHED*/
-}
-
-
-static struct plat_serial8250_port platform_serial_ports[] = {
-	{
-		.membase = (void *)io_p2v(UART_PHYS),
-		.mapbase = (unsigned long)UART_PHYS,
-		//.irq = IRQ_UART,
-		.irq = 13,
-		.uartclk = XTAL_CLOCK,
-		.regshift = 2,
-		.iotype = UPIO_MEM,
-		.type	= PORT_NXP16750,
-		.flags = UPF_BOOT_AUTOCONF | UPF_BUGGY_UART | UPF_SKIP_TEST,
-		.pm = lpc31xx_uart_pm,
-	},
-	{
-		.flags		= 0
-	},
-};
-
-static struct platform_device serial_device = {
-	.name = "serial8250",
-	.id = PLAT8250_DEV_PLATFORM,
-	.dev = {
-		.platform_data = &platform_serial_ports,
-	},
-};
-
-struct platform_device lpc31xx_pcm_device = {
-	.name = "lpc31xx-pcm-audio",
-	.id = -1,
-};
-
-static struct platform_device *devices[] __initdata = {
-	&serial_device,
-	&lpc31xx_pcm_device,
-};
-
-static struct map_desc lpc31xx_io_desc[] __initdata = {
-	{
-		.virtual	= io_p2v(IO_APB1_PHYS),
-		.pfn		= __phys_to_pfn(IO_APB1_PHYS),
-		.length		= SZ_1M,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_APB2_PHYS),
-		.pfn		= __phys_to_pfn(IO_APB2_PHYS),
-		.length		= SZ_1M,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_APB3_PHYS),
-		.pfn		= __phys_to_pfn(IO_APB3_PHYS),
-		.length		= SZ_1M,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_APB4_PHYS),
-		.pfn		= __phys_to_pfn(IO_APB4_PHYS),
-		.length		= SZ_1M,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_SDMMC_PHYS),
-		.pfn		= __phys_to_pfn(IO_SDMMC_PHYS),
-		.length		= SZ_1M,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_USB_PHYS),
-		.pfn		= __phys_to_pfn(IO_USB_PHYS),
-		.length		= SZ_1M,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(EXT_SRAM0_PHYS),
-		.pfn		= __phys_to_pfn(EXT_SRAM0_PHYS),
-		.length		= SZ_1M,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_INTC_PHYS),
-		.pfn		= __phys_to_pfn(IO_INTC_PHYS),
-		.length		= SZ_1M,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_NAND_BUF_PHYS),
-		.pfn		= __phys_to_pfn(IO_NAND_BUF_PHYS),
-		.length		= SZ_1M,
-		.type		= MT_DEVICE
-	},
-};
-
-void __init lpc31xx_map_io(void)
-{
-	iotable_init(lpc31xx_io_desc, ARRAY_SIZE(lpc31xx_io_desc));
-}
-extern int __init cgu_init(char *str);
-
-void __init lpc31xx_uart_init(void)
-{
-	int mul, div;
-
-	struct device_node *node;
-	int irq;
-
-	node = of_find_matching_node(NULL, uart_ids);
-	if (!node)
-		return;
-
-	/* Get the interrupts property */
-	irq = irq_of_parse_and_map(node, 0);
-	if (!irq) {
-		pr_crit("LPC31xx: UART -  unable to get IRQ from DT\n");
-		return;
-	}
-	of_node_put(node);
-
-	platform_serial_ports[0].irq = irq;
-	printk("JDS - Uart IRQ %d\n", irq);
-
-	/* check what FDR bootloader is using */
-	mul = (UART_FDR_REG >> 4) & 0xF;
-	div = UART_FDR_REG & 0xF;
-	if (div != 0)  {
-		platform_serial_ports[0].uartclk = (XTAL_CLOCK * mul) / (mul + div);
-	}
-}
-
-void __init lpc31xx_init(void)
-{
-	/* cgu init */
-	clk_init();
-	cgu_init("");
-	/* Switch on the UART clocks */
-	cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
-	cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
-	cgu_clk_en_dis(CGU_SB_IOCONF_PCLK_ID, 1);
-
-	/* Put adc block in low power state.
-	 * Once ADC driver is added this should move to driver.
-	 */
-	SYS_ADC_PD = 1;
-	/* Disable ring oscillators used by Random number generators */
-	SYS_RNG_OSC_CFG = 0;
-
-	/* fixme */
-#if 0
-	/* Mux I2S signals based on selected channel */
-#if defined (CONFIG_SND_I2S_TX0_MASTER)
-	/* I2S TX0 WS, DATA */
-	GPIO_DRV_IP(IOCONF_EBI_I2STX_0, 0x60);
-
-	/* I2S TX0 BCK */
-	GPIO_DRV_IP(IOCONF_EBI_MCI, 0x80);
-#endif
-
-#if defined (CONFIG_SND_I2S_TX1_MASTER)
-	/* I2S TX1 BCK, WS, DATA */
-	GPIO_DRV_IP(IOCONF_I2STX_1, 0x7);
-#endif
-
-#if defined (CONFIG_SND_I2S_RX0_MASTER) | defined (CONFIG_SND_I2S_RX0_SLAVE)
-	/* I2S RX0 BCK, WS, DATA */
-	GPIO_DRV_IP(IOCONF_I2SRX_0, 0x7);
-#endif
-#if defined (CONFIG_SND_I2S_RX1_MASTER) | defined (CONFIG_SND_I2S_RX1_SLAVE)
-	/* I2S RX1 BCK, WS, DATA */
-	GPIO_DRV_IP(IOCONF_I2SRX_1, 0x7);
-#endif
-	/* AUDIO CODEC CLOCK (256FS) */
-	GPIO_DRV_IP(IOCONF_I2STX_1, 0x8);
-#endif
-	lpc31xx_uart_init();
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-}
-
-
-#if defined(CONFIG_SERIAL_8250_CONSOLE)
-static int __init lpc31xx_init_console(void)
-{
-	static __initdata char serr[] =
-		KERN_ERR "Serial port #%u setup failed\n";
-	struct uart_port up;
-
-	/* Switch on the UART clocks */
-	cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
-	cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
-
- 	/*
-	 * Set up serial port #0. Do not use autodetection; the result is
-	 * not what we want.
- 	 */
-	memset(&up, 0, sizeof(up));
-
-	lpc31xx_uart_init();
-	up.uartclk = platform_serial_ports[0].uartclk;
-	up.irq = platform_serial_ports[0].irq;
-
-	up.membase = (char *) io_p2v(UART_PHYS);
-	up.mapbase = (unsigned long)UART_PHYS,
-	up.regshift = 2;
-	up.iotype = UPIO_MEM;
-	up.type	= PORT_NXP16750;
-	up.flags = UPF_BOOT_AUTOCONF | UPF_BUGGY_UART | UPF_SKIP_TEST;
-	up.line	= 0;
-	if (early_serial_setup(&up))
-		printk(serr, up.line);
-
-	return 0;
-}
-console_initcall(lpc31xx_init_console);
-
-#endif /*CONFIG_SERIAL_8250_CONSOLE*/
-
-
-
-
