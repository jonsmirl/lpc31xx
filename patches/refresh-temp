Bottom: 6363b268b500fcaa807afaf018b6dc438cc5299e
Top:    57f27ce934fc03ad46352bba46d271bc85a3710f
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-07-04 14:44:35 -0400

Refresh of clocks

---

diff --git a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
index 4ef421f..c79b27f 100644
--- a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
+++ b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
@@ -112,6 +112,10 @@
 			status = "okay";
 		};
 
+		codec@01c22c00 {
+			status = "okay";
+		};
+
 		uart0: serial@01c28000 {
 			pinctrl-names = "default";
 			pinctrl-0 = <&uart0_pins_a>;
diff --git a/arch/arm/boot/dts/sun7i-a20.dtsi b/arch/arm/boot/dts/sun7i-a20.dtsi
index bd39b5d..37ebe7c 100644
--- a/arch/arm/boot/dts/sun7i-a20.dtsi
+++ b/arch/arm/boot/dts/sun7i-a20.dtsi
@@ -91,6 +91,14 @@
 			clock-output-names = "pll1";
 		};
 
+		pll2: clk@01c20008 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sun7i-a20-pll2-clk";
+			reg = <0x01c20008 0x4>;
+			clocks = <&osc24M>;
+			clock-output-names = "pll2";
+		};
+
 		pll4: clk@01c20018 {
 			#clock-cells = <0>;
 			compatible = "allwinner,sun7i-a20-pll4-clk";
@@ -327,6 +335,30 @@
 			clock-output-names = "ir1";
 		};
 
+		i2s0_clk: clk@01c200b8 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200b8 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s0";
+		};
+
+		ac97_clk: clk@01c200bc {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200bc 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "ac97";
+		};
+
+		spdif_clk: clk@01c200c0 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200c0 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "spdif";
+		};
+
 		usb_clk: clk@01c200cc {
 			#clock-cells = <1>;
 		        #reset-cells = <1>;
@@ -344,6 +376,30 @@
 			clock-output-names = "spi3";
 		};
 
+		i2s1_clk: clk@01c200d8 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200d8 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s1";
+		};
+
+		i2s2_clk: clk@01c200dc {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200dc 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s2";
+		};
+
+		codec_clk: clk@01c20140 {
+			#clock-cells = <1>;
+			compatible = "allwinner,sunxi-codec-clk";
+			reg = <0x01c20140 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "codec";
+		};
+
 		mbus_clk: clk@01c2015c {
 			#clock-cells = <0>;
 			compatible = "allwinner,sun4i-a10-mod0-clk";
@@ -809,6 +865,78 @@
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
+		
+		spdif@01c21000 {
+			compatible = "allwinner,sun7i-a20-spdif";
+			reg = <0x01C21000 0x40>;
+			interrupts = <0 13 4>;
+			clocks = <&pll2>, <&apb0_gates 1>, <&spdif_clk>;
+			clock-names = "pll2", "apb", "spdif";
+			dmas = <&dma 0 2>, <&dma 0 2>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		ac97@01c21400 {
+			compatible = "allwinner,sun7i-a20-ac97";
+			reg = <0x01C21400 0x40>;
+			interrupts = <0 14 4>;
+			clocks = <&pll2>, <&apb0_gates 2>, <&ac97_clk>;
+			clock-names = "pll2", "apb", "ac97";
+			dmas = <&dma 0 5>, <&dma 0 5>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s0: i2s@01c22000 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C22000 0x40>;
+			interrupts = <0 16 4>;
+			clocks = <&pll2>, <&apb0_gates 3>, <&i2s0_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 3>, <&dma 0 3>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s1: i2s@01c22400 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C22400 0x40>;
+			interrupts = <0 87 4>;
+			clocks = <&pll2>, <&apb0_gates 4>, <&i2s1_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 4>, <&dma 0 4>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s2: i2s@01c24400 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C24400 0x40>;
+			interrupts = <0 90 4>;
+			clocks = <&pll2>, <&apb0_gates 8>, <&i2s2_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 6>, <&dma 0 6>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		codec: codec@01c22c00 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun7i-a20-codec";
+			reg = <0x01C22c00 0x40>;
+			interrupts = <0 30 4>;
+			clocks = <&pll2>, <&apb0_gates 0>, <&codec_clk 31>;
+			clock-names = "pll2", "apb", "codec";
+			dmas = <&dma 0 19>, <&dma 0 19>;
+			dma-names = "rx", "tx";
+			routing =
+				"MIC_IN", "Microphone Jack",
+				"Microphone Jack", "Mic Bias",
+				"LINE_IN", "Line In Jack",
+				"Headphone Jack", "HP_OUT";
+			status = "disabled";
+		};
 
 		uart1: serial@01c28400 {
 			compatible = "snps,dw-apb-uart";
diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 3806d97..eef9028 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -42,7 +42,7 @@
 static unsigned long clk_factors_recalc_rate(struct clk_hw *hw,
 					     unsigned long parent_rate)
 {
-	u8 n = 1, k = 0, p = 0, m = 0;
+	u8 n = 1, k = 0, p = 0, m = 0, q = 0;
 	u32 reg;
 	unsigned long rate;
 	struct clk_factors *factors = to_clk_factors(hw);
@@ -60,9 +60,15 @@ static unsigned long clk_factors_recalc_rate(struct clk_hw *hw,
 		m = FACTOR_GET(config->mshift, config->mwidth, reg);
 	if (config->pwidth != SUNXI_FACTORS_NOT_APPLICABLE)
 		p = FACTOR_GET(config->pshift, config->pwidth, reg);
+	if (config->qwidth != SUNXI_FACTORS_NOT_APPLICABLE)
+		q = FACTOR_GET(config->qshift, config->qwidth, reg);
 
 	/* Calculate the rate */
-	rate = (parent_rate * n * (k + 1) >> p) / (m + 1);
+	if (q == 0) 
+		rate = (parent_rate * n * (k + 1) >> p) / (m + 1);
+	else
+		rate = (parent_rate * n) / m / q;
+	printk("JDS CLK n %d k %d m %d p %d q %d rate %lu\n", n, k, m, p, q, rate);
 
 	return rate;
 }
@@ -72,7 +78,7 @@ static long clk_factors_round_rate(struct clk_hw *hw, unsigned long rate,
 {
 	struct clk_factors *factors = to_clk_factors(hw);
 	factors->get_factors((u32 *)&rate, (u32)*parent_rate,
-			     NULL, NULL, NULL, NULL);
+			     NULL, NULL, NULL, NULL, NULL);
 
 	return rate;
 }
@@ -115,13 +121,13 @@ static long clk_factors_determine_rate(struct clk_hw *hw, unsigned long rate,
 static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
 				unsigned long parent_rate)
 {
-	u8 n = 0, k = 0, m = 0, p = 0;
+	u8 n = 0, k = 0, m = 0, p = 0, q = 0;
 	u32 reg;
 	struct clk_factors *factors = to_clk_factors(hw);
 	struct clk_factors_config *config = factors->config;
 	unsigned long flags = 0;
 
-	factors->get_factors((u32 *)&rate, (u32)parent_rate, &n, &k, &m, &p);
+	factors->get_factors((u32 *)&rate, (u32)parent_rate, &n, &k, &m, &p, &q);
 
 	if (factors->lock)
 		spin_lock_irqsave(factors->lock, flags);
@@ -134,6 +140,7 @@ static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
 	reg = FACTOR_SET(config->kshift, config->kwidth, reg, k);
 	reg = FACTOR_SET(config->mshift, config->mwidth, reg, m);
 	reg = FACTOR_SET(config->pshift, config->pwidth, reg, p);
+	reg = FACTOR_SET(config->qshift, config->qwidth, reg, q);
 
 	/* Apply them now */
 	writel(reg, factors->reg);
diff --git a/drivers/clk/sunxi/clk-factors.h b/drivers/clk/sunxi/clk-factors.h
index 02e1a43..3c1114f 100644
--- a/drivers/clk/sunxi/clk-factors.h
+++ b/drivers/clk/sunxi/clk-factors.h
@@ -15,13 +15,15 @@ struct clk_factors_config {
 	u8 mwidth;
 	u8 pshift;
 	u8 pwidth;
+	u8 qshift;
+	u8 qwidth;
 };
 
 struct clk_factors {
 	struct clk_hw hw;
 	void __iomem *reg;
 	struct clk_factors_config *config;
-	void (*get_factors) (u32 *rate, u32 parent, u8 *n, u8 *k, u8 *m, u8 *p);
+	void (*get_factors) (u32 *rate, u32 parent, u8 *n, u8 *k, u8 *m, u8 *p, u8 *q);
 	spinlock_t *lock;
 };
 
diff --git a/drivers/clk/sunxi/clk-sunxi.c b/drivers/clk/sunxi/clk-sunxi.c
index fb2ce84..3fab4d8 100644
--- a/drivers/clk/sunxi/clk-sunxi.c
+++ b/drivers/clk/sunxi/clk-sunxi.c
@@ -35,7 +35,7 @@ static DEFINE_SPINLOCK(clk_lock);
  */
 
 static void sun4i_get_pll1_factors(u32 *freq, u32 parent_rate,
-				   u8 *n, u8 *k, u8 *m, u8 *p)
+				   u8 *n, u8 *k, u8 *m, u8 *p, u8 *q)
 {
 	u8 div;
 
@@ -86,7 +86,7 @@ static void sun4i_get_pll1_factors(u32 *freq, u32 parent_rate,
  * parent_rate should always be 24MHz
  */
 static void sun6i_a31_get_pll1_factors(u32 *freq, u32 parent_rate,
-				       u8 *n, u8 *k, u8 *m, u8 *p)
+				       u8 *n, u8 *k, u8 *m, u8 *p, u8 *q)
 {
 	/*
 	 * We can operate only on MHz, this will make our life easier
@@ -164,6 +164,29 @@ static void sun6i_a31_get_pll1_factors(u32 *freq, u32 parent_rate,
 }
 
 /**
+ * sun7i_get_pll2_factors()
+ * parent_rate is always 24Mhz
+ */
+
+static void sun7i_get_pll2_factors(u32 *freq, u32 parent_rate,
+				   u8 *n, u8 *k, u8 *m, u8 *p, u8 *q)
+{
+	/* we were called to round the frequency, we can now return */
+	if (n == NULL)
+		return;
+	
+	if (*freq == 22579200) {
+		*n = 79;
+		*m = 21;  /* Pre */
+		*q = 4;   /* Post */
+	} else  {
+		*n = 86;
+		*m = 21;  /* Pre */
+		*q = 4;   /* Post */
+	}
+}
+
+/**
  * sun4i_get_pll5_factors() - calculates n, k factors for PLL5
  * PLL5 rate is calculated as follows
  * rate = parent_rate * n * (k + 1)
@@ -171,7 +194,7 @@ static void sun6i_a31_get_pll1_factors(u32 *freq, u32 parent_rate,
  */
 
 static void sun4i_get_pll5_factors(u32 *freq, u32 parent_rate,
-				   u8 *n, u8 *k, u8 *m, u8 *p)
+				   u8 *n, u8 *k, u8 *m, u8 *p, u8 *q)
 {
 	u8 div;
 
@@ -203,7 +226,7 @@ static void sun4i_get_pll5_factors(u32 *freq, u32 parent_rate,
  */
 
 static void sun6i_a31_get_pll6_factors(u32 *freq, u32 parent_rate,
-				       u8 *n, u8 *k, u8 *m, u8 *p)
+				       u8 *n, u8 *k, u8 *m, u8 *p, u8 *q)
 {
 	u8 div;
 
@@ -235,7 +258,7 @@ static void sun6i_a31_get_pll6_factors(u32 *freq, u32 parent_rate,
  */
 
 static void sun4i_get_apb1_factors(u32 *freq, u32 parent_rate,
-				   u8 *n, u8 *k, u8 *m, u8 *p)
+				   u8 *n, u8 *k, u8 *m, u8 *p, u8 *q)
 {
 	u8 calcm, calcp;
 
@@ -278,7 +301,7 @@ static void sun4i_get_apb1_factors(u32 *freq, u32 parent_rate,
  */
 
 static void sun4i_get_mod0_factors(u32 *freq, u32 parent_rate,
-				   u8 *n, u8 *k, u8 *m, u8 *p)
+				   u8 *n, u8 *k, u8 *m, u8 *p, u8 *q)
 {
 	u8 div, calcm, calcp;
 
@@ -319,7 +342,7 @@ static void sun4i_get_mod0_factors(u32 *freq, u32 parent_rate,
  */
 
 static void sun7i_a20_get_out_factors(u32 *freq, u32 parent_rate,
-				      u8 *n, u8 *k, u8 *m, u8 *p)
+				      u8 *n, u8 *k, u8 *m, u8 *p, u8 *q)
 {
 	u8 div, calcm, calcp;
 
@@ -398,7 +421,7 @@ struct factors_data {
 	int enable;
 	int mux;
 	struct clk_factors_config *table;
-	void (*getter) (u32 *rate, u32 parent_rate, u8 *n, u8 *k, u8 *m, u8 *p);
+	void (*getter) (u32 *rate, u32 parent_rate, u8 *n, u8 *k, u8 *m, u8 *p, u8 *q);
 	const char *name;
 };
 
@@ -422,6 +445,15 @@ static struct clk_factors_config sun6i_a31_pll1_config = {
 	.mwidth = 2,
 };
 
+static struct clk_factors_config sun7i_pll2_config = {
+	.nshift = 8,
+	.nwidth = 7,
+	.mshift = 0,
+	.mwidth = 5,
+	.qshift = 26,
+	.qwidth = 4,
+};
+ 
 static struct clk_factors_config sun4i_pll5_config = {
 	.nshift = 8,
 	.nwidth = 5,
@@ -471,6 +503,12 @@ static const struct factors_data sun6i_a31_pll1_data __initconst = {
 	.getter = sun6i_a31_get_pll1_factors,
 };
 
+static const struct factors_data sun7i_a20_pll2_data __initconst = {
+	.enable = 31,
+	.table = &sun7i_pll2_config,
+	.getter = sun7i_get_pll2_factors,
+};
+
 static const struct factors_data sun7i_a20_pll4_data __initconst = {
 	.enable = 31,
 	.table = &sun4i_pll5_config,
@@ -859,6 +897,10 @@ static const struct gates_data sun6i_a31_usb_gates_data __initconst = {
 	.reset_mask = BIT(2) | BIT(1) | BIT(0),
 };
 
+static const struct gates_data sunxi_codec_data __initconst = {
+	.mask = {BIT(31)},
+};
+
 static void __init sunxi_gates_clk_setup(struct device_node *node,
 					 struct gates_data *data)
 {
@@ -1102,6 +1144,7 @@ free_clkdata:
 static const struct of_device_id clk_factors_match[] __initconst = {
 	{.compatible = "allwinner,sun4i-a10-pll1-clk", .data = &sun4i_pll1_data,},
 	{.compatible = "allwinner,sun6i-a31-pll1-clk", .data = &sun6i_a31_pll1_data,},
+	{.compatible = "allwinner,sun7i-a20-pll2-clk", .data = &sun7i_a20_pll2_data,},
 	{.compatible = "allwinner,sun7i-a20-pll4-clk", .data = &sun7i_a20_pll4_data,},
 	{.compatible = "allwinner,sun6i-a31-pll6-clk", .data = &sun6i_a31_pll6_data,},
 	{.compatible = "allwinner,sun4i-a10-apb1-clk", .data = &sun4i_apb1_data,},
@@ -1155,6 +1198,7 @@ static const struct of_device_id clk_gates_match[] __initconst = {
 	{.compatible = "allwinner,sun4i-a10-usb-clk", .data = &sun4i_a10_usb_gates_data,},
 	{.compatible = "allwinner,sun5i-a13-usb-clk", .data = &sun5i_a13_usb_gates_data,},
 	{.compatible = "allwinner,sun6i-a31-usb-clk", .data = &sun6i_a31_usb_gates_data,},
+	{.compatible = "allwinner,sunxi-codec-clk", .data = &sunxi_codec_data,},
 	{}
 };
 
diff --git a/drivers/dma/sun4i-dma.c b/drivers/dma/sun4i-dma.c
index 24fa391..26c3ebd 100644
--- a/drivers/dma/sun4i-dma.c
+++ b/drivers/dma/sun4i-dma.c
@@ -8,6 +8,8 @@
  * (at your option) any later version.
  */
 
+#define DEBUG
+
 #include <linux/bitmap.h>
 #include <linux/bitops.h>
 #include <linux/clk.h>
@@ -242,12 +244,14 @@ static struct sun4i_dma_pchan *find_and_use_pchan(struct sun4i_dma_dev *priv,
 		max = NDMA_NR_MAX_CHANNELS;
 	}
 
+	printk("JDS DMA find_and_use_pchan\n");
 	for_each_clear_bit_from(i, &priv->pchans_used, max) {
 		pchan = &pchans[i];
 		pchan->vchan = vchan;
 		set_bit(i, priv->pchans_used);
 		break;
 	}
+	printk("JDS DMA find_and_use_pchan %p\n", pchan);
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 
@@ -340,8 +344,8 @@ static int execute_vchan_pending(struct sun4i_dma_dev *priv,
 		/* Figure out which contract we're working with today */
 		vd = vchan_next_desc(&vchan->vc);
 		if (!vd) {
-			dev_dbg(chan2dev(&vchan->vc.chan),
-				"No pending contract found");
+//			dev_dbg(chan2dev(&vchan->vc.chan),
+//				"No pending contract found");
 			ret = 0;
 			goto release_pchan;
 		}
@@ -356,6 +360,8 @@ static int execute_vchan_pending(struct sun4i_dma_dev *priv,
 		}
 	} while (list_empty(&contract->demands));
 
+	printk("JDS DMA execute_vchan_pending\n");
+
 	/* Now find out what we need to do */
 	promise = list_first_entry(&contract->demands,
 				   struct sun4i_dma_promise, list);
@@ -363,6 +369,7 @@ static int execute_vchan_pending(struct sun4i_dma_dev *priv,
 
 	/* ... and make it reality */
 	if (promise) {
+		printk("JDS DMA execute_vchan_pending reality %p\n", vchan->pchan);
 		vchan->contract = contract;
 		set_pchan_interrupt(priv, pchan, 0, 1);
 		configure_pchan(pchan, promise);
@@ -568,6 +575,79 @@ sun4i_dma_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest,
 	return vchan_tx_prep(&vchan->vc, &contract->vd, flags);
 }
 
+static struct dma_async_tx_descriptor *sun4i_dma_prep_dma_cyclic(
+		struct dma_chan *chan, dma_addr_t buf, size_t len,
+		size_t period_len, enum dma_transfer_direction dir,
+		unsigned long flags, void *context) {
+	struct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);
+	struct dma_slave_config *sconfig = &vchan->cfg;
+	struct sun4i_dma_promise *promise;
+	struct sun4i_dma_contract *contract;
+	dma_addr_t srcaddr, dstaddr;
+	u32 endpoints;
+
+	if (!is_slave_direction(dir)) {
+		dev_err(chan2dev(chan), "Invalid DMA direction\n");
+		return NULL;
+	}
+
+	contract = generate_dma_contract();
+	if (!contract)
+		return NULL;
+
+	/* Figure out endpoints */
+	if (vchan->is_dedicated && dir == DMA_MEM_TO_DEV) {
+		endpoints = DDMA_CFG_CONT_MODE | DDMA_CFG_SRC_DRQ_TYPE(DDMA_DRQ_TYPE_SDRAM) |
+			    DDMA_CFG_SRC_ADDR_MODE(DDMA_ADDR_MODE_LINEAR) |
+			    DDMA_CFG_DEST_DRQ_TYPE(vchan->endpoint) |
+			    DDMA_CFG_DEST_ADDR_MODE(DDMA_ADDR_MODE_IO);
+	} else if (!vchan->is_dedicated && dir == DMA_MEM_TO_DEV) {
+		endpoints = NDMA_CFG_CONT_MODE | NDMA_CFG_SRC_DRQ_TYPE(NDMA_DRQ_TYPE_SDRAM) |
+			    NDMA_CFG_DEST_DRQ_TYPE(vchan->endpoint) |
+			    NDMA_CFG_DEST_FIXED_ADDR;
+	} else if (vchan->is_dedicated) {
+		endpoints = DDMA_CFG_CONT_MODE | DDMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |
+			    DDMA_CFG_SRC_ADDR_MODE(DDMA_ADDR_MODE_IO) |
+			    DDMA_CFG_DEST_DRQ_TYPE(DDMA_DRQ_TYPE_SDRAM) |
+			    DDMA_CFG_DEST_ADDR_MODE(DDMA_ADDR_MODE_LINEAR);
+	} else {
+		endpoints = NDMA_CFG_CONT_MODE | NDMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |
+			    NDMA_CFG_SRC_FIXED_ADDR |
+			    NDMA_CFG_DEST_DRQ_TYPE(NDMA_DRQ_TYPE_SDRAM);
+	}
+
+	/* Figure out addresses */
+	if (dir == DMA_MEM_TO_DEV) {
+		srcaddr = buf;
+		dstaddr = sconfig->dst_addr;
+	} else {
+		srcaddr = sconfig->src_addr;
+		dstaddr = buf;
+	}
+
+	/* And make a suitable promise */
+	if (vchan->is_dedicated)
+		promise = generate_ddma_promise(chan, srcaddr, dstaddr,
+						len, sconfig);
+	else
+		promise = generate_ndma_promise(chan, srcaddr, dstaddr,
+						len, sconfig);
+
+	if (!promise)
+		return NULL; /* TODO */
+
+	promise->cfg |= endpoints;
+
+	/* Then add it to the contract */
+	list_add_tail(&promise->list, &contract->demands);
+
+	/*
+	 * Once we've got all the promise ready, add the contract
+	 * to the pending list on the vchan
+	 */
+	return vchan_tx_prep(&vchan->vc, &contract->vd, flags);
+}
+
 static struct dma_async_tx_descriptor *
 sun4i_dma_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 			unsigned int sg_len, enum dma_transfer_direction dir,
@@ -759,6 +839,8 @@ static enum dma_status sun4i_dma_tx_status(struct dma_chan *chan,
 	enum dma_status ret;
 	size_t bytes = 0;
 
+
+	printk("JDS DMA sun4i_dma_tx_status\n");
 	ret = dma_cookie_status(chan, cookie, state);
 	if (ret == DMA_COMPLETE)
 		return ret;
@@ -823,6 +905,7 @@ static irqreturn_t sun4i_dma_interrupt(int irq, void *dev_id)
 	unsigned long pendirq, irqs;
 	int bit;
 
+	printk("JDS - sun4i_ddma_interrupt\n");
 	pendirq = readl_relaxed(priv->base + DMA_IRQ_PENDING_STATUS_REG);
 	irqs = readl_relaxed(priv->base + DMA_IRQ_ENABLE_REG);
 
@@ -876,6 +959,19 @@ static irqreturn_t sun4i_dma_submit_work(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static int sun4i_dma_device_slave_caps(struct dma_chan *dchan,
+				      struct dma_slave_caps *caps)
+{
+	caps->src_addr_widths = 32;
+	caps->dstn_addr_widths = 32;
+	caps->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);
+	caps->cmd_pause = true;
+	caps->cmd_terminate = true;
+	caps->residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;
+
+	return 0;
+}
+
 static int sun4i_dma_probe(struct platform_device *pdev)
 {
 	struct sun4i_dma_dev *priv;
@@ -918,7 +1014,9 @@ static int sun4i_dma_probe(struct platform_device *pdev)
 	priv->slave.device_issue_pending	= sun4i_dma_issue_pending;
 	priv->slave.device_prep_slave_sg	= sun4i_dma_prep_slave_sg;
 	priv->slave.device_prep_dma_memcpy	= sun4i_dma_prep_dma_memcpy;
+	priv->slave.device_prep_dma_cyclic	= sun4i_dma_prep_dma_cyclic;
 	priv->slave.device_control		= sun4i_dma_control;
+	priv->slave.device_slave_caps 		= sun4i_dma_device_slave_caps;
 	priv->slave.chancnt			= DDMA_NR_MAX_VCHANS;
 
 	priv->slave.dev = &pdev->dev;
