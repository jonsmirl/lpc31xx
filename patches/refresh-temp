Bottom: 36a4991b52a56c82e07d2d156200707be668c1d4
Top:    1b3648d51eaded4fafd93c44073b1e1389ca1f6f
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-04-25 18:49:52 -0400

Refresh of spi-rewrite

---

diff --git a/arch/arm/mach-lpc31xx/clock.c b/arch/arm/mach-lpc31xx/clock.c
index 4c143bb..db033c6 100644
--- a/arch/arm/mach-lpc31xx/clock.c
+++ b/arch/arm/mach-lpc31xx/clock.c
@@ -1064,6 +1064,7 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("pnx-i2c.1", NULL, clk_i2c1)
 	_REGISTER_CLOCK("1300a000.i2c", NULL, clk_i2c0)
 	_REGISTER_CLOCK("1300a400.i2c", NULL, clk_i2c1)
+	_REGISTER_CLOCK("15002000.spi", NULL, clk_spi_clk)
 	_REGISTER_CLOCK(NULL, "nand_s0", clk_nand_s0)
 	_REGISTER_CLOCK(NULL, "nand_ecc", clk_nand_ecc)
 	_REGISTER_CLOCK(NULL, "nand_clk", clk_nand_clk)
diff --git a/drivers/spi/spi-lpc31xx.c b/drivers/spi/spi-lpc31xx.c
index 9c92631..883878a 100644
--- a/drivers/spi/spi-lpc31xx.c
+++ b/drivers/spi/spi-lpc31xx.c
@@ -16,6 +16,8 @@
  * GNU General Public License for more details.
  */
 
+#define DEBUG
+
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/device.h>
@@ -33,6 +35,11 @@
 #include <linux/dma-mapping.h>
 #include <linux/scatterlist.h>
 #include <linux/pm_runtime.h>
+#include <linux/of_gpio.h>
+
+/* Register access macros */
+#define spi_readl(reg) __raw_readl(&SPI_##reg)
+#define spi_writel(reg,value) __raw_writel((value),&SPI_##reg)
 
 /***********************************************************************
  * SPI register definitions
@@ -142,7 +149,6 @@ enum spi_reading {
 	READING_NULL,
 	READING_U8,
 	READING_U16,
-	READING_U32
 };
 
 /**
@@ -152,7 +158,39 @@ enum spi_writing {
 	WRITING_NULL,
 	WRITING_U8,
 	WRITING_U16,
-	WRITING_U32
+};
+
+/**
+ * enum ssp_rx_level_trig - receive FIFO watermark level which triggers
+ * IT: Interrupt fires when _N_ or more elements in RX FIFO.
+ */
+enum spi_rx_level_trig {
+	SSP_RX_1_OR_MORE_ELEM,
+	SSP_RX_4_OR_MORE_ELEM,
+	SSP_RX_8_OR_MORE_ELEM,
+	SSP_RX_16_OR_MORE_ELEM,
+	SSP_RX_32_OR_MORE_ELEM
+};
+
+/**
+ * Transmit FIFO watermark level which triggers (IT Interrupt fires
+ * when _N_ or more empty locations in TX FIFO)
+ */
+enum spi_tx_level_trig {
+	SSP_TX_1_OR_MORE_EMPTY_LOC,
+	SSP_TX_4_OR_MORE_EMPTY_LOC,
+	SSP_TX_8_OR_MORE_EMPTY_LOC,
+	SSP_TX_16_OR_MORE_EMPTY_LOC,
+	SSP_TX_32_OR_MORE_EMPTY_LOC
+};
+
+/**
+ * enum spi_clock_params - clock parameters, to set SPI clock at a
+ * desired freq
+ */
+struct spi_clock_params {
+	u8 cpsdvsr; /* value from 2 to 254 (even only!) */
+	u8 scr;	    /* value from 0 to 255 */
 };
 
 /**
@@ -175,14 +213,13 @@ struct vendor_data {
 };
 
 /**
- * struct lpc31xx - This is the private SSP driver data structure
+ * struct lpc31xx_spi - This is the private SSP driver data structure
  * @pdev: Platform device model hookup
  * @vendor: vendor data for the IP block
  * @phybase: the physical memory where the SSP device resides
  * @virtbase: the virtual memory where the SSP is mapped
  * @clk: outgoing clock "SPICLK" for the SPI bus
  * @master: SPI framework hookup
- * @master_info: controller-specific data from machine setup
  * @kworker: thread struct for message pump
  * @kworker_task: pointer to task for message pump kworker thread
  * @pump_messages: work struct for scheduling work to the message pump
@@ -211,18 +248,18 @@ struct vendor_data {
  * @sgt_tx: scatter table for the TX transfer
  * @dummypage: a dummy page used for driving data on the bus with DMA
  */
-struct lpc31xx {
+struct lpc31xx_spi {
 	struct platform_device		*pdev;
 	resource_size_t			phybase;
 	void __iomem			*virtbase;
 	struct clk			*clk;
 	struct spi_master		*master;
-	struct lpc31xx_spi_controller	*master_info;
+	int				irq;
 	/* Message per-transfer pump */
 	struct tasklet_struct		pump_transfers;
 	struct spi_message		*cur_msg;
 	struct spi_transfer		*cur_transfer;
-	struct chip_data		*cur_chip;
+	struct lpc31xx_spi_chip		*cur_chip;
 	bool				next_msg_cs_active;
 	void				*tx;
 	void				*tx_end;
@@ -230,7 +267,7 @@ struct lpc31xx {
 	void				*rx_end;
 	enum spi_reading		read;
 	enum spi_writing		write;
-	u32				exp_fifo_level;
+	uint32_t				exp_fifo_level;
 	enum spi_rx_level_trig		rx_lev_trig;
 	enum spi_tx_level_trig		tx_lev_trig;
 	/* DMA settings */
@@ -245,7 +282,7 @@ struct lpc31xx {
 };
 
 /**
- * struct chip_data - To maintain runtime state of SSP for each client chip
+ * struct lpc31xx_spi_chip - To maintain runtime state of SSP for each client chip
  * @cr0: Value of control register CR0 of SSP - on later ST variants this
  *       register is 32 bits wide rather than just 16
  * @cr1: Value of control register CR1 of SSP
@@ -261,8 +298,8 @@ struct lpc31xx {
  * Runtime state of the SSP controller, maintained per chip,
  * This would be set according to the current message that would be served
  */
-struct chip_data {
-	u32 cr0;
+struct lpc31xx_spi_chip {
+	uint32_t cr0;
 	u16 cr1;
 	u16 dmacr;
 	u16 cpsr;
@@ -270,10 +307,157 @@ struct chip_data {
 	bool enable_dma;
 	enum spi_reading read;
 	enum spi_writing write;
-	void (*cs_control) (u32 command);
+	void (*cs_control) (uint32_t command);
 	int xfer_type;
 };
 
+/*
+ * Clear a latched SPI interrupt
+ */
+static inline void lpc31xx_int_clr(struct lpc31xx_spi *espi, u32 ints)
+{
+	spi_writel(INT_CLRS_REG, ints);
+}
+
+/*
+ * Disable a SPI interrupt
+ */
+static inline void lpc31xx_int_dis(struct lpc31xx_spi *espi, u32 ints)
+{
+	spi_writel(INT_CLRE_REG, ints);
+}
+
+/*
+ * Enable a SPI interrupt
+ */
+static inline void lpc31xx_int_en(struct lpc31xx_spi *espi, u32 ints)
+{
+	spi_writel(INT_SETE_REG, ints);
+}
+
+/*
+ * Set a SPI chip select state
+ */
+static inline void spi_force_cs(struct lpc31xx_spi *espi, u8 cs, uint cs_state)
+{
+#ifdef JDS
+	espi->psppcfg->spics_cfg[cs].spi_cs_set((int) cs, (int) cs_state);
+#endif
+}
+
+/*
+ * Set data width for the SPI chip select
+ */
+static void lpc31xx_set_cs_data_bits(struct lpc31xx_spi *espi, u8 cs, u8 data_width)
+{
+#ifdef JDS
+	if (espi->current_bits_wd[cs] != data_width)
+	{
+		u32 tmp = spi_readl(SLV_SET2_REG(0));
+		tmp &= ~SPI_SLV2_WD_SZ(0x1F);
+		tmp |= SPI_SLV2_WD_SZ((u32) (data_width - 1));
+		spi_writel(SLV_SET2_REG(0), tmp);
+
+		espi->current_bits_wd[cs] = data_width;
+	}
+#endif
+}
+
+/*
+ * Set clock rate and delays for the SPI chip select
+ */
+static void lpc31xx_set_cs_clock(struct lpc31xx_spi *espi, u8 cs, u32 clockrate)
+{
+	u32 reg, div, ps, div1;
+
+#ifdef JDS
+	if (clockrate != espi->current_speed_hz[cs])
+	{
+		reg = spi_readl(SLV_SET1_REG(0));
+		reg &= ~0xFFFF;
+
+		div = (espi->spi_base_clock + clockrate / 2) / clockrate;
+		if (div > SPI_MAX_DIVIDER)
+			div = SPI_MAX_DIVIDER;
+		if (div < SPI_MIN_DIVIDER)
+			div = SPI_MIN_DIVIDER;
+
+		ps = (((div - 1) / 512) + 1) * 2;
+		div1 = (((div + ps / 2) / ps) - 1);
+
+		spi_writel(SLV_SET1_REG(0),
+			(reg | SPI_SLV1_CLK_PS(ps) | SPI_SLV1_CLK_DIV1(div1)));
+
+		espi->current_speed_hz[cs] = clockrate;
+	}
+#endif
+}
+
+/*
+ * Flush the TX and RX FIFOs
+ */
+static int lpc31xx_fifo_flush(struct lpc31xx_spi *espi)
+{
+	unsigned long timeout;
+	volatile uint32_t tmp;
+
+	/* Clear TX FIFO first */
+	spi_writel(TXF_FLUSH_REG, SPI_TXFF_FLUSH);
+
+	/* Clear RX FIFO */
+	timeout = jiffies + msecs_to_jiffies(SPI_POLLING_TIMEOUT);
+	while (!(spi_readl(STS_REG) & SPI_ST_RX_EMPTY)) {
+		if (time_after(jiffies, timeout)) {
+			dev_warn(&espi->pdev->dev,
+				 "timeout while flushing RX FIFO\n");
+			return -ETIMEDOUT;
+		}
+		tmp = spi_readl(FIFO_DATA_REG);
+	}
+	return 0;
+}
+
+
+/*
+ * Enable or disable the SPI clocks
+ */
+static void lpc31xx_spi_clks_enable(void)
+{
+	struct clk *clk;
+	int ret;
+
+	clk = clk_get(NULL, "spi_pclk");
+	ret = clk_enable(clk);
+	clk_put(clk);
+	clk = clk_get(NULL, "spi_pclk_gated");
+	ret = clk_enable(clk);
+	clk_put(clk);
+	clk = clk_get(NULL, "spi_clk");
+	ret = clk_enable(clk);
+	clk_put(clk);
+	clk = clk_get(NULL, "spi_clk_gated");
+	ret = clk_enable(clk);
+	clk_put(clk);
+}
+
+static void lpc31xx_spi_clks_disable(void)
+{
+	struct clk *clk;
+
+	clk = clk_get(NULL, "spi_pclk");
+	clk_disable(clk);
+	clk_put(clk);
+	clk = clk_get(NULL, "spi_pclk_gated");
+	clk_disable(clk);
+	clk_put(clk);
+	clk = clk_get(NULL, "spi_clk");
+	clk_disable(clk);
+	clk_put(clk);
+	clk = clk_get(NULL, "spi_clk_gated");
+	clk_disable(clk);
+	clk_put(clk);
+}
+
 /**
  * null_cs_control - Dummy chip select function
  * @command: select/delect the chip
@@ -281,7 +465,7 @@ struct chip_data {
  * If no chip select function is provided by client this is used as dummy
  * chip select
  */
-static void null_cs_control(u32 command)
+static void null_cs_control(uint32_t command)
 {
 	pr_debug("lpc31xx: dummy chip select control, CS=0x%x\n", command);
 }
@@ -292,12 +476,12 @@ static void null_cs_control(u32 command)
  * set message->status; dma and pio irqs are blocked
  * @lpc31xx: SSP driver private data structure
  */
-static void giveback(struct lpc31xx *lpc31xx)
+static void giveback(struct lpc31xx_spi *espi)
 {
 	struct spi_transfer *last_transfer;
-	lpc31xx->next_msg_cs_active = false;
+	espi->next_msg_cs_active = false;
 
-	last_transfer = list_entry(lpc31xx->cur_msg->transfers.prev,
+	last_transfer = list_entry(espi->cur_msg->transfers.prev,
 					struct spi_transfer,
 					transfer_list);
 
@@ -323,42 +507,45 @@ static void giveback(struct lpc31xx *lpc31xx)
 		 * could invalidate the cs_control() callback...
 		 */
 		/* get a pointer to the next message, if any */
-		next_msg = spi_get_next_queued_message(lpc31xx->master);
+		next_msg = spi_get_next_queued_message(espi->master);
 
 		/*
 		 * see if the next and current messages point
 		 * to the same spi device.
 		 */
-		if (next_msg && next_msg->spi != lpc31xx->cur_msg->spi)
+#ifdef JDS
+		if (next_msg && next_msg->spi != espi->cur_msg->spi)
 			next_msg = NULL;
-		if (!next_msg || lpc31xx->cur_msg->state == STATE_ERROR)
-			lpc31xx->cur_chip->cs_control(SSP_CHIP_DESELECT);
+		if (!next_msg || espi->cur_msg->state == STATE_ERROR)
+			espi->cur_chip->cs_control(SSP_CHIP_DESELECT);
 		else
-			lpc31xx->next_msg_cs_active = true;
+			espi->next_msg_cs_active = true;
+#endif
 
 	}
 
-	lpc31xx->cur_msg = NULL;
-	lpc31xx->cur_transfer = NULL;
-	lpc31xx->cur_chip = NULL;
-	spi_finalize_current_message(lpc31xx->master);
+	espi->cur_msg = NULL;
+	espi->cur_transfer = NULL;
+	espi->cur_chip = NULL;
+	spi_finalize_current_message(espi->master);
 }
 
 /**
  * flush - flush the FIFO to reach a clean state
  * @lpc31xx: SSP driver private data structure
  */
-static int flush(struct lpc31xx *lpc31xx)
+static int flush(struct lpc31xx_spi *espi)
 {
 	unsigned long limit = loops_per_jiffy << 1;
 
-	dev_dbg(&lpc31xx->pdev->dev, "flush\n");
+	dev_dbg(&espi->pdev->dev, "flush\n");
+#ifdef JDS
 	do {
-		while (readw(SSP_SR(lpc31xx->virtbase)) & SSP_SR_MASK_RNE)
-			readw(SSP_DR(lpc31xx->virtbase));
-	} while ((readw(SSP_SR(lpc31xx->virtbase)) & SSP_SR_MASK_BSY) && limit--);
-
-	lpc31xx->exp_fifo_level = 0;
+		while (readw(SSP_SR(espi->virtbase)) & SSP_SR_MASK_RNE)
+			readw(SSP_DR(espi->virtbase));
+	} while ((readw(SSP_SR(espi->virtbase)) & SSP_SR_MASK_BSY) && limit--);
+#endif
+	espi->exp_fifo_level = 0;
 
 	return limit;
 }
@@ -367,142 +554,109 @@ static int flush(struct lpc31xx *lpc31xx)
  * restore_state - Load configuration of current chip
  * @lpc31xx: SSP driver private data structure
  */
-static void restore_state(struct lpc31xx *lpc31xx)
+static void restore_state(struct lpc31xx_spi *espi)
 {
-	struct chip_data *chip = lpc31xx->cur_chip;
+	struct lpc31xx_spi_chip *chip = espi->cur_chip;
 
-#if JDS
-	if (lpc31xx->vendor->extended_cr)
-		writel(chip->cr0, SSP_CR0(lpc31xx->virtbase));
+#ifdef JDS
+	if (espi->vendor->extended_cr)
+		writel(chip->cr0, SSP_CR0(espi->virtbase));
 	else
-		writew(chip->cr0, SSP_CR0(lpc31xx->virtbase));
-	writew(chip->cr1, SSP_CR1(lpc31xx->virtbase));
-	writew(chip->dmacr, SSP_DMACR(lpc31xx->virtbase));
-	writew(chip->cpsr, SSP_CPSR(lpc31xx->virtbase));
-	writew(DISABLE_ALL_INTERRUPTS, SSP_IMSC(lpc31xx->virtbase));
-	writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(lpc31xx->virtbase));
+		writew(chip->cr0, SSP_CR0(espi->virtbase));
+	writew(chip->cr1, SSP_CR1(espi->virtbase));
+	writew(chip->dmacr, SSP_DMACR(espi->virtbase));
+	writew(chip->cpsr, SSP_CPSR(espi->virtbase));
+	writew(DISABLE_ALL_INTERRUPTS, SSP_IMSC(espi->virtbase));
+	writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(espi->virtbase));
 #endif
 }
 
 
 /**
- * load_spi_default_config - Load default configuration for SSP
- * @lpc31xx: SSP driver private data structure
- */
-static void load_spi_default_config(struct lpc31xx *lpc31xx)
-{
-#if JDS
-	if (lpc31xx->vendor->pl023) {
-		writel(DEFAULT_SSP_REG_CR0_ST_PL023, SSP_CR0(lpc31xx->virtbase));
-		writew(DEFAULT_SSP_REG_CR1_ST_PL023, SSP_CR1(lpc31xx->virtbase));
-	} else if (lpc31xx->vendor->extended_cr) {
-		writel(DEFAULT_SSP_REG_CR0_ST, SSP_CR0(lpc31xx->virtbase));
-		writew(DEFAULT_SSP_REG_CR1_ST, SSP_CR1(lpc31xx->virtbase));
-	} else {
-		writew(DEFAULT_SSP_REG_CR0, SSP_CR0(lpc31xx->virtbase));
-		writew(DEFAULT_SSP_REG_CR1, SSP_CR1(lpc31xx->virtbase));
-	}
-	writew(DEFAULT_SSP_REG_DMACR, SSP_DMACR(lpc31xx->virtbase));
-	writew(DEFAULT_SSP_REG_CPSR, SSP_CPSR(lpc31xx->virtbase));
-	writew(DISABLE_ALL_INTERRUPTS, SSP_IMSC(lpc31xx->virtbase));
-	writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(lpc31xx->virtbase));
-#endif
-}
-
-/**
  * This will write to TX and read from RX according to the parameters
  * set in lpc31xx.
  */
-static void readwriter(struct lpc31xx *lpc31xx)
+static void readwriter(struct lpc31xx_spi *espi)
 {
 
 	/*
 	 * The FIFO depth is different between primecell variants.
 	 * I believe filling in too much in the FIFO might cause
-	 * errons in 8bit wide transfers on ARM variants (just 8 words
+	 * errors in 8bit wide transfers on ARM variants (just 8 words
 	 * FIFO, means only 8x8 = 64 bits in FIFO) at least.
 	 *
 	 * To prevent this issue, the TX FIFO is only filled to the
 	 * unused RX FIFO fill length, regardless of what the TX
 	 * FIFO status flag indicates.
 	 */
-	dev_dbg(&lpc31xx->pdev->dev,
+	dev_dbg(&espi->pdev->dev,
 		"%s, rx: %p, rxend: %p, tx: %p, txend: %p\n",
-		__func__, lpc31xx->rx, lpc31xx->rx_end, lpc31xx->tx, lpc31xx->tx_end);
+		__func__, espi->rx, espi->rx_end, espi->tx, espi->tx_end);
 
+#ifdef JDS
 	/* Read as much as you can */
-	while ((readw(SSP_SR(lpc31xx->virtbase)) & SSP_SR_MASK_RNE)
-	       && (lpc31xx->rx < lpc31xx->rx_end)) {
-		switch (lpc31xx->read) {
+	while ((readw(SSP_SR(espi->virtbase)) & SSP_SR_MASK_RNE)
+	       && (espi->rx < espi->rx_end)) {
+		switch (espi->read) {
 		case READING_NULL:
-			readw(SSP_DR(lpc31xx->virtbase));
+			readw(SSP_DR(espi->virtbase));
 			break;
 		case READING_U8:
-			*(u8 *) (lpc31xx->rx) =
-				readw(SSP_DR(lpc31xx->virtbase)) & 0xFFU;
+			*(u8 *) (espi->rx) =
+				readw(SSP_DR(espi->virtbase)) & 0xFFU;
 			break;
 		case READING_U16:
-			*(u16 *) (lpc31xx->rx) =
-				(u16) readw(SSP_DR(lpc31xx->virtbase));
-			break;
-		case READING_U32:
-			*(u32 *) (lpc31xx->rx) =
-				readl(SSP_DR(lpc31xx->virtbase));
+			*(u16 *) (espi->rx) =
+				(u16) readw(SSP_DR(espi->virtbase));
 			break;
 		}
-		lpc31xx->rx += (lpc31xx->cur_chip->n_bytes);
-		lpc31xx->exp_fifo_level--;
+		espi->rx += (espi->cur_chip->n_bytes);
+		espi->exp_fifo_level--;
 	}
 	/*
 	 * Write as much as possible up to the RX FIFO size
 	 */
-	while ((lpc31xx->exp_fifo_level < lpc31xx->vendor->fifodepth)
-	       && (lpc31xx->tx < lpc31xx->tx_end)) {
-		switch (lpc31xx->write) {
+	while ((espi->exp_fifo_level < espi->vendor->fifodepth)
+	       && (espi->tx < espi->tx_end)) {
+		switch (espi->write) {
 		case WRITING_NULL:
-			writew(0x0, SSP_DR(lpc31xx->virtbase));
+			writew(0x0, SSP_DR(espi->virtbase));
 			break;
 		case WRITING_U8:
-			writew(*(u8 *) (lpc31xx->tx), SSP_DR(lpc31xx->virtbase));
+			writew(*(u8 *) (espi->tx), SSP_DR(espi->virtbase));
 			break;
 		case WRITING_U16:
-			writew((*(u16 *) (lpc31xx->tx)), SSP_DR(lpc31xx->virtbase));
-			break;
-		case WRITING_U32:
-			writel(*(u32 *) (lpc31xx->tx), SSP_DR(lpc31xx->virtbase));
+			writew((*(u16 *) (espi->tx)), SSP_DR(espi->virtbase));
 			break;
 		}
-		lpc31xx->tx += (lpc31xx->cur_chip->n_bytes);
-		lpc31xx->exp_fifo_level++;
+		espi->tx += (espi->cur_chip->n_bytes);
+		espi->exp_fifo_level++;
 		/*
 		 * This inner reader takes care of things appearing in the RX
 		 * FIFO as we're transmitting. This will happen a lot since the
 		 * clock starts running when you put things into the TX FIFO,
 		 * and then things are continuously clocked into the RX FIFO.
 		 */
-		while ((readw(SSP_SR(lpc31xx->virtbase)) & SSP_SR_MASK_RNE)
-		       && (lpc31xx->rx < lpc31xx->rx_end)) {
-			switch (lpc31xx->read) {
+		while ((readw(SSP_SR(espi->virtbase)) & SSP_SR_MASK_RNE)
+		       && (espi->rx < espi->rx_end)) {
+			switch (espi->read) {
 			case READING_NULL:
-				readw(SSP_DR(lpc31xx->virtbase));
+				readw(SSP_DR(espi->virtbase));
 				break;
 			case READING_U8:
-				*(u8 *) (lpc31xx->rx) =
-					readw(SSP_DR(lpc31xx->virtbase)) & 0xFFU;
+				*(u8 *) (espi->rx) =
+					readw(SSP_DR(espi->virtbase)) & 0xFFU;
 				break;
 			case READING_U16:
-				*(u16 *) (lpc31xx->rx) =
-					(u16) readw(SSP_DR(lpc31xx->virtbase));
-				break;
-			case READING_U32:
-				*(u32 *) (lpc31xx->rx) =
-					readl(SSP_DR(lpc31xx->virtbase));
+				*(u16 *) (espi->rx) =
+					(u16) readw(SSP_DR(espi->virtbase));
 				break;
 			}
-			lpc31xx->rx += (lpc31xx->cur_chip->n_bytes);
-			lpc31xx->exp_fifo_level--;
+			espi->rx += (espi->cur_chip->n_bytes);
+			espi->exp_fifo_level--;
 		}
 	}
+#endif
 	/*
 	 * When we exit here the TX FIFO should be full and the RX FIFO
 	 * should be empty
@@ -518,14 +672,14 @@ static void readwriter(struct lpc31xx *lpc31xx)
  * message i.e whether its last transfer is done(STATE_DONE) or
  * Next transfer is ready(STATE_RUNNING)
  */
-static void *next_transfer(struct lpc31xx *lpc31xx)
+static void *next_transfer(struct lpc31xx_spi *espi)
 {
-	struct spi_message *msg = lpc31xx->cur_msg;
-	struct spi_transfer *trans = lpc31xx->cur_transfer;
+	struct spi_message *msg = espi->cur_msg;
+	struct spi_transfer *trans = espi->cur_transfer;
 
 	/* Move to next transfer */
 	if (trans->transfer_list.next != &msg->transfers) {
-		lpc31xx->cur_transfer =
+		espi->cur_transfer =
 		    list_entry(trans->transfer_list.next,
 			       struct spi_transfer, transfer_list);
 		return STATE_RUNNING;
@@ -538,23 +692,23 @@ static void *next_transfer(struct lpc31xx *lpc31xx)
  * access to the generic DMA devices/DMA engine.
  */
 #ifdef CONFIG_DMA_ENGINE_X
-static void unmap_free_dma_scatter(struct lpc31xx *lpc31xx)
+static void unmap_free_dma_scatter(struct lpc31xx_spi *espi)
 {
 	/* Unmap and free the SG tables */
-	dma_unmap_sg(lpc31xx->dma_tx_channel->device->dev, lpc31xx->sgt_tx.sgl,
-		     lpc31xx->sgt_tx.nents, DMA_TO_DEVICE);
-	dma_unmap_sg(lpc31xx->dma_rx_channel->device->dev, lpc31xx->sgt_rx.sgl,
-		     lpc31xx->sgt_rx.nents, DMA_FROM_DEVICE);
-	sg_free_table(&lpc31xx->sgt_rx);
-	sg_free_table(&lpc31xx->sgt_tx);
+	dma_unmap_sg(espi->dma_tx_channel->device->dev, espi->sgt_tx.sgl,
+		     espi->sgt_tx.nents, DMA_TO_DEVICE);
+	dma_unmap_sg(espi->dma_rx_channel->device->dev, espi->sgt_rx.sgl,
+		     espi->sgt_rx.nents, DMA_FROM_DEVICE);
+	sg_free_table(&espi->sgt_rx);
+	sg_free_table(&espi->sgt_tx);
 }
 
 static void dma_callback(void *data)
 {
-	struct lpc31xx *lpc31xx = data;
-	struct spi_message *msg = lpc31xx->cur_msg;
+	struct lpc31xx_spi *espi = data;
+	struct spi_message *msg = espi->cur_msg;
 
-	BUG_ON(!lpc31xx->sgt_rx.sgl);
+	BUG_ON(!espi->sgt_rx.sgl);
 
 #ifdef VERBOSE_DEBUG
 	/*
@@ -567,13 +721,13 @@ static void dma_callback(void *data)
 		struct scatterlist *sg;
 		unsigned int i;
 
-		dma_sync_sg_for_cpu(&lpc31xx->pdev->dev,
-				    lpc31xx->sgt_rx.sgl,
-				    lpc31xx->sgt_rx.nents,
+		dma_sync_sg_for_cpu(&espi->pdev->dev,
+				    espi->sgt_rx.sgl,
+				    espi->sgt_rx.nents,
 				    DMA_FROM_DEVICE);
 
-		for_each_sg(lpc31xx->sgt_rx.sgl, sg, lpc31xx->sgt_rx.nents, i) {
-			dev_dbg(&lpc31xx->pdev->dev, "SPI RX SG ENTRY: %d", i);
+		for_each_sg(espi->sgt_rx.sgl, sg, espi->sgt_rx.nents, i) {
+			dev_dbg(&espi->pdev->dev, "SPI RX SG ENTRY: %d", i);
 			print_hex_dump(KERN_ERR, "SPI RX: ",
 				       DUMP_PREFIX_OFFSET,
 				       16,
@@ -582,8 +736,8 @@ static void dma_callback(void *data)
 				       sg_dma_len(sg),
 				       1);
 		}
-		for_each_sg(lpc31xx->sgt_tx.sgl, sg, lpc31xx->sgt_tx.nents, i) {
-			dev_dbg(&lpc31xx->pdev->dev, "SPI TX SG ENTRY: %d", i);
+		for_each_sg(espi->sgt_tx.sgl, sg, espi->sgt_tx.nents, i) {
+			dev_dbg(&espi->pdev->dev, "SPI TX SG ENTRY: %d", i);
 			print_hex_dump(KERN_ERR, "SPI TX: ",
 				       DUMP_PREFIX_OFFSET,
 				       16,
@@ -595,20 +749,20 @@ static void dma_callback(void *data)
 	}
 #endif
 
-	unmap_free_dma_scatter(lpc31xx);
+	unmap_free_dma_scatter(espi);
 
 	/* Update total bytes transferred */
-	msg->actual_length += lpc31xx->cur_transfer->len;
-	if (lpc31xx->cur_transfer->cs_change)
-		lpc31xx->cur_chip->
+	msg->actual_length += espi->cur_transfer->len;
+	if (espi->cur_transfer->cs_change)
+		espi->cur_chip->
 			cs_control(SSP_CHIP_DESELECT);
 
 	/* Move to next transfer */
-	msg->state = next_transfer(lpc31xx);
-	tasklet_schedule(&lpc31xx->pump_transfers);
+	msg->state = next_transfer(espi);
+	tasklet_schedule(&espi->pump_transfers);
 }
 
-static void setup_dma_scatter(struct lpc31xx *lpc31xx,
+static void setup_dma_scatter(struct lpc31xx_spi *espi,
 			      void *buffer,
 			      unsigned int length,
 			      struct sg_table *sgtab)
@@ -635,7 +789,7 @@ static void setup_dma_scatter(struct lpc31xx *lpc31xx,
 				    mapbytes, offset_in_page(bufp));
 			bufp += mapbytes;
 			bytesleft -= mapbytes;
-			dev_dbg(&lpc31xx->pdev->dev,
+			dev_dbg(&espi->pdev->dev,
 				"set RX/TX target page @ %p, %d bytes, %d left\n",
 				bufp, mapbytes, bytesleft);
 		}
@@ -646,10 +800,10 @@ static void setup_dma_scatter(struct lpc31xx *lpc31xx,
 				mapbytes = bytesleft;
 			else
 				mapbytes = PAGE_SIZE;
-			sg_set_page(sg, virt_to_page(lpc31xx->dummypage),
+			sg_set_page(sg, virt_to_page(espi->dummypage),
 				    mapbytes, 0);
 			bytesleft -= mapbytes;
-			dev_dbg(&lpc31xx->pdev->dev,
+			dev_dbg(&espi->pdev->dev,
 				"set RX/TX to dummy page %d bytes, %d left\n",
 				mapbytes, bytesleft);
 
@@ -662,23 +816,23 @@ static void setup_dma_scatter(struct lpc31xx *lpc31xx,
  * configure_dma - configures the channels for the next transfer
  * @lpc31xx: SSP driver's private data structure
  */
-static int configure_dma(struct lpc31xx *lpc31xx)
+static int configure_dma(struct lpc31xx_spi *espi)
 {
 	struct dma_slave_config rx_conf = {
-		.src_addr = SSP_DR(lpc31xx->phybase),
+		.src_addr = SSP_DR(espi->phybase),
 		.direction = DMA_DEV_TO_MEM,
 		.device_fc = false,
 	};
 	struct dma_slave_config tx_conf = {
-		.dst_addr = SSP_DR(lpc31xx->phybase),
+		.dst_addr = SSP_DR(espi->phybase),
 		.direction = DMA_MEM_TO_DEV,
 		.device_fc = false,
 	};
 	unsigned int pages;
 	int ret;
 	int rx_sglen, tx_sglen;
-	struct dma_chan *rxchan = lpc31xx->dma_rx_channel;
-	struct dma_chan *txchan = lpc31xx->dma_tx_channel;
+	struct dma_chan *rxchan = espi->dma_rx_channel;
+	struct dma_chan *txchan = espi->dma_tx_channel;
 	struct dma_async_tx_descriptor *rxdesc;
 	struct dma_async_tx_descriptor *txdesc;
 
@@ -692,7 +846,7 @@ static int configure_dma(struct lpc31xx *lpc31xx)
 	 * not trigger on 2 elements this needs explicit mapping rather than
 	 * calculation.
 	 */
-	switch (lpc31xx->rx_lev_trig) {
+	switch (espi->rx_lev_trig) {
 	case SSP_RX_1_OR_MORE_ELEM:
 		rx_conf.src_maxburst = 1;
 		break;
@@ -709,11 +863,11 @@ static int configure_dma(struct lpc31xx *lpc31xx)
 		rx_conf.src_maxburst = 32;
 		break;
 	default:
-		rx_conf.src_maxburst = lpc31xx->vendor->fifodepth >> 1;
+		rx_conf.src_maxburst = espi->vendor->fifodepth >> 1;
 		break;
 	}
 
-	switch (lpc31xx->tx_lev_trig) {
+	switch (espi->tx_lev_trig) {
 	case SSP_TX_1_OR_MORE_EMPTY_LOC:
 		tx_conf.dst_maxburst = 1;
 		break;
@@ -730,11 +884,11 @@ static int configure_dma(struct lpc31xx *lpc31xx)
 		tx_conf.dst_maxburst = 32;
 		break;
 	default:
-		tx_conf.dst_maxburst = lpc31xx->vendor->fifodepth >> 1;
+		tx_conf.dst_maxburst = espi->vendor->fifodepth >> 1;
 		break;
 	}
 
-	switch (lpc31xx->read) {
+	switch (espi->read) {
 	case READING_NULL:
 		/* Use the same as for writing */
 		rx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;
@@ -750,7 +904,7 @@ static int configure_dma(struct lpc31xx *lpc31xx)
 		break;
 	}
 
-	switch (lpc31xx->write) {
+	switch (espi->write) {
 	case WRITING_NULL:
 		/* Use the same as for reading */
 		tx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;
@@ -777,37 +931,37 @@ static int configure_dma(struct lpc31xx *lpc31xx)
 	dmaengine_slave_config(txchan, &tx_conf);
 
 	/* Create sglists for the transfers */
-	pages = DIV_ROUND_UP(lpc31xx->cur_transfer->len, PAGE_SIZE);
-	dev_dbg(&lpc31xx->pdev->dev, "using %d pages for transfer\n", pages);
+	pages = DIV_ROUND_UP(espi->cur_transfer->len, PAGE_SIZE);
+	dev_dbg(&espi->pdev->dev, "using %d pages for transfer\n", pages);
 
-	ret = sg_alloc_table(&lpc31xx->sgt_rx, pages, GFP_ATOMIC);
+	ret = sg_alloc_table(&espi->sgt_rx, pages, GFP_ATOMIC);
 	if (ret)
 		goto err_alloc_rx_sg;
 
-	ret = sg_alloc_table(&lpc31xx->sgt_tx, pages, GFP_ATOMIC);
+	ret = sg_alloc_table(&espi->sgt_tx, pages, GFP_ATOMIC);
 	if (ret)
 		goto err_alloc_tx_sg;
 
 	/* Fill in the scatterlists for the RX+TX buffers */
-	setup_dma_scatter(lpc31xx, lpc31xx->rx,
-			  lpc31xx->cur_transfer->len, &lpc31xx->sgt_rx);
-	setup_dma_scatter(lpc31xx, lpc31xx->tx,
-			  lpc31xx->cur_transfer->len, &lpc31xx->sgt_tx);
+	setup_dma_scatter(espi, espi->rx,
+			  espi->cur_transfer->len, &espi->sgt_rx);
+	setup_dma_scatter(espi, espi->tx,
+			  espi->cur_transfer->len, &espi->sgt_tx);
 
 	/* Map DMA buffers */
-	rx_sglen = dma_map_sg(rxchan->device->dev, lpc31xx->sgt_rx.sgl,
-			   lpc31xx->sgt_rx.nents, DMA_FROM_DEVICE);
+	rx_sglen = dma_map_sg(rxchan->device->dev, espi->sgt_rx.sgl,
+			   espi->sgt_rx.nents, DMA_FROM_DEVICE);
 	if (!rx_sglen)
 		goto err_rx_sgmap;
 
-	tx_sglen = dma_map_sg(txchan->device->dev, lpc31xx->sgt_tx.sgl,
-			   lpc31xx->sgt_tx.nents, DMA_TO_DEVICE);
+	tx_sglen = dma_map_sg(txchan->device->dev, espi->sgt_tx.sgl,
+			   espi->sgt_tx.nents, DMA_TO_DEVICE);
 	if (!tx_sglen)
 		goto err_tx_sgmap;
 
 	/* Send both scatter lists */
 	rxdesc = dmaengine_prep_slave_sg(rxchan,
-				      lpc31xx->sgt_rx.sgl,
+				      espi->sgt_rx.sgl,
 				      rx_sglen,
 				      DMA_DEV_TO_MEM,
 				      DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
@@ -815,7 +969,7 @@ static int configure_dma(struct lpc31xx *lpc31xx)
 		goto err_rxdesc;
 
 	txdesc = dmaengine_prep_slave_sg(txchan,
-				      lpc31xx->sgt_tx.sgl,
+				      espi->sgt_tx.sgl,
 				      tx_sglen,
 				      DMA_MEM_TO_DEV,
 				      DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
@@ -824,14 +978,14 @@ static int configure_dma(struct lpc31xx *lpc31xx)
 
 	/* Put the callback on the RX transfer only, that should finish last */
 	rxdesc->callback = dma_callback;
-	rxdesc->callback_param = lpc31xx;
+	rxdesc->callback_param = espi;
 
 	/* Submit and fire RX and TX with TX last so we're ready to read! */
 	dmaengine_submit(rxdesc);
 	dmaengine_submit(txdesc);
 	dma_async_issue_pending(rxchan);
 	dma_async_issue_pending(txchan);
-	lpc31xx->dma_running = true;
+	espi->dma_running = true;
 
 	return 0;
 
@@ -839,20 +993,20 @@ err_txdesc:
 	dmaengine_terminate_all(txchan);
 err_rxdesc:
 	dmaengine_terminate_all(rxchan);
-	dma_unmap_sg(txchan->device->dev, lpc31xx->sgt_tx.sgl,
-		     lpc31xx->sgt_tx.nents, DMA_TO_DEVICE);
+	dma_unmap_sg(txchan->device->dev, espi->sgt_tx.sgl,
+		     espi->sgt_tx.nents, DMA_TO_DEVICE);
 err_tx_sgmap:
-	dma_unmap_sg(rxchan->device->dev, lpc31xx->sgt_rx.sgl,
-		     lpc31xx->sgt_tx.nents, DMA_FROM_DEVICE);
+	dma_unmap_sg(rxchan->device->dev, espi->sgt_rx.sgl,
+		     espi->sgt_tx.nents, DMA_FROM_DEVICE);
 err_rx_sgmap:
-	sg_free_table(&lpc31xx->sgt_tx);
+	sg_free_table(&espi->sgt_tx);
 err_alloc_tx_sg:
-	sg_free_table(&lpc31xx->sgt_rx);
+	sg_free_table(&espi->sgt_rx);
 err_alloc_rx_sg:
 	return -ENOMEM;
 }
 
-static int __devinit lpc31xx_dma_probe(struct lpc31xx *lpc31xx)
+static int __devinit lpc31xx_dma_probe(struct lpc31xx_spi *espi)
 {
 	dma_cap_mask_t mask;
 
@@ -863,79 +1017,79 @@ static int __devinit lpc31xx_dma_probe(struct lpc31xx *lpc31xx)
 	 * We need both RX and TX channels to do DMA, else do none
 	 * of them.
 	 */
-	lpc31xx->dma_rx_channel = dma_request_channel(mask,
-					    lpc31xx->master_info->dma_filter,
-					    lpc31xx->master_info->dma_rx_param);
-	if (!lpc31xx->dma_rx_channel) {
-		dev_dbg(&lpc31xx->pdev->dev, "no RX DMA channel!\n");
+	espi->dma_rx_channel = dma_request_channel(mask,
+					    espi->master_info->dma_filter,
+					    espi->master_info->dma_rx_param);
+	if (!espi->dma_rx_channel) {
+		dev_dbg(&espi->pdev->dev, "no RX DMA channel!\n");
 		goto err_no_rxchan;
 	}
 
-	lpc31xx->dma_tx_channel = dma_request_channel(mask,
-					    lpc31xx->master_info->dma_filter,
-					    lpc31xx->master_info->dma_tx_param);
-	if (!lpc31xx->dma_tx_channel) {
-		dev_dbg(&lpc31xx->pdev->dev, "no TX DMA channel!\n");
+	espi->dma_tx_channel = dma_request_channel(mask,
+					    espi->master_info->dma_filter,
+					    espi->master_info->dma_tx_param);
+	if (!espi->dma_tx_channel) {
+		dev_dbg(&espi->pdev->dev, "no TX DMA channel!\n");
 		goto err_no_txchan;
 	}
 
-	lpc31xx->dummypage = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!lpc31xx->dummypage) {
-		dev_dbg(&lpc31xx->pdev->dev, "no DMA dummypage!\n");
+	espi->dummypage = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!espi->dummypage) {
+		dev_dbg(&espi->pdev->dev, "no DMA dummypage!\n");
 		goto err_no_dummypage;
 	}
 
-	dev_info(&lpc31xx->pdev->dev, "setup for DMA on RX %s, TX %s\n",
-		 dma_chan_name(lpc31xx->dma_rx_channel),
-		 dma_chan_name(lpc31xx->dma_tx_channel));
+	dev_info(&espi->pdev->dev, "setup for DMA on RX %s, TX %s\n",
+		 dma_chan_name(espi->dma_rx_channel),
+		 dma_chan_name(espi->dma_tx_channel));
 
 	return 0;
 
 err_no_dummypage:
-	dma_release_channel(lpc31xx->dma_tx_channel);
+	dma_release_channel(espi->dma_tx_channel);
 err_no_txchan:
-	dma_release_channel(lpc31xx->dma_rx_channel);
-	lpc31xx->dma_rx_channel = NULL;
+	dma_release_channel(espi->dma_rx_channel);
+	espi->dma_rx_channel = NULL;
 err_no_rxchan:
-	dev_err(&lpc31xx->pdev->dev,
+	dev_err(&espi->pdev->dev,
 			"Failed to work in dma mode, work without dma!\n");
 	return -ENODEV;
 }
 
-static void terminate_dma(struct lpc31xx *lpc31xx)
+static void terminate_dma(struct lpc31xx_spi *espi)
 {
-	struct dma_chan *rxchan = lpc31xx->dma_rx_channel;
-	struct dma_chan *txchan = lpc31xx->dma_tx_channel;
+	struct dma_chan *rxchan = espi->dma_rx_channel;
+	struct dma_chan *txchan = espi->dma_tx_channel;
 
 	dmaengine_terminate_all(rxchan);
 	dmaengine_terminate_all(txchan);
-	unmap_free_dma_scatter(lpc31xx);
-	lpc31xx->dma_running = false;
+	unmap_free_dma_scatter(espi);
+	espi->dma_running = false;
 }
 
-static void lpc31xx_dma_remove(struct lpc31xx *lpc31xx)
+static void lpc31xx_dma_remove(struct lpc31xx_spi *espi)
 {
-	if (lpc31xx->dma_running)
-		terminate_dma(lpc31xx);
-	if (lpc31xx->dma_tx_channel)
-		dma_release_channel(lpc31xx->dma_tx_channel);
-	if (lpc31xx->dma_rx_channel)
-		dma_release_channel(lpc31xx->dma_rx_channel);
-	kfree(lpc31xx->dummypage);
+	if (espi->dma_running)
+		terminate_dma(espi);
+	if (espi->dma_tx_channel)
+		dma_release_channel(espi->dma_tx_channel);
+	if (espi->dma_rx_channel)
+		dma_release_channel(espi->dma_rx_channel);
+	kfree(espi->dummypage);
 }
 
 #else
-static inline int configure_dma(struct lpc31xx *lpc31xx)
+static inline int configure_dma(struct lpc31xx_spi *espi)
 {
 	return -ENODEV;
 }
 
-static inline int lpc31xx_dma_probe(struct lpc31xx *lpc31xx)
+static inline int lpc31xx_dma_probe(struct lpc31xx_spi *espi)
 {
 	return 0;
 }
 
-static inline void lpc31xx_dma_remove(struct lpc31xx *lpc31xx)
+static inline void lpc31xx_dma_remove(struct lpc31xx_spi *espi)
 {
 }
 #endif
@@ -953,20 +1107,22 @@ static inline void lpc31xx_dma_remove(struct lpc31xx *lpc31xx)
  */
 static irqreturn_t lpc31xx_interrupt_handler(int irq, void *dev_id)
 {
-	struct lpc31xx *lpc31xx = dev_id;
-	struct spi_message *msg = lpc31xx->cur_msg;
+	struct lpc31xx_spi *espi = dev_id;
+	struct spi_message *msg = espi->cur_msg;
 	u16 irq_status = 0;
 	u16 flag = 0;
 
+	dev_dbg(&espi->pdev->dev, "lpc31xx_interrupt_handler\n");
+
 	if (unlikely(!msg)) {
-		dev_err(&lpc31xx->pdev->dev,
+		dev_err(&espi->pdev->dev,
 			"bad message state in interrupt handler");
 		/* Never fail */
 		return IRQ_HANDLED;
 	}
-#if JDS
+#ifdef JDS
 	/* Read the Interrupt Status Register */
-	irq_status = readw(SSP_MIS(lpc31xx->virtbase));
+	irq_status = readw(SSP_MIS(espi->virtbase));
 
 	if (unlikely(!irq_status))
 		return IRQ_NONE;
@@ -981,12 +1137,12 @@ static irqreturn_t lpc31xx_interrupt_handler(int irq, void *dev_id)
 		 * Overrun interrupt - bail out since our Data has been
 		 * corrupted
 		 */
-		dev_err(&lpc31xx->pdev->dev, "FIFO overrun\n");
-		if (readw(SSP_SR(lpc31xx->virtbase)) & SSP_SR_MASK_RFF)
-			dev_err(&lpc31xx->pdev->dev,
+		dev_err(&espi->pdev->dev, "FIFO overrun\n");
+		if (readw(SSP_SR(espi->virtbase)) & SSP_SR_MASK_RFF)
+			dev_err(&espi->pdev->dev,
 				"RXFIFO is full\n");
-		if (readw(SSP_SR(lpc31xx->virtbase)) & SSP_SR_MASK_TNF)
-			dev_err(&lpc31xx->pdev->dev,
+		if (readw(SSP_SR(espi->virtbase)) & SSP_SR_MASK_TNF)
+			dev_err(&espi->pdev->dev,
 				"TXFIFO is full\n");
 
 		/*
@@ -995,25 +1151,25 @@ static irqreturn_t lpc31xx_interrupt_handler(int irq, void *dev_id)
 		 * retried.
 		 */
 		writew(DISABLE_ALL_INTERRUPTS,
-		       SSP_IMSC(lpc31xx->virtbase));
-		writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(lpc31xx->virtbase));
-		writew((readw(SSP_CR1(lpc31xx->virtbase)) &
-			(~SSP_CR1_MASK_SSE)), SSP_CR1(lpc31xx->virtbase));
+		       SSP_IMSC(espi->virtbase));
+		writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(espi->virtbase));
+		writew((readw(SSP_CR1(espi->virtbase)) &
+			(~SSP_CR1_MASK_SSE)), SSP_CR1(espi->virtbase));
 		msg->state = STATE_ERROR;
 
 		/* Schedule message queue handler */
-		tasklet_schedule(&lpc31xx->pump_transfers);
+		tasklet_schedule(&espi->pump_transfers);
 		return IRQ_HANDLED;
 	}
 
-	readwriter(lpc31xx);
+	readwriter(espi);
 
-	if ((lpc31xx->tx == lpc31xx->tx_end) && (flag == 0)) {
+	if ((espi->tx == espi->tx_end) && (flag == 0)) {
 		flag = 1;
 		/* Disable Transmit interrupt, enable receive interrupt */
-		writew((readw(SSP_IMSC(lpc31xx->virtbase)) &
+		writew((readw(SSP_IMSC(espi->virtbase)) &
 		       ~SSP_IMSC_MASK_TXIM) | SSP_IMSC_MASK_RXIM,
-		       SSP_IMSC(lpc31xx->virtbase));
+		       SSP_IMSC(espi->virtbase));
 	}
 
 	/*
@@ -1021,24 +1177,24 @@ static irqreturn_t lpc31xx_interrupt_handler(int irq, void *dev_id)
 	 * we can conclude the entire transaction once RX is complete.
 	 * At this point, all TX will always be finished.
 	 */
-	if (lpc31xx->rx >= lpc31xx->rx_end) {
+	if (espi->rx >= espi->rx_end) {
 		writew(DISABLE_ALL_INTERRUPTS,
-		       SSP_IMSC(lpc31xx->virtbase));
-		writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(lpc31xx->virtbase));
-		if (unlikely(lpc31xx->rx > lpc31xx->rx_end)) {
-			dev_warn(&lpc31xx->pdev->dev, "read %u surplus "
+		       SSP_IMSC(espi->virtbase));
+		writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(espi->virtbase));
+		if (unlikely(espi->rx > espi->rx_end)) {
+			dev_warn(&espi->pdev->dev, "read %u surplus "
 				 "bytes (did you request an odd "
 				 "number of bytes on a 16bit bus?)\n",
-				 (u32) (lpc31xx->rx - lpc31xx->rx_end));
+				 (uint32_t) (espi->rx - espi->rx_end));
 		}
 		/* Update total bytes transferred */
-		msg->actual_length += lpc31xx->cur_transfer->len;
-		if (lpc31xx->cur_transfer->cs_change)
-			lpc31xx->cur_chip->
+		msg->actual_length += espi->cur_transfer->len;
+		if (espi->cur_transfer->cs_change)
+			espi->cur_chip->
 				cs_control(SSP_CHIP_DESELECT);
 		/* Move to next transfer */
-		msg->state = next_transfer(lpc31xx);
-		tasklet_schedule(&lpc31xx->pump_transfers);
+		msg->state = next_transfer(espi);
+		tasklet_schedule(&espi->pump_transfers);
 		return IRQ_HANDLED;
 	}
 #endif
@@ -1049,29 +1205,31 @@ static irqreturn_t lpc31xx_interrupt_handler(int irq, void *dev_id)
  * This sets up the pointers to memory for the next message to
  * send out on the SPI bus.
  */
-static int set_up_next_transfer(struct lpc31xx *lpc31xx,
+static int set_up_next_transfer(struct lpc31xx_spi *espi,
 				struct spi_transfer *transfer)
 {
 	int residue;
 
+	dev_dbg(&espi->pdev->dev, "set_up_next_transfer\n");
+
 	/* Sanity check the message for this bus width */
-	residue = lpc31xx->cur_transfer->len % lpc31xx->cur_chip->n_bytes;
+	residue = espi->cur_transfer->len % espi->cur_chip->n_bytes;
 	if (unlikely(residue != 0)) {
-		dev_err(&lpc31xx->pdev->dev,
+		dev_err(&espi->pdev->dev,
 			"message of %u bytes to transmit but the current "
 			"chip bus has a data width of %u bytes!\n",
-			lpc31xx->cur_transfer->len,
-			lpc31xx->cur_chip->n_bytes);
-		dev_err(&lpc31xx->pdev->dev, "skipping this message\n");
+			espi->cur_transfer->len,
+			espi->cur_chip->n_bytes);
+		dev_err(&espi->pdev->dev, "skipping this message\n");
 		return -EIO;
 	}
-	lpc31xx->tx = (void *)transfer->tx_buf;
-	lpc31xx->tx_end = lpc31xx->tx + lpc31xx->cur_transfer->len;
-	lpc31xx->rx = (void *)transfer->rx_buf;
-	lpc31xx->rx_end = lpc31xx->rx + lpc31xx->cur_transfer->len;
-	lpc31xx->write =
-	    lpc31xx->tx ? lpc31xx->cur_chip->write : WRITING_NULL;
-	lpc31xx->read = lpc31xx->rx ? lpc31xx->cur_chip->read : READING_NULL;
+	espi->tx = (void *)transfer->tx_buf;
+	espi->tx_end = espi->tx + espi->cur_transfer->len;
+	espi->rx = (void *)transfer->rx_buf;
+	espi->rx_end = espi->rx + espi->cur_transfer->len;
+	espi->write =
+	    espi->tx ? espi->cur_chip->write : WRITING_NULL;
+	espi->read = espi->rx ? espi->cur_chip->read : READING_NULL;
 	return 0;
 }
 
@@ -1083,26 +1241,28 @@ static int set_up_next_transfer(struct lpc31xx *lpc31xx,
  */
 static void pump_transfers(unsigned long data)
 {
-	struct lpc31xx *lpc31xx = (struct lpc31xx *) data;
+	struct lpc31xx_spi *espi = (struct lpc31xx_spi *) data;
 	struct spi_message *message = NULL;
 	struct spi_transfer *transfer = NULL;
 	struct spi_transfer *previous = NULL;
 
+	dev_dbg(&espi->pdev->dev, "pump_transfers\n");
+
 	/* Get current state information */
-	message = lpc31xx->cur_msg;
-	transfer = lpc31xx->cur_transfer;
+	message = espi->cur_msg;
+	transfer = espi->cur_transfer;
 
 	/* Handle for abort */
 	if (message->state == STATE_ERROR) {
 		message->status = -EIO;
-		giveback(lpc31xx);
+		giveback(espi);
 		return;
 	}
 
 	/* Handle end of message */
 	if (message->state == STATE_DONE) {
 		message->status = 0;
-		giveback(lpc31xx);
+		giveback(espi);
 		return;
 	}
 
@@ -1119,25 +1279,27 @@ static void pump_transfers(unsigned long data)
 			udelay(previous->delay_usecs);
 
 		/* Reselect chip select only if cs_change was requested */
+#ifdef JDS
 		if (previous->cs_change)
-			lpc31xx->cur_chip->cs_control(SSP_CHIP_SELECT);
+			espi->cur_chip->cs_control(SSP_CHIP_SELECT);
+#endif
 	} else {
 		/* STATE_START */
 		message->state = STATE_RUNNING;
 	}
 
-	if (set_up_next_transfer(lpc31xx, transfer)) {
+	if (set_up_next_transfer(espi, transfer)) {
 		message->state = STATE_ERROR;
 		message->status = -EIO;
-		giveback(lpc31xx);
+		giveback(espi);
 		return;
 	}
 	/* Flush the FIFOs and let's go! */
-	flush(lpc31xx);
+	flush(espi);
 
-	if (lpc31xx->cur_chip->enable_dma) {
-		if (configure_dma(lpc31xx)) {
-			dev_dbg(&lpc31xx->pdev->dev,
+	if (espi->cur_chip->enable_dma) {
+		if (configure_dma(espi)) {
+			dev_dbg(&espi->pdev->dev,
 				"configuration of DMA failed, fall back to interrupt mode\n");
 			goto err_config_dma;
 		}
@@ -1145,35 +1307,40 @@ static void pump_transfers(unsigned long data)
 	}
 
 err_config_dma:
+#ifdef JDS
 	/* enable all interrupts except RX */
-	writew(ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM, SSP_IMSC(lpc31xx->virtbase));
+	writew(ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM, SSP_IMSC(espi->virtbase));
+#endif
+	return;
 }
 
-static void do_interrupt_dma_transfer(struct lpc31xx *lpc31xx)
+static void do_interrupt_dma_transfer(struct lpc31xx_spi *espi)
 {
-#if JDS
+	dev_dbg(&espi->pdev->dev, "do_interrupt_dma_transfer\n");
+
+#ifdef JDS
 	/*
 	 * Default is to enable all interrupts except RX -
 	 * this will be enabled once TX is complete
 	 */
-	u32 irqflags = ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM;
+	uint32_t irqflags = ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM;
 
 	/* Enable target chip, if not already active */
-	if (!lpc31xx->next_msg_cs_active)
-		lpc31xx->cur_chip->cs_control(SSP_CHIP_SELECT);
+	if (!espi->next_msg_cs_active)
+		espi->cur_chip->cs_control(SSP_CHIP_SELECT);
 
-	if (set_up_next_transfer(lpc31xx, lpc31xx->cur_transfer)) {
+	if (set_up_next_transfer(espi, espi->cur_transfer)) {
 		/* Error path */
-		lpc31xx->cur_msg->state = STATE_ERROR;
-		lpc31xx->cur_msg->status = -EIO;
-		giveback(lpc31xx);
+		espi->cur_msg->state = STATE_ERROR;
+		espi->cur_msg->status = -EIO;
+		giveback(espi);
 		return;
 	}
 	/* If we're using DMA, set up DMA here */
-	if (lpc31xx->cur_chip->enable_dma) {
+	if (espi->cur_chip->enable_dma) {
 		/* Configure DMA transfer */
-		if (configure_dma(lpc31xx)) {
-			dev_dbg(&lpc31xx->pdev->dev,
+		if (configure_dma(espi)) {
+			dev_dbg(&espi->pdev->dev,
 				"configuration of DMA failed, fall back to interrupt mode\n");
 			goto err_config_dma;
 		}
@@ -1182,28 +1349,30 @@ static void do_interrupt_dma_transfer(struct lpc31xx *lpc31xx)
 	}
 err_config_dma:
 	/* Enable SSP, turn on interrupts */
-	writew((readw(SSP_CR1(lpc31xx->virtbase)) | SSP_CR1_MASK_SSE),
-	       SSP_CR1(lpc31xx->virtbase));
-	writew(irqflags, SSP_IMSC(lpc31xx->virtbase));
+	writew((readw(SSP_CR1(espi->virtbase)) | SSP_CR1_MASK_SSE),
+	       SSP_CR1(espi->virtbase));
+	writew(irqflags, SSP_IMSC(espi->virtbase));
 #endif
 }
 
-static void do_polling_transfer(struct lpc31xx *lpc31xx)
+static void do_polling_transfer(struct lpc31xx_spi *espi)
 {
 	struct spi_message *message = NULL;
 	struct spi_transfer *transfer = NULL;
 	struct spi_transfer *previous = NULL;
-	struct chip_data *chip;
+	struct lpc31xx_spi_chip *chip;
 	unsigned long time, timeout;
 
-	chip = lpc31xx->cur_chip;
-	message = lpc31xx->cur_msg;
+	dev_dbg(&espi->pdev->dev, "do_polling_transfer\n");
+
+	chip = espi->cur_chip;
+	message = espi->cur_msg;
 
 	while (message->state != STATE_DONE) {
 		/* Handle for abort */
 		if (message->state == STATE_ERROR)
 			break;
-		transfer = lpc31xx->cur_transfer;
+		transfer = espi->cur_transfer;
 
 		/* Delay if requested at end of transfer */
 		if (message->state == STATE_RUNNING) {
@@ -1212,34 +1381,40 @@ static void do_polling_transfer(struct lpc31xx *lpc31xx)
 				       struct spi_transfer, transfer_list);
 			if (previous->delay_usecs)
 				udelay(previous->delay_usecs);
+#ifdef JDS
 			if (previous->cs_change)
-				lpc31xx->cur_chip->cs_control(SSP_CHIP_SELECT);
+				espi->cur_chip->cs_control(SSP_CHIP_SELECT);
+#endif
 		} else {
 			/* STATE_START */
 			message->state = STATE_RUNNING;
-			if (!lpc31xx->next_msg_cs_active)
-				lpc31xx->cur_chip->cs_control(SSP_CHIP_SELECT);
+#ifdef JDS
+			if (!espi->next_msg_cs_active)
+				espi->cur_chip->cs_control(SSP_CHIP_SELECT);
+#endif
 		}
 
 		/* Configuration Changing Per Transfer */
-		if (set_up_next_transfer(lpc31xx, transfer)) {
+		if (set_up_next_transfer(espi, transfer)) {
 			/* Error path */
 			message->state = STATE_ERROR;
 			break;
 		}
 		/* Flush FIFOs and enable SSP */
-		flush(lpc31xx);
-		writew((readw(SSP_CR1(lpc31xx->virtbase)) | SSP_CR1_MASK_SSE),
-		       SSP_CR1(lpc31xx->virtbase));
+		flush(espi);
+#ifdef JDS
+		writew((readw(SSP_CR1(espi->virtbase)) | SSP_CR1_MASK_SSE),
+		       SSP_CR1(espi->virtbase));
+#endif
 
-		dev_dbg(&lpc31xx->pdev->dev, "polling transfer ongoing ...\n");
+		dev_dbg(&espi->pdev->dev, "polling transfer ongoing ...\n");
 
 		timeout = jiffies + msecs_to_jiffies(SPI_POLLING_TIMEOUT);
-		while (lpc31xx->tx < lpc31xx->tx_end || lpc31xx->rx < lpc31xx->rx_end) {
+		while (espi->tx < espi->tx_end || espi->rx < espi->rx_end) {
 			time = jiffies;
-			readwriter(lpc31xx);
+			readwriter(espi);
 			if (time_after(time, timeout)) {
-				dev_warn(&lpc31xx->pdev->dev,
+				dev_warn(&espi->pdev->dev,
 				"%s: timeout!\n", __func__);
 				message->state = STATE_ERROR;
 				goto out;
@@ -1248,11 +1423,13 @@ static void do_polling_transfer(struct lpc31xx *lpc31xx)
 		}
 
 		/* Update total byte transferred */
-		message->actual_length += lpc31xx->cur_transfer->len;
-		if (lpc31xx->cur_transfer->cs_change)
-			lpc31xx->cur_chip->cs_control(SSP_CHIP_DESELECT);
+		message->actual_length += espi->cur_transfer->len;
+#ifdef JDS
+		if (espi->cur_transfer->cs_change)
+			espi->cur_chip->cs_control(SSP_CHIP_DESELECT);
+#endif
 		/* Move to next transfer */
-		message->state = next_transfer(lpc31xx);
+		message->state = next_transfer(espi);
 	}
 out:
 	/* Handle end of message */
@@ -1261,93 +1438,100 @@ out:
 	else
 		message->status = -EIO;
 
-	giveback(lpc31xx);
+	giveback(espi);
 	return;
 }
 
 static int lpc31xx_transfer_one_message(struct spi_master *master,
 				      struct spi_message *msg)
 {
-	struct lpc31xx *lpc31xx = spi_master_get_devdata(master);
+	struct lpc31xx_spi *espi = spi_master_get_devdata(master);
+
+	dev_dbg(&espi->pdev->dev, "lpc31xx_transfer_one_message\n");
 
 	/* Initial message state */
-	lpc31xx->cur_msg = msg;
+	espi->cur_msg = msg;
 	msg->state = STATE_START;
 
-	lpc31xx->cur_transfer = list_entry(msg->transfers.next,
+	espi->cur_transfer = list_entry(msg->transfers.next,
 					 struct spi_transfer, transfer_list);
 
 	/* Setup the SPI using the per chip configuration */
-	lpc31xx->cur_chip = spi_get_ctldata(msg->spi);
+	espi->cur_chip = spi_get_ctldata(msg->spi);
 
-	restore_state(lpc31xx);
-	flush(lpc31xx);
+	restore_state(espi);
+	flush(espi);
 
-	if (lpc31xx->cur_chip->xfer_type == POLLING_TRANSFER)
-		do_polling_transfer(lpc31xx);
+#ifdef JDS
+	if (espi->cur_chip->xfer_type == POLLING_TRANSFER)
+		do_polling_transfer(espi);
 	else
-		do_interrupt_dma_transfer(lpc31xx);
+		do_interrupt_dma_transfer(espi);
+#endif
 
 	return 0;
 }
 
 static int lpc31xx_prepare_transfer_hardware(struct spi_master *master)
 {
-	struct lpc31xx *lpc31xx = spi_master_get_devdata(master);
+	struct lpc31xx_spi *espi = spi_master_get_devdata(master);
 
+	dev_dbg(&espi->pdev->dev, "lpc31xx_prepare_transfer_hardware\n");
 	/*
 	 * Just make sure we have all we need to run the transfer by syncing
 	 * with the runtime PM framework.
 	 */
-	pm_runtime_get_sync(&lpc31xx->pdev->dev);
+	pm_runtime_get_sync(&espi->pdev->dev);
 	return 0;
 }
 
 static int lpc31xx_unprepare_transfer_hardware(struct spi_master *master)
 {
-	struct lpc31xx *lpc31xx = spi_master_get_devdata(master);
+	struct lpc31xx_spi *espi = spi_master_get_devdata(master);
 
+	dev_dbg(&espi->pdev->dev, "lpc31xx_unprepare_transfer_hardware\n");
+#ifdef JDS
 	/* nothing more to do - disable spi/spi and power off */
-	writew((readw(SSP_CR1(lpc31xx->virtbase)) &
-		(~SSP_CR1_MASK_SSE)), SSP_CR1(lpc31xx->virtbase));
+	writew((readw(SSP_CR1(espi->virtbase)) &
+		(~SSP_CR1_MASK_SSE)), SSP_CR1(espi->virtbase));
 
-	if (lpc31xx->master_info->autosuspend_delay > 0) {
-		pm_runtime_mark_last_busy(&lpc31xx->pdev->dev);
-		pm_runtime_put_autosuspend(&lpc31xx->pdev->dev);
+	if (espi->master_info->autosuspend_delay > 0) {
+		pm_runtime_mark_last_busy(&espi->pdev->dev);
+		pm_runtime_put_autosuspend(&espi->pdev->dev);
 	} else {
-		pm_runtime_put(&lpc31xx->pdev->dev);
+		pm_runtime_put(&espi->pdev->dev);
 	}
-
+#endif
 	return 0;
 }
 
-static int verify_controller_parameters(struct lpc31xx *lpc31xx,
-				struct lpc31xx_config_chip const *chip_info)
+static int verify_controller_parameters(struct lpc31xx_spi *espi,
+				struct lpc31xx_spi_config_chip const *chip_info)
 {
-#if JDS
+#ifdef JDS
 	if ((chip_info->iface < SSP_INTERFACE_MOTOROLA_SPI)
 	    || (chip_info->iface > SSP_INTERFACE_UNIDIRECTIONAL)) {
-		dev_err(&lpc31xx->pdev->dev,
+		dev_err(&espi->pdev->dev,
 			"interface is configured incorrectly\n");
 		return -EINVAL;
 	}
 	if ((chip_info->iface == SSP_INTERFACE_UNIDIRECTIONAL) &&
-	    (!lpc31xx->vendor->unidir)) {
-		dev_err(&lpc31xx->pdev->dev,
+	    (!espi->vendor->unidir)) {
+		dev_err(&espi->pdev->dev,
 			"unidirectional mode not supported in this "
 			"hardware version\n");
 		return -EINVAL;
 	}
 	if ((chip_info->hierarchy != SSP_MASTER)
 	    && (chip_info->hierarchy != SSP_SLAVE)) {
-		dev_err(&lpc31xx->pdev->dev,
+		dev_err(&espi->pdev->dev,
 			"hierarchy is configured incorrectly\n");
 		return -EINVAL;
 	}
 	if ((chip_info->com_mode != INTERRUPT_TRANSFER)
 	    && (chip_info->com_mode != DMA_TRANSFER)
 	    && (chip_info->com_mode != POLLING_TRANSFER)) {
-		dev_err(&lpc31xx->pdev->dev,
+		dev_err(&espi->pdev->dev,
 			"Communication mode is configured incorrectly\n");
 		return -EINVAL;
 	}
@@ -1358,21 +1542,21 @@ static int verify_controller_parameters(struct lpc31xx *lpc31xx,
 		/* These are always OK, all variants can handle this */
 		break;
 	case SSP_RX_16_OR_MORE_ELEM:
-		if (lpc31xx->vendor->fifodepth < 16) {
-			dev_err(&lpc31xx->pdev->dev,
+		if (espi->vendor->fifodepth < 16) {
+			dev_err(&espi->pdev->dev,
 			"RX FIFO Trigger Level is configured incorrectly\n");
 			return -EINVAL;
 		}
 		break;
 	case SSP_RX_32_OR_MORE_ELEM:
-		if (lpc31xx->vendor->fifodepth < 32) {
-			dev_err(&lpc31xx->pdev->dev,
+		if (espi->vendor->fifodepth < 32) {
+			dev_err(&espi->pdev->dev,
 			"RX FIFO Trigger Level is configured incorrectly\n");
 			return -EINVAL;
 		}
 		break;
 	default:
-		dev_err(&lpc31xx->pdev->dev,
+		dev_err(&espi->pdev->dev,
 			"RX FIFO Trigger Level is configured incorrectly\n");
 		return -EINVAL;
 		break;
@@ -1384,21 +1568,21 @@ static int verify_controller_parameters(struct lpc31xx *lpc31xx,
 		/* These are always OK, all variants can handle this */
 		break;
 	case SSP_TX_16_OR_MORE_EMPTY_LOC:
-		if (lpc31xx->vendor->fifodepth < 16) {
-			dev_err(&lpc31xx->pdev->dev,
+		if (espi->vendor->fifodepth < 16) {
+			dev_err(&espi->pdev->dev,
 			"TX FIFO Trigger Level is configured incorrectly\n");
 			return -EINVAL;
 		}
 		break;
 	case SSP_TX_32_OR_MORE_EMPTY_LOC:
-		if (lpc31xx->vendor->fifodepth < 32) {
-			dev_err(&lpc31xx->pdev->dev,
+		if (espi->vendor->fifodepth < 32) {
+			dev_err(&espi->pdev->dev,
 			"TX FIFO Trigger Level is configured incorrectly\n");
 			return -EINVAL;
 		}
 		break;
 	default:
-		dev_err(&lpc31xx->pdev->dev,
+		dev_err(&espi->pdev->dev,
 			"TX FIFO Trigger Level is configured incorrectly\n");
 		return -EINVAL;
 		break;
@@ -1406,29 +1590,29 @@ static int verify_controller_parameters(struct lpc31xx *lpc31xx,
 	if (chip_info->iface == SSP_INTERFACE_NATIONAL_MICROWIRE) {
 		if ((chip_info->ctrl_len < SSP_BITS_4)
 		    || (chip_info->ctrl_len > SSP_BITS_32)) {
-			dev_err(&lpc31xx->pdev->dev,
+			dev_err(&espi->pdev->dev,
 				"CTRL LEN is configured incorrectly\n");
 			return -EINVAL;
 		}
 		if ((chip_info->wait_state != SSP_MWIRE_WAIT_ZERO)
 		    && (chip_info->wait_state != SSP_MWIRE_WAIT_ONE)) {
-			dev_err(&lpc31xx->pdev->dev,
+			dev_err(&espi->pdev->dev,
 				"Wait State is configured incorrectly\n");
 			return -EINVAL;
 		}
 		/* Half duplex is only available in the ST Micro version */
-		if (lpc31xx->vendor->extended_cr) {
+		if (espi->vendor->extended_cr) {
 			if ((chip_info->duplex !=
 			     SSP_MICROWIRE_CHANNEL_FULL_DUPLEX)
 			    && (chip_info->duplex !=
 				SSP_MICROWIRE_CHANNEL_HALF_DUPLEX)) {
-				dev_err(&lpc31xx->pdev->dev,
+				dev_err(&espi->pdev->dev,
 					"Microwire duplex mode is configured incorrectly\n");
 				return -EINVAL;
 			}
 		} else {
 			if (chip_info->duplex != SSP_MICROWIRE_CHANNEL_FULL_DUPLEX)
-				dev_err(&lpc31xx->pdev->dev,
+				dev_err(&espi->pdev->dev,
 					"Microwire half duplex mode requested,"
 					" but this is only available in the"
 					" ST version of LPC31xx\n");
@@ -1439,76 +1623,52 @@ static int verify_controller_parameters(struct lpc31xx *lpc31xx,
 	return 0;
 }
 
-static inline u32 spi_rate(u32 rate, u16 cpsdvsr, u16 scr)
+static inline uint32_t spi_rate(uint32_t rate, u16 cpsdvsr, u16 scr)
 {
 	return rate / (cpsdvsr * (1 + scr));
 }
 
-static int calculate_effective_freq(struct lpc31xx *lpc31xx, int freq, struct
+static int calculate_effective_freq(struct lpc31xx_spi *espi, int freq, struct
 				    spi_clock_params * clk_freq)
 {
-#if JDS
-	/* Lets calculate the frequency parameters */
-	u16 cpsdvsr = CPSDVR_MIN, scr = SCR_MIN;
-	u32 rate, max_tclk, min_tclk, best_freq = 0, best_cpsdvsr = 0,
-		best_scr = 0, tmp, found = 0;
-
-	rate = clk_get_rate(lpc31xx->clk);
-	/* cpsdvscr = 2 & scr 0 */
-	max_tclk = spi_rate(rate, CPSDVR_MIN, SCR_MIN);
-	/* cpsdvsr = 254 & scr = 255 */
-	min_tclk = spi_rate(rate, CPSDVR_MAX, SCR_MAX);
-
-	if (!((freq <= max_tclk) && (freq >= min_tclk))) {
-		dev_err(&lpc31xx->pdev->dev,
-			"controller data is incorrect: out of range frequency");
-		return -EINVAL;
-	}
+	unsigned long spi_clk_rate = clk_get_rate(espi->clk);
+	int cpsr, scr, max_rate, min_rate;
 
+	dev_dbg(&espi->pdev->dev, "calculate_effective_freq\n");
 	/*
-	 * best_freq will give closest possible available rate (<= requested
-	 * freq) for all values of scr & cpsdvsr.
+	 * Make sure that max value is between values supported by the
+	 * controller. Note that minimum value is already checked in
+	 * lpc31xx_spi_transfer().
 	 */
-	while ((cpsdvsr <= CPSDVR_MAX) && !found) {
-		while (scr <= SCR_MAX) {
-			tmp = spi_rate(rate, cpsdvsr, scr);
-
-			if (tmp > freq)
-				scr++;
-			/*
-			 * If found exact value, update and break.
-			 * If found more closer value, update and continue.
-			 */
-			else if ((tmp == freq) || (tmp > best_freq)) {
-				best_freq = tmp;
-				best_cpsdvsr = cpsdvsr;
-				best_scr = scr;
+	max_rate = spi_clk_rate / 2;
+	min_rate = spi_clk_rate / (254 * 256);
+	freq = clamp(freq, min_rate, max_rate);
 
-				if (tmp == freq)
-					break;
+	/*
+	 * Calculate divisors so that we can get speed according the
+	 * following formula:
+	 *	rate = spi_clock_rate / (cpsr * (1 + scr))
+	 *
+	 * cpsr must be even number and starts from 2, scr can be any number
+	 * between 0 and 255.
+	 */
+	for (cpsr = 2; cpsr <= 254; cpsr += 2) {
+		for (scr = 0; scr <= 255; scr++) {
+			if ((spi_clk_rate / (cpsr * (scr + 1))) <= freq) {
+				clk_freq->scr = (uint8_t)scr;
+				clk_freq->cpsdvsr = (uint8_t)cpsr;
+				return 0;
 			}
-			scr++;
 		}
-		cpsdvsr += 2;
-		scr = SCR_MIN;
 	}
-
-	clk_freq->cpsdvsr = (u8) (best_cpsdvsr & 0xFF);
-	clk_freq->scr = (u8) (best_scr & 0xFF);
-	dev_dbg(&lpc31xx->pdev->dev,
-		"SSP Target Frequency is: %u, Effective Frequency is %u\n",
-		freq, best_freq);
-	dev_dbg(&lpc31xx->pdev->dev, "SSP cpsdvsr = %d, scr = %d\n",
-		clk_freq->cpsdvsr, clk_freq->scr);
-#endif
-	return 0;
-}
+	return -EINVAL;}
 
 /*
  * A piece of default chip info unless the platform
  * supplies it.
  */
-static const struct lpc31xx_config_chip lpc31xx_default_chip_info = {
+#ifdef JDS
+static const struct lpc31xx_spi_config_chip lpc31xx_default_chip_info = {
 	.com_mode = POLLING_TRANSFER,
 	.iface = SSP_INTERFACE_MOTOROLA_SPI,
 	.hierarchy = SSP_SLAVE,
@@ -1520,6 +1680,7 @@ static const struct lpc31xx_config_chip lpc31xx_default_chip_info = {
 	.duplex = SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
 	.cs_control = null_cs_control,
 };
+#endif
 
 /**
  * lpc31xx_setup - setup function registered to SPI master framework
@@ -1535,13 +1696,15 @@ static const struct lpc31xx_config_chip lpc31xx_default_chip_info = {
  */
 static int lpc31xx_setup(struct spi_device *spi)
 {
-	struct lpc31xx_config_chip const *chip_info;
-	struct chip_data *chip;
+	struct lpc31xx_spi_config_chip const *chip_info;
+	struct lpc31xx_spi_chip *chip;
 	struct spi_clock_params clk_freq = { .cpsdvsr = 0, .scr = 0};
 	int status = 0;
-	struct lpc31xx *lpc31xx = spi_master_get_devdata(spi->master);
+	struct lpc31xx_spi *espi = spi_master_get_devdata(spi->master);
 	unsigned int bits = spi->bits_per_word;
-	u32 tmp;
+	uint32_t tmp;
+
+	dev_dbg(&spi->dev, "lpc31xx_setup\n");
 
 	if (!spi->max_speed_hz)
 		return -EINVAL;
@@ -1550,7 +1713,7 @@ static int lpc31xx_setup(struct spi_device *spi)
 	chip = spi_get_ctldata(spi);
 
 	if (chip == NULL) {
-		chip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);
+		chip = kzalloc(sizeof(struct lpc31xx_spi_chip), GFP_KERNEL);
 		if (!chip) {
 			dev_err(&spi->dev,
 				"cannot allocate controller state\n");
@@ -1564,7 +1727,9 @@ static int lpc31xx_setup(struct spi_device *spi)
 	chip_info = spi->controller_data;
 
 	if (chip_info == NULL) {
+#ifdef JDS
 		chip_info = &lpc31xx_default_chip_info;
+#endif
 		/* spi_board_info.controller_data not is supplied */
 		dev_dbg(&spi->dev,
 			"using default controller_data settings\n");
@@ -1572,40 +1737,19 @@ static int lpc31xx_setup(struct spi_device *spi)
 		dev_dbg(&spi->dev,
 			"using user supplied controller_data settings\n");
 
-#if JDS
-	/*
-	 * We can override with custom divisors, else we use the board
-	 * frequency setting
-	 */
-	if ((0 == chip_info->clk_freq.cpsdvsr)
-	    && (0 == chip_info->clk_freq.scr)) {
-		status = calculate_effective_freq(lpc31xx,
-						  spi->max_speed_hz,
-						  &clk_freq);
-		if (status < 0)
-			goto err_config_params;
-	} else {
-		memcpy(&clk_freq, &chip_info->clk_freq, sizeof(clk_freq));
-		if ((clk_freq.cpsdvsr % 2) != 0)
-			clk_freq.cpsdvsr =
-				clk_freq.cpsdvsr - 1;
-	}
-	if ((clk_freq.cpsdvsr < CPSDVR_MIN)
-	    || (clk_freq.cpsdvsr > CPSDVR_MAX)) {
-		status = -EINVAL;
-		dev_err(&spi->dev,
-			"cpsdvsr is configured incorrectly\n");
+	status = calculate_effective_freq(espi, spi->max_speed_hz, &clk_freq);
+	if (status < 0)
 		goto err_config_params;
-	}
+#ifdef JDS
 
-	status = verify_controller_parameters(lpc31xx, chip_info);
+	status = verify_controller_parameters(espi, chip_info);
 	if (status) {
 		dev_err(&spi->dev, "controller data is incorrect");
 		goto err_config_params;
 	}
 
-	lpc31xx->rx_lev_trig = chip_info->rx_lev_trig;
-	lpc31xx->tx_lev_trig = chip_info->tx_lev_trig;
+	espi->rx_lev_trig = chip_info->rx_lev_trig;
+	espi->tx_lev_trig = chip_info->tx_lev_trig;
 
 	/* Now set controller state based on controller data */
 	chip->xfer_type = chip_info->com_mode;
@@ -1632,30 +1776,19 @@ static int lpc31xx_setup(struct spi_device *spi)
 		chip->read = READING_U16;
 		chip->write = WRITING_U16;
 	} else {
-		if (lpc31xx->vendor->max_bpw >= 32) {
-			dev_dbg(&spi->dev, "17 <= n <= 32 bits per word\n");
-			chip->n_bytes = 4;
-			chip->read = READING_U32;
-			chip->write = WRITING_U32;
-		} else {
-			dev_err(&spi->dev,
-				"illegal data size for this controller!\n");
-			dev_err(&spi->dev,
-				"a standard lpc31xx can only handle "
-				"1 <= n <= 16 bit words\n");
-			status = -ENOTSUPP;
-			goto err_config_params;
-		}
+		/* LPC31xx doesn't support more than 16-bits */
+		status = -ENOTSUPP;
+		goto err_config_params;
 	}
 
-#if JDS
+#ifdef JDS
 	/* Now Initialize all register settings required for this chip */
 	chip->cr0 = 0;
 	chip->cr1 = 0;
 	chip->dmacr = 0;
 	chip->cpsr = 0;
 	if ((chip_info->com_mode == DMA_TRANSFER)
-	    && ((lpc31xx->master_info)->enable_dma)) {
+	    && ((espi->master_info)->enable_dma)) {
 		chip->enable_dma = true;
 		dev_dbg(&spi->dev, "DMA mode set in controller state\n");
 		SSP_WRITE_BITS(chip->dmacr, SSP_DMA_ENABLED,
@@ -1674,10 +1807,10 @@ static int lpc31xx_setup(struct spi_device *spi)
 	chip->cpsr = clk_freq.cpsdvsr;
 
 	/* Special setup for the ST micro extended control registers */
-	if (lpc31xx->vendor->extended_cr) {
-		u32 etx;
+	if (espi->vendor->extended_cr) {
+		uint32_t etx;
 
-		if (lpc31xx->vendor->pl023) {
+		if (espi->vendor->pl023) {
 			/* These bits are only in the PL023 */
 			SSP_WRITE_BITS(chip->cr1, chip_info->clkdelay,
 				       SSP_CR1_MASK_FBCLKDEL_ST, 13);
@@ -1730,7 +1863,7 @@ static int lpc31xx_setup(struct spi_device *spi)
 
 	SSP_WRITE_BITS(chip->cr0, clk_freq.scr, SSP_CR0_MASK_SCR, 8);
 	/* Loopback is available on all versions except PL023 */
-	if (lpc31xx->vendor->loopback) {
+	if (espi->vendor->loopback) {
 		if (spi->mode & SPI_LOOP)
 			tmp = LOOPBACK_ENABLED;
 		else
@@ -1752,6 +1885,57 @@ static int lpc31xx_setup(struct spi_device *spi)
 	return status;
 }
 
+/*
+ * Setup the initial state of the SPI interface
+ */
+static void lpc31xx_spi_prep(struct lpc31xx_spi *espi)
+{
+	u32 tmp;
+
+	/* Reset SPI block */
+	spi_writel(CONFIG_REG, SPI_CFG_SW_RESET);
+
+	/* Clear FIFOs */
+	lpc31xx_fifo_flush(espi);
+
+	/* Clear latched interrupts */
+	lpc31xx_int_dis(espi, SPI_ALL_INTS);
+	lpc31xx_int_clr(espi, SPI_ALL_INTS);
+
+	/* Setup master mode, normal transmit mode, and interslave delay */
+	spi_writel(CONFIG_REG, SPI_CFG_INTER_DLY(1));
+
+	/* Make sure all 3 chip selects are initially disabled */
+	spi_writel(SLV_ENAB_REG, 0);
+	spi_writel(CONFIG_REG, (spi_readl(CONFIG_REG) | SPI_CFG_UPDATE_EN));
+
+	/* FIFO trip points at 50% */
+	spi_writel(INT_TRSH_REG, (SPI_INT_TSHLD_TX(0x20) | SPI_INT_TSHLD_RX(0x20)));
+
+	/* Only chip select 0 is used in this driver. However, the timings for this
+	   chip select effect transfer speed and need to be adjusted for each GPO
+	   based chip select. Use a default value to start with for now. */
+	/* Inter-transfer delay is 0 (not used) */
+	tmp = spi_readl(SLV_SET1_REG(0));
+	tmp &= ~SPI_SLV1_INTER_TX_DLY(0xFF);
+	spi_writel(SLV_SET1_REG(0), (tmp | SPI_SLV1_INTER_TX_DLY(0)));
+
+	/* Configure enabled chip select slave setting 2 */
+	tmp = SPI_SLV2_PPCS_DLY(0) | SPI_SLV2_CS_HIGH | SPI_SLV2_SPO;
+	spi_writel(SLV_SET2_REG(0), tmp);
+
+	/* Use a default of 8 data bits and a 100K clock for now */
+	lpc31xx_set_cs_data_bits(espi, 0, 8);
+	lpc31xx_set_cs_clock(espi, 0, 100000);
+
+	/* We'll always use CS0 for this driver. Since the chip select is generated
+	   by a GPO, it doesn't matter which one we use */
+	spi_writel(SLV_ENAB_REG, SPI_SLV_EN(0));
+	spi_writel(CONFIG_REG, (spi_readl(CONFIG_REG) | SPI_CFG_UPDATE_EN));
+
+	/* Controller stays disabled until a transfer occurs */
+}
+
 /**
  * lpc31xx_cleanup - cleanup function registered to SPI master framework
  * @spi: spi device which is requesting cleanup
@@ -1761,7 +1945,7 @@ static int lpc31xx_setup(struct spi_device *spi)
  */
 static void lpc31xx_cleanup(struct spi_device *spi)
 {
-	struct chip_data *chip = spi_get_ctldata(spi);
+	struct lpc31xx_spi_chip *chip = spi_get_ctldata(spi);
 
 	spi_set_ctldata(spi, NULL);
 	kfree(chip);
@@ -1772,104 +1956,115 @@ lpc31xx_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct spi_master *master;
-	struct lpc31xx *lpc31xx = NULL;	/*Data for this driver */
-	int status = 0;
-
-	dev_info(&pdev->dev, "NXP LPC31xx SPI driver\n");
+	struct lpc31xx_spi *espi = NULL;	/*Data for this driver */
+	int ngpios, status = 0;
+	struct resource *res;
 
 	/* Allocate master with space for data */
-	master = spi_alloc_master(dev, sizeof(struct lpc31xx));
+	master = spi_alloc_master(dev, sizeof(struct lpc31xx_spi));
 	if (master == NULL) {
 		dev_err(&pdev->dev, "probe - cannot alloc SPI master\n");
 		status = -ENOMEM;
 		goto err_no_master;
 	}
 
-	lpc31xx = spi_master_get_devdata(master);
-	lpc31xx->master = master;
-	lpc31xx->master_info = platform_info;
-	lpc31xx->pdev = pdev;
+	espi = spi_master_get_devdata(master);
+	espi->master = master;
+	espi->pdev = pdev;
+
+	ngpios = of_gpio_count(pdev->dev.of_node);
 
 	/*
 	 * Bus Number Which has been Assigned to this SSP controller
 	 * on this board
 	 */
-	master->bus_num = platform_info->bus_id;
-	master->num_chipselect = platform_info->num_chipselect;
+	master->bus_num = 0;
+	master->num_chipselect = max(ngpios, 1);  /* always one even if no gpios */
 	master->cleanup = lpc31xx_cleanup;
 	master->setup = lpc31xx_setup;
 	master->prepare_transfer_hardware = lpc31xx_prepare_transfer_hardware;
 	master->transfer_one_message = lpc31xx_transfer_one_message;
 	master->unprepare_transfer_hardware = lpc31xx_unprepare_transfer_hardware;
-	master->rt = platform_info->rt;
+	master->rt = false;
+	master->dev.of_node = of_node_get(pdev->dev.of_node);
 
 	/*
 	 * Supports mode 0-3, loopback, and active low CS. Transfers are
 	 * always MS bit first on the original lpc31xx.
 	 */
 	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;
-	if (lpc31xx->vendor->extended_cr)
-		master->mode_bits |= SPI_LSB_FIRST;
 
-	dev_dbg(&pdev->dev, "BUSNO: %d\n", master->bus_num);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "unable to get iomem resource\n");
+		status = -ENODEV;
+		goto err_no_ioregion;
+	}
 
-	status = amba_request_regions(pdev, NULL);
-	if (status)
+	res = request_mem_region(res->start, resource_size(res), pdev->name);
+	if (!res) {
+		dev_err(&pdev->dev, "unable to request iomem resources\n");
+		status = -EBUSY;
 		goto err_no_ioregion;
+	}
 
-	lpc31xx->phybase = pdev->res.start;
-	lpc31xx->virtbase = ioremap(pdev->res.start, resource_size(&pdev->res));
-	if (lpc31xx->virtbase == NULL) {
+	espi->phybase = res->start;
+	espi->virtbase = ioremap(res->start, resource_size(res));
+	if (espi->virtbase == NULL) {
 		status = -ENOMEM;
 		goto err_no_ioremap;
 	}
-	printk(KERN_INFO "lpc31xx: mapped registers from 0x%08x to %p\n",
-	       pdev->res.start, lpc31xx->virtbase);
 
-	lpc31xx->clk = clk_get(&pdev->dev, NULL);
-	if (IS_ERR(lpc31xx->clk)) {
-		status = PTR_ERR(lpc31xx->clk);
-		dev_err(&pdev->dev, "could not retrieve SSP/SPI bus clock\n");
+	espi->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(espi->clk)) {
+		status = PTR_ERR(espi->clk);
+		dev_err(&pdev->dev, "could not retrieve SPI bus clock\n");
 		goto err_no_clk;
 	}
 
-	status = clk_prepare(lpc31xx->clk);
+	status = clk_prepare(espi->clk);
 	if (status) {
-		dev_err(&pdev->dev, "could not prepare SSP/SPI bus clock\n");
+		dev_err(&pdev->dev, "could not prepare SPI bus clock\n");
 		goto  err_clk_prep;
 	}
 
-	status = clk_enable(lpc31xx->clk);
+	status = clk_enable(espi->clk);
 	if (status) {
-		dev_err(&pdev->dev, "could not enable SSP/SPI bus clock\n");
+		dev_err(&pdev->dev, "could not enable SPI bus clock\n");
 		goto err_no_clk_en;
 	}
 
 	/* Initialize transfer pump */
-	tasklet_init(&lpc31xx->pump_transfers, pump_transfers,
-		     (unsigned long)lpc31xx);
+	tasklet_init(&espi->pump_transfers, pump_transfers,
+		     (unsigned long)espi);
 
-	/* Disable SSP */
-	writew((readw(SSP_CR1(lpc31xx->virtbase)) & (~SSP_CR1_MASK_SSE)),
-	       SSP_CR1(lpc31xx->virtbase));
-	load_spi_default_config(lpc31xx);
+	/* Disable SPI */
+	lpc31xx_spi_prep(espi);
 
-	status = request_irq(pdev->irq[0], lpc31xx_interrupt_handler, 0, "lpc31xx",
-			     lpc31xx);
+	espi->irq = platform_get_irq(pdev, 4);
+	if (espi->irq < 0) {
+		status = espi->irq;
+		dev_err(&pdev->dev, "failed to get irq resources\n");
+		goto err_no_irq;
+	}
+
+	status = request_irq(espi->irq, lpc31xx_interrupt_handler, 0, "lpc31xx-spi", espi);
 	if (status < 0) {
 		dev_err(&pdev->dev, "probe - cannot get IRQ (%d)\n", status);
 		goto err_no_irq;
 	}
 
 	/* Get DMA channels */
+#ifdef JDS
 	if (platform_info->enable_dma) {
-		status = lpc31xx_dma_probe(lpc31xx);
+		status = lpc31xx_dma_probe(espi);
 		if (status != 0)
 			platform_info->enable_dma = 0;
 	}
+#endif
 
 	/* Register with the SPI framework */
-	amba_set_drvdata(pdev, lpc31xx);
+	platform_set_drvdata(pdev, espi);
 	status = spi_register_master(master);
 	if (status != 0) {
 		dev_err(&pdev->dev,
@@ -1878,6 +2073,7 @@ lpc31xx_probe(struct platform_device *pdev)
 	}
 	dev_dbg(dev, "probe succeeded\n");
 
+#ifdef JDS
 	/* let runtime pm put suspend */
 	if (platform_info->autosuspend_delay > 0) {
 		dev_info(&pdev->dev,
@@ -1890,68 +2086,76 @@ lpc31xx_probe(struct platform_device *pdev)
 	} else {
 		pm_runtime_put(dev);
 	}
+#endif
+	dev_info(&pdev->dev, "NXP LPC31xx SPI driver\n");
+
 	return 0;
 
  err_spi_register:
+#ifdef JDS
 	if (platform_info->enable_dma)
-		lpc31xx_dma_remove(lpc31xx);
-
-	free_irq(pdev->irq[0], lpc31xx);
- err_no_irq:
-	clk_disable(lpc31xx->clk);
- err_no_clk_en:
-	clk_unprepare(lpc31xx->clk);
- err_clk_prep:
-	clk_put(lpc31xx->clk);
- err_no_clk:
-	iounmap(lpc31xx->virtbase);
- err_no_ioremap:
-	amba_release_regions(pdev);
- err_no_ioregion:
+		lpc31xx_dma_remove(espi);
+#endif
+
+	free_irq(espi->irq, espi);
+err_no_irq:
+	clk_disable(espi->clk);
+err_no_clk_en:
+	clk_unprepare(espi->clk);
+err_clk_prep:
+	clk_put(espi->clk);
+err_no_clk:
+	iounmap(espi->virtbase);
+err_no_ioremap:
+	release_mem_region(res->start, resource_size(res));
+err_no_ioregion:
 	spi_master_put(master);
- err_no_master:
- err_no_pdata:
+err_no_master:
 	return status;
 }
 
 static int __devexit
 lpc31xx_remove(struct platform_device *pdev)
 {
-	struct lpc31xx *lpc31xx = platform_get_drvdata(pdev);
+	struct lpc31xx_spi *espi = platform_get_drvdata(pdev);
+	struct resource *res;
 
-	if (!lpc31xx)
+	if (!espi)
 		return 0;
 
 	/*
 	 * undo pm_runtime_put() in probe.  I assume that we're not
-	 * accessing the primecell here.
+	 * accessing the device here.
 	 */
 	pm_runtime_get_noresume(&pdev->dev);
 
-	load_spi_default_config(lpc31xx);
-	if (lpc31xx->master_info->enable_dma)
-		lpc31xx_dma_remove(lpc31xx);
-
-	free_irq(pdev->irq[0], lpc31xx);
-	clk_disable(lpc31xx->clk);
-	clk_unprepare(lpc31xx->clk);
-	clk_put(lpc31xx->clk);
-	iounmap(lpc31xx->virtbase);
-	amba_release_regions(pdev);
-	tasklet_disable(&lpc31xx->pump_transfers);
-	spi_unregister_master(lpc31xx->master);
-	spi_master_put(lpc31xx->master);
-	amba_set_drvdata(pdev, NULL);
+	lpc31xx_spi_prep(espi);
+#ifdef JDS
+	if (espi->master_info->enable_dma)
+		lpc31xx_dma_remove(espi);
+#endif
+
+	free_irq(espi->irq, espi);
+	clk_disable(espi->clk);
+	clk_unprepare(espi->clk);
+	clk_put(espi->clk);
+	iounmap(espi->virtbase);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+	tasklet_disable(&espi->pump_transfers);
+	spi_unregister_master(espi->master);
+	spi_master_put(espi->master);
+	platform_set_drvdata(pdev, NULL);
 	return 0;
 }
 
 #ifdef CONFIG_SUSPEND
 static int lpc31xx_suspend(struct device *dev)
 {
-	struct lpc31xx *lpc31xx = dev_get_drvdata(dev);
+	struct lpc31xx_spi *espi = dev_get_drvdata(dev);
 	int ret;
 
-	ret = spi_master_suspend(lpc31xx->master);
+	ret = spi_master_suspend(espi->master);
 	if (ret) {
 		dev_warn(dev, "cannot suspend master\n");
 		return ret;
@@ -1963,11 +2167,11 @@ static int lpc31xx_suspend(struct device *dev)
 
 static int lpc31xx_resume(struct device *dev)
 {
-	struct lpc31xx *lpc31xx = dev_get_drvdata(dev);
+	struct lpc31xx_spi *espi = dev_get_drvdata(dev);
 	int ret;
 
 	/* Start the queue running */
-	ret = spi_master_resume(lpc31xx->master);
+	ret = spi_master_resume(espi->master);
 	if (ret)
 		dev_err(dev, "problem starting queue (%d)\n", ret);
 	else
@@ -1980,18 +2184,18 @@ static int lpc31xx_resume(struct device *dev)
 #ifdef CONFIG_PM_RUNTIME
 static int lpc31xx_runtime_suspend(struct device *dev)
 {
-	struct lpc31xx *lpc31xx = dev_get_drvdata(dev);
+	struct lpc31xx_spi *espi = dev_get_drvdata(dev);
 
-	clk_disable(lpc31xx->clk);
+	clk_disable(espi->clk);
 
 	return 0;
 }
 
 static int lpc31xx_runtime_resume(struct device *dev)
 {
-	struct lpc31xx *lpc31xx = dev_get_drvdata(dev);
+	struct lpc31xx_spi *espi = dev_get_drvdata(dev);
 
-	clk_enable(lpc31xx->clk);
+	clk_enable(espi->clk);
 
 	return 0;
 }
@@ -2002,6 +2206,11 @@ static const struct dev_pm_ops lpc31xx_dev_pm_ops = {
 	SET_RUNTIME_PM_OPS(lpc31xx_runtime_suspend, lpc31xx_runtime_resume, NULL)
 };
 
+static const struct of_device_id lpc31xx_spi_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-spi" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lpc31xx_spi_of_match);
 
 static struct platform_driver lpc31xx_spi_driver = {
 	.probe		= lpc31xx_probe,
@@ -2010,6 +2219,7 @@ static struct platform_driver lpc31xx_spi_driver = {
 		.name	= "spi-lpc31xx",
 		.pm	= &lpc31xx_dev_pm_ops,
 		.owner	= THIS_MODULE,
+		.of_match_table = lpc31xx_spi_of_match,
 	},
 };
 
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 3d8f662..c24c327 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -18,6 +18,8 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#define DEBUG
+
 #include <linux/kernel.h>
 #include <linux/device.h>
 #include <linux/init.h>
