Bottom: f8f468f2d480812a7b628603961f0cb10eb3e9eb
Top:    0c6ed4da4dd02e6bea3f2c0eef2c009daf1a4cb6
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-07-27 07:51:01 -0400

Refresh of tyler

---

diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
index 8403b20..3b8d2b3 100644
--- a/sound/soc/sunxi/Kconfig
+++ b/sound/soc/sunxi/Kconfig
@@ -13,5 +13,8 @@ config SND_SUNXI_SOC_I2S
 	select REGMAP_MMIO
 	default y
 
+source "sound/soc/sunxi/i2s/Kconfig"
+
+
 endmenu
 
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
index d87b4c1..b40e4cb 100644
--- a/sound/soc/sunxi/Makefile
+++ b/sound/soc/sunxi/Makefile
@@ -1,3 +1,5 @@
 obj-$(CONFIG_SND_SUNXI_SOC_CODEC) += sunxi-codec.o
 obj-$(CONFIG_SND_SUNXI_SOC_I2S) += sunxi-i2s.o
-
+obj-$(CONFIG_SND_SUNXI_SOC_HDMI_INTERFACE) += hdmiaudio/
+obj-$(CONFIG_SND_SUNXI_SOC_SPDIF_INTERFACE) += spdif/
+obj-$(CONFIG_SND_SUNXI_SOC_I2S_INTERFACE) += i2s/
diff --git a/sound/soc/sunxi/sunxi-i2s.c b/sound/soc/sunxi/sunxi-i2s.c
index edba590..9788f4a 100644
--- a/sound/soc/sunxi/sunxi-i2s.c
+++ b/sound/soc/sunxi/sunxi-i2s.c
@@ -22,7 +22,6 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/of.h>
-#include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/of_address.h>
 #include <linux/clk.h>
@@ -35,480 +34,465 @@
 #include <sound/initval.h>
 #include <sound/dmaengine_pcm.h>
 
-/* Codec register offsets and bit fields */
-#define SUNXI_DAC_DPC		(0x00)
-#define EN_DA				(31)
-#define DAC_VERSION			(23) /* For CODEC OLD VERSION */
-#define DVOL				(12)
-#define SUNXI_DAC_FIFOC		(0x04)
-#define DAC_FS				(29)
-#define FIR_VERSION			(28)
-#define SEND_LASAT			(26)
-#define TX_FIFO_MODE			(24)
-#define DAC_DRQ_CLR_CNT			(21)
-#define TX_TRIG_LEVEL			(8)
-#define DAC_MONO_EN			(6)
-#define TX_SAMPLE_BITS			(5)
-#define DAC_DRQ_EN			(4)
-#define DAC_FIFO_FLUSH			(0)
-#define SUNXI_DAC_FIFOS		(0x08)
-#define SUNXI_DAC_TXDATA	(0x0c)
-#define SUNXI_DAC_ACTL		(0x10)
-#define DACAENR				(31)
-#define DACAENL				(30)
-#define MIXEN				(29)
-#define DACPAS				(8)
-#define MIXPAS				(7)
-#define PAMUTE				(6)
-#define PAVOL				(0)
-#define SUNXI_DAC_TUNE		(0x14)
-#define SUNXI_DAC_DEBUG		(0x18)
-#define SUNXI_ADC_FIFOC		(0x1c)
-#define EN_AD				(28)
-#define RX_FIFO_MODE			(24)
-#define RX_TRIG_LEVEL			(8)
-#define ADC_MONO_EN			(7)
-#define RX_SAMPLE_BITS			(6)
-#define ADC_DRQ_EN			(4)
-#define ADC_FIFO_FLUSH			(0)
-#define SUNXI_ADC_FIFOS		(0x20)
-#define SUNXI_ADC_RXDATA	(0x24)
-#define SUNXI_ADC_ACTL		(0x28)
-#define ADCREN				(31)
-#define ADCLEN				(30)
-#define PREG1EN				(29)
-#define PREG2EN				(28)
-#define VMICEN				(27)
-#define ADCG				(20)
-#define ADCIS				(17)
-#define PA_EN				(4)
-#define DDE				(3)
-#define SUNXI_ADC_DEBUG		(0x2c)
-#define SUNXI_DAC_TXCNT		(0x30)
-#define SUNXI_ADC_RXCNT		(0x34)
-#define SUNXI_AC_SYS_VERI	(0x38)
-#define SUNXI_AC_MIC_PHONE_CAL	(0x3c)
-
-
-#define DAIFMT_16BITS             (16)
-#define DAIFMT_20BITS             (20)
-
-#define DAIFMT_BS_MASK            (~(1<<16)) /* FIFO big small mode mask */
-#define DAIFMT_BITS_MASK          (~(1<<5))  /* FIFO Bits select mask, not used yet */
-#define SAMPLE_RATE_MASK          (~(7<<29)) /* Sample Rate slect mask*/
-
-#define DAC_CHANNEL		  (6)
-
-enum sunxi_device_id {SUN4A, SUN4I, SUN5I, SUN7I};
-
-struct sunxi_priv {
-	struct regmap *regmap;
-	int irq;
-	struct clk *clk_apb, *clk_pll2, *clk_module;
-
-	enum sunxi_device_id id;
-
-	struct snd_dmaengine_dai_dma_data playback_dma_data;
-	struct snd_dmaengine_dai_dma_data capture_dma_data;
-};
+#include "sunxi-i2s.h"
 
-static int i2s_play_start(struct sunxi_priv *priv)
+void sunxi_snd_txctrl_i2s(struct sunxi_priv *priv, struct snd_pcm_substream *substream, int on)
 {
-#ifdef JDS
-	if (gpio_pa_shutdown)
-		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
-#endif
+	u32 reg_val;
 
-	/* flush TX FIFO */
-	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_FIFO_FLUSH, 0x1 << DAC_FIFO_FLUSH);
+	regmap_update_bits(priv->regmap, SUNXI_TXCHSEL, 0x7 << SUNXI_TXCHSEL_CHNUM, 
+				(substream->runtime->channels - 1) << SUNXI_TXCHSEL_CHNUM);
 
-	/* enable DAC DRQ */
-	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_DRQ_EN, 0x1 << DAC_DRQ_EN);
-	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PAMUTE, 0x1 << PAMUTE);
+	regmap_raw_read(priv->regmap, SUNXI_TXCHMAP, &reg_val, sizeof(reg_val));
+	reg_val = 0;
+	if (priv->revision == SUN4I) {
+		if(substream->runtime->channels == 1) {
+			reg_val = 0x76543200;
+		} else {
+			reg_val = 0x76543210;
+		}
+	} else {
+		if(substream->runtime->channels == 1) {
+			reg_val = 0x00000000;
+		} else {
+			reg_val = 0x00000010;
+		}
+	}
+	regmap_write(priv->regmap, SUNXI_TXCHMAP, reg_val);
+
+	regmap_read(priv->regmap, SUNXI_IISCTL, &reg_val);
+	if (priv->revision == SUN4I) {
+		reg_val &= ~SUNXI_IISCTL_SDO3EN;
+		reg_val &= ~SUNXI_IISCTL_SDO2EN;
+		reg_val &= ~SUNXI_IISCTL_SDO1EN;
+		reg_val &= ~SUNXI_IISCTL_SDO0EN;
+		switch(substream->runtime->channels) {
+			case 1:
+			case 2:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+				break;
+			case 3:
+			case 4:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+				reg_val |= SUNXI_IISCTL_SDO1EN;
+				break;
+			case 5:
+			case 6:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+				reg_val |= SUNXI_IISCTL_SDO1EN;
+				reg_val |= SUNXI_IISCTL_SDO2EN;
+				break;
+			case 7:
+			case 8:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+				reg_val |= SUNXI_IISCTL_SDO1EN;
+				reg_val |= SUNXI_IISCTL_SDO2EN;
+				reg_val |= SUNXI_IISCTL_SDO3EN;
+				break;
+			default:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+		}
+	} else {
+		reg_val |= SUNXI_IISCTL_SDO0EN;
+	}
+	regmap_write(priv->regmap, SUNXI_IISCTL, reg_val);
 
-	return 0;
-}
+	//flush TX FIFO
+	regmap_update_bits(priv->regmap, SUNXI_IISFCTL, 1 << SUNXI_IISFCTL_FTX, 1 << SUNXI_IISFCTL_FTX);
 
-static int i2s_play_stop(struct sunxi_priv *priv)
-{
-#ifdef JDS
-	if (gpio_pa_shutdown)
-		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
-#endif
+	//clear TX counter
+	regmap_write(priv->regmap, SUNXI_IISTXCNT, 0);
 
-	/* mute PA */
-	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PAMUTE, 0x0 << PAMUTE);
-	mdelay(5);
+	if (on) {
+		/* IIS TX ENABLE */
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_TXEN, 1 << SUNXI_IISCTL_TXEN);
 
-	/* disable DAC DRQ */
-	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_DRQ_EN, 0x0 << DAC_DRQ_EN);
+		/* enable DMA DRQ mode for play */
+		regmap_update_bits(priv->regmap, SUNXI_IISINT, 1 << SUNXI_IISINT_TXDRQEN, 1 << SUNXI_IISINT_TXDRQEN);
 
-	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAENL, 0x0 << DACAENL);
-	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAENR, 0x0 << DACAENR);
+		//Global Enable Digital Audio Interface
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_GEN, 1 << SUNXI_IISCTL_GEN);
 
-	return 0;
-}
-
-static int i2s_capture_start(struct sunxi_priv *priv)
-{
-#ifdef JDS
-	if (gpio_pa_shutdown)
-		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
-#endif
+	} else {
+		/* IIS TX DISABLE */
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_TXEN, 0 << SUNXI_IISCTL_TXEN);
 
-	/* enable ADC DRQ */
-	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DRQ_EN, 0x1 << ADC_DRQ_EN);
+		/* DISBALE dma DRQ mode */
+		regmap_update_bits(priv->regmap, SUNXI_IISINT, 1 << SUNXI_IISINT_TXDRQEN, 0 << SUNXI_IISINT_TXDRQEN);
 
-	return 0;
+		//Global disable Digital Audio Interface
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_GEN, 0 << SUNXI_IISCTL_GEN);
+	}
 }
 
-static int i2s_capture_stop(struct sunxi_priv *priv)
+void sunxi_snd_rxctrl_i2s(struct sunxi_priv *priv, int on)
 {
-	/* disable ADC DRQ */
-	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DRQ_EN, 0x0 << ADC_DRQ_EN);
+	//flush RX FIFO
+	regmap_update_bits(priv->regmap, SUNXI_IISFCTL, 1 << SUNXI_IISFCTL_FRX, 1 << SUNXI_IISFCTL_FRX);
 
-	/* enable mic1 PA */
-	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << PREG1EN, 0x0 << PREG1EN);
+	//clear RX counter
+	regmap_write(priv->regmap, SUNXI_IISRXCNT, 0);
 
-	/* enable VMIC */
-	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << VMICEN, 0x0 << VMICEN);
-	if (priv->id == SUN7I) {
-		/* FIXME - undocumented */
-		regmap_update_bits(priv->regmap, SUNXI_DAC_TUNE, 0x3 << 8, 0x0 << 8);
-	}
+	if (on) {
+		/* IIS RX ENABLE */
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_RXEN, 1 << SUNXI_IISCTL_RXEN);
 
-	/* enable ADC digital */
-	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << EN_AD, 0x0 << EN_AD);
+		/* enable DMA DRQ mode for record */
+		regmap_update_bits(priv->regmap, SUNXI_IISINT, 1 << SUNXI_IISINT_RXDRQEN, 1 << SUNXI_IISINT_RXDRQEN);
 
-	/* set RX FIFO mode */
-	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << RX_FIFO_MODE, 0x0 << RX_FIFO_MODE);
+		//Global Enable Digital Audio Interface
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_GEN, 1 << SUNXI_IISCTL_GEN);
 
-	/* flush RX FIFO */
-	regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_FIFO_FLUSH, 0x0 << ADC_FIFO_FLUSH);
+	} else {
+		/* IIS RX DISABLE */
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_RXEN, 0 << SUNXI_IISCTL_RXEN);
 
-	/* enable adc1 analog */
-	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << ADCLEN, 0x0 << ADCLEN);
+		/* DISBALE dma DRQ mode */
+		regmap_update_bits(priv->regmap, SUNXI_IISINT, 1 << SUNXI_IISINT_RXDRQEN, 0 << SUNXI_IISINT_RXDRQEN);
 
-	return 0;
+		//Global disable Digital Audio Interface
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_GEN, 0 << SUNXI_IISCTL_GEN);
+	}
 }
 
-static int sunxi_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
-			       struct snd_soc_dai *dai)
+static inline int sunxi_snd_is_clkmaster(struct sunxi_priv *priv)
 {
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct snd_soc_card *card = codec->card;
-	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+	u32 reg_val;
 
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-			i2s_capture_start(priv);
-		else
-			i2s_play_start(priv);
+	regmap_read(priv->regmap, SUNXI_IISCTL, &reg_val);
+	return ((reg_val & SUNXI_IISCTL_MS) ? 0 : 1);
+}
+
+static int sunxi_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 reg_val;
+
+	//SDO ON
+	if (priv->revision == SUN4I) {
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 
+			SUNXI_IISCTL_SDO0EN | SUNXI_IISCTL_SDO1EN | SUNXI_IISCTL_SDO2EN | SUNXI_IISCTL_SDO3EN,
+			SUNXI_IISCTL_SDO0EN | SUNXI_IISCTL_SDO1EN | SUNXI_IISCTL_SDO2EN | SUNXI_IISCTL_SDO3EN);
+	} else {
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, SUNXI_IISCTL_SDO0EN, SUNXI_IISCTL_SDO0EN);
+	}
+
+
+	/* master or slave selection */
+	switch(fmt & SND_SOC_DAIFMT_MASTER_MASK){
+	case SND_SOC_DAIFMT_CBM_CFM:   /* codec clk & frm master */
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_MS, 1 << SUNXI_IISCTL_MS);
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:   /* codec clk & frm slave */
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_MS, 0 << SUNXI_IISCTL_MS);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* pcm or i2s mode selection */
+	switch(fmt & SND_SOC_DAIFMT_FORMAT_MASK){
+	case SND_SOC_DAIFMT_I2S:        /* I2S mode */
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_PCM, 0 << SUNXI_IISCTL_PCM);
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, SUNXI_IISFAT0_FMT_RVD, SUNXI_IISFAT0_FMT_I2S);
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:    /* Right Justified mode */
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_PCM, 0 << SUNXI_IISCTL_PCM);
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, SUNXI_IISFAT0_FMT_RVD, SUNXI_IISFAT0_FMT_RGT);
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:     /* Left Justified mode */
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_PCM, 0 << SUNXI_IISCTL_PCM);
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, SUNXI_IISFAT0_FMT_RVD, SUNXI_IISFAT0_FMT_LFT);
 		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-			i2s_capture_stop(priv);
-		else
-			i2s_play_stop(priv);
+	case SND_SOC_DAIFMT_DSP_A:      /* L data msb after FRM LRC */
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_PCM, 1 << SUNXI_IISCTL_PCM);
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, 1 << SUNXI_IISFAT0_LRCP, 1 << SUNXI_IISFAT0_LRCP);
+		break;
+	case SND_SOC_DAIFMT_DSP_B:      /* L data msb during FRM LRC */
+		regmap_update_bits(priv->regmap, SUNXI_IISCTL, 1 << SUNXI_IISCTL_PCM, 1 << SUNXI_IISCTL_PCM);
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, 1 << SUNXI_IISFAT0_LRCP, 1 << SUNXI_IISFAT0_LRCP);
 		break;
 	default:
 		return -EINVAL;
 	}
 
+	/* DAI signal inversions */
+	switch(fmt & SND_SOC_DAIFMT_INV_MASK){
+	case SND_SOC_DAIFMT_NB_NF:     /* normal bit clock + frame */
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, 1 << SUNXI_IISFAT0_LRCP, 0 << SUNXI_IISFAT0_LRCP);
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, 1 << SUNXI_IISFAT0_BCP, 0 << SUNXI_IISFAT0_BCP);
+		break;
+	case SND_SOC_DAIFMT_NB_IF:     /* normal bclk + inv frm */
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, 1 << SUNXI_IISFAT0_LRCP, 1 << SUNXI_IISFAT0_LRCP);
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, 1 << SUNXI_IISFAT0_BCP, 0 << SUNXI_IISFAT0_BCP);
+		break;
+	case SND_SOC_DAIFMT_IB_NF:     /* invert bclk + nor frm */
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, 1 << SUNXI_IISFAT0_LRCP, 0 << SUNXI_IISFAT0_LRCP);
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, 1 << SUNXI_IISFAT0_BCP, 1 << SUNXI_IISFAT0_BCP);
+		break;
+	case SND_SOC_DAIFMT_IB_IF:     /* invert bclk + frm */
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, 1 << SUNXI_IISFAT0_LRCP, 1 << SUNXI_IISFAT0_LRCP);
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, 1 << SUNXI_IISFAT0_BCP, 1 << SUNXI_IISFAT0_BCP);
+		break;
+	}
+
+	/* word select size */
+	if(priv->ws_size == 16)
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, SUNXI_IISFAT0_WSS_32BCLK, SUNXI_IISFAT0_WSS_16BCLK);
+	else if(priv->ws_size == 20)
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, SUNXI_IISFAT0_WSS_32BCLK, SUNXI_IISFAT0_WSS_20BCLK);
+	else if(priv->ws_size == 24)
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, SUNXI_IISFAT0_WSS_32BCLK, SUNXI_IISFAT0_WSS_24BCLK);
+	else
+		regmap_update_bits(priv->regmap, SUNXI_IISFAT0, SUNXI_IISFAT0_WSS_32BCLK, SUNXI_IISFAT0_WSS_32BCLK);
+
+	/* PCM REGISTER setup */
+	reg_val = priv->pcm_txtype & 0x3;
+	reg_val |= priv->pcm_rxtype << 2;
+
+	if(!priv->pcm_sync_type)
+		reg_val |= SUNXI_IISFAT1_SSYNC;							//short sync
+	if(priv->pcm_sw == 16)
+		reg_val |= SUNXI_IISFAT1_SW;
+
+	reg_val |=((priv->pcm_start_slot - 1)&0x3)<<6;		//start slot index
+
+	reg_val |= priv->pcm_lsb_first<<9;			//MSB or LSB first
+
+	if(priv->pcm_sync_period == 256)
+		reg_val |= 0x4 << 12;
+	else if (priv->pcm_sync_period == 128)
+		reg_val |= 0x3 << 12;
+	else if (priv->pcm_sync_period == 64)
+		reg_val |= 0x2 << 12;
+	else if (priv->pcm_sync_period == 32)
+		reg_val |= 0x1 << 12;
+	regmap_write(priv->regmap, SUNXI_IISFAT1, reg_val);
+
+	/* set FIFO control register */
+	reg_val = 0 & 0x3;
+	reg_val |= (1 & 0x1) << 2;
+	reg_val |= SUNXI_IISFCTL_RXTL(0xf);				//RX FIFO trigger level
+	reg_val |= SUNXI_IISFCTL_TXTL(0x40);				//TX FIFO empty trigger level
+	regmap_write(priv->regmap, SUNXI_IISFCTL, reg_val);
 	return 0;
 }
 
-static int sunxi_i2s_prepare(struct snd_pcm_substream *substream,
-			       struct snd_soc_dai *dai)
+static int sunxi_i2s_hw_params(struct snd_pcm_substream *substream, 
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *cpu_dai)
 {
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct snd_soc_card *card = codec->card;
-	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1 << EN_DA, 0x1 << EN_DA);
-		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_FIFO_FLUSH, 0x1 << DAC_FIFO_FLUSH);
-		/* set TX FIFO send DRQ level */
-		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x3f << TX_TRIG_LEVEL, 0xf << TX_TRIG_LEVEL);
-		if (substream->runtime->rate > 32000) {
-			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << FIR_VERSION, 0x0 << FIR_VERSION);
-		} else {
-			regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << FIR_VERSION, 0x1 << FIR_VERSION);
-		}
-		/* set TX FIFO MODE - 0 works for both 16 and 24 bits */
-		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << TX_FIFO_MODE, 0x0 << TX_FIFO_MODE);
-		/* send last sample when DAC FIFO under run */
-		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << SEND_LASAT, 0x0 << SEND_LASAT);
-		/* enable dac analog */
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAENL, 0x1 << DACAENL);
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACAENR, 0x1 << DACAENR);
-		/* enable DAC to PA */
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << DACPAS, 0x1 << DACPAS);
-	} else {
-		/* enable mic1 PA */
-		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << PREG1EN, 0x1 << PREG1EN);
-		/* mic1 gain 32dB */  /* FIXME - makes no sense */
-		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << 25, 0x1 << 25);
-		/* enable VMIC */
-		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << VMICEN, 0x1 << VMICEN);
-
-		if (priv->id == SUN7I) {
-			/* boost up record effect */
-			regmap_update_bits(priv->regmap, SUNXI_DAC_TUNE, 0x3 << 8, 0x1 << 8);
-		}
+	return 0;
+}
+
+static int sunxi_i2s_trigger(struct snd_pcm_substream *substream,
+                              int cmd, struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret = 0;
 
-		/* enable ADC digital */
-		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << EN_AD, 0x1 << EN_AD);
-		/* set RX FIFO mode */
-		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << RX_FIFO_MODE, 0x1 << RX_FIFO_MODE);
-		/* flush RX FIFO */
-		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_FIFO_FLUSH, 0x1 << ADC_FIFO_FLUSH);
-		/* set RX FIFO rec drq level */
-		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 0xf << RX_TRIG_LEVEL, 0x7 << RX_TRIG_LEVEL);
-		/* enable adc1 analog */
-		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x3 << ADCLEN, 0x3 << ADCLEN);
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+				sunxi_snd_rxctrl_i2s(priv, 1);
+			} else {
+				sunxi_snd_txctrl_i2s(priv, substream, 1);
+			}
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+				sunxi_snd_rxctrl_i2s(priv, 0);
+			} else {
+				sunxi_snd_txctrl_i2s(priv, substream, 0);
+			}
+			break;
+		default:
+			ret = -EINVAL;
+			break;
 	}
 
-	return 0;
+	return ret;
 }
 
-static int sunxi_i2s_hw_params(struct snd_pcm_substream *substream,
-				 struct snd_pcm_hw_params *params,
-				 struct snd_soc_dai *dai)
+//freq:   1: 22.5792MHz   0: 24.576MHz
+static int sunxi_i2s_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id, unsigned int freq, int dir)
 {
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct snd_soc_card *card = codec->card;
-	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
-	int is_mono = !!(params_channels(params) == 1);
-	int is_24bit = !!(hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS)->min == 32);
-	unsigned int rate = params_rate(params);
-	unsigned int hwrate;
-
-	switch (rate) {
-	case 176400:
-	case 88200:
-	case 44100:
-	case 33075:
-	case 22050:
-	case 14700:
-	case 11025:
-	case 7350:
-	default:
-		clk_set_rate(priv->clk_pll2, 22579200);
-		clk_set_rate(priv->clk_module, 22579200);
-		break;
-	case 192000:
-	case 96000:
-	case 48000:
-	case 32000:
-	case 24000:
-	case 16000:
-	case 12000:
-	case 8000:
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	if (!freq) {
 		clk_set_rate(priv->clk_pll2, 24576000);
-		clk_set_rate(priv->clk_module, 24576000);
-		break;
+	} else {
+		clk_set_rate(priv->clk_pll2, 22579200);
 	}
 
-	switch (rate) {
-	case 192000:
-	case 176400:
-		hwrate = 6;
+	return 0;
+}
+
+static int sunxi_i2s_set_clkdiv(struct snd_soc_dai *cpu_dai, int div_id, int div)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 reg;
+
+	switch (div_id) {
+	case SUNXI_DIV_MCLK:
+		if(div <= 8)
+			div  = (div >>1);
+		else if(div  == 12)
+			div  = 0x5;
+		else if(div  == 16)
+			div  = 0x6;
+		else if(div == 24)
+			div = 0x7;
+		else if(div == 32)
+			div = 0x8;
+		else if(div == 48)
+			div = 0x9;
+		else if(div == 64)
+			div = 0xa;
+		regmap_update_bits(priv->regmap, SUNXI_IISCLKD, SUNXI_IISCLKD_MCLK_MASK, div << SUNXI_IISCLKD_MCLK_OFFS);
 		break;
-	case 96000:
-	case 88200:
-		hwrate = 7;
+	case SUNXI_DIV_BCLK:
+		if(div <= 8)
+			div = (div>>1) - 1;
+		else if(div == 12)
+			div = 0x4;
+		else if(div == 16)
+			div = 0x5;
+		else if(div == 32)
+			div = 0x6;
+		else if(div == 64)
+			div = 0x7;
+		regmap_update_bits(priv->regmap, SUNXI_IISCLKD, SUNXI_IISCLKD_BCLK_MASK, div << SUNXI_IISCLKD_BCLK_OFFS);
 		break;
 	default:
-	case 48000:
-	case 44100:
-		hwrate = 0;
-		break;
-	case 32000:
-	case 33075:
-		hwrate = 1;
-		break;
-	case 24000:
-	case 22050:
-		hwrate = 2;
-		break;
-	case 16000:
-	case 14700:
-		hwrate = 3;
-		break;
-	case 12000:
-	case 11025:
-		hwrate = 4;
-		break;
-	case 8000:
-	case 7350:
-		hwrate = 5;
-		break;
+		return -EINVAL;
 	}
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 7 << DAC_FS, hwrate << DAC_FS);
-		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << DAC_MONO_EN, is_mono << DAC_MONO_EN);
-		regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << TX_SAMPLE_BITS, is_24bit << TX_SAMPLE_BITS);
-		if (is_24bit)
-			priv->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-		else
-			priv->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-	} else  {
-		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 7 << 29, hwrate << 29);
-		regmap_update_bits(priv->regmap, SUNXI_ADC_FIFOC, 1 << ADC_MONO_EN, is_mono << ADC_MONO_EN);
+	//diable MCLK output when high samplerate
+	regmap_read(priv->regmap, SUNXI_IISCLKD, &reg);
+	if (!(reg & 0xF)) {
+		regmap_update_bits(priv->regmap, SUNXI_IISCLKD, SUNXI_IISCLKD_MCLKOEN, 0);
+	} else {
+		regmap_update_bits(priv->regmap, SUNXI_IISCLKD, SUNXI_IISCLKD_MCLKOEN, SUNXI_IISCLKD_MCLKOEN);
 	}
-
 	return 0;
 }
 
-static const struct snd_kcontrol_new sun7i_dac_ctls[] = {
-	/*SUNXI_DAC_ACTL = 0x10,PAVOL*/
-	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0),
-	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
-	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
-	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
-	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
-	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
-	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0),
-	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0),
-	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
-	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
-	SOC_SINGLE("MIC output volume", SUNXI_DAC_ACTL, 20, 7, 0),
-	/*	FM Input to output mixer Gain Control
-	* 	From -4.5db to 6db,1.5db/step,default is 0db
-	*	-4.5db:0x0,-3.0db:0x1,-1.5db:0x2,0db:0x3
-	*	1.5db:0x4,3.0db:0x5,4.5db:0x6,6db:0x7
-	*/
-	SOC_SINGLE("Fm output Volume", SUNXI_DAC_ACTL, 23, 7, 0),
-	/*	Line-in gain stage to output mixer Gain Control
-	*	0:-1.5db,1:0db
-	*/
-	SOC_SINGLE("Line output Volume", SUNXI_DAC_ACTL, 26, 1, 0),
-
-	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0),
-	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0),
-	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0),
-	SOC_SINGLE("Linein Pre-AMP", SUNXI_ADC_ACTL, 13, 7, 0),
-	SOC_SINGLE("LINEIN APM Volume", SUNXI_AC_MIC_PHONE_CAL, 13, 0x7, 0),
-	/* ADC Input Gain Control, capture volume
-	* 000:-4.5db,001:-3db,010:-1.5db,011:0db,100:1.5db,101:3db,110:4.5db,111:6db
-	*/
-	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0),
-	/*
-	*	MIC2 pre-amplifier Gain Control
-	*	00:0db,01:35db,10:38db,11:41db
-	*/
-	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
-	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
-	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0),
-	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0),
-	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0),
-	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
-	SOC_SINGLE("Mic2 gain Volume", SUNXI_AC_MIC_PHONE_CAL, 26, 7, 0),
-	/*
-	*	MIC1 pre-amplifier Gain Control
-	*	00:0db,01:35db,10:38db,11:41db
-	*/
-	SOC_SINGLE("Mic1 gain Volume", SUNXI_AC_MIC_PHONE_CAL, 29, 3, 0),
-};
-
-static int sunxi_i2s_dai_probe(struct snd_soc_dai *dai)
+static int sunxi_i2s_dai_probe(struct snd_soc_dai *cpu_dai)
 {
-	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
-	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
 
-	snd_soc_dai_init_dma_data(dai, &priv->playback_dma_data, &priv->capture_dma_data);
+	snd_soc_dai_init_dma_data(cpu_dai, &priv->playback_dma_data, &priv->capture_dma_data);
 
 	return 0;
 }
 
-static int sunxi_i2s_startup(struct snd_pcm_substream *substream,
-			       struct snd_soc_dai *dai)
+static int sunxi_i2s_dai_remove(struct snd_soc_dai *cpu_dai)
 {
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct snd_soc_card *card = codec->card;
-	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
-
-	return clk_prepare_enable(priv->clk_module);
+	return 0;
 }
 
-static void sunxi_i2s_shutdown(struct snd_pcm_substream *substream,
-				 struct snd_soc_dai *dai)
+static void iisregsave(void)
 {
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct snd_soc_card *card = codec->card;
-	struct sunxi_priv *priv = snd_soc_card_get_drvdata(card);
+	/*regsave[0] = readl(priv->regs + SUNXI_IISCTL);
+	regsave[1] = readl(priv->regs + SUNXI_IISFAT0);
+	regsave[2] = readl(priv->regs + SUNXI_IISFAT1);
+	regsave[3] = readl(priv->regs + SUNXI_IISFCTL) | (0x3<<24);
+	regsave[4] = readl(priv->regs + SUNXI_IISINT);
+	regsave[5] = readl(priv->regs + SUNXI_IISCLKD);
+	regsave[6] = readl(priv->regs + SUNXI_TXCHSEL);
+	regsave[7] = readl(priv->regs + SUNXI_TXCHMAP);*/
+}
 
-	clk_disable_unprepare(priv->clk_module);
+static void iisregrestore(void)
+{
+	/*writel(regsave[0], priv->regs + SUNXI_IISCTL);
+	writel(regsave[1], priv->regs + SUNXI_IISFAT0);
+	writel(regsave[2], priv->regs + SUNXI_IISFAT1);
+	writel(regsave[3], priv->regs + SUNXI_IISFCTL);
+	writel(regsave[4], priv->regs + SUNXI_IISINT);
+	writel(regsave[5], priv->regs + SUNXI_IISCLKD);
+	writel(regsave[6], priv->regs + SUNXI_TXCHSEL);
+	writel(regsave[7], priv->regs + SUNXI_TXCHMAP);*/
 }
 
+static int sunxi_i2s_suspend(struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	printk("[IIS]Entered %s\n", __func__);
+
+	//Global Enable Digital Audio Interface
+	regmap_update_bits(priv->regmap, SUNXI_IISCTL, SUNXI_IISCTL_GEN, 0);
+
+	iisregsave();
+
+	//release the module clock
+	clk_disable(priv->clk_module);
+
+	clk_disable(priv->clk_apb);
+
+	//printk("[IIS]PLL2 0x01c20008 = %#x\n", *(volatile int*)0xF1C20008);
+	printk("[IIS]SPECIAL CLK 0x01c20068 = %#x, line= %d\n", *(volatile int*)0xF1C20068, __LINE__);
+	printk("[IIS]SPECIAL CLK 0x01c200B8 = %#x, line = %d\n", *(volatile int*)0xF1C200B8, __LINE__);
 
-static int i2s_init(struct sunxi_priv *priv)
+	return 0;
+}
+static int sunxi_i2s_resume(struct snd_soc_dai *cpu_dai)
 {
-	/* enable DAC digital */
-	regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 1 << EN_DA, 1 << EN_DA);
+	struct sunxi_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
 
-	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 1 << FIR_VERSION, 1 << FIR_VERSION);
+	printk("[IIS]Entered %s\n", __func__);
 
-	/* set digital volume to maximum */
-	if (priv->id == SUN4A)
-		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x3F << DVOL, 0 << DVOL);
+	//release the module clock
+	clk_enable(priv->clk_apb);
 
-	/* PA mute */
-	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 1 << PAMUTE, 0 << PAMUTE);
+	//release the module clock
+	clk_enable(priv->clk_module);
 
-	/* enable PA */
-	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 1 << PA_EN, 1 << PA_EN);
-	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 3 << DAC_DRQ_CLR_CNT, 3 << DAC_DRQ_CLR_CNT);
+	iisregrestore();
 
-	/* set volume */
-	if (priv->id == SUN4A)
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x3f << PAVOL, 1 << PAVOL);
-	else
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x3f << PAVOL, 0x30 << PAVOL);
+	//Global Enable Digital Audio Interface
+	regmap_update_bits(priv->regmap, SUNXI_IISCTL, SUNXI_IISCTL_GEN, SUNXI_IISCTL_GEN);
+
+	//printk("[IIS]PLL2 0x01c20008 = %#x\n", *(volatile int*)0xF1C20008);
+	printk("[IIS]SPECIAL CLK 0x01c20068 = %#x, line= %d\n", *(volatile int*)0xF1C20068, __LINE__);
+	printk("[IIS]SPECIAL CLK 0x01c200B8 = %#x, line = %d\n", *(volatile int*)0xF1C200B8, __LINE__);
 
 	return 0;
 }
 
-static const struct snd_soc_dai_ops sunxi_i2s_dai_ops = {
-	.startup = sunxi_i2s_startup,
-	.shutdown = sunxi_i2s_shutdown,
-	.trigger = sunxi_i2s_trigger,
-	.hw_params = sunxi_i2s_hw_params,
-	.prepare = sunxi_i2s_prepare,
+#define SUNXI_I2S_RATES (SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT)
+static struct snd_soc_dai_ops sunxi_i2s_dai_ops = {
+	.trigger 	= sunxi_i2s_trigger,
+	.hw_params 	= sunxi_i2s_hw_params,
+	.set_fmt 	= sunxi_i2s_set_fmt,
+	.set_clkdiv = sunxi_i2s_set_clkdiv,
+	.set_sysclk = sunxi_i2s_set_sysclk,
 };
 
 static struct snd_soc_dai_driver sunxi_i2s_dai = {
-	.probe = sunxi_i2s_dai_probe,
-	.playback = {
+	.probe 		= sunxi_i2s_dai_probe,
+	.suspend 	= sunxi_i2s_suspend,
+	.resume 	= sunxi_i2s_resume,
+	.remove 	= sunxi_i2s_dai_remove,
+	.playback 	= {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.capture 	= {
 		.channels_min = 1,
 		.channels_max = 2,
-		.formats = (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE),
-
-		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_11025 |\
-			 SNDRV_PCM_RATE_22050| SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\
-			 SNDRV_PCM_RATE_48000 |SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000 |\
-			 SNDRV_PCM_RATE_KNOT),
-		.rate_min = 8000,
-		.rate_max = 192000,
+		.rates = SUNXI_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
 	},
-	.ops = &sunxi_i2s_dai_ops,
+	.symmetric_rates = 1,
+	.ops 		= &sunxi_i2s_dai_ops,
 };
 
 static const struct snd_soc_component_driver sunxi_i2s_component = {
@@ -519,18 +503,10 @@ static const struct regmap_config sunxi_i2s_regmap_config = {
 	.reg_bits = 32,
 	.reg_stride = 4,
 	.val_bits = 32,
-	.max_register = SUNXI_AC_MIC_PHONE_CAL,
-};
-
-static const struct snd_soc_dapm_widget i2s_dapm_widgets[] = {
-	SND_SOC_DAPM_OUTPUT("Mic Bias"),
-	SND_SOC_DAPM_OUTPUT("HP_OUT"),
-	SND_SOC_DAPM_INPUT("MIC_IN"),
-	SND_SOC_DAPM_INPUT("LINE_IN"),
+	.max_register = SUNXI_RXCHMAP,
 };
 
 static const struct of_device_id sunxi_i2s_of_match[] = {
-	{ .compatible = "allwinner,sun4i-a10a-iis", .data = (void *)SUN4A},
 	{ .compatible = "allwinner,sun4i-a10-iis", .data = (void *)SUN4I},
 	{ .compatible = "allwinner,sun5i-a13-iis", .data = (void *)SUN5I},
 	{ .compatible = "allwinner,sun7i-a20-iis", .data = (void *)SUN7I},
@@ -559,7 +535,7 @@ static int sunxi_i2s_probe(struct platform_device *pdev)
 	if (!priv)
 		return -ENOMEM;
 
-	priv->id = (int)of_id->data;
+	priv->revision = (enum sunxi_soc_family)of_id->data;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	base = devm_ioremap_resource(&pdev->dev, res);
@@ -571,12 +547,6 @@ static int sunxi_i2s_probe(struct platform_device *pdev)
 	if (IS_ERR(priv->regmap))
 		return PTR_ERR(priv->regmap);
 
-	priv->irq = irq_of_parse_and_map(np, 0);
-	if (!priv->irq) {
-		dev_err(dev, "no irq for node %s\n", np->full_name);
-		return -ENXIO;
-	}
-
 	/* Get the clocks from the DT */
 	priv->clk_apb = devm_clk_get(dev, "apb");
 	if (IS_ERR(priv->clk_apb)) {
@@ -613,15 +583,17 @@ static int sunxi_i2s_probe(struct platform_device *pdev)
 	}
 
 	/* DMA configuration for TX FIFO */
-	priv->playback_dma_data.addr = res->start + SUNXI_DAC_TXDATA;
+	priv->playback_dma_data.addr = res->start + SUNXI_IISTXFIFO;
 	priv->playback_dma_data.maxburst = 4;
 	priv->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 
 	/* DMA configuration for RX FIFO */
-	priv->capture_dma_data.addr = res->start + SUNXI_ADC_RXDATA;
+	priv->capture_dma_data.addr = res->start + SUNXI_IISRXFIFO;
 	priv->capture_dma_data.maxburst = 4;
 	priv->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 
+	dev_set_drvdata(&pdev->dev, priv);
+
 	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_i2s_component, &sunxi_i2s_dai, 1);
 	if (ret)
 		goto err_clk_disable;
@@ -630,8 +602,6 @@ static int sunxi_i2s_probe(struct platform_device *pdev)
 	if (ret)
 		goto err_clk_disable;
 
-	i2s_init(priv);
-
 	return 0;
 
 err_clk_disable:
@@ -662,6 +632,5 @@ static struct platform_driver sunxi_i2s_driver = {
 module_platform_driver(sunxi_i2s_driver);
 
 MODULE_DESCRIPTION("sunxi i2s ASoC driver");
-MODULE_AUTHOR("Emilio López <emilio@elopez.com.ar>");
 MODULE_AUTHOR("Jon Smirl <jonsmirl@gmail.com>");
 MODULE_LICENSE("GPL");
