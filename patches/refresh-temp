Bottom: 6655a83a0f90a25bb0b8d53f85b7a03f4ea7ec5f
Top:    ad0aac38305ff3e642599eb2b9bab17ebe455ec7
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-04-21 15:33:52 -0400

Refresh of irq

---

diff --git a/arch/arm/boot/dts/ea3131.dts b/arch/arm/boot/dts/ea3131.dts
index b79b64a..c5cb88c 100644
--- a/arch/arm/boot/dts/ea3131.dts
+++ b/arch/arm/boot/dts/ea3131.dts
@@ -18,14 +18,14 @@
 
 	evtr@13000000 {
 		events = <
-			0 0x67 3 /* irq 0 EVT_wdog_m0, EVT_RISING_EDGE */
-			0 0x7A 2 /* irq 1 EVT_usb_otg_vbus_pwr_en, EVT_FALLING_EDGE */
-			0 0x77 2 /* irq 2 EVT_USB_VBUS, EVT_FALLING_EDGE */
-			0 0x7b 0 /* irq 3 EVT_USB_ID, EVT_ACTIVE_LOW */
-			1 0x18 1 /* irq 4 EVT_mNAND_RYBN3, EVT_ACTIVE_HIGH, DM9000_ETH_INT */
-			2 0x50 0 /* irq 5 EVT_mI2STX_BCK0, EVT_ACTIVE_LOW, SDMMC_CD */
-			3 0x55 0 /* irq 6 EVT_I2SRX_WS0, EVT_ACTIVE_LOW, EA_VBUS_OVRC */
-			3 0x33 1 /* irq 7 EVT_GPIO4, EVT_ACTIVE_HIGH, PENDOWN */
+			0 0x67 /* irq 0 EVT_wdog_m0, EVT_RISING_EDGE */
+			0 0x7A /* irq 1 EVT_usb_otg_vbus_pwr_en, EVT_FALLING_EDGE */
+			0 0x77 /* irq 2 EVT_USB_VBUS, EVT_FALLING_EDGE */
+			0 0x7b /* irq 3 EVT_USB_ID, EVT_ACTIVE_LOW */
+			1 0x18 /* irq 4 EVT_mNAND_RYBN3, EVT_ACTIVE_HIGH, DM9000_ETH_INT */
+			2 0x50 /* irq 5 EVT_mI2STX_BCK0, EVT_ACTIVE_LOW, SDMMC_CD */
+			3 0x55 /* irq 6 EVT_I2SRX_WS0, EVT_ACTIVE_LOW, EA_VBUS_OVRC */
+			3 0x33 /* irq 7 EVT_GPIO4, EVT_ACTIVE_HIGH, PENDOWN */
 		>;
 	};
 	i2c@1300a000 {
diff --git a/arch/arm/boot/dts/lpc3130.dtsi b/arch/arm/boot/dts/lpc3130.dtsi
index 17c78f3..8d7628b 100644
--- a/arch/arm/boot/dts/lpc3130.dtsi
+++ b/arch/arm/boot/dts/lpc3130.dtsi
@@ -1,5 +1,5 @@
 /*
- * lpc3130.dtsi - Device Tree Include file for LPC3131 family SoC
+ * lpc3130.dtsi - Device Tree Include file for LPC31xx family SoC
  *
  *  Copyright (C) 2011 Jon Smirl <jonsmirl@gmail.com>
  *
@@ -7,8 +7,8 @@
  */
 
 / {
-	model = "NXP LPC3131 SoC";
-	compatible = "nxp,lpc3131";
+	model = "NXP LPC3130 SoC";
+	compatible = "nxp,lpc3130";
 	#address-cells = <1>;
 	#size-cells = <1>;
 	interrupt-parent = <&intc>;
@@ -26,7 +26,7 @@
 		interrupts = <28>;
 	};
 	evtr: evtr@13000000 {
-		#event-cells = <3>;
+		#event-cells = <2>;
 		compatible = "nxp,lpc31xx-evtr";
 		interrupt-controller;
 		#interrupt-cells = <2>;
diff --git a/arch/arm/boot/dts/lpc3131.dtsi b/arch/arm/boot/dts/lpc3131.dtsi
index e668c07..4a70eeb 100644
--- a/arch/arm/boot/dts/lpc3131.dtsi
+++ b/arch/arm/boot/dts/lpc3131.dtsi
@@ -1,5 +1,5 @@
 /*
- * lpc3131.dtsi - Device Tree Include file for LPC3131 family SoC
+ * lpc3131.dtsi - Device Tree Include file for LPC31xx family SoC
  *
  *  Copyright (C) 2011 Jon Smirl <jonsmirl@gmail.com>
  *
@@ -10,10 +10,10 @@
 
 / {
 	model = "NXP LPC3131 SoC";
-	compatible = "nxp,lpc3131";
-	
-	isram0: memory@11028000 {
-		reg = <0x11028000 0x18000>;
-		interrupts = <28>;
+	compatible = "nxp,lpc3131", "nxp,lpc3130";
+
+	isram1: memory@11040000 {
+		reg = <0x11040000 0x18000>;
+		interrupts = <29>;
 	};
 };
diff --git a/arch/arm/mach-lpc31xx/evtr.c b/arch/arm/mach-lpc31xx/evtr.c
index ed6d992..5aece7f 100644
--- a/arch/arm/mach-lpc31xx/evtr.c
+++ b/arch/arm/mach-lpc31xx/evtr.c
@@ -24,12 +24,14 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/timer.h>
+#include <linux/io.h>
 #include <linux/of_irq.h>
 #include <linux/module.h>
 #include <linux/irqdomain.h>
 #include <linux/of_platform.h>
 #include <linux/slab.h>
 #include <linux/gpio.h>
+#include <linux/of_address.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
@@ -37,143 +39,37 @@
 #include <mach/irqs.h>
 #include <mach/clock.h>
 
-#define IRQ_EVT_START   NR_IRQ_CPU
+#define IRQ_EVT_ROUTER0	1	/*interrupts from Event router 0*/
+#define IRQ_EVT_ROUTER1	2	/*interrupts from Event router 1*/
+#define IRQ_EVT_ROUTER2	3	/*interrupts from Event router 2*/
+#define IRQ_EVT_ROUTER3	4	/*interrupts from Event router 3*/
+
+/***********************************************************************
+ * Event router register definitions
+ **********************************************************************/
+#define EVTR_INT_PEND(bank)  (0xC00 + ((bank) << 2))
+#define EVTR_INT_CLR(bank)   (0xC20 + ((bank) << 2))
+#define EVTR_INT_SET(bank)   (0xC40 + ((bank) << 2))
+#define EVTR_MASK(bank)      (0xC60 + ((bank) << 2))
+#define EVTR_MASK_CLR(bank)  (0xC80 + ((bank) << 2))
+#define EVTR_MASK_SET(bank)  (0xCA0 + ((bank) << 2))
+#define EVTR_APR(bank)       (0xCC0 + ((bank) << 2))
+#define EVTR_ATR(bank)       (0xCE0 + ((bank) << 2))
+#define EVTR_RSR(bank)       (0xD20 + ((bank) << 2))
+#define EVTR_OUT_PEND(vec,bank)     (0x1000 + ((vec) << 5) + ((bank) << 2))
+#define EVTR_OUT_MASK(vec,bank)     (0x1400 + ((vec) << 5) + ((bank) << 2))
+#define EVTR_OUT_MASK_CLR(vec,bank) (0x1800 + ((vec) << 5) + ((bank) << 2))
+#define EVTR_OUT_MASK_SET(vec,bank) (0x1C00 + ((vec) << 5) + ((bank) << 2))
+
+static struct irq_domain *evtr_domain;
+struct event_data {
+	int event;
+	int group;
+	int virq;
+};
 
-/* System specific IRQs */
-/* event PIN or internal signal */
-typedef enum _EVT_TYPE_
-{
-  EVT_ipint_int = 0,
-  EVT_mLCD_DB_0,
-  EVT_mLCD_DB_1,
-  EVT_mLCD_DB_2,
-  EVT_mLCD_DB_3,
-  EVT_mLCD_DB_4,
-  EVT_mLCD_DB_5,
-  EVT_mLCD_DB_6,
-  EVT_mLCD_DB_7,
-  EVT_mLCD_DB_8,
-  EVT_mLCD_DB_9,
-  EVT_mLCD_DB_10,
-  EVT_mLCD_DB_11,
-  EVT_mLCD_DB_12,
-  EVT_mLCD_DB_13,
-  EVT_mLCD_DB_14,
-  EVT_mLCD_DB_15,
-  EVT_mLCD_RS,
-  EVT_mLCD_CSB,
-  EVT_mLCD_E_RD,
-  EVT_mLCD_RW_WR,
-  EVT_mNAND_RYBN0,
-  EVT_mNAND_RYBN1,
-  EVT_mNAND_RYBN2,
-  EVT_mNAND_RYBN3,
-  EVT_EBI_D_0,
-  EVT_EBI_D_1,
-  EVT_EBI_D_2,
-  EVT_EBI_D_3,
-  EVT_EBI_D_4,
-  EVT_EBI_D_5,
-  EVT_EBI_D_6,
-
-  EVT_EBI_D_7,
-  EVT_EBI_D_8,
-  EVT_EBI_D_9,
-  EVT_EBI_D_10,
-  EVT_EBI_D_11,
-  EVT_EBI_D_12,
-  EVT_EBI_D_13,
-  EVT_EBI_D_14,
-  EVT_EBI_D_15,
-  EVT_EBI_NWE,
-  EVT_EBI_A_0_ALE,
-  EVT_EBI_A_1_CLE,
-  EVT_EBI_DQM_0_NOE,
-  EVT_EBI_NCAS_BLOUT_0,
-  EVT_EBI_NRAS_BLOUT_1,
-  EVT_GPIO1,
-  EVT_GPIO0,
-  EVT_GPIO2,
-  EVT_GPIO3,
-  EVT_GPIO4,
-  EVT_mGPIO5,
-  EVT_mGPIO6,
-  EVT_mGPIO7,
-  EVT_mGPIO8,
-  EVT_mGPIO9,
-  EVT_mGPIO10,
-  EVT_GPIO11,
-  EVT_GPIO12,
-  EVT_GPIO13,
-  EVT_GPIO14,
-  EVT_GPIO15,
-  EVT_GPIO16,
-
-  EVT_GPIO17,
-  EVT_GPIO18,
-  EVT_NAND_NCS_0,
-  EVT_NAND_NCS_1,
-  EVT_NAND_NCS_2,
-  EVT_NAND_NCS_3,
-  EVT_SPI_MISO,
-  EVT_SPI_MOSI,
-  EVT_SPI_CS_IN,
-  EVT_SPI_SCK,
-  EVT_SPI_CS_OUT0,
-  EVT_UART_RXD,
-  EVT_UART_TXD,
-  EVT_mUART_CTS_N,
-  EVT_mUART_RTS_N,
-  EVT_mI2STX_CLK0,
-  EVT_mI2STX_BCK0,
-  EVT_mI2STX_DATA0,
-  EVT_mI2STX_WS0,
-  EVT_I2SRX_BCK0,
-  EVT_I2SRX_DATA0,
-  EVT_I2SRX_WS0,
-  EVT_I2SRX_DATA1,
-  EVT_I2SRX_BCK1,
-  EVT_I2SRX_WS1,
-  EVT_I2STX_DATA1,
-  EVT_I2STX_BCK1,
-  EVT_I2STX_WS1,
-  EVT_CLK_256FS_O,
-  EVT_I2C_SDA1,
-  EVT_I2C_SCL1,
-  EVT_PWM_DATA,
-
-  EVT_AD_NINT_I,
-  EVT_PLAY_DET_I,
-  EVT_timer0_intct1,
-  EVT_timer1_intct1,
-  EVT_timer2_intct1,
-  EVT_timer3_intct1,
-  EVT_adc_int,
-  EVT_wdog_m0,
-  EVT_uart_rxd,
-  EVT_i2c0_scl_n,
-  EVT_i2c1_scl_n,
-  EVT_arm926_nfiq,
-  EVT_arm926_nirq,
-  EVT_MCI_DAT_0,
-  EVT_MCI_DAT_1,
-  EVT_MCI_DAT_2,
-  EVT_MCI_DAT_3,
-  EVT_MCI_DAT_4,
-  EVT_MCI_DAT_5,
-  EVT_MCI_DAT_6,
-  EVT_MCI_DAT_7,
-  EVT_MCI_CMD,
-  EVT_MCI_CLK,
-  EVT_USB_VBUS,
-  EVT_usb_otg_ahb_needclk,
-  EVT_usb_atx_pll_lock,
-  EVT_usb_otg_vbus_pwr_en,
-  EVT_USB_ID,
-  EVT_isram0_mrc_finished,
-  EVT_isram1_mrc_finished,
-  EVT_LAST
-} EVENT_T;
+static struct event_data *events;
+static int num_events;
 
 /* External interrupt type enumerations */
 typedef enum
@@ -188,13 +84,6 @@ typedef enum
 /* Macros to compute the bank based on EVENT_T */
 #define EVT_GET_BANK(evt)   (((evt) >> 5) & 0x3)
 
-/* structure to map board IRQ to event pin */
-typedef struct {
-	u32 irq;
-	EVENT_T event_pin;
-	EVENT_TYPE_T type;
-} IRQ_EVENT_MAP_T;
-
 #define EVT_MAX_VALID_BANKS   4
 #define EVT_MAX_VALID_INT_OUT 5
 
@@ -214,185 +103,65 @@ typedef struct {
 #define EVT_ATR_BANK2_DEF 0x00000000
 #define EVT_ATR_BANK3_DEF 0x077FFFFC
 
-/* Other chip IRQs routed through event router.
- * These IRQs should be treated as board IRQs but they are
- * common for all boards.
- */
-#define IRQ_WDT        30  /* Watchdog interrupt */
-#define IRQ_VBUS_EN    31  /* VBUS power enable */
-#define IRQ_VBUS_OVRC  32  /* Detect VBUS over current - Host mode */
-#define IRQ_USB_ID     33  /* Detect ID pin change - OTG */
-
-#define _INTERNAL_IRQ_EVENT_MAP	\
-	{IRQ_WDT, EVT_wdog_m0, EVT_RISING_EDGE}, \
-	{IRQ_VBUS_EN, EVT_usb_otg_vbus_pwr_en, EVT_FALLING_EDGE}, \
-	{IRQ_VBUS_OVRC, EVT_USB_VBUS, EVT_FALLING_EDGE}, \
-	{IRQ_USB_ID, EVT_USB_ID, EVT_ACTIVE_LOW}, \
-
-#if defined(CONFIG_LPC3152_AD)
-/* For chips with analog die there are some more AD events routed
- * through event router.
- */
-#define IRQ_RTC	        34
-#define IRQ_PLAY        35
-#define NR_IRQ_CHIP_EVT	6
-
-#define AD_IRQ_EVENT_MAP	\
-	{IRQ_RTC, EVT_AD_NINT_I, EVT_ACTIVE_LOW}, \
-	{IRQ_PLAY, EVT_PLAY_DET_I, EVT_ACTIVE_HIGH}, \
-
-#define CHIP_IRQ_EVENT_MAP   _INTERNAL_IRQ_EVENT_MAP \
-	AD_IRQ_EVENT_MAP
-
-#else
-#define CHIP_IRQ_EVENT_MAP   _INTERNAL_IRQ_EVENT_MAP
-#define NR_IRQ_CHIP_EVT	     4
-#endif
-
-/* now compute the board start IRQ number */
-#define IRQ_BOARD_START   (NR_IRQ_CPU + NR_IRQ_CHIP_EVT)
-
-/* Route all internal chip events to IRQ_EVT_ROUTER0 */
-#define IRQ_EVTR0_START        IRQ_EVT_START
-#define IRQ_EVTR0_END          (IRQ_BOARD_START - 1)
-
-
-#if defined (CONFIG_MACH_VAL3153)
-
-# define IRQ_CS8900_ETH_INT  IRQ_BOARD_START	/* Ethernet chip */
-# define IRQ_SDMMC_CD0       (IRQ_BOARD_START + 1)	/* SD card detect */
-# define IRQ_SDMMC_CD1       (IRQ_BOARD_START + 2)	/* SD card detect */
-# define NR_IRQ_EBOARD        3
-
-/* now define board irq to event pin map */
-#define BOARD_IRQ_EVENT_MAP	{ \
-	CHIP_IRQ_EVENT_MAP \
-	{IRQ_CS8900_ETH_INT, EVT_GPIO16, EVT_ACTIVE_HIGH}, \
-	{IRQ_SDMMC_CD0, EVT_GPIO12, EVT_ACTIVE_HIGH}, \
-	{IRQ_SDMMC_CD1, EVT_GPIO13, EVT_ACTIVE_HIGH}, \
-	}
-/* Following defines group the board IRQs into 4 IRQ_EVNTR groups.
-   IRQ_EVT_ROUTERx IRQ is generated when event in the corresponding
-   group triggers.
-*/
-#define IRQ_EVTR1_START        IRQ_CS8900_ETH_INT
-#define IRQ_EVTR1_END          IRQ_CS8900_ETH_INT
-#define IRQ_EVTR2_START        IRQ_SDMMC_CD0
-#define IRQ_EVTR2_END          IRQ_SDMMC_CD0
-#define IRQ_EVTR3_START        IRQ_SDMMC_CD1
-#define IRQ_EVTR3_END          IRQ_SDMMC_CD1
-
-
-#elif defined (CONFIG_MACH_EA313X) || defined(CONFIG_MACH_EA3152)
-# define IRQ_DM9000_ETH_INT   IRQ_BOARD_START	/* Ethernet chip */
-# define IRQ_SDMMC_CD         (IRQ_BOARD_START + 1)	/* SD card detect */
-# define IRQ_EA_VBUS_OVRC     (IRQ_BOARD_START + 2)	/* Over current indicator */
-# define IRQ_PENDOWN	      (IRQ_BOARD_START + 3)	/* Pendown from touch screen */
-# define NR_IRQ_EBOARD        4
-
-/* now define board irq to event pin map */
-#define BOARD_IRQ_EVENT_MAP	{ \
-	CHIP_IRQ_EVENT_MAP \
-	{IRQ_DM9000_ETH_INT, EVT_mNAND_RYBN3, EVT_ACTIVE_HIGH}, \
-	{IRQ_SDMMC_CD, EVT_mI2STX_BCK0, EVT_ACTIVE_LOW}, \
-	{IRQ_EA_VBUS_OVRC, EVT_I2SRX_WS0, EVT_ACTIVE_LOW}, \
-	{IRQ_PENDOWN, EVT_GPIO4, EVT_ACTIVE_HIGH}, \
-	}
-/* Following defines group the board IRQs into 4 IRQ_EVNTR groups.
-   IRQ_EVT_ROUTERx IRQ is generated when event in the corresponding
-   group triggers.
-*/
-#define IRQ_EVTR1_START        IRQ_DM9000_ETH_INT
-#define IRQ_EVTR1_END          IRQ_DM9000_ETH_INT
-#define IRQ_EVTR2_START        IRQ_SDMMC_CD
-#define IRQ_EVTR2_END          IRQ_SDMMC_CD
-#define IRQ_EVTR3_START        IRQ_EA_VBUS_OVRC
-#define IRQ_EVTR3_END          IRQ_PENDOWN
-
-#elif defined (CONFIG_MACH_VAL3154)
-# define IRQ_SDMMC_CD	 IRQ_BOARD_START 	/* SD card detect */
-# define NR_IRQ_EBOARD	 1
-
-/* now define board irq to event pin map */
-#define BOARD_IRQ_EVENT_MAP	{ \
-	CHIP_IRQ_EVENT_MAP \
-	{IRQ_SDMMC_CD, EVT_mI2STX_BCK0, EVT_ACTIVE_LOW}, \
-	}
-/* Following defines group the board IRQs into 4 IRQ_EVNTR groups.
-   IRQ_EVT_ROUTERx IRQ is generated when event in the corresponding
-   group triggers.
-*/
-#define IRQ_EVTR1_START        IRQ_SDMMC_CD
-#define IRQ_EVTR1_END          IRQ_SDMMC_CD
-#define IRQ_EVTR2_START        0
-#define IRQ_EVTR2_END          0
-#define IRQ_EVTR3_START        0
-#define IRQ_EVTR3_END          0
-
-#else
-# define NR_IRQ_EBOARD          0
-#define IRQ_EVTR0_START        0
-#define IRQ_EVTR0_END          0
-#define IRQ_EVTR1_START        0
-#define IRQ_EVTR1_END          0
-#define IRQ_EVTR2_START        0
-#define IRQ_EVTR2_END          0
-#define IRQ_EVTR3_START        0
-#define IRQ_EVTR3_END          0
-
-#endif
-
-
-static IRQ_EVENT_MAP_T irq_2_event[] = BOARD_IRQ_EVENT_MAP;
+static void __iomem *evtr_regs;
+#define evtr_read(reg) \
+	__raw_readl(evtr_regs + reg)
+#define evtr_write(reg, value) \
+	__raw_writel(value, evtr_regs + reg);
 
 static void evt_mask_irq(struct irq_data *data)
 {
-	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
-	u32 bit_pos = irq_2_event[data->irq - IRQ_EVT_START].event_pin & 0x1F;
+	uint32_t bank = EVT_GET_BANK(events[data->hwirq].event);
+	uint32_t bit_pos = events[data->hwirq].event & 0x1F;
 
-	EVRT_MASK_CLR(bank) = _BIT(bit_pos);
+	evtr_write(EVTR_MASK_CLR(bank), BIT(bit_pos));
 }
 
 static void evt_unmask_irq(struct irq_data *data)
 {
-	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
-	u32 bit_pos = irq_2_event[data->irq - IRQ_EVT_START].event_pin & 0x1F;
+	uint32_t bank = EVT_GET_BANK(events[data->hwirq].event);
+	uint32_t bit_pos = events[data->hwirq].event & 0x1F;
 
-	EVRT_MASK_SET(bank) = _BIT(bit_pos);
+	evtr_write(EVTR_MASK_SET(bank), BIT(bit_pos));
 }
 
 static void evt_ack_irq(struct irq_data *data)
 {
-	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
-	u32 bit_pos = irq_2_event[data->irq - IRQ_EVT_START].event_pin & 0x1F;
-	//EVRT_MASK_CLR(bank) = _BIT(bit_pos);
-	EVRT_INT_CLR(bank) = _BIT(bit_pos);
+	uint32_t bank = EVT_GET_BANK(events[data->hwirq].event);
+	uint32_t bit_pos = events[data->hwirq].event & 0x1F;
+
+	evtr_write(EVTR_INT_CLR(bank), BIT(bit_pos));
 }
 
 static int evt_set_type(struct irq_data *data, unsigned int flow_type)
 {
-	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
-	u32 bit_pos = irq_2_event[data->irq - IRQ_EVT_START].event_pin & 0x1F;
+	uint32_t bank = EVT_GET_BANK(events[data->hwirq].event);
+	uint32_t bit_pos = events[data->hwirq].event & 0x1F;
 
 	switch (flow_type) {
 	case IRQ_TYPE_EDGE_RISING:
-		EVRT_APR(bank) |= _BIT(bit_pos);
-		EVRT_ATR(bank) |= _BIT(bit_pos);
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) | _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	case IRQ_TYPE_EDGE_FALLING:
-		EVRT_APR(bank) &= ~_BIT(bit_pos);
-		EVRT_ATR(bank) |= _BIT(bit_pos);
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) & ~_BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	case IRQ_TYPE_EDGE_BOTH:
-		EVRT_ATR(bank) |= _BIT(bit_pos);
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	case IRQ_TYPE_LEVEL_HIGH:
-		EVRT_APR(bank) |= _BIT(bit_pos);
-		EVRT_ATR(bank) &= ~_BIT(bit_pos);
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) | _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) &~ _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	case IRQ_TYPE_LEVEL_LOW:
-		EVRT_APR(bank) &= ~_BIT(bit_pos);
-		EVRT_ATR(bank) &= ~_BIT(bit_pos);
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) &~ _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) &~ _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	default:
 		return -EINVAL;
@@ -403,185 +172,17 @@ static int evt_set_type(struct irq_data *data, unsigned int flow_type)
 
 static int evt_set_wake(struct irq_data *data, unsigned int on)
 {
-	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
-	u32 bit_pos = irq_2_event[data->irq - IRQ_EVT_START].event_pin & 0x1F;
+	uint32_t bank = EVT_GET_BANK(events[data->hwirq].event);
+	uint32_t bit_pos = events[data->hwirq].event & 0x1F;
 
-	if (on)
+	if (on) {
 		/* enable routing to CGU_WAKEUP */
-		EVRT_OUT_MASK_SET(4, bank) = _BIT(bit_pos);
-	else
+		evtr_write(EVTR_OUT_MASK_SET(4, bank), _BIT(bit_pos));
+	} else {
 		/* disable routing to CGU_WAKEUP */
-		EVRT_OUT_MASK_CLR(4, bank) = _BIT(bit_pos);
-
-	return 0;
-}
-
-static int set_input(unsigned irq);
-
-unsigned int evt_startup(struct irq_data *data)
-{
-	evt_unmask_irq(data);
-	return set_input(data->irq);
-}
-
-static struct irq_chip lpc31xx_evtr_chip = {
-	.name = "EVENTROUTER",
-	.irq_ack = evt_ack_irq,
-	.irq_mask = evt_mask_irq,
-	.irq_unmask = evt_unmask_irq,
-	.irq_set_type = evt_set_type,
-	.irq_set_wake = evt_set_wake,
-	.irq_startup = evt_startup,
-};
-
-
-
-#define ROUTER_HDLR(n) \
-	static void router##n##_handler (unsigned int irq, struct irq_desc *desc) { \
-		u32 status, bank, bit_pos; \
-		if (IRQ_EVTR##n##_START == IRQ_EVTR##n##_END) { \
-			/* translate IRQ number */ \
-			irq = IRQ_EVTR##n##_START; \
-			generic_handle_irq(irq); \
-		} else { \
-			for (irq = IRQ_EVTR##n##_START; irq <= IRQ_EVTR##n##_END; irq++) {  \
-				/* compute bank & bit position for the event_pin */ \
-				bank = EVT_GET_BANK(irq_2_event[irq - IRQ_EVT_START].event_pin); \
-				bit_pos = irq_2_event[irq - IRQ_EVT_START].event_pin & 0x1F; \
-				status = EVRT_OUT_PEND(n, bank); \
-				if (status & _BIT(bit_pos)) { \
-					generic_handle_irq(irq); \
-				} \
-			} \
-		} \
-	}
-
-
-#if IRQ_EVTR0_END
-ROUTER_HDLR(0)
-#endif /* IRQ_EVTR0_END */
-
-#if IRQ_EVTR1_END
-ROUTER_HDLR(1)
-#endif /* IRQ_EVTR1_END */
-
-#if IRQ_EVTR2_END
-ROUTER_HDLR(2)
-#endif /* IRQ_EVTR2_END */
-
-#if IRQ_EVTR3_END
-ROUTER_HDLR(3)
-#endif /* IRQ_EVTR3_END */
-
-void __init lpc31xx_init_evtr(void)
-{
-	unsigned int irq;
-	int i, j, v;
-	u32 bank, bit_pos;
-
-	/* mask all external events */
-	for (i = 0; i < EVT_MAX_VALID_BANKS; i++)
-	{
-		/* mask all events */
-		EVRT_MASK_CLR(i) = 0xFFFFFFFF;
-		/* clear all pending events */
-		EVRT_INT_CLR(i) = 0xFFFFFFFF;
-
-		for (j = 0; j < EVT_MAX_VALID_INT_OUT; j++)
-		{
-			/* mask all events */
-			EVRT_OUT_MASK_CLR(j,i) = 0xFFFFFFFF;
-		}
-	}
-
-	/* Now configure external/board interrupts using event router */
-	for (irq = IRQ_EVT_START; irq < IRQ_EVT_START + NR_IRQ_CHIP_EVT + NR_IRQ_EBOARD; irq++) {
-		/* compute bank & bit position for the event_pin */
-		bank = EVT_GET_BANK(irq_2_event[irq - IRQ_EVT_START].event_pin);
-		bit_pos = irq_2_event[irq - IRQ_EVT_START].event_pin & 0x1F;
-
-		irq_set_chip(irq, &lpc31xx_evtr_chip);
-		set_irq_flags(irq, IRQF_VALID);
-		/* configure the interrupt sensitivity */
-		switch (irq_2_event[irq - IRQ_EVT_START].type) {
-			case EVT_ACTIVE_LOW:
-				EVRT_APR(bank) &= ~_BIT(bit_pos);
-				EVRT_ATR(bank) &= ~_BIT(bit_pos);
-				irq_set_handler(irq, handle_level_irq);
-				break;
-			case EVT_ACTIVE_HIGH:
-				EVRT_APR(bank) |= _BIT(bit_pos);
-				EVRT_ATR(bank) &= ~_BIT(bit_pos);
-				irq_set_handler(irq, handle_level_irq);
-				break;
-			case EVT_FALLING_EDGE:
-				EVRT_APR(bank) &= ~_BIT(bit_pos);
-				EVRT_ATR(bank) |= _BIT(bit_pos);
-				irq_set_handler(irq, handle_edge_irq);
-				break;
-			case EVT_RISING_EDGE:
-				EVRT_APR(bank) |= _BIT(bit_pos);
-				EVRT_ATR(bank) |= _BIT(bit_pos);
-				irq_set_handler(irq, handle_edge_irq);
-				break;
-			case EVT_BOTH_EDGE:
-				EVRT_ATR(bank) |= _BIT(bit_pos);
-				irq_set_handler(irq, handle_edge_irq);
-				break;
-			default:
-				printk("Invalid Event type.\r\n");
-				break;
-		}
-		if ( (irq >= IRQ_EVTR0_START) && (irq <= IRQ_EVTR0_END) ) {
-			/* enable routing to vector 0 */
-			EVRT_OUT_MASK_SET(0, bank) = _BIT(bit_pos);
-			v = 0;
-		} else if ( (irq >= IRQ_EVTR1_START) && (irq <= IRQ_EVTR1_END) ) {
-			/* enable routing to vector 1 */
-			EVRT_OUT_MASK_SET(1, bank) = _BIT(bit_pos);
-			v = 1;
-		} else if ( (irq >= IRQ_EVTR2_START) && (irq <= IRQ_EVTR2_END) ) {
-			/* enable routing to vector 2 */
-			EVRT_OUT_MASK_SET(2, bank) = _BIT(bit_pos);
-			v = 2;
-		} else if ( (irq >= IRQ_EVTR3_START) && (irq <= IRQ_EVTR3_END) ) {
-			/* enable routing to vector 3 */
-			EVRT_OUT_MASK_SET(3, bank) = _BIT(bit_pos);
-			v = 3;
-		} else {
-			v = -1;
-			printk("Invalid Event router setup.\r\n");
-		}
-		printk("irq=%d Event=0x%02x bank:%d bit:%02d type:%d vector %d\n", irq,
-			irq_2_event[irq - IRQ_EVT_START].event_pin, bank,
-			bit_pos, irq_2_event[irq - IRQ_EVT_START].type, v);
-
+		evtr_write(EVTR_OUT_MASK_CLR(4, bank), _BIT(bit_pos));
 	}
-	/* for power management. Wake from internal irqs */
-	EVRT_APR(3) &= ~_BIT(12);
-	EVRT_ATR(3) &= ~_BIT(12);
-	EVRT_MASK_SET(3) = _BIT(12);
-
-	/* install IRQ_EVT_ROUTER0  chain handler */
-#if IRQ_EVTR0_END
-	/* install chain handler for IRQ_EVT_ROUTER0 */
-	irq_set_chained_handler (IRQ_EVT_ROUTER0, router0_handler);
-#endif
-
-#if IRQ_EVTR1_END
-	/* install chain handler for IRQ_EVT_ROUTER1 */
-	irq_set_chained_handler (IRQ_EVT_ROUTER1, router1_handler);
-#endif
-
-#if IRQ_EVTR2_END
-	/* install chain handler for IRQ_EVT_ROUTER2 */
-	irq_set_chained_handler (IRQ_EVT_ROUTER2, router2_handler);
-#endif
-
-#if IRQ_EVTR3_END
-	/* install chain handler for IRQ_EVT_ROUTER3 */
-	irq_set_chained_handler (IRQ_EVT_ROUTER3, router3_handler);
-#endif
+	return 0;
 }
 
 /* table to map from event to gpio bit */
@@ -605,15 +206,6 @@ int event_to_gpioreg[] = {
 	0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,
 };
 
-struct event_data {
-	int event;
-	int group;
-	int edge;
-};
-
-static struct event_data *events;
-static int num_events;
-
 extern int lpc3131_reg_to_gpio(unsigned index, unsigned gpio);
 
 /* when a gpio pin is request as an interrupt source,
@@ -623,7 +215,7 @@ static int set_input(unsigned irq)
 {
 	int ret, reg, gpio, event;
 
-	event = events[irq - 30].event;
+	event = events[irq].event;
 	reg  = event_to_gpioreg[event];
 	if (!reg) /* not a gpio pin */
 		return 0;
@@ -635,52 +227,112 @@ static int set_input(unsigned irq)
 	return gpio_direction_input(gpio);
 }
 
-int event_to_irq(int event)
+unsigned int evt_startup(struct irq_data *data)
+{
+	evt_unmask_irq(data);
+	return set_input(data->hwirq);
+}
+
+int lpc31xx_set_cgu_wakeup(int enable, int event)
+{
+	uint32_t bank = EVT_GET_BANK(event);
+	uint32_t bit_pos = event & 0x1F;
+
+	if (!evtr_regs)
+		return -EAGAIN;
+
+	if (enable)
+		evtr_write(EVTR_OUT_MASK_SET(4, bank), _BIT(bit_pos))
+	else
+		evtr_write(EVTR_OUT_MASK_CLR(4, bank), _BIT(bit_pos))
+	return 0;
+}
+EXPORT_SYMBOL(lpc31xx_set_cgu_wakeup);
+
+static struct irq_chip lpc31xx_evtr_chip = {
+	.name = "EVENTROUTER",
+	.irq_ack = evt_ack_irq,
+	.irq_mask = evt_mask_irq,
+	.irq_unmask = evt_unmask_irq,
+	.irq_set_type = evt_set_type,
+	.irq_set_wake = evt_set_wake,
+	.irq_startup = evt_startup,
+};
+
+#define ROUTER_HDLR(n) \
+	static void router##n##_handler (unsigned int irq, struct irq_desc *desc) { \
+		uint32_t i, status, bank, bit_pos; \
+		for (i = 0; i < num_events; i++) { \
+			if (events[i].group == n) { \
+				bank = EVT_GET_BANK(events[i].event); \
+				bit_pos = events[i].event & 0x1F; \
+				status = evtr_read(EVTR_OUT_PEND(n, bank)); \
+				if (status & _BIT(bit_pos)) { \
+					generic_handle_irq(events[i].virq); \
+					return; \
+				} \
+			} \
+		} \
+	}
+
+ROUTER_HDLR(0)
+ROUTER_HDLR(1)
+ROUTER_HDLR(2)
+ROUTER_HDLR(3)
+
+int lpc31xx_event_to_irq(int event)
 {
 	int i;
 	for (i = 0; i < num_events; i++) {
 		if (events[i].event == event) {
-			return i + 30; /* fixme */
+			return i;
 		}
 	}
 	return -EINVAL;
 }
-EXPORT_SYMBOL(event_to_irq);
-
-static const struct of_device_id evtr_of_match[] __initconst = {
-	{ .compatible = "nxp,lpc31xx-evtr", },
-	{},
-};
+EXPORT_SYMBOL(lpc31xx_event_to_irq);
 
-int lpc31xx_set_cgu_wakeup(int enable, int event)
+static int evtr_irq_map(struct irq_domain *h, unsigned int virq, irq_hw_number_t hw)
 {
-	uint32_t bank = EVT_GET_BANK(event);
-	uint32_t bit_pos = event & 0x1F;
+	uint32_t bank, bit_pos;
 
-	if (enable) {
-		EVRT_OUT_MASK_SET(4, bank) = _BIT(bit_pos);
-	} else {
-		EVRT_OUT_MASK_CLR(4, bank) = _BIT(bit_pos);
-	}
+	/* compute bank & bit position for the event_pin */
+	bank = EVT_GET_BANK(events[hw].event);
+	bit_pos = events[hw].event & 0x1F;
+	events[hw].virq = virq;
+
+	irq_set_chip(virq, &lpc31xx_evtr_chip);
+	set_irq_flags(virq, IRQF_VALID);
+
+	evtr_write(EVTR_OUT_MASK_SET(events[hw].group, bank), _BIT(bit_pos));
 	return 0;
 }
-EXPORT_SYMBOL(lpc31xx_set_cgu_wakeup);
+
+static struct irq_domain_ops evtr_irq_ops = {
+	.map	= evtr_irq_map,
+	.xlate	= irq_domain_xlate_twocell,
+};
+
+static const struct of_device_id evtr_of_match[] __initconst = {
+	{ .compatible = "nxp,lpc31xx-evtr", },
+	{},
+};
 
 static int __devinit lpc31xx_evtr_probe(struct platform_device *pdev)
 {
 	const __be32 *ip;
 	struct device_node *np = pdev->dev.of_node;
-	int cells, length, i;
-
-	printk("###### Event router probe ######\n");
+	int cells, length, i, j;
 
-	irq_domain_generate_simple(evtr_of_match, 0x13000000, 30);
+	evtr_regs = of_iomap(np, 0);
+	if (!evtr_regs)
+		return -EINVAL;
 
 	ip = of_get_property(np, "#event-cells", NULL);
 	if (!ip)
 		return -EINVAL;
 	cells = be32_to_cpup(ip);
-	if (cells != 3)
+	if (cells != 2)
 		return -EINVAL;
 
 	ip = of_get_property(np, "events", &length);
@@ -689,10 +341,50 @@ static int __devinit lpc31xx_evtr_probe(struct platform_device *pdev)
 	for (i = 0; i < num_events; i++) {
 		events[i].group = be32_to_cpup(ip++);
 		events[i].event = be32_to_cpup(ip++);
-		events[i].edge = be32_to_cpup(ip++);
-		printk("group %d bit %02x edge %d\n", events[i].group, events[i].event, events[i].edge);
-		//set_input(events[i].event);
+		if ((events[i].group < 0) || (events[i].group >= EVT_MAX_VALID_BANKS))
+			panic("Event router groups must be 0-3");
+	}
+	/* enable clock to Event router */
+	cgu_clk_en_dis(CGU_SB_EVENT_ROUTER_PCLK_ID, 1);
+
+	/* mask all external events */
+	for (i = 0; i < EVT_MAX_VALID_BANKS; i++)
+	{
+		/* mask all events */
+		evtr_write(EVTR_MASK_CLR(i), 0xFFFFFFFF);
+		/* clear all pending events */
+		evtr_write(EVTR_INT_CLR(i), 0xFFFFFFFF);
+
+		for (j = 0; j < EVT_MAX_VALID_INT_OUT; j++)
+		{
+			/* mask all events */
+			evtr_write(EVTR_OUT_MASK_CLR(j,i), 0xFFFFFFFF);
+		}
 	}
+
+	evtr_domain = irq_domain_add_linear(np, num_events, &evtr_irq_ops, NULL);
+	if (!evtr_domain)
+		panic("Unable to add lpc31xx evtr domain (DT)\n");
+
+	irq_set_default_host(evtr_domain);
+
+	/* for power management. Wake from internal irqs */
+	evtr_write(EVTR_APR(3), evtr_read(EVTR_APR(3)) & ~_BIT(12));
+	evtr_write(EVTR_ATR(3), evtr_read(EVTR_ATR(3)) & ~_BIT(12));
+	evtr_write(EVTR_MASK_SET(3), _BIT(12));
+
+	/* install chain handler for IRQ_EVT_ROUTER0 */
+	irq_set_chained_handler (IRQ_EVT_ROUTER0, router0_handler);
+
+	/* install chain handler for IRQ_EVT_ROUTER1 */
+	irq_set_chained_handler (IRQ_EVT_ROUTER1, router1_handler);
+
+	/* install chain handler for IRQ_EVT_ROUTER2 */
+	irq_set_chained_handler (IRQ_EVT_ROUTER2, router2_handler);
+
+	/* install chain handler for IRQ_EVT_ROUTER3 */
+	irq_set_chained_handler (IRQ_EVT_ROUTER3, router3_handler);
+
 	return 0;
 }
 
@@ -719,7 +411,7 @@ static __init int lpc31xx_evtr_init(void)
 	return 0;
 }
 
-/* Make sure we get initialised before anyone else tries to use us */
+/* Make sure we get initialized before anyone else tries to use us */
 core_initcall(lpc31xx_evtr_init);
 
 
diff --git a/drivers/gpio/gpio-lpc31xx.c b/drivers/gpio/gpio-lpc31xx.c
index 0f25f73..0c5af9e 100644
--- a/drivers/gpio/gpio-lpc31xx.c
+++ b/drivers/gpio/gpio-lpc31xx.c
@@ -156,14 +156,14 @@ static void lpc3131_gpio_set_value(struct gpio_chip *chip, unsigned gpio, int va
 		*gpc(base, GPIO_M0_RESET) = pin;
 }
 
-extern int event_to_irq(int event);
+extern int lpc31xx_event_to_irq(int event);
 
 static int lpc3131_gpio_to_irq(struct gpio_chip *gc, unsigned gpio)
 {
 	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
 	struct lpc31xx_gpio_chip *chip = container_of(mm_gc, struct lpc31xx_gpio_chip, mmchip);
 
-	return event_to_irq(gpio_evt[chip->index].evt[gpio]);
+	return lpc31xx_event_to_irq(gpio_evt[chip->index].evt[gpio]);
 }
 
 int lpc3131_reg_to_gpio(unsigned index, unsigned gpio)
