Bottom: 852b103b3fbb9e3defe3de32ae51342e265db6f2
Top:    a37ea3c2e5f8ae8238c9978e2ad3fbedca70ef8f
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-03-22 11:01:54 -0400

Refresh of devicetree

---

diff --git a/arch/arm/boot/dts/ea3131.dts b/arch/arm/boot/dts/ea3131.dts
index 2f29f8a..799d5b6 100644
--- a/arch/arm/boot/dts/ea3131.dts
+++ b/arch/arm/boot/dts/ea3131.dts
@@ -21,14 +21,9 @@
 	};
 
 	ahb {
-		apb {
-			dbgu: serial@fffff200 {
-				status = "okay";
-			};
-
-			usart1: serial@fffb4000 {
-				status = "okay";
-			};
+		sdmmc@18000000 {
+			cd-gpio = <&gpio 0x87 0>;
+			power-gpio = <&gpio 0x45 0>;
 		};
 	};
 };
diff --git a/arch/arm/boot/dts/lpc3131.dtsi b/arch/arm/boot/dts/lpc3131.dtsi
index 8091962..0a4ced1 100644
--- a/arch/arm/boot/dts/lpc3131.dtsi
+++ b/arch/arm/boot/dts/lpc3131.dtsi
@@ -29,9 +29,11 @@
 
 		isram0: memory@11028000 {
 			reg = <0x11028000 0x18000>;
+			interrupts = <28>;
 		};
 		isram1: memory@11040000 {
 			reg = <0x11040000 0x18000>;
+			interrupts = <29>;
 		};
 
 		apb0: apb@13000000 {
@@ -43,36 +45,33 @@
 			evtr@13000000 {
 				compatible = "nxp,lpc31xx-evtr";
 				reg = <0x13000000 0x800>;
+				interrupts = <1 2 3 4>;
 			};
 			adc@13002000 {
 				compatible = "nxp,lpc31xx-adc";
 				reg = <0x13002000 0x400>;
-				interrupts = <1>;
+				interrupts = <9>;
 			};
 			wdt@13002400 {
 				compatible = "nxp,lpc31xx-wdt";
 				reg = <0x13002400 0x400>;
-				interrupts = <1>;
+				interrupts = <30>;
 			};
 			sys@13002800 {
 				compatible = "nxp,lpc31xx-sys";
 				reg = <0x13002800 0x400>;
-				interrupts = <1>;
 			};
-			gpio@13003000 {
+			gpio: gpio@13003000 {
 				compatible = "nxp,lpc31xx-gpio";
 				reg = <0x13003000 0x1000>;
-				interrupts = <1>;
 			};
 			cgu@13004000 {
 				compatible = "nxp,lpc31xx-cgu";
 				reg = <0x13004000 0x1000>;
-				interrupts = <1>;
 			};
 			rng@13006000 {
 				compatible = "nxp,lpc31xx-rng";
 				reg = <0x13006000 0x200>;
-				interrupts = <1>;
 			};
 		};
 		apb1: apb@13008000 {
@@ -84,37 +83,37 @@
 			timer0: timer@13008000 {
 				compatible = "nxp,lpc31xx-timer";
 				reg = <0x13008000 0x400>;
-				interrupts = <1>;
+				interrupts = <5>;
 			};
 			timer1: timer@13008400 {
 				compatible = "nxp,lpc31xx-timer";
 				reg = <0x13008400 0x400>;
-				interrupts = <1>;
+				interrupts = <6>;
 			};
 			timer2: timer@13008800 {
 				compatible = "nxp,lpc31xx-timer";
 				reg = <0x13008800 0x400>;
-				interrupts = <1>;
+				interrupts = <7>;
 			};
 			timer3: timer@13008c00 {
 				compatible = "nxp,lpc31xx-timer";
 				reg = <0x13008c00 0x400>;
-				interrupts = <1>;
+				interrupts = <8>;
 			};
 			pwm@13009000 {
 				compatible = "nxp,lpc31xx-pwm";
 				reg = <0x13009000 0x200>;
-				interrupts = <1>;
+				interrupts = <11>;
 			};
 			i2c0: i2c@1300a000 {
 				compatible = "nxp,lpc31xx-i2c";
 				reg = <0x1300a000 0x400>;
-				interrupts = <1>;
+				interrupts = <11>;
 			};
 			i2c1: i2c@1300a400 {
 				compatible = "nxp,lpc31xx-i2c";
 				reg = <0x1300a400 0x400>;
-				interrupts = <1>;
+				interrupts = <12>;
 			};
 		};
 		apb2: apb@15000000 {
@@ -126,22 +125,22 @@
 			pcm@15000000 {
 				compatible = "nxp,lpc31xx-pcm";
 				reg = <0x15000000 0x400>;
-				interrupts = <1>;
+				interrupts = <14>;
 			};
 			lcd@15000400 {
 				compatible = "nxp,lpc31xx-lcd";
 				reg = <0x15000400 0x400>;
-				interrupts = <1>;
+				interrupts = <18>;
 			};
 			uart@15001000 {
 				compatible = "nxp,lpc31xx-uart";
 				reg = <0x15001000 0x1000>;
-				interrupts = <1>;
+				interrupts = <10>;
 			};
 			spi@15002000 {
 				compatible = "nxp,lpc31xx-spi";
 				reg = <0x15002000 0x1000>;
-				interrupts = <1>;
+				interrupts = <18 19 20 21 22 23>;
 			};
 		};
 		apb3: apb@16000000 {
@@ -153,7 +152,7 @@
 			i2s@16000000 {
 				compatible = "nxp,lpc31xx-i2s";
 				reg = <0x16000000 0x1000>;
-				interrupts = <1>;
+				interrupts = <13 14 15 16>;
 			};
 		};
 		apb4: apb@17000000 {
@@ -165,38 +164,39 @@
 			dma@17000000 {
 				compatible = "nxp,lpc31xx-dma";
 				reg = <0x17000000 0x800>;
-				interrupts = <1>;
+				interrupts = <24>;
 			};
 			nand@17000800 {
 				compatible = "nxp,lpc31xx-nand";
 				reg = <0x17000800 0x800>;
-				interrupts = <1>;
+				interrupts = <25>;
 			};
 		};
 		mpmc@17008000 {
 			compatible = "nxp,lpc31xx-mpmc";
 			reg = <0x17008000 0x1000>;
-			interrupts = <1>;
+			interrupts = <21>;
 		};
 		sdmmc@18000000 {
 			compatible = "nxp,lpc31xx-sdmmc";
 			reg = <0x18000000 0x1000>;
-			interrupts = <1>;
+			interrupts = <26>;
 		};
 		usb@19000000 {
-			compatible = "nxp,lpc31xx-usb";
+			compatible = "nxp,lpc31xx-usb, usb-ehci";
 			reg = <0x19000000 0x1000>;
-			interrupts = <1>;
+			interrupts = <27>;
 		};
 		intc: intc@60000000 {
 			compatible = "nxp,lpc31xx-intc";
 			reg = <0x60000000 0x1000>;
-			interrupts = <1>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
 		};
 		nand-buffer@70000000 {
 			compatible = "nxp,lpc31xx-nand-buffer";
 			reg = <0x70000000 0x1000>;
-			interrupts = <1>;
+			interrupts = <24>;
 		};
 	};
 };
diff --git a/arch/arm/mach-lpc31xx/Makefile b/arch/arm/mach-lpc31xx/Makefile
index 5298fdf..5559f7c 100644
--- a/arch/arm/mach-lpc31xx/Makefile
+++ b/arch/arm/mach-lpc31xx/Makefile
@@ -4,7 +4,7 @@
 
 # Object file lists.
 
-obj-y			+= irq.o time.o generic.o i2c.o gpio.o dma.o usb.o wdt.o clock.o
+obj-y			+= irq.o time.o generic.o i2c.o gpio.o dma.o usb.o wdt.o clock.o dt.o
 obj-$(CONFIG_GPIOLIB) += gpiolib.o
 
 
diff --git a/arch/arm/mach-lpc31xx/dt.c b/arch/arm/mach-lpc31xx/dt.c
new file mode 100644
index 0000000..aa644cb
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/dt.c
@@ -0,0 +1,63 @@
+/*
+ * NXP LPC3131 board support using the device tree
+ *
+ *  Copyright (C) 2010 Secret Lab Technologies Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <asm/hardware/vic.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+
+#include <mach/board.h>
+
+static void __init lpc31xx_dt_init(void)
+{
+	of_platform_populate(NULL, of_default_bus_match_table,
+			     NULL, NULL);
+}
+
+void __init lpc31xx_init_early(void)
+{
+printk("JDS - lpc31xx_init_early\n");
+}
+
+void lpc31xx_restart(char mode, const char *cmd)
+{
+printk("JDS - lpc31xx_restart\n");
+}
+
+static const char *lpc31xx_dt_match[] __initconst = {
+	"ncp,lpc3130",
+	"nxp,lpc3131",
+	"nxp,lpc3152",
+	"nxp,lpc3153",
+	NULL,
+};
+
+DT_MACHINE_START(EA313X, "NXP LPC31xx (Device Tree Support)")
+	.map_io		= lpc313x_map_io,
+	.init_early	= lpc31xx_init_early,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= lpc31xx_dt_init,
+	.dt_compat	= lpc31xx_dt_match,
+	.restart	= lpc31xx_restart,
+MACHINE_END
diff --git a/arch/arm/mach-lpc31xx/generic.c b/arch/arm/mach-lpc31xx/generic.c
index 4980a58..a3b8e06 100644
--- a/arch/arm/mach-lpc31xx/generic.c
+++ b/arch/arm/mach-lpc31xx/generic.c
@@ -173,10 +173,17 @@ static struct map_desc lpc313x_io_desc[] __initdata = {
 		.length		= IO_ISRAM0_SIZE,
 		.type		= MT_DEVICE
 	},
+	{
+		.virtual	= io_p2v(IO_USB_PHYS),
+		.pfn		= __phys_to_pfn(IO_USB_PHYS),
+		.length		= IO_USB_SIZE,
+		.type		= MT_DEVICE
+	},
 };
 
 void __init lpc313x_map_io(void)
 {
+printk("JDS - lpc313x_map_io\n");
 	iotable_init(lpc313x_io_desc, ARRAY_SIZE(lpc313x_io_desc));
 }
 extern int __init cgu_init(char *str);
diff --git a/arch/arm/mach-lpc31xx/irq.c b/arch/arm/mach-lpc31xx/irq.c
index 50dc8a7..f2c36a9 100644
--- a/arch/arm/mach-lpc31xx/irq.c
+++ b/arch/arm/mach-lpc31xx/irq.c
@@ -24,6 +24,8 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/timer.h>
+#include <linux/of_irq.h>
+#include <linux/irqdomain.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
@@ -81,6 +83,12 @@ static struct irq_chip lpc313x_internal_chip = {
 	.irq_set_wake = intc_set_wake,
 };
 
+static struct irq_domain lpc313x_domain = {
+	.irq_base = 1,
+	.nr_irq = NR_IRQ_CPU,
+	.ops = &irq_domain_simple_ops,
+};
+
 static void evt_mask_irq(struct irq_data *data)
 {
 	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
@@ -199,6 +207,10 @@ ROUTER_HDLR(2)
 ROUTER_HDLR(3)
 #endif /* IRQ_EVTR3_END */
 
+static const struct of_device_id intc_of_match[] __initconst = {
+	{ .compatible = "nxp,lpc31xx-intc", },
+	{},
+};
 
 void __init lpc313x_init_irq(void)
 {
@@ -206,6 +218,8 @@ void __init lpc313x_init_irq(void)
 	int i, j;
 	u32 bank, bit_pos;
 
+	irq_domain_generate_simple(intc_of_match, 0x60000000, 0);
+
 	/* enable clock to interrupt controller */
 	cgu_clk_en_dis(CGU_SB_AHB2INTC_CLK_ID, 1);
 	cgu_clk_en_dis(CGU_SB_INTC_CLK_ID, 1);
@@ -341,6 +355,8 @@ void __init lpc313x_init_irq(void)
 	/* on the basis of priority level, for both targets (IRQ/FIQ)    */
 	INTC_IRQ_PRI_MASK = 0;
 	INTC_FIQ_PRI_MASK = 0;
+
+	irq_domain_add(&lpc313x_domain);
 }
 
 
diff --git a/drivers/mmc/host/lpc31xx_mmc.c b/drivers/mmc/host/lpc31xx_mmc.c
index 73d67e7..e0a0339 100644
--- a/drivers/mmc/host/lpc31xx_mmc.c
+++ b/drivers/mmc/host/lpc31xx_mmc.c
@@ -37,6 +37,8 @@
 #include <linux/delay.h>
 #include <linux/irq.h>
 #include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 
 #include "lpc31xx_mmc.h"
 #include <mach/irqs.h>
@@ -1401,6 +1403,13 @@ static void lpc313x_mci_cleanup_slot(struct lpc313x_mci_slot *slot,
 	mmc_free_host(slot->mmc);
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id lpc313x_mci_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-sdmmc" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lpc313x_mci_of_match);
+#endif
 
 static int lpc313x_mci_probe(struct platform_device *pdev)
 {
@@ -1412,19 +1421,23 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 	int				ret = 0;
 	int i;
 
+printk("JDS - lpc313x_mci_probe\n");
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!regs)
 		return -ENXIO;
 
 
+printk("JDS - lpc313x_mci_probe 1\n");
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
 		return irq;
 
+printk("JDS - lpc313x_mci_probe 2\n");
 	host = kzalloc(sizeof(struct lpc313x_mci), GFP_KERNEL);
 	if (!host)
 		return -ENOMEM;
 
+printk("JDS - lpc313x_mci_probe 3\n");
 	host->pdev = pdev;
 	host->pdata = pdata = pdev->dev.platform_data;
 	if (!pdata) {
@@ -1652,7 +1665,9 @@ static struct platform_driver lpc313x_mci_driver = {
 	.resume     = lpc313x_mci_resume,
 	.remove		= __exit_p(lpc313x_mci_remove),
 	.driver		= {
-		.name		= "lpc313x_mmc",
+		.name	= "lpc313x_mmc",
+		.owner	= THIS_MODULE,
+		.of_match_table = lpc313x_mci_of_match,
 	},
 };
