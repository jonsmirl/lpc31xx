Bottom: e85545c58a3230c674afc9daeb93393e796a0715
Top:    027289ca16787c59c9f62118dfebaabcf903d46a
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-04-14 00:16:57 -0400

Refresh of dma.patch

---

diff --git a/arch/arm/boot/dts/ea3131.dts b/arch/arm/boot/dts/ea3131.dts
index 0911d76..d4008f3 100644
--- a/arch/arm/boot/dts/ea3131.dts
+++ b/arch/arm/boot/dts/ea3131.dts
@@ -16,6 +16,18 @@
 		bootargs = "console=ttyS0,115200n8 root=/dev/mmcblk0p3 init=/etc/preinit rw rootwait loglevel=7";
 	};
 
+	evtr@13000000 {
+		events = <
+			0 0x67 3 /* irq 0 EVT_wdog_m0, EVT_RISING_EDGE */
+			0 0x7A 2 /* irq 1 EVT_usb_otg_vbus_pwr_en, EVT_FALLING_EDGE */
+			0 0x77 2 /* irq 2 EVT_USB_VBUS, EVT_FALLING_EDGE */
+			0 0x7b 0 /* irq 3 EVT_USB_ID, EVT_ACTIVE_LOW */
+			1 0x18 1 /* irq 4 EVT_mNAND_RYBN3, EVT_ACTIVE_HIGH, DM9000_ETH_INT */
+			2 0x50 0 /* irq 5 EVT_mI2STX_BCK0, EVT_ACTIVE_LOW, SDMMC_CD */
+			3 0x55 0 /* irq 6 EVT_I2SRX_WS0, EVT_ACTIVE_LOW, EA_VBUS_OVRC */
+			3 0x33 1 /* irq 7 EVT_GPIO4, EVT_ACTIVE_HIGH, PENDOWN */
+		>;
+	};
 	i2c@1300a000 {
 		slave-addr = <0x6E>;
 		pca9532: leds@60 {
@@ -33,7 +45,7 @@
 		};
 	};
 	spi@15002000 {
-		gpios = <&gpio_spi 4 0 
+		gpios = <&gpio_spi 4 0  /* chip selects */
 			 &gpio_ebi_i2stx_0 3 0>; 
 		s25sl032a@0 {
 			compatible = "code,s25sl032a";
@@ -66,17 +78,17 @@
 		slot@0 {
 			width = <4>;
 			detect-delays = <250>;
-			gpio-cd = <&gpio_cgu 7 0>;
-			gpio-power = <&gpio_ebi_i2stx_0 5 0>;
-			/* gpio-power = <&gpio_ebi_i2stx_0 5 0>; broken in hardware */
-			/* gpio-wp = <>; not implemented in hardware */
-			/* gpio-select = <>; not implemented in hardware */
 			voltage-ranges = <3200 3400>;
+			gpios = <
+				&gpio_ebi_mci 7 0 /* card detect */
+				0 /* write protect, no hardware */
+				&gpio_ebi_i2stx_0 5 0 /* broken hardware design */
+				0 /* slot select, no hardware */
+			>;
 		};
 	};
 	usb@19000000 {
 		vbus-over =  <&gpio_i2srx_0 2 0>;
-		vbus-interrupts = <36>;
 	};
 	sram@20000000 {
 		mpmc-config = <0x81 0 0 31 0 3 0>;
@@ -86,12 +98,15 @@
 		};
 	};
 	sram@20020000 {
-		/* enable oe toggle between consec reads */
+		/* enable oe toggle between consecutive reads */
 		mpmc-config = <0x81 1 1 4 1 1 2 0x24>;
 		dm9000@20020000 {
 			compatible = "davicom,dm9000";
 			reg = <0x20020000 0x100 0x20030000 0x100>;
-			interrupts = <34>;
+			gpios = <
+				&gpio_ebi_i2stx_0 2 0 /* main irq, map gpio to irq */
+				0  /* WOL irq, map gpio to irq */
+			>;
 		};			
 	};
 	memory@30000000 {
diff --git a/arch/arm/boot/dts/lpc3131.dtsi b/arch/arm/boot/dts/lpc3131.dtsi
index 7768a40..6fd9b64 100644
--- a/arch/arm/boot/dts/lpc3131.dtsi
+++ b/arch/arm/boot/dts/lpc3131.dtsi
@@ -29,10 +29,14 @@
 		reg = <0x11040000 0x18000>;
 		interrupts = <29>;
 	};
-	evtr@13000000 {
+	evtr: evtr@13000000 {
+		#event-cells = <3>;
 		compatible = "nxp,lpc31xx-evtr";
+		interrupt-controller;
+		#interrupt-cells = <1>;
 		reg = <0x13000000 0x800>;
-		interrupts = <1 2 3 4>;
+		interrupt-parent = <&intc>;
+		interrupts = <1 2 3 4>;  /* cascaded */
 	};
 	adc@13002000 {
 		compatible = "nxp,lpc31xx-adc";
diff --git a/drivers/gpio/gpio-lpc31xx.c b/drivers/gpio/gpio-lpc31xx.c
index 0d5c722..19f5e42 100644
--- a/drivers/gpio/gpio-lpc31xx.c
+++ b/drivers/gpio/gpio-lpc31xx.c
@@ -111,6 +111,12 @@ static void lpc3131_gpio_set_value(struct gpio_chip *chip, unsigned gpio, int va
 		*gpc(base, GPIO_M0_RESET) = pin;
 }
 
+static int lpc3131_gpio_to_irq(struct gpio_chip *chip, int irq)
+{
+	printk("------------- implement lpc3131_gpio_to_irq -------------\n");
+	return -ENOENT;
+}
+
 static int lpc313x_gpiochip_remove(struct platform_device *ofdev)
 {
 	return -EBUSY;
@@ -133,6 +139,7 @@ static int __devinit lpc313x_simple_gpiochip_probe(struct platform_device *ofdev
 	gc->direction_output = lpc3131_gpio_direction_output;
 	gc->get              = lpc3131_gpio_get_value;
 	gc->set              = lpc3131_gpio_set_value;
+	gc->to_irq	     = lpc3131_gpio_to_irq;
 
 	ret = of_mm_gpiochip_add(ofdev->dev.of_node, chip);
 	if (ret)
diff --git a/drivers/net/ethernet/davicom/dm9000.c b/drivers/net/ethernet/davicom/dm9000.c
index f8fd607..77edf3f 100644
--- a/drivers/net/ethernet/davicom/dm9000.c
+++ b/drivers/net/ethernet/davicom/dm9000.c
@@ -35,11 +35,15 @@
 #include <linux/platform_device.h>
 #include <linux/irq.h>
 #include <linux/slab.h>
+#include <linux/of_gpio.h>
 
 #include <asm/delay.h>
 #include <asm/irq.h>
 #include <asm/io.h>
 
+#include <linux/gpio.h>
+#include <mach/gpio.h>
+
 #include "dm9000.h"
 
 /* Board/System/Debug information/definition ---------------- */
@@ -96,7 +100,7 @@ typedef struct board_info {
 
 	void __iomem	*io_addr;	/* Register I/O base address */
 	void __iomem	*io_data;	/* Data I/O address */
-	u16		 irq;		/* IRQ */
+	unsigned long	 irq_flags;
 
 	u16		tx_pkt_cnt;
 	u16		queue_pkt_len;
@@ -123,7 +127,6 @@ typedef struct board_info {
 	struct resource *data_res;
 	struct resource	*addr_req;   /* resources requested */
 	struct resource *data_req;
-	struct resource *irq_res;
 
 	int		 irq_wake;
 
@@ -691,17 +694,18 @@ static void
 dm9000_release_board(struct platform_device *pdev, struct board_info *db)
 {
 	/* unmap our resources */
-
 	iounmap(db->io_addr);
 	iounmap(db->io_data);
 
 	/* release the resources */
-
-	release_resource(db->data_req);
-	kfree(db->data_req);
-
-	release_resource(db->addr_req);
-	kfree(db->addr_req);
+	if (db->data_req) {
+		release_resource(db->data_req);
+		kfree(db->data_req);
+	}
+	if (db->addr_req) {
+		release_resource(db->addr_req);
+		kfree(db->addr_req);
+	}
 }
 
 static unsigned char dm9000_type_to_char(enum dm9000_type type)
@@ -1166,7 +1170,7 @@ static int
 dm9000_open(struct net_device *dev)
 {
 	board_info_t *db = netdev_priv(dev);
-	unsigned long irqflags = db->irq_res->flags & IRQF_TRIGGER_MASK;
+	unsigned long irqflags = db->irq_flags & IRQF_TRIGGER_MASK;
 
 	if (netif_msg_ifup(db))
 		dev_dbg(db->dev, "enabling %s\n", dev->name);
@@ -1357,6 +1361,57 @@ static const struct net_device_ops dm9000_netdev_ops = {
 #endif
 };
 
+# define DM_IO_DELAY()	do { gpio_get_value(GPIO_MNAND_RYBN3);} while(0)
+
+static void dm9000_dumpblk(void __iomem *reg, int count)
+{
+	int i;
+	int tmp;
+
+	count = (count + 1) >> 1;
+	for (i = 0; i < count; i++) {
+		DM_IO_DELAY();
+		tmp = readw(reg);
+	}
+}
+
+static void dm9000_inblk(void __iomem *reg, void *data, int count)
+{
+	int i;
+	u16* pdata = (u16*)data;
+	count = (count + 1) >> 1;
+	for (i = 0; i < count; i++) {
+		DM_IO_DELAY();
+		*pdata++ = readw(reg);
+	}
+}
+
+#ifdef CONFIG_OF
+static int  __devinit
+of_gpio_to_irq(struct platform_device *pdev, int offset)
+{
+	int ret, gpio;
+	enum of_gpio_flags flags;
+
+	gpio = of_get_gpio_flags(pdev->dev.of_node, offset, &flags);
+	if (!gpio_is_valid(gpio)) {
+		dev_err(&pdev->dev, "invalid gpio #%d: %d\n", offset, gpio);
+		return gpio;
+	}
+	ret = gpio_request(gpio, dev_name(&pdev->dev));
+	if (ret) {
+		dev_err(&pdev->dev, "can't request gpio #%d: %d\n", offset, ret);
+		return ret;
+	}
+	ret = gpio_direction_input(gpio);
+	if (ret) {
+		dev_err(&pdev->dev, "can't set input direction for gpio #%d: %d\n", offset, ret);
+		return ret;
+	}
+	return gpio_to_irq(gpio);
+}
+#endif
+
 /*
  * Search DM9000 board, allocate space and register it
  */
@@ -1366,6 +1421,7 @@ dm9000_probe(struct platform_device *pdev)
 	struct dm9000_plat_data *pdata = pdev->dev.platform_data;
 	struct board_info *db;	/* Point a board information structure */
 	struct net_device *ndev;
+	struct resource *irq_res;
 	const unsigned char *mac_src;
 	int ret = 0;
 	int iosize;
@@ -1396,16 +1452,35 @@ dm9000_probe(struct platform_device *pdev)
 
 	db->addr_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	db->data_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-	db->irq_res  = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-
-	if (db->addr_res == NULL || db->data_res == NULL ||
-	    db->irq_res == NULL) {
+	if (db->addr_res == NULL || db->data_res == NULL ) {
 		dev_err(db->dev, "insufficient resources\n");
 		ret = -ENOENT;
 		goto out;
 	}
 
+	irq_res  = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (irq_res) {
+		ndev->irq	= irq_res->start;
+		db->irq_flags	= irq_res->flags;
+	} else {
+#ifdef CONFIG_OF
+		ret = of_gpio_to_irq(pdev, 0);
+		db->irq_flags = IORESOURCE_IRQ_HIGHLEVEL;
+#else
+		ret = -ENOENT;
+#endif
+		if (ret < 0) {
+			dev_err(db->dev, "missing irq %d\n", ret);
+			goto out;
+		}
+		ndev->irq = ret;
+	}
+
 	db->irq_wake = platform_get_irq(pdev, 1);
+#ifdef CONFIG_OF
+	if (db->irq_wake < 0)
+		db->irq_wake = of_gpio_to_irq(pdev, 1);
+#endif
 	if (db->irq_wake >= 0) {
 		dev_dbg(db->dev, "wakeup irq %d\n", db->irq_wake);
 
@@ -1463,10 +1538,11 @@ dm9000_probe(struct platform_device *pdev)
 		ret = -EINVAL;
 		goto out;
 	}
+/* fixme */
+pdata->flags		= DM9000_PLATF_16BITONLY | DM9000_PLATF_NO_EEPROM | DM9000_PLATF_SIMPLE_PHY;
 
 	/* fill in parameters for net-dev structure */
 	ndev->base_addr = (unsigned long)db->io_addr;
-	ndev->irq	= db->irq_res->start;
 
 	/* ensure at least we have a default set of IO routines */
 	dm9000_set_io(db, iosize);
@@ -1489,13 +1565,15 @@ dm9000_probe(struct platform_device *pdev)
 		 * over-rides */
 
 		if (pdata->inblk != NULL)
-			db->inblk = pdata->inblk;
+//			db->inblk = pdata->inblk;
+			db->inblk = dm9000_inblk;
 
 		if (pdata->outblk != NULL)
 			db->outblk = pdata->outblk;
 
 		if (pdata->dumpblk != NULL)
-			db->dumpblk = pdata->dumpblk;
+//			db->dumpblk = pdata->dumpblk;
+			db->dumpblk = dm9000_dumpblk;
 
 		db->flags = pdata->flags;
 	}
