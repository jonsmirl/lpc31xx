Bottom: 6a0ebb480816ac35d07b46efb7b6739bbfa30628
Top:    532db155b01f6147e2de0552ef68db50245041d1
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-04-22 18:53:13 -0400

Refresh of intc.patch

---

diff --git a/arch/arm/mach-lpc31xx/evtr.c b/arch/arm/mach-lpc31xx/evtr.c
index b44a647..463558b 100644
--- a/arch/arm/mach-lpc31xx/evtr.c
+++ b/arch/arm/mach-lpc31xx/evtr.c
@@ -28,8 +28,10 @@
 #include <linux/module.h>
 #include <linux/irqdomain.h>
 #include <linux/of_platform.h>
+#include <linux/of_address.h>
 #include <linux/slab.h>
 #include <linux/gpio.h>
+#include <linux/io.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
@@ -37,6 +39,23 @@
 #include <mach/irqs.h>
 #include <mach/clock.h>
 
+/***********************************************************************
+ * Event router register definitions
+ **********************************************************************/
+#define EVTR_INT_PEND(bank)  (0xC00 + ((bank) << 2))
+#define EVTR_INT_CLR(bank)   (0xC20 + ((bank) << 2))
+#define EVTR_INT_SET(bank)   (0xC40 + ((bank) << 2))
+#define EVTR_MASK(bank)      (0xC60 + ((bank) << 2))
+#define EVTR_MASK_CLR(bank)  (0xC80 + ((bank) << 2))
+#define EVTR_MASK_SET(bank)  (0xCA0 + ((bank) << 2))
+#define EVTR_APR(bank)       (0xCC0 + ((bank) << 2))
+#define EVTR_ATR(bank)       (0xCE0 + ((bank) << 2))
+#define EVTR_RSR(bank)       (0xD20 + ((bank) << 2))
+#define EVTR_OUT_PEND(vec,bank)     (0x1000 + ((vec) << 5) + ((bank) << 2))
+#define EVTR_OUT_MASK(vec,bank)     (0x1400 + ((vec) << 5) + ((bank) << 2))
+#define EVTR_OUT_MASK_CLR(vec,bank) (0x1800 + ((vec) << 5) + ((bank) << 2))
+#define EVTR_OUT_MASK_SET(vec,bank) (0x1C00 + ((vec) << 5) + ((bank) << 2))
+
 #define IRQ_EVT_ROUTER0	1	/*interrupts from Event router 0*/
 #define IRQ_EVT_ROUTER1	2	/*interrupts from Event router 1*/
 #define IRQ_EVT_ROUTER2	3	/*interrupts from Event router 2*/
@@ -84,6 +103,12 @@ static struct irq_domain *evtr_domain;
 static struct event_data *events;
 static int num_events;
 
+static void __iomem *evtr_regs;
+#define evtr_read(reg) \
+	__raw_readl(evtr_regs + reg)
+#define evtr_write(reg, value) \
+	__raw_writel(value, evtr_regs + reg);
+
 /* table to map from event to gpio bit */
 /* mask 0x1E0 reg, mask 0x1F bit */
 int event_to_gpioreg[] = {
@@ -110,7 +135,7 @@ static void evt_mask_irq(struct irq_data *data)
 	uint32_t bank = EVT_GET_BANK(events[data->hwirq].event);
 	uint32_t bit_pos = events[data->hwirq].event& 0x1F;
 
-	EVRT_MASK_CLR(bank) = _BIT(bit_pos);
+	evtr_write(EVTR_MASK_CLR(bank), _BIT(bit_pos));
 }
 
 static void evt_unmask_irq(struct irq_data *data)
@@ -118,7 +143,7 @@ static void evt_unmask_irq(struct irq_data *data)
 	uint32_t bank = EVT_GET_BANK(events[data->hwirq].event);
 	uint32_t bit_pos = events[data->hwirq].event & 0x1F;
 
-	EVRT_MASK_SET(bank) = _BIT(bit_pos);
+	evtr_write(EVTR_MASK_SET(bank), _BIT(bit_pos));
 }
 
 static void evt_ack_irq(struct irq_data *data)
@@ -126,7 +151,7 @@ static void evt_ack_irq(struct irq_data *data)
 	uint32_t bank = EVT_GET_BANK(events[data->hwirq].event);
 	uint32_t bit_pos = events[data->hwirq].event & 0x1F;
 	//EVRT_MASK_CLR(bank) = _BIT(bit_pos);
-	EVRT_INT_CLR(bank) = _BIT(bit_pos);
+	evtr_write(EVTR_INT_CLR(bank), _BIT(bit_pos));
 }
 
 static int evt_set_type(struct irq_data *data, unsigned int flow_type)
@@ -136,23 +161,28 @@ static int evt_set_type(struct irq_data *data, unsigned int flow_type)
 
 	switch (flow_type) {
 	case IRQ_TYPE_EDGE_RISING:
-		EVRT_APR(bank) |= _BIT(bit_pos);
-		EVRT_ATR(bank) |= _BIT(bit_pos);
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) | _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	case IRQ_TYPE_EDGE_FALLING:
-		EVRT_APR(bank) &= ~_BIT(bit_pos);
-		EVRT_ATR(bank) |= _BIT(bit_pos);
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) & ~_BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	case IRQ_TYPE_EDGE_BOTH:
-		EVRT_ATR(bank) |= _BIT(bit_pos);
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	case IRQ_TYPE_LEVEL_HIGH:
-		EVRT_APR(bank) |= _BIT(bit_pos);
-		EVRT_ATR(bank) &= ~_BIT(bit_pos);
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) | _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) &~ _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	case IRQ_TYPE_LEVEL_LOW:
-		EVRT_APR(bank) &= ~_BIT(bit_pos);
-		EVRT_ATR(bank) &= ~_BIT(bit_pos);
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) &~ _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) &~ _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	default:
 		return -EINVAL;
@@ -166,13 +196,13 @@ static int evt_set_wake(struct irq_data *data, unsigned int on)
 	uint32_t bank = EVT_GET_BANK(events[data->hwirq].event);
 	uint32_t bit_pos = events[data->hwirq].event & 0x1F;
 
-	if (on)
+	if (on) {
 		/* enable routing to CGU_WAKEUP */
-		EVRT_OUT_MASK_SET(4, bank) = _BIT(bit_pos);
-	else
+		evtr_write(EVTR_OUT_MASK_SET(4, bank), _BIT(bit_pos));
+	} else {
 		/* disable routing to CGU_WAKEUP */
-		EVRT_OUT_MASK_CLR(4, bank) = _BIT(bit_pos);
-
+		evtr_write(EVTR_OUT_MASK_CLR(4, bank), _BIT(bit_pos));
+	}
 	return 0;
 }
 
@@ -227,7 +257,7 @@ static struct irq_chip lpc31xx_evtr_chip = {
 			/* compute bank & bit position for the event_pin */ \
 			bank = EVT_GET_BANK(events[i].event); \
 			bit_pos = events[i].event & 0x1F; \
-			status = EVRT_OUT_PEND(n, bank); \
+			status = evtr_read(EVTR_OUT_PEND(n, bank)); \
 			if (status & _BIT(bit_pos)) { \
 				generic_handle_irq(events[i].virq); \
 				break; \
@@ -241,7 +271,7 @@ ROUTER_HDLR(1)
 ROUTER_HDLR(2)
 ROUTER_HDLR(3)
 
-int event_to_irq(int event)
+int lpc31xx_event_to_irq(int event)
 {
 	int i;
 	for (i = 0; i < num_events; i++) {
@@ -251,7 +281,7 @@ int event_to_irq(int event)
 	}
 	return -EINVAL;
 }
-EXPORT_SYMBOL(event_to_irq);
+EXPORT_SYMBOL(lpc31xx_event_to_irq);
 
 static const struct of_device_id evtr_of_match[] __initconst = {
 	{ .compatible = "nxp,lpc31xx-evtr", },
@@ -269,35 +299,35 @@ static int evtr_irq_map(struct irq_domain *h, unsigned int virq, irq_hw_number_t
 	set_irq_flags(virq, IRQF_VALID);
 	/* configure the interrupt sensitivity */
 	switch (events[hw].edge) {
-		case EVT_ACTIVE_LOW:
-			EVRT_APR(bank) &= ~_BIT(bit_pos);
-			EVRT_ATR(bank) &= ~_BIT(bit_pos);
-			irq_set_handler(virq, handle_level_irq);
-			break;
-		case EVT_ACTIVE_HIGH:
-			EVRT_APR(bank) |= _BIT(bit_pos);
-			EVRT_ATR(bank) &= ~_BIT(bit_pos);
-			irq_set_handler(virq, handle_level_irq);
-			break;
-		case EVT_FALLING_EDGE:
-			EVRT_APR(bank) &= ~_BIT(bit_pos);
-			EVRT_ATR(bank) |= _BIT(bit_pos);
-			irq_set_handler(virq, handle_edge_irq);
-			break;
-		case EVT_RISING_EDGE:
-			EVRT_APR(bank) |= _BIT(bit_pos);
-			EVRT_ATR(bank) |= _BIT(bit_pos);
-			irq_set_handler(virq, handle_edge_irq);
-			break;
-		case EVT_BOTH_EDGE:
-			EVRT_ATR(bank) |= _BIT(bit_pos);
-			irq_set_handler(virq, handle_edge_irq);
-			break;
-		default:
-			printk("Invalid Event type.\r\n");
-			break;
+	case EVT_RISING_EDGE:
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) | _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(virq, handle_edge_irq);
+		break;
+	case EVT_FALLING_EDGE:
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) & ~_BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(virq, handle_edge_irq);
+		break;
+	case EVT_BOTH_EDGE:
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(virq, handle_edge_irq);
+		break;
+	case EVT_ACTIVE_HIGH:
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) | _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) &~ _BIT(bit_pos));
+		irq_set_handler(virq, handle_level_irq);
+		break;
+	case EVT_ACTIVE_LOW:
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) &~ _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) &~ _BIT(bit_pos));
+		irq_set_handler(virq, handle_level_irq);
+		break;
+	default:
+		printk("Invalid Event type.\r\n");
+		break;
 	}
-	EVRT_OUT_MASK_SET(events[hw].group, bank) = _BIT(bit_pos);
+	evtr_write(EVTR_OUT_MASK_SET(events[hw].group, bank), _BIT(bit_pos));
 	printk("evtr hw=%ld virq=%d Event=0x%02x bank:%d bit:%02d type:%d vector %d\n", hw, virq,
 		events[hw].event, bank,
 		bit_pos, events[hw].edge, events[hw].group);
@@ -318,7 +348,9 @@ static int __devinit lpc31xx_evtr_probe(struct platform_device *pdev)
 	struct device_node *np = pdev->dev.of_node;
 	int cells, length;
 
-	printk("###### Event router probe ######\n");
+	evtr_regs = of_iomap(np, 0);
+	if (!evtr_regs)
+		return -EINVAL;
 
 	ip = of_get_property(np, "#event-cells", NULL);
 	if (!ip)
@@ -334,30 +366,31 @@ static int __devinit lpc31xx_evtr_probe(struct platform_device *pdev)
 		events[i].group = be32_to_cpup(ip++);
 		events[i].event = be32_to_cpup(ip++);
 		events[i].edge = be32_to_cpup(ip++);
-		printk("group %d bit %02x edge %d\n", events[i].group, events[i].event, events[i].edge);
+		if ((events[i].group < 0) || (events[i].group >= EVT_MAX_VALID_BANKS))
+			panic("Event router groups must be 0-3");
 	}
+	/* enable clock to Event router */
+	cgu_clk_en_dis(CGU_SB_EVENT_ROUTER_PCLK_ID, 1);
 
 	/* mask all external events */
-	for (i = 0; i < EVT_MAX_VALID_BANKS; i++)
-	{
+	for (i = 0; i < EVT_MAX_VALID_BANKS; i++) {
 		/* mask all events */
-		EVRT_MASK_CLR(i) = 0xFFFFFFFF;
+		evtr_write(EVTR_MASK_CLR(i), 0xFFFFFFFF);
 		/* clear all pending events */
-		EVRT_INT_CLR(i) = 0xFFFFFFFF;
+		evtr_write(EVTR_INT_CLR(i), 0xFFFFFFFF);
 
-		for (j = 0; j < EVT_MAX_VALID_INT_OUT; j++)
-		{
+		for (j = 0; j < EVT_MAX_VALID_INT_OUT; j++) {
 			/* mask all events */
-			EVRT_OUT_MASK_CLR(j,i) = 0xFFFFFFFF;
+			evtr_write(EVTR_OUT_MASK_CLR(j,i), 0xFFFFFFFF);
 		}
 	}
 	//evtr_domain = irq_domain_add_linear(np, num_events, &evtr_ops, NULL);
 	evtr_domain = irq_domain_add_legacy(np, num_events, 30, 0, &evtr_ops, NULL);
 
 	/* for power management. Wake from internal irqs */
-	EVRT_APR(3) &= ~_BIT(12);
-	EVRT_ATR(3) &= ~_BIT(12);
-	EVRT_MASK_SET(3) = _BIT(12);
+	evtr_write(EVTR_APR(3), evtr_read(EVTR_APR(3)) & ~_BIT(12));
+	evtr_write(EVTR_ATR(3), evtr_read(EVTR_ATR(3)) & ~_BIT(12));
+	evtr_write(EVTR_MASK_SET(3), _BIT(12));
 
 	/* install IRQ_EVT_ROUTER0  chain handler */
 	irq_set_chained_handler (IRQ_EVT_ROUTER0, router0_handler);
diff --git a/arch/arm/mach-lpc31xx/include/mach/registers.h b/arch/arm/mach-lpc31xx/include/mach/registers.h
index 456f5c6..beb6f77 100644
--- a/arch/arm/mach-lpc31xx/include/mach/registers.h
+++ b/arch/arm/mach-lpc31xx/include/mach/registers.h
@@ -24,47 +24,6 @@
 #ifndef __ASM_ARCH_REGISTERS_H
 #define __ASM_ARCH_REGISTERS_H
 
-
-/***********************************************************************
- * Interrupt controller register definitions
- **********************************************************************/
-#define INTC_IRQ_PRI_MASK     __REG(INTC_PHYS + 0x000)
-#define INTC_FIQ_PRI_MASK     __REG(INTC_PHYS + 0x004)
-#define INTC_IRQ_VEC_BASE     __REG(INTC_PHYS + 0x100)
-#define INTC_FIQ_VEC_BASE     __REG(INTC_PHYS + 0x104)
-#define INTC_REQ_REG(irq)     __REG(INTC_PHYS + 0x400 + ((irq) << 2))
-
-#define INTC_REQ_PEND         _BIT(31)
-#define INTC_REQ_SET_SWINT    _BIT(30)
-#define INTC_REQ_CLR_SWINT    _BIT(29)
-#define INTC_REQ_WE_PRIO_LVL  _BIT(28)
-#define INTC_REQ_WE_TARGET    _BIT(27)
-#define INTC_REQ_WE_ENABLE    _BIT(26)
-#define INTC_REQ_WE_ACT_LOW   _BIT(25)
-#define INTC_REQ_ACT_LOW      _BIT(17)
-#define INTC_REQ_ENABLE       _BIT(16)
-#define INTC_REQ_TARGET(n)    _SBF(8, ((n) & 0x3F))
-#define INTC_REQ_PRIO_LVL(n)  ((n) & 0xFF)
-#define INTC_REQ_TARGET_IRQ   (INTC_REQ_WE_TARGET)
-#define INTC_REQ_TARGET_FIQ   (INTC_REQ_WE_TARGET | _BIT(8))
-
-/***********************************************************************
- * Event router register definitions
- **********************************************************************/
-#define EVRT_INT_PEND(bank)  __REG (EVTR_PHYS + 0xC00 + ((bank) << 2))
-#define EVRT_INT_CLR(bank)   __REG (EVTR_PHYS + 0xC20 + ((bank) << 2))
-#define EVRT_INT_SET(bank)   __REG (EVTR_PHYS + 0xC40 + ((bank) << 2))
-#define EVRT_MASK(bank)      __REG (EVTR_PHYS + 0xC60 + ((bank) << 2))
-#define EVRT_MASK_CLR(bank)  __REG (EVTR_PHYS + 0xC80 + ((bank) << 2))
-#define EVRT_MASK_SET(bank)  __REG (EVTR_PHYS + 0xCA0 + ((bank) << 2))
-#define EVRT_APR(bank)       __REG (EVTR_PHYS + 0xCC0 + ((bank) << 2))
-#define EVRT_ATR(bank)       __REG (EVTR_PHYS + 0xCE0 + ((bank) << 2))
-#define EVRT_RSR(bank)       __REG (EVTR_PHYS + 0xD20 + ((bank) << 2))
-#define EVRT_OUT_PEND(vec,bank)     __REG (EVTR_PHYS + 0x1000 + ((vec) << 5) + ((bank) << 2))
-#define EVRT_OUT_MASK(vec,bank)     __REG (EVTR_PHYS + 0x1400 + ((vec) << 5) + ((bank) << 2))
-#define EVRT_OUT_MASK_CLR(vec,bank) __REG (EVTR_PHYS + 0x1800 + ((vec) << 5) + ((bank) << 2))
-#define EVRT_OUT_MASK_SET(vec,bank) __REG (EVTR_PHYS + 0x1C00 + ((vec) << 5) + ((bank) << 2))
-
 /***********************************************************************
  * WDT register definitions
  **********************************************************************/
diff --git a/arch/arm/mach-lpc31xx/irq.c b/arch/arm/mach-lpc31xx/irq.c
index 2ac9b6c..9c2e364 100644
--- a/arch/arm/mach-lpc31xx/irq.c
+++ b/arch/arm/mach-lpc31xx/irq.c
@@ -27,6 +27,7 @@
 #include <linux/of_irq.h>
 #include <linux/irqdomain.h>
 #include <linux/of_address.h>
+#include <linux/io.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
@@ -34,24 +35,55 @@
 #include <mach/irqs.h>
 #include <mach/clock.h>
 
+/***********************************************************************
+ * Interrupt controller register definitions
+ **********************************************************************/
+#define INTC_IRQ_PRI_MASK     0x000
+#define INTC_FIQ_PRI_MASK     0x004
+#define INTC_IRQ_VEC_BASE     0x100
+#define INTC_FIQ_VEC_BASE     0x104
+#define INTC_REQ_REG(irq)     (0x400 + ((irq) << 2))
+
+#define INTC_REQ_PEND         _BIT(31)
+#define INTC_REQ_SET_SWINT    _BIT(30)
+#define INTC_REQ_CLR_SWINT    _BIT(29)
+#define INTC_REQ_WE_PRIO_LVL  _BIT(28)
+#define INTC_REQ_WE_TARGET    _BIT(27)
+#define INTC_REQ_WE_ENABLE    _BIT(26)
+#define INTC_REQ_WE_ACT_LOW   _BIT(25)
+#define INTC_REQ_ACT_LOW      _BIT(17)
+#define INTC_REQ_ENABLE       _BIT(16)
+#define INTC_REQ_TARGET(n)    _SBF(8, ((n) & 0x3F))
+#define INTC_REQ_PRIO_LVL(n)  ((n) & 0xFF)
+#define INTC_REQ_TARGET_IRQ   (INTC_REQ_WE_TARGET)
+#define INTC_REQ_TARGET_FIQ   (INTC_REQ_WE_TARGET | _BIT(8))
+
 #define NR_IRQ_CPU	30	/* IRQs directly recognized by CPU */
 
+static void __iomem *intc_regs;
+#define intc_read(reg) \
+	__raw_readl(intc_regs + reg)
+#define intc_write(reg, value) \
+	__raw_writel(value, intc_regs + reg);
+
+
 /* Macros to compute the bank based on EVENT_T */
-#define EVT_GET_BANK(evt)	(((evt) >> 5) & 0x3)
 #define EVT_arm926_nirq		0x6C
 
 static struct irq_domain *intc_domain;
 
 static void intc_mask_irq(struct irq_data *data)
 {
-	INTC_REQ_REG(data->hwirq) = INTC_REQ_WE_ENABLE;
+	intc_write(INTC_REQ_REG(data->hwirq), INTC_REQ_WE_ENABLE);
 }
 
 static void intc_unmask_irq(struct irq_data *data)
 {
-	INTC_REQ_REG(data->hwirq) = INTC_REQ_ENABLE | INTC_REQ_WE_ENABLE;
+	intc_write(INTC_REQ_REG(data->hwirq), INTC_REQ_ENABLE | INTC_REQ_WE_ENABLE);
 }
 
+extern int lpc31xx_set_cgu_wakeup(int enable, int event);
+
 static int intc_set_wake(struct irq_data *data, unsigned int on)
 {
 	static uint32_t wake_ints = 0;
@@ -66,13 +98,7 @@ static int intc_set_wake(struct irq_data *data, unsigned int on)
 	/* Note: the clocks to corresponding blocks shouldn't be suspended
 	 * by individual drivers for this logic to work.
 	 */
-	if (wake_ints) {
-		/* enable ARM_IRQ routing to CGU_WAKEUP */
-		EVRT_OUT_MASK_SET(4, EVT_GET_BANK(EVT_arm926_nirq)) = _BIT((EVT_arm926_nirq & 0x1F));
-	} else {
-		/* disable ARM_IRQ routing to CGU_WAKEUP */
-		EVRT_OUT_MASK_CLR(4, EVT_GET_BANK(EVT_arm926_nirq)) = _BIT((EVT_arm926_nirq & 0x1F));
-	}
+	lpc31xx_set_cgu_wakeup(EVT_arm926_nirq, wake_ints);
 
 	//printk("wake on irq=%d value=%d 0x%08x/0x%08x/0x%08x 0x%08x/0x%08x\r\n", irq, value, 
 	//	EVRT_MASK(3), EVRT_APR(3), EVRT_ATR(3),
@@ -97,16 +123,16 @@ static const struct of_device_id intc_of_match[] __initconst = {
 static int intc_irq_map(struct irq_domain *h, unsigned int virq, irq_hw_number_t hw)
 {
 	/* Set the initial control values */
-	INTC_REQ_REG(hw) = INTC_REQ_WE_ENABLE;
+	intc_write(INTC_REQ_REG(hw), INTC_REQ_WE_ENABLE);
 
 	/* Initialize as high-active, Disable the interrupt,
 	* Set target to IRQ , Set priority level to 1 (= lowest) for
 	* all the interrupt lines */
-	INTC_REQ_REG(hw) = INTC_REQ_WE_ACT_LOW |
+	intc_write(INTC_REQ_REG(hw), INTC_REQ_WE_ACT_LOW |
 		INTC_REQ_WE_ENABLE |
 		INTC_REQ_TARGET_IRQ |
 		INTC_REQ_PRIO_LVL(1) |
-		INTC_REQ_WE_PRIO_LVL;
+		INTC_REQ_WE_PRIO_LVL);
 
 	irq_set_chip_and_handler(virq, &lpc31xx_internal_chip, handle_level_irq);
 	set_irq_flags(virq, IRQF_VALID);
@@ -124,6 +150,12 @@ void __init lpc31xx_init_irq(void)
 {
 	struct device_node *node;
 
+	/* Remap the necessary zones */
+	node = of_find_matching_node(NULL, intc_of_match);
+	intc_regs = of_iomap(node, 0);
+	if (!intc_regs)
+		panic(__FILE__	": find_and_map failed on 'lpc31xx-intc'");
+
 	/* enable clock to interrupt controller */
 	cgu_clk_en_dis(CGU_SB_AHB2INTC_CLK_ID, 1);
 	cgu_clk_en_dis(CGU_SB_INTC_CLK_ID, 1);
@@ -131,12 +163,12 @@ void __init lpc31xx_init_irq(void)
 	cgu_clk_en_dis(CGU_SB_EVENT_ROUTER_PCLK_ID, 1);
 
 	/* Set the vector base (we don't use direct vectoring, so this is 0) */
-	INTC_IRQ_VEC_BASE = 0x00000000;
-	INTC_FIQ_VEC_BASE = 0x00000000;
+	intc_write(INTC_IRQ_VEC_BASE, 0x00000000);
+	intc_write(INTC_FIQ_VEC_BASE, 0x00000000);
 
 	/* mask all interrupt by setting high priority until init is done*/
-	INTC_IRQ_PRI_MASK = 0xFF;
-	INTC_FIQ_PRI_MASK = 0xFF;
+	intc_write(INTC_IRQ_PRI_MASK, 0xFF);
+	intc_write(INTC_FIQ_PRI_MASK, 0xFF);
 
 	node = of_find_matching_node_by_address(NULL, intc_of_match, INTC_PHYS);
 	intc_domain = irq_domain_add_legacy(node, NR_IRQ_CPU, 0, 0, &intc_ops, NULL);
@@ -145,8 +177,8 @@ void __init lpc31xx_init_irq(void)
 
 	/* Set the priority threshold to 0, i.e. don't mask any interrupt */
 	/* on the basis of priority level, for both targets (IRQ/FIQ)    */
-	INTC_IRQ_PRI_MASK = 0;
-	INTC_FIQ_PRI_MASK = 0;
+	intc_write(INTC_IRQ_PRI_MASK, 0);
+	intc_write(INTC_FIQ_PRI_MASK, 0);
 }
