Bottom: cc2918a8c9adcf1ca3faad00084ab4402c226a93
Top:    b3dc79cf8aff7dcd9f9b7e19de2a077d9c211304
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-03-29 20:53:19 -0400

Refresh of i2c-resource

---

diff --git a/arch/arm/boot/dts/ea3131.dts b/arch/arm/boot/dts/ea3131.dts
index 3f528552..2ad2999 100644
--- a/arch/arm/boot/dts/ea3131.dts
+++ b/arch/arm/boot/dts/ea3131.dts
@@ -33,8 +33,8 @@
 	};
 	apb@15000000 {
 		spi@15002000 {
-			at45db321d@0 {
-				compatible = "st,m25";
+			s25sl032a@0 {
+				compatible = "code,s25sl032a";
 				spi-max-frequency = <1000000>;
 				reg = <0>;
 			};
@@ -47,7 +47,8 @@
 				x_plate_ohms = <419>;
 				y_plate_ohms = <486>;
 				pen_irq = <37>;
-				gpio_pendown = <&gpio 0x1c4 0>;
+				gpio_pendown = <&gpio_gpio 4 0>;
+				gpio_cs = <&gpio_ebi_i2stx_0 3 0>; 
 			};
 		};
 	};
@@ -68,39 +69,35 @@
 		};
 	};
 	sdmmc@18000000 {
-		cd-gpio = <&gpio 0x87 0>;
-		power-gpio = <&gpio 0x45 0>;
+		slot@0 {
+			width = <4>;
+			detect-delays = <250>;
+			gpio-cd = <&gpio_cgu 7 0>;
+			gpio-power = <&gpio_ebi_i2stx_0 5 0>;
+			/* gpio-power = <&gpio_ebi_i2stx_0 5 0>; broken in hardware */
+			/* gpio-wp = <>; not implemented in hardware */
+			/* gpio-select = <>; not implemented in hardware */
+			voltage-ranges = <3200 3400>;
+		};
 	};
 	usb@19000000 {
-		vbus-over =  <&pca9532 0xFF 0>;
+		vbus-over =  <&gpio_i2srx_0 2 0>;
+		vbus-interrupts = <36>;
 	};
 	sram@20000000 {
-		STCONFIG = <0x81>;
-		STWTWEN  = <0>;
-		STWTOEN  = <0>;
-		STWTRD   = <31>;
-		STWTPG   = <0>;
-		STWTWR   = <3>;
-		STWTTURN = <0>;
+		mpmc-config = <0x81 0 0 31 0 3 0>;
 		ssd1289@20000000 {
 			compatible = "ssd,ssd1289";
 			reg = <0x20000000 0x10000 0x20010000 0x10000>;
 		};
 	};
 	sram@20020000 {
-		STCONFIG = <0x81>;
-		STWTWEN = <1>;
-		STWTOEN = <1>;
-		STWTRD = <4>;
-		STWTPG = <1>;
-		STWTWR = <1>;
-		STWTTURN = <2>;
 		/* enable oe toggle between consec reads */
-		WTD_DEL = <0x24>;
+		mpmc-config = <0x81 1 1 4 1 1 2 0x24>;
 		dm9000@20020000 {
 			compatible = "davicom,dm9000";
 			reg = <0x20020000 0x100 0x20030000 0x100>;
-			interrupts = <37>;
+			interrupts = <34>;
 		};			
 	};
 	memory@30000000 {
diff --git a/arch/arm/boot/dts/lpc3131.dtsi b/arch/arm/boot/dts/lpc3131.dtsi
index dd1860d..15d6e11 100644
--- a/arch/arm/boot/dts/lpc3131.dtsi
+++ b/arch/arm/boot/dts/lpc3131.dtsi
@@ -55,10 +55,82 @@
 			compatible = "nxp,lpc31xx-sys";
 			reg = <0x13002800 0x400>;
 		};
-		gpio: gpio@13003000 {
+		gpio_ebi_mci: gpio@13003000 {
 			#gpio-cells = <2>;
 			compatible = "nxp,lpc31xx-gpio";
-			reg = <0x13003000 0x1000>;
+			reg = <0x13003000 0x40>;
+			gpio-controller;
+		};
+		gpio_ebi_i2stx_0: gpio@13003040 {
+			#gpio-cells = <2>;
+			compatible = "nxp,lpc31xx-gpio";
+			reg = <0x13003040 0x40>;
+			gpio-controller;
+		};
+		gpio_cgu: gpio@13003080 {
+			#gpio-cells = <2>;
+			compatible = "nxp,lpc31xx-gpio";
+			reg = <0x13003080 0x40>;
+			gpio-controller;
+		};
+		gpio_i2srx_0: gpio@130030c0 {
+			#gpio-cells = <2>;
+			compatible = "nxp,lpc31xx-gpio";
+			reg = <0x130030c0 0x40>;
+			gpio-controller;
+		};
+		gpio_i2srx_1: gpio@13003100 {
+			#gpio-cells = <2>;
+			compatible = "nxp,lpc31xx-gpio";
+			reg = <0x13003100 0x40>;
+			gpio-controller;
+		};
+		gpio_i2stx_1: gpio@13003140 {
+			#gpio-cells = <2>;
+			compatible = "nxp,lpc31xx-gpio";
+			reg = <0x13003140 0x40>;
+			gpio-controller;
+		};
+		gpio_ebi: gpio@13003180 {
+			#gpio-cells = <2>;
+			compatible = "nxp,lpc31xx-gpio";
+			reg = <0x13003180 0x40>;
+			gpio-controller;
+		};
+		gpio_gpio: gpio@130031c0 {
+			#gpio-cells = <2>;
+			compatible = "nxp,lpc31xx-gpio";
+			reg = <0x130031c0 0x40>;
+			gpio-controller;
+		};
+		gpio_i2c1: gpio@13003200 {
+			#gpio-cells = <2>;
+			compatible = "nxp,lpc31xx-gpio";
+			reg = <0x13003200 0x40>;
+			gpio-controller;
+		};
+		gpio_spi: gpio@13003240 {
+			#gpio-cells = <2>;
+			compatible = "nxp,lpc31xx-gpio";
+			reg = <0x13003240 0x40>;
+			gpio-controller;
+		};
+		gpio_nand_ctrl: gpio@13003280 {
+			#gpio-cells = <2>;
+			compatible = "nxp,lpc31xx-gpio";
+			reg = <0x13003280 0x40>;
+			gpio-controller;
+		};
+		gpio_pwm: gpio@130032c0 {
+			#gpio-cells = <2>;
+			compatible = "nxp,lpc31xx-gpio";
+			reg = <0x130032c0 0x40>;
+			gpio-controller;
+		};
+		gpio_uart: gpio@13003300 {
+			#gpio-cells = <2>;
+			compatible = "nxp,lpc31xx-gpio";
+			reg = <0x13003300 0x40>;
 			gpio-controller;
 		};
 		cgu@13004000 {
@@ -187,8 +259,14 @@
 	};
 	sdmmc@18000000 {
 		compatible = "nxp,lpc31xx-sdmmc";
+		#address-cells = <1>;
+		#size-cells = <0>;
 		reg = <0x18000000 0x1000>;
 		interrupts = <26>;
+		slot@0 {
+			reg = <0>;
+			voltage-ranges = <3300 3300>;
+		};
 	};
 	usb@19000000 {
 		compatible = "nxp,lpc31xx-usb", "usb-ehci";
diff --git a/arch/arm/mach-lpc31xx/Makefile b/arch/arm/mach-lpc31xx/Makefile
index 4633f9b..2e02523 100644
--- a/arch/arm/mach-lpc31xx/Makefile
+++ b/arch/arm/mach-lpc31xx/Makefile
@@ -5,7 +5,6 @@
 # Object file lists.
 
 obj-y			+= irq.o time.o generic.o i2c.o dma.o usb.o wdt.o clock.o
-obj-$(CONFIG_GPIOLIB) += gpiolib.o
 obj-$(CONFIG_OF) += dt.o
 
 
diff --git a/arch/arm/mach-lpc31xx/board-ea313x.c b/arch/arm/mach-lpc31xx/board-ea313x.c
index 83226a9..07396a3 100644
--- a/arch/arm/mach-lpc31xx/board-ea313x.c
+++ b/arch/arm/mach-lpc31xx/board-ea313x.c
@@ -255,13 +255,6 @@ static struct pca9532_platform_data ea313x_leds = {
 	.pwm = { 0, 0 },
 };
 
-static struct i2c_board_info ea313x_i2c_devices[] __initdata = {
-	{
-		I2C_BOARD_INFO("pca9532", 0x60),
-		.platform_data = &ea313x_leds,
-	},
-};
-
 #if defined(CONFIG_MACH_EA3152)
 static struct i2c_board_info ea3152_i2c1_devices[] __initdata = {
 	{
diff --git a/arch/arm/mach-lpc31xx/gpio.c b/arch/arm/mach-lpc31xx/gpio.c
deleted file mode 100644
index 446faca..0000000
--- a/arch/arm/mach-lpc31xx/gpio.c
+++ /dev/null
@@ -1,114 +0,0 @@
-/*  linux/arch/arm/mach-lpc313x/gpio.c
- *
- *  Author:	Durgesh Pattamatta
- *  Copyright (C) 2009 NXP semiconductors
- *
- * GPIO driver for LPC313x & LPC315x.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/string.h>
-
-#include <asm/errno.h>
-#include <mach/hardware.h>
-#include <mach/gpio.h>
-
-
-void lpx313x_gpio_func_mode(int gpio)
-{
-	unsigned long flags;
-	int port = (gpio & GPIO_PORT_MASK);
-	int pin = 1 << (gpio & GPIO_PIN_MASK);
-
-	raw_local_irq_save(flags);
-
-	GPIO_M1_RESET(port) = pin; 
-	GPIO_M0_SET(port) = pin;
-
-	raw_local_irq_restore(flags);
-
-}
-
-EXPORT_SYMBOL(lpx313x_gpio_func_mode);
-
-
-
-
-
-
-#ifndef CONFIG_GPIOLIB
-int gpio_is_valid(unsigned gpio)
-{
-	int ret = 1;
-	int port = (gpio & GPIO_PORT_MASK);
-	int pin_no = (gpio & GPIO_PIN_MASK);
-
-
-	if ( (gpio & ~(GPIO_PORT_MASK | GPIO_PIN_MASK)) &&
-	     ((port >> 5) > 12)) {
-		return 0;
-	} 
-	switch (port) {
-		case IOCONF_EBI_I2STX_0:
-			if (pin_no > 9)
-				ret = 0;
-			break;
-		case IOCONF_PWM:
-		case IOCONF_CGU:
-			if (pin_no > 0)
-				ret = 0;
-			break;
-		case IOCONF_I2SRX_0:
-		case IOCONF_I2SRX_1:
-			if (pin_no > 2)
-				ret = 0;
-			break;
-		case IOCONF_I2STX_1:
-			if (pin_no > 3)
-				ret = 0;
-			break;
-		case IOCONF_EBI:
-			if (pin_no > 15)
-				ret = 0;
-			break;
-		case IOCONF_GPIO:
-			if (pin_no > 14)
-				ret = 0;
-			break;
-		case IOCONF_UART:
-		case IOCONF_I2C1:
-			if (pin_no > 1)
-				ret = 0;
-			break;
-		case IOCONF_SPI:
-			if (pin_no > 4)
-				ret = 0;
-			break;
-		case IOCONF_NAND_CTRL:
-			if (pin_no > 3)
-				ret = 0;
-			break;
-	}
-	return ret;
-}
-
-EXPORT_SYMBOL(gpio_is_valid);
-#endif
-
diff --git a/arch/arm/mach-lpc31xx/include/mach/board.h b/arch/arm/mach-lpc31xx/include/mach/board.h
index 2bcd065..c8d01ea 100644
--- a/arch/arm/mach-lpc31xx/include/mach/board.h
+++ b/arch/arm/mach-lpc31xx/include/mach/board.h
@@ -120,32 +120,5 @@ struct lpc313x_spi_cfg {
 #define MAX_MCI_SLOTS		1
 #endif
 
-/*
- * the board-type specific routines
- */
-struct lpc313x_mci_board {
-	u32 num_slots;
-	u32 detect_delay_ms; /* delay in mS before detecting cards after interrupt */
-	int (*init)(u32 slot_id, irq_handler_t , void *);
-	int (*get_ro)(u32 slot_id);
-	int (*get_cd)(u32 slot_id);
-	int (*get_ocr)(u32 slot_id);
-	int (*get_bus_wd)(u32 slot_id);
-	/*
-	 * Enable power to selected slot and set voltage to desired level.
-	 * Voltage levels are specified using MMC_VDD_xxx defines defined
-	 * in linux/mmc/host.h file.
-	 */
-	void (*setpower)(u32 slot_id, u32 volt);
-	void (*exit)(u32 slot_id);
-	void (*select_slot)(u32 slot_id);
-};
-
-struct lpc313x_mci_irq_data {
-	u32 irq;
-	irq_handler_t irq_hdlr;
-	void* data;
-};
-
 #endif /*__MACH_BOARD_H*/
 
diff --git a/arch/arm/mach-lpc31xx/usb.c b/arch/arm/mach-lpc31xx/usb.c
index 538f11b..9c1c8b0 100644
--- a/arch/arm/mach-lpc31xx/usb.c
+++ b/arch/arm/mach-lpc31xx/usb.c
@@ -38,6 +38,7 @@
 #include <linux/io.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
+#include <linux/of_gpio.h>
 
 #include <asm/irq.h>
 #include <asm/system.h>
@@ -119,15 +120,6 @@ struct lpc313x_usb_board_t {
 
 static struct lpc313x_usb_board_t lpc313x_usb_brd;
 
-static u64 usb_dmamask = 0xffffffffUL;;
-/*-------------------------------------------------------------------------*/
-
-static void	lpc313x_usb_release(struct device *dev)
-{
-	// do nothing
-}
-
-
 #if defined(CONFIG_USB_GADGET_FSL_USB2) || defined(CONFIG_USB_OTG)
 
 static struct platform_device lpc313x_udc_device = {
@@ -189,6 +181,7 @@ static void lpc313x_vbusen_timer(unsigned long data)
 /*-------------------------------------------------------------------------*/
 int __init usbotg_init(void)
 {
+	int over;
 	u32 bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
 	u32 bit_pos = EVT_usb_atx_pll_lock & 0x1F;
 	int retval = 0;
@@ -245,10 +238,13 @@ int __init usbotg_init(void)
 
 #if defined(CONFIG_MACH_EA313X) || defined(CONFIG_MACH_EA3152)
 		/* set thw I2SRX_WS0 pin as GPIO_IN for vbus overcurrent flag */
-		retval = gpio_request(GPIO_I2SRX_WS0, "vbus overcurrent");
+#if 0
+		over = of_get_named_gpio(np, "vbus-over", 0);
+		retval = gpio_request(over, "vbus overcurrent");
 		if ( 0 != retval )
-			printk(KERN_INFO "Can't acquire GPIO_I2SRX_WS0\n");
-		gpio_direction_input(GPIO_I2SRX_WS0);
+			printk(KERN_INFO "Can't acquire vbus-over GPIO\n");
+		gpio_direction_input(over);
+#endif
 		lpc313x_usb_brd.vbus_ovrc_irq = IRQ_EA_VBUS_OVRC;
 
 #else
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index fa10df6..a33f4bf 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -20,6 +20,7 @@ obj-$(CONFIG_GPIO_IT8761E)	+= gpio-it8761e.o
 obj-$(CONFIG_GPIO_JANZ_TTL)	+= gpio-janz-ttl.o
 obj-$(CONFIG_ARCH_KS8695)	+= gpio-ks8695.o
 obj-$(CONFIG_GPIO_LANGWELL)	+= gpio-langwell.o
+obj-$(CONFIG_ARCH_LPC31XX)	+= gpio-lpc31xx.o
 obj-$(CONFIG_ARCH_LPC32XX)	+= gpio-lpc32xx.o
 obj-$(CONFIG_GPIO_MAX730X)	+= gpio-max730x.o
 obj-$(CONFIG_GPIO_MAX7300)	+= gpio-max7300.o
diff --git a/arch/arm/mach-lpc31xx/gpiolib.c b/drivers/gpio/gpio-lpc31xx.c
similarity index 77%
rename from arch/arm/mach-lpc31xx/gpiolib.c
rename to drivers/gpio/gpio-lpc31xx.c
index 9fe8c86..6e523fa 100644
--- a/arch/arm/mach-lpc31xx/gpiolib.c
+++ b/drivers/gpio/gpio-lpc31xx.c
@@ -15,6 +15,9 @@
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
 #include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
@@ -208,37 +211,58 @@ static inline void lpc3131_gpio_set_value(struct gpio_chip *chip, unsigned offse
 	lpc313x_gpio_set_value(chip->base + offset, value);
 }
 
-__init void lpc313x_gpiolib_add(struct lpc313x_gpio_chip *chip)
+static int lpc313x_gpiochip_remove(struct platform_device *ofdev)
 {
-	struct gpio_chip *gc = &chip->chip;
+	return -EBUSY;
+}
+
+static int __devinit lpc313x_simple_gpiochip_probe(struct platform_device *ofdev)
+{
+	struct of_mm_gpio_chip *chip;
+	struct gpio_chip *gc;
 	int ret;
 
-	BUG_ON(!chip->base);
-	BUG_ON(!gc->label);
-	BUG_ON(!gc->ngpio);
-
-	if (!gc->direction_input)
-		gc->direction_input = lpc3131_gpio_direction_input;
-	if (!gc->direction_output)
-		gc->direction_output = lpc3131_gpio_direction_output;
-	if (!gc->set)
-		gc->set = lpc3131_gpio_set_value;
-	if (!gc->get)
-		gc->get = lpc3131_gpio_get_value;
-
-	/* gpiochip_add() prints own failure message on error. */
-	ret = gpiochip_add(gc);
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	gc = &chip->gc;
+
+	gc->ngpio            = 32;
+	gc->direction_input  = lpc3131_gpio_direction_input;
+	gc->direction_output = lpc3131_gpio_direction_output;
+	gc->get              = lpc3131_gpio_get_value;
+	gc->set              = lpc3131_gpio_set_value;
+
+	ret = of_mm_gpiochip_add(ofdev->dev.of_node, chip);
+	if (ret)
+		return ret;
+
+	return 0;
 }
 
+static const struct of_device_id lpc313x_simple_gpiochip_match[] = {
+	{ .compatible = "nxp,lpc31xx-gpio", },
+	{}
+};
+
+static struct platform_driver lpc313x_simple_gpiochip_driver = {
+	.driver = {
+		.name = "lpc31xx-gpio",
+		.owner = THIS_MODULE,
+		.of_match_table = lpc313x_simple_gpiochip_match,
+	},
+	.probe = lpc313x_simple_gpiochip_probe,
+	.remove = lpc313x_gpiochip_remove,
+};
+
 static __init int lpc313x_gpiolib_init(void)
 {
-	struct lpc313x_gpio_chip *chip = lpc313x_gpios;
-	int gpn;
-
-	for (gpn = 0; gpn < ARRAY_SIZE(lpc313x_gpios); gpn++, chip++)
-		lpc313x_gpiolib_add(chip);
+	if (platform_driver_register(&lpc313x_simple_gpiochip_driver))
+		printk(KERN_ERR "Unable to register simple GPIO driver\n");
 
 	return 0;
 }
 
+/* Make sure we get initialised before anyone else tries to use us */
 core_initcall(lpc313x_gpiolib_init);
diff --git a/drivers/mmc/host/lpc31xx_mmc.c b/drivers/mmc/host/lpc31xx_mmc.c
index c86b1904..a9a7dfa 100644
--- a/drivers/mmc/host/lpc31xx_mmc.c
+++ b/drivers/mmc/host/lpc31xx_mmc.c
@@ -39,6 +39,7 @@
 #include <linux/slab.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <linux/of_gpio.h>
 #include <linux/gpio.h>
 
 #include "lpc31xx_mmc.h"
@@ -75,6 +76,7 @@ enum lpc313x_mci_state {
 	STATE_SENDING_STOP,
 	STATE_DATA_ERROR,
 };
+
 /*forward declaration */
 struct lpc313x_mci_slot;
 
@@ -108,7 +110,7 @@ struct lpc313x_mci {
 	u32			bus_hz;
 	u32			current_speed;
 	struct platform_device	*pdev;
-	struct lpc313x_mci_board *pdata;
+	int slot_count;
 	struct lpc313x_mci_slot	*slot[MAX_MCI_SLOTS];
 };
 
@@ -129,6 +131,11 @@ struct lpc313x_mci_slot {
 	int			id;
 	int			irq;
 
+	int			gpio_cd;
+	int			gpio_wp;
+	int			gpio_power;
+	int			gpio_select;
+
 	struct timer_list	detect_timer;
 };
 
@@ -421,7 +428,7 @@ static int lpc313x_mci_submit_data_dma(struct lpc313x_mci *host, struct mmc_data
 		return -EINVAL;
 
 	for_each_sg(data->sg, sg, data->sg_len, i) {
-		if (sg->offset & 3 || sg->length & 3)
+		if ((sg->offset & 3) || (sg->length & 3))
 			return -EINVAL;
 	}
 
@@ -581,6 +588,27 @@ void lpc313x_mci_setup_bus(struct lpc313x_mci_slot *slot)
 	mci_writel(CTYPE, slot->ctype);
 }
 
+static void lpc313x_mci_select_slot(struct lpc313x_mci_slot *slot, int enable)
+{
+	if (slot->gpio_select >= 0) {
+		printk("lpc313x_mci_select_slot %d\n", slot->gpio_select);
+		gpio_set_value(slot->gpio_select, enable);
+	}
+}
+
+static void lpc313x_mci_set_power(struct lpc313x_mci_slot *slot, int enable)
+{
+	/* on current version of EA board the card detect
+	 * pull-up in on switched power side. So can't do
+	 * power management so use the always enable power
+	 * jumper.
+	 */
+	if (slot->gpio_power >= 0) {
+		printk("lpc313x_mci_set_power %d\n", slot->gpio_power);
+		gpio_set_value(slot->gpio_power, enable);
+	}
+}
+
 static void lpc313x_mci_start_request(struct lpc313x_mci *host,
 		struct lpc313x_mci_slot *slot)
 {
@@ -591,8 +619,11 @@ static void lpc313x_mci_start_request(struct lpc313x_mci *host,
 
 	mrq = slot->mrq;
 	/* now select the proper slot */
-	if (host->pdata->select_slot)
-		host->pdata->select_slot(slot->id);
+	if (host->cur_slot != slot) {
+		if (host->cur_slot)
+			lpc313x_mci_select_slot(host->cur_slot, 0);
+		lpc313x_mci_select_slot(slot, 1);
+	}
 
 	/* Slot specific timing and width adjustment */
 	lpc313x_mci_setup_bus(slot);
@@ -704,31 +735,28 @@ static void lpc313x_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 
 
-static int lpc313x_mci_get_ro(struct mmc_host *mmc)
+static int lpc313x_mci_get_wp(struct mmc_host *mmc)
 {
 	int			read_only = -ENOSYS;
 	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
-	struct lpc313x_mci_board *brd = slot->host->pdata;
 
-	if (brd->get_ro != NULL) {
-		read_only = brd->get_ro(slot->id);
+	if (slot->gpio_wp >= 0) {
+		read_only =  gpio_get_value(slot->gpio_wp);
 		dev_dbg(&mmc->class_dev, "card is %s\n",
 				read_only ? "read-only" : "read-write");
 	}
-
 	return read_only;
 }
 
 
-static int lpc313x_mci_get_cd(struct mmc_host *mmc)
+static int lpc313x_mci_get_cd(struct lpc313x_mci_slot *slot)
 {
 	int			present = -ENOSYS;
-	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
-	struct lpc313x_mci_board *brd = slot->host->pdata;
-
-	present = !brd->get_cd(slot->id);
-	dev_vdbg(&mmc->class_dev, "card is %spresent\n", present ? "" : "not ");
 
+	if (slot->gpio_cd >= 0) {
+		present = !gpio_get_value(slot->gpio_cd);
+		dev_vdbg(&slot->mmc->class_dev, "card is %spresent\n", present ? "" : "not ");
+	}
 	return present;
 }
 
@@ -749,8 +777,7 @@ static void lpc313x_mci_enable_sdio_irq(struct mmc_host *host, int enable)
 static const struct mmc_host_ops lpc313x_mci_ops = {
 	.request	= lpc313x_mci_request,
 	.set_ios	= lpc313x_mci_set_ios,
-	.get_ro		= lpc313x_mci_get_ro,
-	.get_cd		= lpc313x_mci_get_cd,
+	.get_ro		= lpc313x_mci_get_wp,
 	.enable_sdio_irq= lpc313x_mci_enable_sdio_irq,
 };
 
@@ -1229,7 +1256,7 @@ static void lpc313x_mci_detect_change(unsigned long slot_data)
 		return;
 
 	enable_irq(slot->irq);
-	present = !host->pdata->get_cd(slot->id);
+	present = !gpio_get_value(slot->gpio_cd);
 	present_old = test_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
 	dev_vdbg(&slot->mmc->class_dev, "detect change: %d (was %d)\n",
 			present, present_old);
@@ -1242,17 +1269,8 @@ static void lpc313x_mci_detect_change(unsigned long slot_data)
 		spin_lock(&host->lock);
 
 		/* Power up slot */
-		if (present != 0) {
-			if (host->pdata->setpower)
-				host->pdata->setpower(slot->id, slot->mmc->ocr_avail);
-
-			set_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
-		} else {
-			if (host->pdata->setpower)
-				host->pdata->setpower(slot->id, 0);
-
-			clear_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
-		}
+		lpc313x_mci_set_power(slot, present);
+		set_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
 
 
 		/* Clean up queue if present */
@@ -1316,6 +1334,10 @@ static irqreturn_t lpc313x_mci_detect_interrupt(int irq, void *dev_id)
 {
 	struct lpc313x_mci_slot	*slot = dev_id;
 
+	/* select the opposite level senstivity */
+	int level =  lpc313x_mci_get_cd(slot) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
+	irq_set_irq_type(slot->irq, level);
+
 	/*
 	 * Disable interrupts until the pin has stabilized and check
 	 * the state then. Use mod_timer() since we may be in the
@@ -1328,10 +1350,13 @@ static irqreturn_t lpc313x_mci_detect_interrupt(int irq, void *dev_id)
 }
 
 static int __init
-lpc313x_mci_init_slot(struct lpc313x_mci *host, unsigned int id)
+lpc313x_mci_init_slot(struct lpc313x_mci *host, struct device_node *np)
 {
 	struct mmc_host			*mmc;
 	struct lpc313x_mci_slot		*slot;
+	const u32 *voltage_ranges;
+	const int *width;
+	int i, ret, num_ranges, level;
 
 	mmc = mmc_alloc_host(sizeof(struct lpc313x_mci_slot), &host->pdev->dev);
 
@@ -1339,44 +1364,89 @@ lpc313x_mci_init_slot(struct lpc313x_mci *host, unsigned int id)
 		return -ENOMEM;
 
 	slot = mmc_priv(mmc);
-	slot->id = id;
+	slot->id = host->slot_count++;
+
 	slot->mmc = mmc;
 	slot->host = host;
+	slot->gpio_cd = of_get_named_gpio(np, "gpio-cd", 0);
+	if (slot->gpio_cd >= 0) {
+		gpio_request(slot->gpio_cd, "mmc cd");
+		gpio_direction_input(slot->gpio_cd);
+	}
+	slot->gpio_wp = of_get_named_gpio(np, "gpio-wp", 0);
+	if (slot->gpio_wp >= 0)
+		gpio_request(slot->gpio_cd, "mmc wp");
+	slot->gpio_power = of_get_named_gpio(np, "gpio-power", 0);
+	if (slot->gpio_power >= 0)
+		gpio_request(slot->gpio_cd, "mmc power");
+	slot->gpio_select = of_get_named_gpio(np, "gpio-select", 0);
+	if (slot->gpio_select >= 0)
+		gpio_request(slot->gpio_select, "mmc select");
 
 	mmc->ops = &lpc313x_mci_ops;
 	mmc->f_min = DIV_ROUND_UP(host->bus_hz, 510);
 	mmc->f_max = host->bus_hz/2; //max f is clock to mmc_clk/2
-	if (host->pdata->get_ocr)
-		mmc->ocr_avail = host->pdata->get_ocr(id);
-	else
-		mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
+
+	voltage_ranges = of_get_property(np, "voltage-ranges", &num_ranges);
+	num_ranges = num_ranges / sizeof(*voltage_ranges) / 2;
+	if (!voltage_ranges || !num_ranges) {
+		dev_err(&host->pdev->dev, "OF: voltage-ranges unspecified\n");
+		ret = -EINVAL;
+		goto err_ocr;
+	}
+
+	for (i = 0; i < num_ranges; i++) {
+		const int j = i * 2;
+		u32 mask;
+
+		mask = mmc_vddrange_to_ocrmask(be32_to_cpu(voltage_ranges[j]),
+					       be32_to_cpu(voltage_ranges[j + 1]));
+		if (!mask) {
+			ret = -EINVAL;
+			dev_err(&host->pdev->dev, "OF: voltage-range #%d is invalid\n", i);
+			goto err_ocr;
+		}
+		mmc->ocr_avail |= mask;
+	}
 
 	/* Start with slot power disabled, will be enabled when card is detected */
-	if (host->pdata->setpower)
-		host->pdata->setpower(id, 0);
+	lpc313x_mci_set_power(slot, 0);
 
 	mmc->caps = MMC_CAP_SDIO_IRQ;
-	if (host->pdata->get_bus_wd)
-		if (host->pdata->get_bus_wd(slot->id) >= 4)
-			mmc->caps |= MMC_CAP_4_BIT_DATA;
+	width = of_get_property(np, "width", NULL);
+	if (*width == 4)
+		mmc->caps |= MMC_CAP_4_BIT_DATA;
+	else if (*width == 8)
+		mmc->caps |= MMC_CAP_8_BIT_DATA;
 
 	mmc->max_blk_size = 65536; /* BLKSIZ is 16 bits*/
 	mmc->max_blk_count = 512;
 	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
 	mmc->max_seg_size = mmc->max_req_size;
 
-	/* call board init */
-	slot->irq = host->pdata->init(id, lpc313x_mci_detect_interrupt, slot);
+	slot->irq = of_get_property(np, "interrupts", NULL);
+	/* select the opposite level sensitivity */
+	level =  lpc313x_mci_get_cd(slot) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
+
+	/* set card detect irq info */
+	irq_set_irq_type(slot->irq, level);
+	ret = request_irq(slot->irq,
+			lpc313x_mci_detect_interrupt,
+			level,
+			"mmc-cd",
+			slot);
+	/****temporary for PM testing */
+	enable_irq_wake(slot->irq);
+
 	/* Assume card is present initially */
-	if(!host->pdata->get_cd(id))
+	if(!gpio_get_value(slot->gpio_cd))
 		set_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
 	else
 		clear_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
 
-	host->slot[id] = slot;
+	host->slot[host->slot_count++] = slot;
 	mmc_add_host(mmc);
 
-
 #if defined (CONFIG_DEBUG_FS)
 	lpc313x_mci_init_debugfs(slot);
 #endif
@@ -1386,14 +1456,16 @@ lpc313x_mci_init_slot(struct lpc313x_mci *host, unsigned int id)
 			(unsigned long)slot);
 
 	return 0;
+err_ocr:
+	return ret;
 }
 
 static void lpc313x_mci_cleanup_slot(struct lpc313x_mci_slot *slot,
 		unsigned int id)
 {
 	/* Shutdown detect IRQ and kill detect thread */
-	if (slot->host->pdata->exit)
-		slot->host->pdata->exit(id);
+	free_irq(slot->irq, slot);
+
 	del_timer_sync(&slot->detect_timer);
 
 	/* Debugfs stuff is cleaned up by mmc core */
@@ -1404,135 +1476,21 @@ static void lpc313x_mci_cleanup_slot(struct lpc313x_mci_slot *slot,
 	mmc_free_host(slot->mmc);
 }
 
-static struct lpc313x_mci_irq_data irq_data = {
-	.irq = IRQ_SDMMC_CD,
-};
-
-static int mci_get_cd(u32 slot_id)
-{
-	return gpio_get_value(GPIO_MI2STX_BCK0);
-}
-
-static irqreturn_t ea313x_mci_detect_interrupt(int irq, void *data)
-{
-	struct lpc313x_mci_irq_data	*pdata = data;
-
-	/* select the opposite level senstivity */
-	int level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
-
-	irq_set_irq_type(pdata->irq, level);
-
-	/* change the polarity of irq trigger */
-	return pdata->irq_hdlr(irq, pdata->data);
-}
-
-static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
-{
-	int ret;
-	int level;
-
-	/* enable power to the slot */
-	gpio_request(GPIO_MI2STX_DATA0, "mmc power");
-	gpio_set_value(GPIO_MI2STX_DATA0, 0);
-	/* set cd pins as GPIO pins */
-	gpio_request(GPIO_MI2STX_BCK0, "mmc card detect");
-	gpio_direction_input(GPIO_MI2STX_BCK0);
-
-	/* select the opposite level senstivity */
-	level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
-	/* set card detect irq info */
-	irq_data.data = data;
-	irq_data.irq_hdlr = irqhdlr;
-	irq_set_irq_type(irq_data.irq, level);
-	ret = request_irq(irq_data.irq,
-			ea313x_mci_detect_interrupt,
-			level,
-			"mmc-cd", 
-			&irq_data);
-	/****temporary for PM testing */
-	enable_irq_wake(irq_data.irq);
-
-	return irq_data.irq;
-}
-
-static int mci_get_ro(u32 slot_id)
-{
-	return 0;
-}
-
-static int mci_get_ocr(u32 slot_id)
-{
-	return MMC_VDD_32_33 | MMC_VDD_33_34;
-}
-
-static void mci_setpower(u32 slot_id, u32 volt)
-{
-	/* on current version of EA board the card detect
-	 * pull-up in on switched power side. So can't do
-	 * power management so use the always enable power 
-	 * jumper.
-	 */
-}
-static int mci_get_bus_wd(u32 slot_id)
-{
-	return 4;
-}
-
-static void mci_exit(u32 slot_id)
-{
-	free_irq(irq_data.irq, &irq_data);
-}
-
-#ifndef CONFIG_OF
-static struct resource lpc313x_mci_resources[] = {
-	[0] = {
-		.start  = IO_SDMMC_PHYS,
-		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_MCI,
-		.end	= IRQ_MCI,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-#endif
-
-static struct lpc313x_mci_board ea313x_mci_platform_data = {
-	.num_slots		= 1,
-	.detect_delay_ms	= 250,
-	.init 			= mci_init,
-	.get_ro			= mci_get_ro,
-	.get_cd 		= mci_get_cd,
-	.get_ocr		= mci_get_ocr,
-	.get_bus_wd		= mci_get_bus_wd,
-	.setpower 		= mci_setpower,
-	.exit			= mci_exit,
-};
-
-#if defined(CONFIG_OF)
 static const struct of_device_id lpc313x_mci_of_match[] = {
 	{ .compatible = "nxp,lpc31xx-sdmmc" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, lpc313x_mci_of_match);
-#endif
 
 static int lpc313x_mci_probe(struct platform_device *pdev)
 {
-	struct lpc313x_mci		*host;
-	struct resource			*regs;
-	struct lpc313x_mci_board	*pdata;
+	struct device_node *node;
+	struct device_node *np = pdev->dev.of_node;
+	struct lpc313x_mci *host;
+	struct resource *regs;
 	struct clk *clk;
-	int				irq;
-	int				ret = 0;
-	int i;
-
-#ifndef CONFIG_OF
-pdev->num_resources = ARRAY_SIZE(lpc313x_mci_resources);
-pdev->resource = lpc313x_mci_resources;
-#endif
-pdev->dev.platform_data = &ea313x_mci_platform_data;
+	int irq;
+	int ret = 0;
 
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!regs)
@@ -1545,21 +1503,7 @@ pdev->dev.platform_data = &ea313x_mci_platform_data;
 	host = kzalloc(sizeof(struct lpc313x_mci), GFP_KERNEL);
 	if (!host)
 		return -ENOMEM;
-
 	host->pdev = pdev;
-	host->pdata = pdata = pdev->dev.platform_data;
-	if (!pdata) {
-		dev_err(&pdev->dev, "Platform data missing\n");
-		ret = -ENODEV;
-		goto err_freehost;
-	}
-
-	if (((pdata->num_slots > 1) && !(pdata->select_slot)) ||
-	     !(pdata->get_ro) || !(pdata->get_cd) || !(pdata->init)) {
-		dev_err(&pdev->dev, "Platform data wrong\n");
-		ret = -ENODEV;
-		goto err_freehost;
-	}
 
 	spin_lock_init(&host->lock);
 	INIT_LIST_HEAD(&host->queue);
@@ -1649,12 +1593,11 @@ pdev->dev.platform_data = &ea313x_mci_platform_data;
 
 	platform_set_drvdata(pdev, host);
 
-	/* We need at least one slot to succeed ####pd####*/
-	for (i = 0; i < host->pdata->num_slots; i++) {
-		ret = lpc313x_mci_init_slot(host, i);
+	for_each_child_of_node(np, node) {
+		ret = lpc313x_mci_init_slot(host, node);
 		if (ret) {
-		    ret = -ENODEV;
-		    goto err_init_slot;
+			ret = -ENODEV;
+			goto err_init_slot;
 		}
 	}
 
@@ -1670,10 +1613,10 @@ pdev->dev.platform_data = &ea313x_mci_platform_data;
 
 err_init_slot:
 	/* De-init any initialized slots */
-	while (i > 0) {
-		if (host->slot[i])
-			lpc313x_mci_cleanup_slot(host->slot[i], i);
-		i--;
+	while (host->slot_count > 0) {
+		if (host->slot[host->slot_count])
+			lpc313x_mci_cleanup_slot(host->slot[host->slot_count], host->slot_count);
+		host->slot_count--;
 	}
 	free_irq(irq, host);
 err_dmaunmap:
@@ -1701,7 +1644,7 @@ static int __exit lpc313x_mci_remove(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, NULL);
 
-	for (i = 0; i < host->pdata->num_slots; i++) {
+	for (i = 0; i < host->slot_count; i++) {
 		dev_dbg(&pdev->dev, "remove slot %d\n", i);
 		if (host->slot[i])
 			lpc313x_mci_cleanup_slot(host->slot[i], i);
diff --git a/drivers/of/base.c b/drivers/of/base.c
index 133908a..6765652 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -17,6 +17,8 @@
  *      as published by the Free Software Foundation; either version
  *      2 of the License, or (at your option) any later version.
  */
+#define DEBUG
+
 #include <linux/ctype.h>
 #include <linux/module.h>
 #include <linux/of.h>
diff --git a/drivers/of/gpio.c b/drivers/of/gpio.c
index 7e62d15..917d66f 100644
--- a/drivers/of/gpio.c
+++ b/drivers/of/gpio.c
@@ -11,6 +11,8 @@
  * (at your option) any later version.
  */
 
+#define DEBUG
+
 #include <linux/device.h>
 #include <linux/errno.h>
 #include <linux/module.h>
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 1ac2deb..f8cdf79 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -31,7 +31,7 @@ obj-$(CONFIG_SPI_FSL_SPI)		+= spi-fsl-spi.o
 obj-$(CONFIG_SPI_GPIO)			+= spi-gpio.o
 obj-$(CONFIG_SPI_IMX)			+= spi-imx.o
 obj-$(CONFIG_SPI_LM70_LLP)		+= spi-lm70llp.o
-obj-$(CONFIG_SPI_LPC313X)		+= spi_lpc313x.o
+obj-$(CONFIG_SPI_LPC313X)		+= spi-lpc313x.o
 obj-$(CONFIG_SPI_MPC512x_PSC)		+= spi-mpc512x-psc.o
 obj-$(CONFIG_SPI_MPC52xx_PSC)		+= spi-mpc52xx-psc.o
 obj-$(CONFIG_SPI_MPC52xx)		+= spi-mpc52xx.o
diff --git a/drivers/spi/spi_lpc313x.c b/drivers/spi/spi-lpc313x.c
similarity index 100%
rename from drivers/spi/spi_lpc313x.c
rename to drivers/spi/spi-lpc313x.c
