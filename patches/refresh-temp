Bottom: 002ed62263fdae7bfe16702556f8b0c5db317e56
Top:    b092ec8440f1287f5d3056cfd01cb650f75f6e9d
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-07-04 12:17:51 -0400

Refresh of initial-sound-driver-port

---

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 6e76cfb..eef9028 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -67,7 +67,7 @@ static unsigned long clk_factors_recalc_rate(struct clk_hw *hw,
 	if (q == 0) 
 		rate = (parent_rate * n * (k + 1) >> p) / (m + 1);
 	else
-		rate = (parent_rate * n / m / q;
+		rate = (parent_rate * n) / m / q;
 	printk("JDS CLK n %d k %d m %d p %d q %d rate %lu\n", n, k, m, p, q, rate);
 
 	return rate;
@@ -78,7 +78,7 @@ static long clk_factors_round_rate(struct clk_hw *hw, unsigned long rate,
 {
 	struct clk_factors *factors = to_clk_factors(hw);
 	factors->get_factors((u32 *)&rate, (u32)*parent_rate,
-			     NULL, NULL, NULL, NULL);
+			     NULL, NULL, NULL, NULL, NULL);
 
 	return rate;
 }
diff --git a/drivers/clk/sunxi/clk-sunxi.c b/drivers/clk/sunxi/clk-sunxi.c
index 4274532..95a0feb 100644
--- a/drivers/clk/sunxi/clk-sunxi.c
+++ b/drivers/clk/sunxi/clk-sunxi.c
@@ -1147,7 +1147,7 @@ free_clkdata:
 static const struct of_device_id clk_factors_match[] __initconst = {
 	{.compatible = "allwinner,sun4i-a10-pll1-clk", .data = &sun4i_pll1_data,},
 	{.compatible = "allwinner,sun6i-a31-pll1-clk", .data = &sun6i_a31_pll1_data,},
-+	{.compatible = "allwinner,sun7i-a20-pll2-clk", .data = &sun7i_a20_pll2_data,},
+	{.compatible = "allwinner,sun7i-a20-pll2-clk", .data = &sun7i_a20_pll2_data,},
 	{.compatible = "allwinner,sun7i-a20-pll4-clk", .data = &sun7i_a20_pll4_data,},
 	{.compatible = "allwinner,sun6i-a31-pll6-clk", .data = &sun6i_a31_pll6_data,},
 	{.compatible = "allwinner,sun4i-a10-apb1-clk", .data = &sun4i_apb1_data,},
diff --git a/drivers/dma/sun4i-dma.c b/drivers/dma/sun4i-dma.c
index 97fb587..26c3ebd 100644
--- a/drivers/dma/sun4i-dma.c
+++ b/drivers/dma/sun4i-dma.c
@@ -581,63 +581,70 @@ static struct dma_async_tx_descriptor *sun4i_dma_prep_dma_cyclic(
 		unsigned long flags, void *context) {
 	struct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);
 	struct dma_slave_config *sconfig = &vchan->cfg;
-	struct sun4i_ddma_promise *promise;
-	struct sun4i_ddma_contract *contract;
-	dma_addr_t src, dest;
+	struct sun4i_dma_promise *promise;
+	struct sun4i_dma_contract *contract;
+	dma_addr_t srcaddr, dstaddr;
+	u32 endpoints;
 
 	if (!is_slave_direction(dir)) {
 		dev_err(chan2dev(chan), "Invalid DMA direction\n");
 		return NULL;
 	}
 
-	contract = generate_ddma_contract();
+	contract = generate_dma_contract();
 	if (!contract)
 		return NULL;
 
-	/* Figure out addresses */
-	if (dir == DMA_MEM_TO_DEV) {
-		src = buf;
-		dest = sconfig->dst_addr;
-	} else {
-		src = sconfig->src_addr;
-		dest = buf;
-	}
-
-	if (vchan->is_dedicated)
-		promise = generate_ddma_promise(chan, src, dest, len, sconfig);
-	else
-		promise = generate_ndma_promise(chan, src, dest, len, sconfig);
-
-	if (!promise) {
-		kfree(contract);
-		return NULL;
-	}
-
 	/* Figure out endpoints */
 	if (vchan->is_dedicated && dir == DMA_MEM_TO_DEV) {
-		promise->cfg |= DDMA_CFG_CONT_MODE | DDMA_CFG_SRC_DRQ_TYPE(DDMA_DRQ_TYPE_SDRAM) |
+		endpoints = DDMA_CFG_CONT_MODE | DDMA_CFG_SRC_DRQ_TYPE(DDMA_DRQ_TYPE_SDRAM) |
 			    DDMA_CFG_SRC_ADDR_MODE(DDMA_ADDR_MODE_LINEAR) |
 			    DDMA_CFG_DEST_DRQ_TYPE(vchan->endpoint) |
 			    DDMA_CFG_DEST_ADDR_MODE(DDMA_ADDR_MODE_IO);
 	} else if (!vchan->is_dedicated && dir == DMA_MEM_TO_DEV) {
-		promise->cfg |= NDMA_CFG_CONT_MODE | NDMA_CFG_SRC_DRQ_TYPE(NDMA_DRQ_TYPE_SDRAM) |
+		endpoints = NDMA_CFG_CONT_MODE | NDMA_CFG_SRC_DRQ_TYPE(NDMA_DRQ_TYPE_SDRAM) |
 			    NDMA_CFG_DEST_DRQ_TYPE(vchan->endpoint) |
 			    NDMA_CFG_DEST_FIXED_ADDR;
 	} else if (vchan->is_dedicated) {
-		promise->cfg |= DDMA_CFG_CONT_MODE | DDMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |
+		endpoints = DDMA_CFG_CONT_MODE | DDMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |
 			    DDMA_CFG_SRC_ADDR_MODE(DDMA_ADDR_MODE_IO) |
 			    DDMA_CFG_DEST_DRQ_TYPE(DDMA_DRQ_TYPE_SDRAM) |
 			    DDMA_CFG_DEST_ADDR_MODE(DDMA_ADDR_MODE_LINEAR);
 	} else {
-		promise->cfg |= NDMA_CFG_CONT_MODE | NDMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |
+		endpoints = NDMA_CFG_CONT_MODE | NDMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |
 			    NDMA_CFG_SRC_FIXED_ADDR |
 			    NDMA_CFG_DEST_DRQ_TYPE(NDMA_DRQ_TYPE_SDRAM);
 	}
 
-	/* Fill the contract with our only promise */
+	/* Figure out addresses */
+	if (dir == DMA_MEM_TO_DEV) {
+		srcaddr = buf;
+		dstaddr = sconfig->dst_addr;
+	} else {
+		srcaddr = sconfig->src_addr;
+		dstaddr = buf;
+	}
+
+	/* And make a suitable promise */
+	if (vchan->is_dedicated)
+		promise = generate_ddma_promise(chan, srcaddr, dstaddr,
+						len, sconfig);
+	else
+		promise = generate_ndma_promise(chan, srcaddr, dstaddr,
+						len, sconfig);
+
+	if (!promise)
+		return NULL; /* TODO */
+
+	promise->cfg |= endpoints;
+
+	/* Then add it to the contract */
 	list_add_tail(&promise->list, &contract->demands);
 
-	/* And add it to the vchan */
+	/*
+	 * Once we've got all the promise ready, add the contract
+	 * to the pending list on the vchan
+	 */
 	return vchan_tx_prep(&vchan->vc, &contract->vd, flags);
 }
