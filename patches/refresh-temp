Bottom: de77d8887082c6061300f418516e9ca61fc3667b
Top:    245b7709a76634b665df357b95c6f37635b061e3
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-06-30 08:54:31 -0400

Refresh of initial-sound-driver-port

---

diff --git a/arch/arm/boot/dts/sun7i-a20.dtsi b/arch/arm/boot/dts/sun7i-a20.dtsi
index 1a44eba..955fdb0 100644
--- a/arch/arm/boot/dts/sun7i-a20.dtsi
+++ b/arch/arm/boot/dts/sun7i-a20.dtsi
@@ -1155,8 +1155,9 @@
 	};
 
 	ac: ac@0 {
-		compatible = "allwinner,sunxi-ac";
-	}
+		#sound-dai-cells = <0>;
+		compatible = "allwinner,stub";
+	};
 
 	sound {
 		compatible = "simple-audio-card";
diff --git a/cop b/cop
index 727aee3..42d5878 100755
--- a/cop
+++ b/cop
@@ -1,6 +1,6 @@
 #!/bin/sh
 
 
-make zImage modules uImage dtbs
-cp /work/hans/sound/soc/sunxi/sunxi-codec.ko /work/root/lib/modules/3.15.0+/kernel/sound/soc/sunxi
+make zImage uImage dtbs
+#cp /work/hans/sound/soc/sunxi/sunxi-codec.ko /work/root/lib/modules/3.15.0+/kernel/sound/soc/sunxi
 
diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 399cf4d..9e67ac5 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -62,11 +62,17 @@ static unsigned long clk_factors_recalc_rate(struct clk_hw *hw,
 		p = FACTOR_GET(config->pshift, config->pwidth, reg);
 
 	/* Calculate the rate */
-	if (config->n_from_one)
+	switch (config->rate_adjust) {
+	case N_FROM_ONE:
 		rate = (parent_rate * (n + 1) * (k + 1) >> p) / (m + 1);
-	else
+		break;
+	case PLL2_DIV:
+		rate = parent_rate * n / k / m;
+		break;
+	default:
 		rate = (parent_rate * n * (k + 1) >> p) / (m + 1);
-
+		break;
+	}
 	return rate;
 }
 
@@ -139,6 +145,7 @@ static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
 	reg = FACTOR_SET(config->pshift, config->pwidth, reg, p);
 
 	/* Apply them now */
+	printk("CLK - write reg %p value %x\n", factors->reg, reg);
 	writel(reg, factors->reg);
 
 	/* delay 500us so pll stabilizes */
diff --git a/drivers/clk/sunxi/clk-factors.h b/drivers/clk/sunxi/clk-factors.h
index 0484a48..2d63400 100644
--- a/drivers/clk/sunxi/clk-factors.h
+++ b/drivers/clk/sunxi/clk-factors.h
@@ -6,6 +6,8 @@
 
 #define SUNXI_FACTORS_NOT_APPLICABLE	(0)
 
+enum erate_adjust {NO_ADJUST = 0, N_FROM_ONE, PLL2_DIV};
+
 struct clk_factors_config {
 	u8 nshift;
 	u8 nwidth;
@@ -15,7 +17,7 @@ struct clk_factors_config {
 	u8 mwidth;
 	u8 pshift;
 	u8 pwidth;
-	u8 n_from_one;
+	enum erate_adjust rate_adjust;
 };
 
 struct clk_factors {
diff --git a/drivers/clk/sunxi/clk-sunxi.c b/drivers/clk/sunxi/clk-sunxi.c
index b3483a7..1e4c98d 100644
--- a/drivers/clk/sunxi/clk-sunxi.c
+++ b/drivers/clk/sunxi/clk-sunxi.c
@@ -503,7 +503,7 @@ static struct clk_factors_config sun8i_a23_pll1_config = {
 	.mwidth = 2,
 	.pshift = 16,
 	.pwidth = 2,
-	.n_from_one = 1,
+	.rate_adjust = N_FROM_ONE,
 };
 
 static struct clk_factors_config sun7i_pll2_config = {
@@ -513,6 +513,7 @@ static struct clk_factors_config sun7i_pll2_config = {
 	.kwidth = 4,
 	.mshift = 0,
 	.mwidth = 5,
+	.rate_adjust = PLL2_DIV,
 };
 
 static struct clk_factors_config sun4i_pll5_config = {
@@ -527,7 +528,7 @@ static struct clk_factors_config sun6i_a31_pll6_config = {
 	.nwidth = 5,
 	.kshift = 4,
 	.kwidth = 2,
-	.n_from_one = 1,
+	.rate_adjust = N_FROM_ONE,
 };
 
 static struct clk_factors_config sun4i_apb1_config = {
@@ -1018,17 +1019,19 @@ static void __init sunxi_gates_clk_setup(struct device_node *node,
 	for_each_set_bit(i, data->mask, SUNXI_GATES_MAX_SIZE) {
 		of_property_read_string_index(node, "clock-output-names",
 					      j, &clk_name);
-
 		clk_data->clks[i] = clk_register_gate(NULL, clk_name,
 						      clk_parent, 0,
 						      reg + 4 * (i/32), i % 32,
 						      0, &clk_lock);
 		WARN_ON(IS_ERR(clk_data->clks[i]));
 		clk_register_clkdev(clk_data->clks[i], clk_name, NULL);
-
 		j++;
 	}
 
+	/* if there is a single gate, copy it to entry[0] so there is no requirement for phandle arg */
+	if (j == 1)
+		clk_data->clks[0] = clk_data->clks[i];
+
 	/* Adjust to the real max */
 	clk_data->clk_num = i;
 
diff --git a/drivers/dma/sun4i-dma.c b/drivers/dma/sun4i-dma.c
index 21b62a2..5c30ecd 100644
--- a/drivers/dma/sun4i-dma.c
+++ b/drivers/dma/sun4i-dma.c
@@ -8,8 +8,6 @@
  * (at your option) any later version.
  */
 
-#define DEBUG
-
 #include <linux/bitmap.h>
 #include <linux/bitops.h>
 #include <linux/clk.h>
@@ -288,7 +286,6 @@ static struct sun4i_dma_pchan *find_and_use_pchan(struct sun4i_ddma_dev *priv,
 	unsigned long flags;
 	int i, max;
 
-	printk("JDS - find_and_use_pchan\n");
 	spin_lock_irqsave(&priv->lock, flags);
 
 	/* pchans 0-NDMA_NR_MAX_CHANNELS are normal, and
@@ -387,7 +384,6 @@ static int execute_vchan_pending(struct sun4i_ddma_dev *priv,
 	unsigned long flags;
 	int ret = 0;
 
-	printk("JDS - execute_vchan_pending\n");
 	/* We need a pchan to do anything, so secure one if available */
 	pchan = find_and_use_pchan(priv, vchan);
 	if (!pchan)
@@ -999,6 +995,19 @@ static void sun4i_ddma_tasklet(unsigned long data)
 		execute_vchan_pending(priv, &priv->vchans[i]);
 }
 
+static int sun4i_dma_device_slave_caps(struct dma_chan *dchan,
+				      struct dma_slave_caps *caps)
+{
+	caps->src_addr_widths = 32;
+	caps->dstn_addr_widths = 32;
+	caps->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);
+	caps->cmd_pause = true;
+	caps->cmd_terminate = true;
+	caps->residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;
+
+	return 0;
+}
+
 static int sun4i_dma_probe(struct platform_device *pdev)
 {
 	struct sun4i_ddma_dev *priv;
@@ -1044,6 +1053,7 @@ static int sun4i_dma_probe(struct platform_device *pdev)
 	priv->slave.device_prep_dma_memcpy	= sun4i_dma_prep_dma_memcpy;
 	priv->slave.device_prep_dma_cyclic	= sun4i_dma_prep_dma_cyclic;
 	priv->slave.device_control		= sun4i_dma_control;
+	priv->slave.device_slave_caps 		= sun4i_dma_device_slave_caps;
 	priv->slave.chancnt			= DDMA_NR_MAX_VCHANS;
 
 	priv->slave.dev = &pdev->dev;
diff --git a/sound/core/pcm_dmaengine.c b/sound/core/pcm_dmaengine.c
index fd420af..7878410 100644
--- a/sound/core/pcm_dmaengine.c
+++ b/sound/core/pcm_dmaengine.c
@@ -306,6 +306,7 @@ int snd_dmaengine_pcm_open(struct snd_pcm_substream *substream,
 	struct dmaengine_pcm_runtime_data *prtd;
 	int ret;
 
+	printk("JDS - snd_dmaengine_pcm_open\n");
 	if (!chan)
 		return -ENXIO;
 
@@ -322,6 +323,7 @@ int snd_dmaengine_pcm_open(struct snd_pcm_substream *substream,
 
 	substream->runtime->private_data = prtd;
 
+	printk("JDS - snd_dmaengine_pcm_open ret\n");
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_dmaengine_pcm_open);
diff --git a/sound/soc/soc-generic-dmaengine-pcm.c b/sound/soc/soc-generic-dmaengine-pcm.c
index f64f2f4..4ba2a2bc 100644
--- a/sound/soc/soc-generic-dmaengine-pcm.c
+++ b/sound/soc/soc-generic-dmaengine-pcm.c
@@ -296,11 +296,14 @@ static snd_pcm_uframes_t dmaengine_pcm_pointer(
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);
+	snd_pcm_uframes_t ret;
 
 	if (pcm->flags & SND_DMAENGINE_PCM_FLAG_NO_RESIDUE)
-		return snd_dmaengine_pcm_pointer_no_residue(substream);
+		ret = snd_dmaengine_pcm_pointer_no_residue(substream);
 	else
-		return snd_dmaengine_pcm_pointer(substream);
+		ret = snd_dmaengine_pcm_pointer(substream);
+	printk("dmaengine_pcm_pointer %x\n", ret);
+	return ret;
 }
 
 static const struct snd_pcm_ops dmaengine_pcm_ops = {
diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c
index a391de0..59a03a0 100644
--- a/sound/soc/soc-pcm.c
+++ b/sound/soc/soc-pcm.c
@@ -671,12 +671,14 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	int ret = 0;
 
+	printk("JDS - soc_pcm_hw_params\n");
 	mutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);
 
 	ret = soc_pcm_params_symmetry(substream, params);
 	if (ret)
 		goto out;
 
+	printk("JDS - soc_pcm_hw_params a\n");
 	if (rtd->dai_link->ops && rtd->dai_link->ops->hw_params) {
 		ret = rtd->dai_link->ops->hw_params(substream, params);
 		if (ret < 0) {
@@ -686,6 +688,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
+	printk("JDS - soc_pcm_hw_params b\n");
 	if (codec_dai->driver->ops && codec_dai->driver->ops->hw_params) {
 		ret = codec_dai->driver->ops->hw_params(substream, params, codec_dai);
 		if (ret < 0) {
@@ -695,6 +698,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
+	printk("JDS - soc_pcm_hw_params c\n");
 	if (cpu_dai->driver->ops && cpu_dai->driver->ops->hw_params) {
 		ret = cpu_dai->driver->ops->hw_params(substream, params, cpu_dai);
 		if (ret < 0) {
@@ -704,6 +708,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
+	printk("JDS - soc_pcm_hw_params d\n");
 	if (platform->driver->ops && platform->driver->ops->hw_params) {
 		ret = platform->driver->ops->hw_params(substream, params);
 		if (ret < 0) {
@@ -726,6 +731,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 
 out:
 	mutex_unlock(&rtd->pcm_mutex);
+	printk("JDS - soc_pcm_hw_params e\n");
 	return ret;
 
 platform_err:
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
index c15cb8b..35a8a91 100644
--- a/sound/soc/sunxi/Makefile
+++ b/sound/soc/sunxi/Makefile
@@ -1,4 +1,4 @@
 obj-$(CONFIG_SND_SUNXI_SOC_CODEC) += sunxi-codec.o
-obj-$(CONFIG_SND_SUNXI_SOC_CODEC_JDS) += sunxi_codec_main.o
+obj-$(CONFIG_SND_SUNXI_SOC_CODEC_JDS) += sunxi_codec_main.o stub.o
 
 
diff --git a/sound/soc/sunxi/codec_new.c b/sound/soc/sunxi/codec_new.c
new file mode 100644
index 0000000..52dbb48
--- /dev/null
+++ b/sound/soc/sunxi/codec_new.c
@@ -0,0 +1,440 @@
+/*
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/clk.h>
+#include <linux/regmap.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+
+//Codec Register
+#define SUNXI_DAC_DPC                (0x00)
+#define SUNXI_DAC_FIFOC              (0x04)
+#define SUNXI_DAC_FIFOS              (0x08)
+#define SUNXI_DAC_TXDATA             (0x0c)
+#define SUNXI_DAC_ACTL               (0x10)
+#define SUNXI_DAC_TUNE               (0x14)
+#define SUNXI_DAC_DEBUG              (0x18)
+#define SUNXI_ADC_FIFOC              (0x1c)
+#define SUNXI_ADC_FIFOS              (0x20)
+#define SUNXI_ADC_RXDATA             (0x24)
+#define SUNXI_ADC_ACTL               (0x28)
+#define SUNXI_ADC_DEBUG              (0x2c)
+#define SUNXI_DAC_TXCNT              (0x30)
+#define SUNXI_ADC_RXCNT              (0x34)
+#define SUNXI_BIAS_CRT               (0x38)
+#define SUNXI_MIC_CRT                (0x3c)
+#define SUNXI_CODEC_REGS_NUM         (13)
+
+#define DAIFMT_16BITS             (16)
+#define DAIFMT_20BITS             (20)
+
+#define DAIFMT_BS_MASK            (~(1<<16))  	//FIFO big small mode mask
+#define DAIFMT_BITS_MASK          (~(1<<5))		//FIFO Bits select mask,not used yet.
+#define SAMPLE_RATE_MASK          (~(7<<29))  	//Sample Rate slect mask
+
+#define DAC_EN                    (31)
+#define DIGITAL_VOL               (12)
+//For CODEC OLD VERSION
+#define DAC_VERSION               (23)
+
+#define DAC_CHANNEL		  (6)
+#define LAST_SE                   (26)
+#define TX_FIFO_MODE              (24)
+#define DRA_LEVEL                 (21)
+#define TX_TRI_LEVEL              (8)
+#define DAC_MODE                  (6)			//not used yet
+#define TASR                      (5)			//not used yet
+#define DAC_DRQ                   (4)
+#define DAC_FIFO_FLUSH            (0)
+
+#define VOLUME                    (0)
+#define PA_MUTE                   (6)
+#define MIXPAS                    (7)
+#define DACPAS                    (8)
+#define MIXEN                     (29)
+#define DACAEN_L                  (30)
+#define DACAEN_R                  (31)
+
+#define ADC_DIG_EN                (28)
+#define RX_FIFO_MODE              (24)
+#define RX_TRI_LEVEL              (8)
+#define ADC_MODE                  (7)
+#define RASR                      (6)
+#define ADC_DRQ                   (4)
+#define ADC_FIFO_FLUSH            (0)
+
+#define  ADC_LF_EN                (31)
+#define  ADC_RI_EN                (30)
+#define  ADC_EN                   (30)
+#define  MIC1_EN                  (29)
+#define  MIC2_EN                  (28)
+#define  VMIC_EN                  (27)
+#define  MIC_GAIN                 (25)
+#define  ADC_SELECT               (17)
+#define  PA_ENABLE                (4)
+#define  HP_DIRECT                (3)
+
+
+enum sunxi_device_id {SUN4A, SUN4I, SUN5I, SUN7I}; 
+
+struct sunxi_codec {
+	struct regmap *regmap;
+	int irq;
+	struct clk *clk_apb, *clk_pll2, *clk_module;
+
+	enum sunxi_device_id id;
+
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+
+	struct snd_ratnum ratnum;
+	struct snd_pcm_hw_constraint_ratnums rate_constraints;
+};
+
+static int sunxi_codec_trigger(struct snd_pcm_substream *substream, int cmd,
+	struct snd_soc_dai *dai)
+{
+//JDS	struct sunxi_codec *codec = snd_soc_dai_get_drvdata(dai);
+	unsigned int val;
+
+	printk("JDS - sunxi_codec_trigger\n");
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+//JDS		val = SUNXI_SPDIF_CTRL_TXDATA;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		val = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+//JDS	regmap_update_bits(codec->regmap, SUNXI_SPDIF_REG_CTRL, SUNXI_SPDIF_CTRL_TXDATA, val);
+
+	return 0;
+}
+
+static int sunxi_codec_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sunxi_codec *codec = snd_soc_dai_get_drvdata(dai);
+	unsigned int rate = params_rate(params);
+
+	printk("JDS - sunxi_codec_hw_params\n");
+	switch (params_rate(params)) {
+	case 44100:
+	case 22050:
+	case 11025:
+	default:
+		clk_set_rate(codec->clk_pll2, 22579200);
+		clk_set_rate(codec->clk_module, 22579200);
+		break;
+	case 192000:
+	case 96000:
+	case 48000:
+	case 32000:
+	case 24000:
+	case 16000:
+	case 12000:
+	case 8000:
+		clk_set_rate(codec->clk_pll2, 24576000);
+		clk_set_rate(codec->clk_module, 24576000);
+		break;
+	}
+
+	switch (params_rate(params)) {
+	default:
+	case 44100:
+		rate = 0;
+		break;
+	case 22050:
+		rate = 2;
+		break;
+	case 11025:
+		rate = 4;
+		break;
+	case 192000:
+		rate = 6;
+		break;
+	case 96000:
+		rate = 7;
+		break;
+	case 48000:
+		rate = 0;
+		break;
+	case 32000:
+		rate = 1;
+		break;
+	case 24000:
+		rate = 2;
+		break;
+	case 16000:
+		rate = 3;
+		break;
+	case 12000:
+		rate = 4;
+		break;
+	case 8000:
+		rate = 5;
+		break;
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 7 << 29, rate << 29);
+		if (substream->runtime->channels == 1)
+			regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 1 << 6, 1 << 6);
+		else
+			regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 1 << 6, 0 << 6);
+	} else  {
+		regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 7 << 29, rate << 29);
+		if (substream->runtime->channels == 1)
+			regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 1 << 7, 1 << 7);
+		else
+			regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 1 << 7, 0 << 7);
+	}
+	return 0;
+}
+
+static int sunxi_codec_dai_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_codec *codec = snd_soc_dai_get_drvdata(dai);
+
+	printk("JDS - sunxi_codec_dai_probe\n");
+	snd_soc_dai_init_dma_data(dai, &codec->playback_dma_data, &codec->capture_dma_data);
+
+	return 0;
+}
+
+static int sunxi_codec_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct sunxi_codec *codec = snd_soc_dai_get_drvdata(dai);
+	int ret;
+
+	printk("JDS - sunxi_codec_startup\n");
+	ret = snd_pcm_hw_constraint_ratnums(substream->runtime, 0,
+			   SNDRV_PCM_HW_PARAM_RATE,
+			   &codec->rate_constraints);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(codec->clk_module);
+	if (ret)
+		return ret;
+
+//	regmap_update_bits(codec->regmap, SUNXI_SPDIF_REG_CTRL, SUNXI_SPDIF_CTRL_TXEN, SUNXI_SPDIF_CTRL_TXEN);
+
+	printk("JDS - sunxi_codec_startup - ok\n");
+	return 0;
+}
+
+static void sunxi_codec_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct sunxi_codec *codec = snd_soc_dai_get_drvdata(dai);
+
+//JDS	regmap_update_bits(codec->regmap, SUNXI_SPDIF_REG_CTRL, SUNXI_SPDIF_CTRL_TXEN, 0);
+
+	printk("JDS - sunxi_codec_shutdown\n");
+	clk_disable_unprepare(codec->clk_module);
+}
+
+static const struct snd_soc_dai_ops sunxi_codec_dai_ops = {
+	.startup = sunxi_codec_startup,
+	.shutdown = sunxi_codec_shutdown,
+	.trigger = sunxi_codec_trigger,
+	.hw_params = sunxi_codec_hw_params,
+};
+
+static struct snd_soc_dai_driver sunxi_codec_dai = {
+	.probe = sunxi_codec_dai_probe,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+
+		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_11025 |\
+			 SNDRV_PCM_RATE_22050| SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\
+			 SNDRV_PCM_RATE_48000 |SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000 |\
+			 SNDRV_PCM_RATE_KNOT),
+		.rate_min = 8000,
+		.rate_max = 192000,
+	},
+	.ops = &sunxi_codec_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_codec_component = {
+	.name = "sunxi-codec",
+};
+
+static const struct regmap_config sunxi_codec_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_MIC_CRT,
+};
+
+static const struct of_device_id sunxi_codec_of_match[] = {
+	{ .compatible = "allwinner,sun4i-a10a-codec", .data = (void *)SUN4A},
+	{ .compatible = "allwinner,sun4i-a10-codec", .data = (void *)SUN4I},
+	{ .compatible = "allwinner,sun5i-a13-codec", .data = (void *)SUN5I},
+	{ .compatible = "allwinner,sun7i-a20-codec", .data = (void *)SUN7I},
+	{}
+};
+MODULE_DEVICE_TABLE(of, sunxi_codec_of_match);
+
+static int sunxi_codec_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct sunxi_codec *codec;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	of_id = of_match_device(sunxi_codec_of_match, dev);
+	if (!of_id)
+		return -EINVAL;
+
+	codec = devm_kzalloc(&pdev->dev, sizeof(*codec), GFP_KERNEL);
+	if (!codec)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, codec);
+
+	codec->id = (int)of_id->data;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	codec->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					    &sunxi_codec_regmap_config);
+	if (IS_ERR(codec->regmap))
+		return PTR_ERR(codec->regmap);
+
+	codec->irq = irq_of_parse_and_map(np, 0);
+	if (!codec->irq) {
+		dev_err(dev, "no irq for node %s\n", np->full_name);
+		return -ENXIO;
+	}
+
+	/* Clock */
+	codec->clk_apb = devm_clk_get(dev, "apb");
+	if (IS_ERR(codec->clk_apb)) {
+		dev_err(dev, "failed to get apb clock.\n");
+		return PTR_ERR(codec->clk_apb);
+	}
+	codec->clk_pll2 = devm_clk_get(dev, "pll2");
+	if (IS_ERR(codec->clk_pll2)) {
+		dev_err(dev, "failed to get pll2 clock.\n");
+		return PTR_ERR(codec->clk_pll2);
+	}
+	codec->clk_module = devm_clk_get(dev, "codec");
+	if (IS_ERR(codec->clk_module)) {
+		dev_err(dev, "failed to get codec clock.\n");
+		return PTR_ERR(codec->clk_module);
+	}
+	ret = clk_set_rate(codec->clk_pll2, 24576000);
+	if (ret) {
+		dev_err(dev, "set codec base clock rate failed!\n");
+		return ret;
+	}
+	if (clk_prepare_enable(codec->clk_pll2)) {
+		dev_err(dev, "try to enable clk_pll2 failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(codec->clk_apb)) {
+		dev_err(dev, "try to enable clk_apb failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(codec->clk_module)) {
+		dev_err(dev, "try to enable clk_module failed\n");
+		return -EINVAL;
+	}
+
+	codec->playback_dma_data.addr = res->start + SUNXI_DAC_TXDATA;
+	codec->playback_dma_data.maxburst = 4;
+	codec->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	codec->capture_dma_data.addr = res->start + SUNXI_ADC_RXDATA;
+	codec->capture_dma_data.maxburst = 4;
+	codec->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	codec->ratnum.num = clk_get_rate(codec->clk_module) / 128;
+	codec->ratnum.den_step = 1;
+	codec->ratnum.den_min = 1;
+	codec->ratnum.den_max = 64;
+
+	codec->rate_constraints.rats = &codec->ratnum;
+	codec->rate_constraints.nrats = 1;
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_codec_component,
+					 &sunxi_codec_dai, 1);
+	if (ret)
+		goto err_clk_disable;
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret)
+		goto err_clk_disable;
+
+	return 0;
+
+err_clk_disable:
+	clk_disable_unprepare(codec->clk_module);
+	clk_disable_unprepare(codec->clk_apb);
+	clk_disable_unprepare(codec->clk_pll2);
+	return ret;
+}
+
+static int sunxi_codec_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_codec *codec = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(codec->clk_module);
+	clk_disable_unprepare(codec->clk_apb);
+	clk_disable_unprepare(codec->clk_pll2);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_codec_driver = {
+	.driver = {
+		.name = "sunxi-codec",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_codec_of_match,
+	},
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_dev_remove,
+};
+module_platform_driver(sunxi_codec_driver);
+
+MODULE_ALIAS("platform:sunxi-codec-dai");
+MODULE_DESCRIPTION("sunxi CODEC ALSA codec driver");
+MODULE_AUTHOR("software");
+MODULE_LICENSE("GPL v2");
+
diff --git a/sound/soc/sunxi/codec_old.c b/sound/soc/sunxi/codec_old.c
new file mode 100644
index 0000000..5143b42
--- /dev/null
+++ b/sound/soc/sunxi/codec_old.c
@@ -0,0 +1,752 @@
+/*
+ * ALSA SoC codec Out Audio Layer for spear processors
+ *
+ * Copyright (C) 2012 ST Microelectronics
+ * Vipin Kumar <vipin.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/regmap.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include "sunxi-codec.h"
+
+static void codec_resume_events(struct work_struct *work);
+struct workqueue_struct *resume_work_queue;
+static DECLARE_WORK(codec_resume_work, codec_resume_events);
+
+static void sunxi_configure(struct card_data *priv)
+{
+#ifdef JDS
+	writel(sunxi_RESET, priv->io_base + sunxi_SOFT_RST);
+	mdelay(1);
+	writel(readl(priv->io_base + sunxi_SOFT_RST) & ~sunxi_RESET,
+			priv->io_base + sunxi_SOFT_RST);
+
+	writel(sunxi_FDMA_TRIG_16 | sunxi_MEMFMT_16_16 |
+			sunxi_VALID_HW | sunxi_USER_HW |
+			sunxi_CHNLSTA_HW | sunxi_PARITY_HW,
+			priv->io_base + sunxi_CFG);
+
+	writel(0x7F, priv->io_base + sunxi_INT_STA_CLR);
+	writel(0x7F, priv->io_base + sunxi_INT_EN_CLR);
+#endif 
+}
+
+static int sunxi_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *cpu_dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	ret = clk_enable(priv->codec_moduleclk);
+	if (ret)
+		return ret;
+
+	priv->running = true;
+	sunxi_configure(priv);
+
+	return 0;
+}
+
+static void sunxi_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return;
+
+	clk_disable(priv->codec_moduleclk);
+	priv->running = false;
+}
+
+static void sunxi_clock(struct card_data *priv, u32 core_freq,
+		u32 rate)
+{
+#ifdef JDS
+	u32 divider, ctrl;
+	clk_set_rate(priv->clk, core_freq);
+	divider = DIV_ROUND_CLOSEST(clk_get_rate(priv->clk), (rate * 128));
+
+	ctrl = readl(priv->io_base + sunxi_CTRL);
+	ctrl &= ~codec_DIVIDER_MASK;
+	ctrl |= (divider << codec_DIVIDER_SHIFT) & codec_DIVIDER_MASK;
+	writel(ctrl, priv->io_base + sunxi_CTRL);
+#endif
+}
+
+static int sunxi_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params,
+		struct snd_soc_dai *dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	u32 rate, core_freq;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	rate = params_rate(params);
+
+	switch (rate) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64000:
+		/*
+		 * The clock is multiplied by 10 to bring it to feasible range
+		 * of frequencies for sscg
+		 */
+		core_freq = 64000 * 128 * 10;	/* 81.92 MHz */
+		break;
+	case 5512:
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		core_freq = 176400 * 128;	/* 22.5792 MHz */
+		break;
+	case 48000:
+	case 96000:
+	case 192000:
+	default:
+		core_freq = 192000 * 128;	/* 24.576 MHz */
+		break;
+	}
+
+	sunxi_clock(priv, core_freq, rate);
+	priv->saved_params.core_freq = core_freq;
+	priv->saved_params.rate = rate;
+
+	return 0;
+}
+
+static int sunxi_trigger(struct snd_pcm_substream *substream, int cmd,
+		struct snd_soc_dai *dai)
+{
+#ifdef JDS
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	u32 ctrl;
+#endif
+	int ret = 0;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+#ifdef JDS		
+			ctrl = readl(priv->io_base + sunxi_CTRL);
+			ctrl &= ~codec_OPMODE_MASK;
+			if (!priv->saved_params.mute)
+				ctrl |= codec_OPMODE_AUD_DATA |
+					codec_STATE_NORMAL;
+			else
+				ctrl |= codec_OPMODE_MUTE_PCM;
+			writel(ctrl, priv->io_base + sunxi_CTRL);
+#endif
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+#ifdef JDS		
+		ctrl = readl(priv->io_base + sunxi_CTRL);
+		ctrl &= ~codec_OPMODE_MASK;
+		ctrl |= codec_OPMODE_OFF;
+		writel(ctrl, priv->io_base + sunxi_CTRL);
+#endif
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sunxi_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+#ifdef JDS
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	u32 val;
+
+	priv->saved_params.mute = mute;
+	val = readl(priv->io_base + sunxi_CTRL);
+	val &= ~codec_OPMODE_MASK;
+
+	if (mute)
+		val |= codec_OPMODE_MUTE_PCM;
+	else {
+		if (priv->running)
+			val |= codec_OPMODE_AUD_DATA | codec_STATE_NORMAL;
+		else
+			val |= codec_OPMODE_OFF;
+	}
+
+	writel(val, priv->io_base + sunxi_CTRL);
+#endif
+	return 0;
+}
+
+static int codec_mute_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	ucontrol->value.integer.value[0] = priv->saved_params.mute;
+	return 0;
+}
+
+static int codec_mute_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	if (priv->saved_params.mute == ucontrol->value.integer.value[0])
+		return 0;
+
+	sunxi_digital_mute(cpu_dai, ucontrol->value.integer.value[0]);
+
+	return 1;
+}
+
+#ifdef JDS
+static void codec_resume_events(struct work_struct *work)
+{
+	printk("%s,%d\n", __func__, __LINE__);
+
+	if (priv->id == SUN7I) {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	else
+		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1, DAC_EN, 0x1);
+
+	msleep(20);
+	//enable PA
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x1);
+	msleep(550);
+	//enable dac analog
+
+	if (priv->id == SUN7I) {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x1);
+		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1, 8, 0x0);
+	} else {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x1);
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x1);
+
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACPAS, 0x1);
+	}
+	if (gpio_pa_shutdown) {
+		msleep(50);
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+	}
+}
+#endif
+
+
+
+/**
+ *	codec_reset - reset the codec
+ * @codec	SoC Audio Codec
+ * Reset the codec, set the register of codec default value
+ * Return 0 for success
+ */
+static int codec_init(struct card_data *priv)
+{
+	//enable dac digital
+	regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1 << DAC_EN, 0x1 << DAC_EN);
+
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << 28, 0x1 << 28);
+	//set digital volume to maximum
+	if (priv->id == SUN4A)
+		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x6 << DIGITAL_VOL, 0x0 << DIGITAL_VOL);
+
+	//pa mute
+	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
+	//enable PA
+	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << PA_ENABLE, 0x1 << PA_ENABLE);
+	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x3 << DRA_LEVEL, 0x3 << DRA_LEVEL);
+	//set volume
+	if ((priv->id == SUN4A) || (priv->id == SUN4I)) {
+		int device_lr_change = 0;
+		if (priv->id == SUN4A)
+			regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x01 << VOLUME);
+		else 
+			regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x3b << VOLUME);
+#ifdef JDS
+		rc = script_parser_fetch("audio_para", "audio_lr_change", &device_lr_change, 1);
+		if (rc != SCRIPT_AUDIO_OK) {
+			pr_err("No audio_lr_change in fex audio_para\n");
+			return -1;
+		}
+#endif
+		if (device_lr_change)
+			regmap_update_bits(priv->regmap, SUNXI_DAC_DEBUG, 0x1 << DAC_CHANNEL, 0x1 << DAC_CHANNEL);
+	} else {
+		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x3b << VOLUME);
+	}
+	return 0;
+}
+
+
+/*	对sunxi-codec.c各寄存器的各种设定，或读取。主要实现函数有三个.
+ * 	.info = snd_codec_info_volsw, .get = snd_codec_get_volsw,\.put = snd_codec_put_volsw,
+ * It should be noted that the only difference between sunxi and sun5i is the Master Playback Volume
+ */
+static const struct snd_kcontrol_new sun4i_dac[] = {
+	//FOR B C VERSION
+	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
+	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	SOC_SINGLE("Fm Volume", SUNXI_DAC_ACTL, 23, 7, 0), //Fm 音量
+	SOC_SINGLE("Line Volume", SUNXI_DAC_ACTL, 26, 1, 0), //Line音量
+	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
+	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+};
+
+static const struct snd_kcontrol_new sun4a_dac[] = {
+	//For A VERSION
+	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_DPC, 12, 0x3f, 0), //62 steps, 3e + 1 = 3f 主音量控制
+	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	SOC_SINGLE("Fm Volume", SUNXI_DAC_ACTL, 23, 7, 0), //Fm 音量
+	SOC_SINGLE("Line Volume", SUNXI_DAC_ACTL, 26, 1, 0), //Line音量
+	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
+	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+};
+
+static const struct snd_kcontrol_new sunxi_adc_controls[] = { 
+	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
+	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
+	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0),
+	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0), //录音音量
+	SOC_SINGLE("Line Capture Volume", SUNXI_ADC_ACTL, 13, 7, 0), 
+	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
+	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
+	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
+	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
+	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
+	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
+};
+
+static const struct snd_kcontrol_new sun7i_dac_ctls[] = {
+	/*SUNXI_DAC_ACTL = 0x10,PAVOL*/
+	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
+	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0), 
+	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+	SOC_SINGLE("MIC output volume", SUNXI_DAC_ACTL, 20, 7, 0),
+	/*	FM Input to output mixer Gain Control
+	* 	From -4.5db to 6db,1.5db/step,default is 0db
+	*	-4.5db:0x0,-3.0db:0x1,-1.5db:0x2,0db:0x3
+	*	1.5db:0x4,3.0db:0x5,4.5db:0x6,6db:0x7
+	*/
+	SOC_SINGLE("Fm output Volume", SUNXI_DAC_ACTL, 23, 7, 0),
+	/*	Line-in gain stage to output mixer Gain Control
+	*	0:-1.5db,1:0db
+	*/
+	SOC_SINGLE("Line output Volume", SUNXI_DAC_ACTL, 26, 1, 0),
+};
+
+static const struct snd_kcontrol_new sun7i_adc_ctls[] = { 
+	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
+	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
+	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0), 
+	SOC_SINGLE("Linein Pre-AMP", SUNXI_ADC_ACTL, 13, 7, 0), 
+	SOC_SINGLE("LINEIN APM Volume", SUNXI_MIC_CRT, 13, 0x7, 0),
+	/* ADC Input Gain Control, capture volume
+	* 000:-4.5db,001:-3db,010:-1.5db,011:0db,100:1.5db,101:3db,110:4.5db,111:6db
+	*/
+	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0),
+	/*
+	*	MIC2 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
+	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
+	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
+	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
+	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
+	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
+	SOC_SINGLE("Mic2 gain Volume", SUNXI_MIC_CRT, 26, 7, 0),
+	/*
+	*	MIC1 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	SOC_SINGLE("Mic1 gain Volume", SUNXI_MIC_CRT, 29, 3, 0), 
+};
+
+
+
+static int sunxi_soc_dai_probe(struct snd_soc_dai *dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	struct snd_dmaengine_dai_dma_data *playback_dma_data;
+	struct snd_dmaengine_dai_dma_data *capture_dma_data;
+
+	playback_dma_data = devm_kzalloc(dai->dev,
+					 sizeof(*playback_dma_data),
+					 GFP_KERNEL);
+	if (!playback_dma_data)
+		return -ENOMEM;
+
+	capture_dma_data = devm_kzalloc(dai->dev,
+					sizeof(*capture_dma_data),
+					GFP_KERNEL);
+	if (!capture_dma_data)
+		return -ENOMEM;
+
+	playback_dma_data->addr = priv->codec_phys + SUNXI_DAC_TXDATA;
+	capture_dma_data->addr = priv->codec_phys + SUNXI_ADC_RXDATA;
+
+	playback_dma_data->maxburst = 4;
+	capture_dma_data->maxburst = 4;
+
+	playback_dma_data->addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	playback_dma_data->addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	snd_soc_dai_init_dma_data(dai, playback_dma_data, capture_dma_data);
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_dai_ops = {
+	.digital_mute	= sunxi_digital_mute,
+	.startup	= sunxi_startup,
+	.shutdown	= sunxi_shutdown,
+	.trigger	= sunxi_trigger,
+	.hw_params	= sunxi_hw_params,
+};
+
+static struct snd_soc_dai_driver sunxi_dai = {
+	.name		= "cat",
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+				 SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | \
+				 SNDRV_PCM_RATE_192000),
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.probe = sunxi_soc_dai_probe,
+	.ops = &sunxi_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_component = {
+	.name		= "horse",
+};
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S20_3LE | \
+			SNDRV_PCM_FMTBIT_S24_LE)
+
+unsigned int read(struct snd_soc_codec *codec, unsigned int reg);
+int write(struct snd_soc_codec *, unsigned int reg, unsigned int);
+
+
+static struct snd_soc_codec_driver soc_codec_sun4a_codec = {
+	.controls = sun4a_dac,
+	.num_controls = ARRAY_SIZE(sun4a_dac),
+};
+
+static struct snd_soc_codec_driver soc_codec_sun4i_codec = {
+	.controls = sun4i_dac,
+	.num_controls = ARRAY_SIZE(sun4i_dac),
+};
+
+static struct snd_soc_codec_driver soc_codec_sun7i_codec = {
+	.controls = sun7i_dac_ctls,
+	.num_controls = ARRAY_SIZE(sun7i_dac_ctls),
+};
+
+static struct snd_soc_dai_driver dit_stub_dai = {
+	.name		= "dog",
+	.playback 	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 384,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+};
+
+static const struct regmap_config sunxi_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_MIC_CRT,
+};
+
+static const struct of_device_id snd_sunxi_codec_ids[] = {
+	{ .compatible = "allwinner,sun4i-a10a-codec", .data = (void *)SUN4A},
+	{ .compatible = "allwinner,sun4i-a10-codec", .data = (void *)SUN4I},
+	{ .compatible = "allwinner,sun5i-a13-codec", .data = (void *)SUN5I},
+	{ .compatible = "allwinner,sun7i-a20-codec", .data = (void *)SUN7I},
+	{}
+};
+MODULE_DEVICE_TABLE(of, snd_sunxi_codec_ids);
+
+static int sunxi_codec_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct card_data *priv;
+	struct resource res;
+	int ret;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	of_id = of_match_device(snd_sunxi_codec_ids, &pdev->dev);
+	if (!of_id)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "could not allocate DAI object\n");
+		return -ENOMEM;
+	}
+	
+	priv->id = (int)of_id->data;
+
+	/* Get the addresses and IRQ */
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		dev_err(&pdev->dev, "could not determine device resources\n");
+		return ret;
+	}
+	priv->baseaddr = of_iomap(np, 0);
+	if (!priv->baseaddr) {
+		dev_err(&pdev->dev, "could not map device resources\n");
+		return -ENOMEM;
+	}
+	priv->codec_phys = res.start;
+
+	priv->regmap = devm_regmap_init_mmio(&pdev->dev, priv->baseaddr, &sunxi_regmap_config);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	priv->irq = irq_of_parse_and_map(np, 0);
+	if (!priv->irq) {
+		dev_err(&pdev->dev, "no irq for node %s\n", np->full_name);
+		return -ENXIO;
+	}
+
+	/* Clock */
+	priv->codec_apbclk = devm_clk_get(dev, "apb");
+	if (IS_ERR(priv->codec_apbclk)) {
+		dev_err(dev, "failed to get apb clock.\n");
+		return PTR_ERR(priv->codec_apbclk);
+	}
+	priv->codec_pll2clk = devm_clk_get(dev, "pll2");
+	if (IS_ERR(priv->codec_pll2clk)) {
+		dev_err(dev, "failed to get pll2 clock.\n");
+		return PTR_ERR(priv->codec_pll2clk);
+	}
+	priv->codec_moduleclk = devm_clk_get(dev, "codec");
+	if (IS_ERR(priv->codec_moduleclk)) {
+		dev_err(dev, "failed to get codec clock.\n");
+		return PTR_ERR(priv->codec_moduleclk);
+	}
+	ret = clk_set_rate(priv->codec_pll2clk, 24576000);
+	if (ret) {
+		dev_err(dev, "set codec base clock failed!\n");
+		return ret;
+	}
+	if (clk_prepare_enable(priv->codec_pll2clk)) {
+		dev_err(dev, "try to enable codec_pll2clk failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(priv->codec_apbclk)) {
+		dev_err(dev, "try to enable apb_codec_clk failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(priv->codec_moduleclk)) {
+		dev_err(dev, "try to enable codec failed\n");
+		ret = -EINVAL;
+		goto exit_clkdisable_apb_clk;
+	}
+	dev_set_drvdata(&pdev->dev, priv);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_component, &sunxi_dai, 1);
+	if (ret)
+		return ret;
+
+	switch (priv->id) {
+	case SUN4A:
+		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun4a_codec, &dit_stub_dai, 1);
+	case SUN4I:
+	case SUN5I:
+		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun4i_codec, &dit_stub_dai, 1);
+	case SUN7I:
+		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun7i_codec, &dit_stub_dai, 1);
+	}
+	if (ret)
+		return ret;
+
+	snd_dmaengine_pcm_register(&pdev->dev, NULL, SND_DMAENGINE_PCM_FLAG_NO_RESIDUE);
+
+	codec_init(priv);
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+
+	resume_work_queue = create_singlethread_workqueue("codec_resume");
+	if (resume_work_queue == NULL) {
+		printk("[su4i-codec] try to create workqueue for codec failed!\n");
+		ret = -ENOMEM;
+		goto err_resume_work_queue;
+	}
+#endif
+	printk("JDS - codec driver success registered\n");
+	return ret;
+
+err_resume_work_queue:
+exit_clkdisable_apb_clk:
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int snd_sunxi_codec_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct card_data *priv = dev_get_drvdata(&pdev->dev);
+
+	if (priv->running)
+		clk_disable(priv->codec_moduleclk);
+
+	return 0;
+}
+
+static int snd_sunxi_codec_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct card_data *priv = dev_get_drvdata(&pdev->dev);
+
+	if (priv->running) {
+		clk_enable(priv->codec_moduleclk);
+		sunxi_configure(priv);
+		sunxi_clock(priv, priv->saved_params.core_freq,
+				priv->saved_params.rate);
+	}
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(sunxi_dev_pm_ops, snd_sunxi_codec_suspend, \
+		snd_sunxi_codec_resume);
+
+#define sunxi_DEV_PM_OPS (&sunxi_dev_pm_ops)
+
+#else
+#define sunxi_DEV_PM_OPS NULL
+
+#endif
+
+static int sunxi_codec_remove(struct platform_device *pdev)
+{
+#ifdef JDS
+	clk_disable(codec_moduleclk);
+	//释放codec_pll2clk时钟句柄
+	clk_put(codec_pll2clk);
+	//释放codec_apbclk时钟句柄
+	clk_put(codec_apbclk);
+
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+#endif
+	return 0;
+	snd_dmaengine_pcm_unregister(&pdev->dev);
+}
+
+static void sunxi_codec_shutdown(struct platform_device *devptr)
+{
+#ifdef JDS
+	if (gpio_pa_shutdown) {
+//JDS		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+		mdelay(50);
+	}
+	regmap_update_bits(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x0);
+	mdelay(100);
+	//pa mute
+	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	mdelay(500);
+	//disable dac analog
+	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x0);
+	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x0);
+
+	//disable dac to pa
+	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x0);
+	regmap_update_bits(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x0);
+
+	clk_disable(codec_moduleclk);
+#endif
+}
+
+/*method relating*/
+static struct platform_driver sunxi_codec_driver =
+{
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_remove,
+	.shutdown = sunxi_codec_shutdown,
+#ifdef CONFIG_PM
+//JDS	.suspend = snd_sunxi_codec_suspend,
+//JDS	.resume = snd_sunxi_codec_resume,
+#endif
+	.driver = {
+		.name = "sunxi-codec",
+		.of_match_table = snd_sunxi_codec_ids,
+	},
+};
+
+module_platform_driver(sunxi_codec_driver);
+
+MODULE_ALIAS("platform:sunxi-codec-dai");
+MODULE_DESCRIPTION("sunxi CODEC ALSA codec driver");
+MODULE_AUTHOR("software");
+MODULE_LICENSE("GPL v2");
+
diff --git a/sound/soc/sunxi/stub.c b/sound/soc/sunxi/stub.c
new file mode 100644
index 0000000..a0bfc81
--- /dev/null
+++ b/sound/soc/sunxi/stub.c
@@ -0,0 +1,97 @@
+/*
+ * ALSA SoC SPDIF DIT driver
+ *
+ *  This driver is used by controllers which can operate in DIT (SPDI/F) where
+ *  no codec is needed.  This file provides stub codec that can be used
+ *  in these configurations. TI DaVinci Audio controller uses this driver.
+ *
+ * Author:      Steve Chen,  <schen@mvista.com>
+ * Copyright:   (C) 2009 MontaVista Software, Inc., <source@mvista.com>
+ * Copyright:   (C) 2009  Texas Instruments, India
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <linux/of.h>
+
+#define DRV_NAME "spdif-dit"
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S20_3LE | \
+			SNDRV_PCM_FMTBIT_S24_LE)
+
+static const struct snd_soc_dapm_widget dit_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("spdif-out"),
+	SND_SOC_DAPM_OUTPUT("Mic Bias"),
+	SND_SOC_DAPM_OUTPUT("HP_OUT"),
+	SND_SOC_DAPM_INPUT("MIC_IN"),
+	SND_SOC_DAPM_INPUT("LINE_IN"),
+};
+
+static const struct snd_soc_dapm_route dit_routes[] = {
+	{ "spdif-out", NULL, "Playback" },
+};
+
+static struct snd_soc_codec_driver soc_codec_spdif_dit = {
+	.dapm_widgets = dit_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(dit_widgets),
+	.dapm_routes = dit_routes,
+	.num_dapm_routes = ARRAY_SIZE(dit_routes),
+};
+
+static struct snd_soc_dai_driver dit_stub_dai = {
+	.name		= "awstub",
+	.playback 	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 384,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+};
+
+static int spdif_dit_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_spdif_dit,
+			&dit_stub_dai, 1);
+}
+
+static int spdif_dit_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id spdif_dit_dt_ids[] = {
+	{ .compatible = "allwinner,stub", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, spdif_dit_dt_ids);
+#endif
+
+static struct platform_driver spdif_dit_driver = {
+	.probe		= spdif_dit_probe,
+	.remove		= spdif_dit_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(spdif_dit_dt_ids),
+	},
+};
+
+module_platform_driver(spdif_dit_driver);
+
+MODULE_AUTHOR("Steve Chen <schen@mvista.com>");
+MODULE_DESCRIPTION("SPDIF dummy codec driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/sunxi/sunxi_codec_main.c b/sound/soc/sunxi/sunxi_codec_main.c
index 5143b42..8ecca97 100644
--- a/sound/soc/sunxi/sunxi_codec_main.c
+++ b/sound/soc/sunxi/sunxi_codec_main.c
@@ -1,748 +1,554 @@
 /*
- * ALSA SoC codec Out Audio Layer for spear processors
  *
- * Copyright (C) 2012 ST Microelectronics
- * Vipin Kumar <vipin.kumar@st.com>
- *
- * This file is licensed under the terms of the GNU General Public
- * License version 2. This program is licensed "as is" without any
- * warranty of any kind, whether express or implied.
+ * Licensed under the GPL-2.
  */
 
-#include <linux/clk.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/io.h>
-#include <linux/ioport.h>
+#include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of.h>
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/of_address.h>
+#include <linux/clk.h>
 #include <linux/regmap.h>
-#include <sound/dmaengine_pcm.h>
+
 #include <sound/core.h>
-#include <sound/soc.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
-#include <sound/control.h>
+#include <sound/soc.h>
 #include <sound/initval.h>
-#include "sunxi-codec.h"
+#include <sound/dmaengine_pcm.h>
 
-static void codec_resume_events(struct work_struct *work);
-struct workqueue_struct *resume_work_queue;
-static DECLARE_WORK(codec_resume_work, codec_resume_events);
+//Codec Register
+#define SUNXI_DAC_DPC                (0x00)
+#define SUNXI_DAC_FIFOC              (0x04)
+#define SUNXI_DAC_FIFOS              (0x08)
+#define SUNXI_DAC_TXDATA             (0x0c)
+#define SUNXI_DAC_ACTL               (0x10)
+#define SUNXI_DAC_TUNE               (0x14)
+#define SUNXI_DAC_DEBUG              (0x18)
+#define SUNXI_ADC_FIFOC              (0x1c)
+#define SUNXI_ADC_FIFOS              (0x20)
+#define SUNXI_ADC_RXDATA             (0x24)
+#define SUNXI_ADC_ACTL               (0x28)
+#define SUNXI_ADC_DEBUG              (0x2c)
+#define SUNXI_DAC_TXCNT              (0x30)
+#define SUNXI_ADC_RXCNT              (0x34)
+#define SUNXI_BIAS_CRT               (0x38)
+#define SUNXI_MIC_CRT                (0x3c)
+#define SUNXI_CODEC_REGS_NUM         (13)
+
+#define DAIFMT_16BITS             (16)
+#define DAIFMT_20BITS             (20)
+
+#define DAIFMT_BS_MASK            (~(1<<16))  	//FIFO big small mode mask
+#define DAIFMT_BITS_MASK          (~(1<<5))		//FIFO Bits select mask,not used yet.
+#define SAMPLE_RATE_MASK          (~(7<<29))  	//Sample Rate slect mask
+
+#define DAC_EN                    (31)
+#define DIGITAL_VOL               (12)
+//For CODEC OLD VERSION
+#define DAC_VERSION               (23)
+
+#define DAC_CHANNEL		  (6)
+#define LAST_SE                   (26)
+#define TX_FIFO_MODE              (24)
+#define DRA_LEVEL                 (21)
+#define TX_TRI_LEVEL              (8)
+#define DAC_MODE                  (6)			//not used yet
+#define TASR                      (5)			//not used yet
+#define DAC_DRQ                   (4)
+#define DAC_FIFO_FLUSH            (0)
+
+#define VOLUME                    (0)
+#define PA_MUTE                   (6)
+#define MIXPAS                    (7)
+#define DACPAS                    (8)
+#define MIXEN                     (29)
+#define DACAEN_L                  (30)
+#define DACAEN_R                  (31)
+
+#define ADC_DIG_EN                (28)
+#define RX_FIFO_MODE              (24)
+#define RX_TRI_LEVEL              (8)
+#define ADC_MODE                  (7)
+#define RASR                      (6)
+#define ADC_DRQ                   (4)
+#define ADC_FIFO_FLUSH            (0)
+
+#define  ADC_LF_EN                (31)
+#define  ADC_RI_EN                (30)
+#define  ADC_EN                   (30)
+#define  MIC1_EN                  (29)
+#define  MIC2_EN                  (28)
+#define  VMIC_EN                  (27)
+#define  MIC_GAIN                 (25)
+#define  ADC_SELECT               (17)
+#define  PA_ENABLE                (4)
+#define  HP_DIRECT                (3)
+
+
+enum sunxi_device_id {SUN4A, SUN4I, SUN5I, SUN7I}; 
+
+struct sunxi_codec {
+	struct regmap *regmap;
+	int irq;
+	struct clk *clk_apb, *clk_pll2, *clk_module;
+
+	enum sunxi_device_id id;
+
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+
+	struct snd_ratnum ratnum;
+	struct snd_pcm_hw_constraint_ratnums rate_constraints;
+};
 
-static void sunxi_configure(struct card_data *priv)
+static int codec_play_start(struct sunxi_codec *codec)
 {
 #ifdef JDS
-	writel(sunxi_RESET, priv->io_base + sunxi_SOFT_RST);
-	mdelay(1);
-	writel(readl(priv->io_base + sunxi_SOFT_RST) & ~sunxi_RESET,
-			priv->io_base + sunxi_SOFT_RST);
-
-	writel(sunxi_FDMA_TRIG_16 | sunxi_MEMFMT_16_16 |
-			sunxi_VALID_HW | sunxi_USER_HW |
-			sunxi_CHNLSTA_HW | sunxi_PARITY_HW,
-			priv->io_base + sunxi_CFG);
-
-	writel(0x7F, priv->io_base + sunxi_INT_STA_CLR);
-	writel(0x7F, priv->io_base + sunxi_INT_EN_CLR);
-#endif 
-}
-
-static int sunxi_startup(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *cpu_dai)
-{
-	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
-	int ret;
-
-	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
-		return -EINVAL;
-
-	ret = clk_enable(priv->codec_moduleclk);
-	if (ret)
-		return ret;
-
-	priv->running = true;
-	sunxi_configure(priv);
-
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+#endif
+	//flush TX FIFO
+	regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_FIFO_FLUSH, 0x1 << DAC_FIFO_FLUSH);
+	//enable dac drq
+	regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_DRQ, 0x1 << DAC_DRQ);
 	return 0;
 }
 
-static void sunxi_shutdown(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
+static int codec_play_stop(struct sunxi_codec *codec)
 {
-	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
-
-	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
-		return;
-
-	clk_disable(priv->codec_moduleclk);
-	priv->running = false;
+	//pa mute
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+#endif
+	regmap_update_bits(codec->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
+	mdelay(5);
+	//disable dac drq
+	regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_DRQ, 0x0 << DAC_DRQ);
+	//pa mute
+	regmap_update_bits(codec->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
+	regmap_update_bits(codec->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_L, 0x0 << DACAEN_L);
+	regmap_update_bits(codec->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_R, 0x0 << DACAEN_R);
+	return 0;
 }
 
-static void sunxi_clock(struct card_data *priv, u32 core_freq,
-		u32 rate)
+static int codec_capture_start(struct sunxi_codec *codec)
 {
+	//enable adc drq
 #ifdef JDS
-	u32 divider, ctrl;
-	clk_set_rate(priv->clk, core_freq);
-	divider = DIV_ROUND_CLOSEST(clk_get_rate(priv->clk), (rate * 128));
-
-	ctrl = readl(priv->io_base + sunxi_CTRL);
-	ctrl &= ~codec_DIVIDER_MASK;
-	ctrl |= (divider << codec_DIVIDER_SHIFT) & codec_DIVIDER_MASK;
-	writel(ctrl, priv->io_base + sunxi_CTRL);
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
 #endif
+	regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DRQ, 0x1 << ADC_DRQ);
+	return 0;
 }
 
-static int sunxi_hw_params(struct snd_pcm_substream *substream,
-		struct snd_pcm_hw_params *params,
-		struct snd_soc_dai *dai)
+static int codec_capture_stop(struct sunxi_codec *codec)
 {
-	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
-	u32 rate, core_freq;
-
-	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
-		return -EINVAL;
-
-	rate = params_rate(params);
-
-	switch (rate) {
-	case 8000:
-	case 16000:
-	case 32000:
-	case 64000:
-		/*
-		 * The clock is multiplied by 10 to bring it to feasible range
-		 * of frequencies for sscg
-		 */
-		core_freq = 64000 * 128 * 10;	/* 81.92 MHz */
-		break;
-	case 5512:
-	case 11025:
-	case 22050:
-	case 44100:
-	case 88200:
-	case 176400:
-		core_freq = 176400 * 128;	/* 22.5792 MHz */
-		break;
-	case 48000:
-	case 96000:
-	case 192000:
-	default:
-		core_freq = 192000 * 128;	/* 24.576 MHz */
-		break;
+	//disable adc drq
+	regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DRQ, 0x0 << ADC_DRQ);
+	//enable mic1 pa
+	regmap_update_bits(codec->regmap, SUNXI_ADC_ACTL, 0x1 << MIC1_EN, 0x0 << MIC1_EN);
+	//enable VMIC
+	regmap_update_bits(codec->regmap, SUNXI_ADC_ACTL, 0x1 << VMIC_EN, 0x0 << VMIC_EN);
+	if (codec->id == SUN7I) {
+		regmap_update_bits(codec->regmap, SUNXI_DAC_TUNE, 0x3 << 8, 0x0 << 8);
 	}
-
-	sunxi_clock(priv, core_freq, rate);
-	priv->saved_params.core_freq = core_freq;
-	priv->saved_params.rate = rate;
-
+	//enable adc digital
+	regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DIG_EN, 0x0 << ADC_DIG_EN);
+	//set RX FIFO mode
+	regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 0x1 << RX_FIFO_MODE, 0x0 << RX_FIFO_MODE);
+	//flush RX FIFO
+	regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_FIFO_FLUSH, 0x0 << ADC_FIFO_FLUSH);
+	//enable adc1 analog
+	regmap_update_bits(codec->regmap, SUNXI_ADC_ACTL, 0x3 << ADC_EN, 0x0 << ADC_EN);
 	return 0;
 }
 
-static int sunxi_trigger(struct snd_pcm_substream *substream, int cmd,
-		struct snd_soc_dai *dai)
+static int sunxi_codec_trigger(struct snd_pcm_substream *substream, int cmd,
+	struct snd_soc_dai *dai)
 {
-#ifdef JDS
-	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
-	u32 ctrl;
-#endif
-	int ret = 0;
-
-	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
-		return -EINVAL;
+	struct sunxi_codec *codec = snd_soc_dai_get_drvdata(dai);
 
+	printk("JDS - sunxi_codec_trigger cmd %d\n", cmd);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-#ifdef JDS		
-			ctrl = readl(priv->io_base + sunxi_CTRL);
-			ctrl &= ~codec_OPMODE_MASK;
-			if (!priv->saved_params.mute)
-				ctrl |= codec_OPMODE_AUD_DATA |
-					codec_STATE_NORMAL;
-			else
-				ctrl |= codec_OPMODE_MUTE_PCM;
-			writel(ctrl, priv->io_base + sunxi_CTRL);
-#endif
-		break;
-
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			codec_capture_start(codec);
+		else
+			codec_play_start(codec);
+		break;		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-#ifdef JDS		
-		ctrl = readl(priv->io_base + sunxi_CTRL);
-		ctrl &= ~codec_OPMODE_MASK;
-		ctrl |= codec_OPMODE_OFF;
-		writel(ctrl, priv->io_base + sunxi_CTRL);
-#endif
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			codec_capture_stop(codec);
+		else
+			codec_play_stop(codec);
 		break;
-
 	default:
-		ret = -EINVAL;
-		break;
-	}
-	return ret;
-}
-
-static int sunxi_digital_mute(struct snd_soc_dai *dai, int mute)
-{
-#ifdef JDS
-	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
-	u32 val;
-
-	priv->saved_params.mute = mute;
-	val = readl(priv->io_base + sunxi_CTRL);
-	val &= ~codec_OPMODE_MASK;
-
-	if (mute)
-		val |= codec_OPMODE_MUTE_PCM;
-	else {
-		if (priv->running)
-			val |= codec_OPMODE_AUD_DATA | codec_STATE_NORMAL;
-		else
-			val |= codec_OPMODE_OFF;
+		return -EINVAL;
 	}
-
-	writel(val, priv->io_base + sunxi_CTRL);
-#endif
 	return 0;
 }
 
-static int codec_mute_get(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
+static int sunxi_codec_prepare(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)
 {
-	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
-	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	struct sunxi_codec *codec = snd_soc_dai_get_drvdata(dai);
+
+	printk("JDS - sunxi_codec_prepare\n");
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		regmap_update_bits(codec->regmap, SUNXI_DAC_DPC, 0x1 << DAC_EN, 0x1 << DAC_EN);
+		regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 0x1 << DAC_FIFO_FLUSH, 0x1 << DAC_FIFO_FLUSH);
+		//set TX FIFO send drq level
+		regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 0xf << TX_TRI_LEVEL, 0xf << TX_TRI_LEVEL);
+		if (substream->runtime->rate > 32000) {
+			regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 0x1 << 28, 0x0 << 28);
+		} else {
+			regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 0x1 << 28, 0x1 << 28);
+		}
+		//set TX FIFO MODE
+		regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 0x1 << TX_FIFO_MODE, 0x1 << TX_FIFO_MODE);
+		//send last sample when dac fifo under run
+		regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 0x1 << LAST_SE, 0x0 << LAST_SE);
+		//enable dac analog
+		regmap_update_bits(codec->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_L, 0x1 << DACAEN_L);
+		regmap_update_bits(codec->regmap, SUNXI_DAC_ACTL, 0x1 << DACAEN_R, 0x1 << DACAEN_R);
+		//enable dac to pa
+		regmap_update_bits(codec->regmap, SUNXI_DAC_ACTL, 0x1 << DACPAS, 0x1 << DACPAS);
+	} else {
+		//enable mic1 pa
+		regmap_update_bits(codec->regmap, SUNXI_ADC_ACTL, 0x1 << MIC1_EN, 0x1 << MIC1_EN);
+		//mic1 gain 32dB
+		regmap_update_bits(codec->regmap, SUNXI_ADC_ACTL, 0x3 << 25, 0x1 << 25);
+		//enable VMIC
+		regmap_update_bits(codec->regmap, SUNXI_ADC_ACTL, 0x1 << VMIC_EN, 0x1 << VMIC_EN);
+
+		if (codec->id == SUN7I) {
+			/* boost up record effect */
+			regmap_update_bits(codec->regmap, SUNXI_DAC_TUNE, 0x3 << 8, 0x1 << 8);
+		}
 
-	ucontrol->value.integer.value[0] = priv->saved_params.mute;
+		//enable adc digital
+		regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_DIG_EN, 0x1 << ADC_DIG_EN);
+		//set RX FIFO mode
+		regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 0x1 << RX_FIFO_MODE, 0x1 << RX_FIFO_MODE);
+		//flush RX FIFO
+		regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 0x1 << ADC_FIFO_FLUSH, 0x1 << ADC_FIFO_FLUSH);
+		//set RX FIFO rec drq level
+		regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 0xf << RX_TRI_LEVEL, 0x7 << RX_TRI_LEVEL);
+		//enable adc1 analog
+		regmap_update_bits(codec->regmap, SUNXI_ADC_ACTL, 0x3 << ADC_EN, 0x3 << ADC_EN);
+	}
 	return 0;
 }
 
-static int codec_mute_put(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
+static int sunxi_codec_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
 {
-	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
-	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
-
-	if (priv->saved_params.mute == ucontrol->value.integer.value[0])
-		return 0;
-
-	sunxi_digital_mute(cpu_dai, ucontrol->value.integer.value[0]);
-
-	return 1;
-}
+	struct sunxi_codec *codec = snd_soc_dai_get_drvdata(dai);
+	unsigned int rate = params_rate(params);
 
-#ifdef JDS
-static void codec_resume_events(struct work_struct *work)
-{
-	printk("%s,%d\n", __func__, __LINE__);
-
-	if (priv->id == SUN7I) {
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
-	else
-		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1, DAC_EN, 0x1);
-
-	msleep(20);
-	//enable PA
-	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x1);
-	msleep(550);
-	//enable dac analog
-
-	if (priv->id == SUN7I) {
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x1);
-		regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1, 8, 0x0);
-	} else {
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x1);
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x1);
+	printk("JDS - sunxi_codec_hw_params\n");
+	switch (params_rate(params)) {
+	case 44100:
+	case 22050:
+	case 11025:
+	default:
+		clk_set_rate(codec->clk_pll2, 22579200);
+		clk_set_rate(codec->clk_module, 22579200);
+		break;
+	case 192000:
+	case 96000:
+	case 48000:
+	case 32000:
+	case 24000:
+	case 16000:
+	case 12000:
+	case 8000:
+		clk_set_rate(codec->clk_pll2, 24576000);
+		clk_set_rate(codec->clk_module, 24576000);
+		break;
+	}
 
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1, DACPAS, 0x1);
+	switch (params_rate(params)) {
+	default:
+	case 44100:
+		rate = 0;
+		break;
+	case 22050:
+		rate = 2;
+		break;
+	case 11025:
+		rate = 4;
+		break;
+	case 192000:
+		rate = 6;
+		break;
+	case 96000:
+		rate = 7;
+		break;
+	case 48000:
+		rate = 0;
+		break;
+	case 32000:
+		rate = 1;
+		break;
+	case 24000:
+		rate = 2;
+		break;
+	case 16000:
+		rate = 3;
+		break;
+	case 12000:
+		rate = 4;
+		break;
+	case 8000:
+		rate = 5;
+		break;
 	}
-	if (gpio_pa_shutdown) {
-		msleep(50);
-		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 7 << 29, rate << 29);
+		if (substream->runtime->channels == 1)
+			regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 1 << 6, 1 << 6);
+		else
+			regmap_update_bits(codec->regmap, SUNXI_DAC_FIFOC, 1 << 6, 0 << 6);
+	} else  {
+		regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 7 << 29, rate << 29);
+		if (substream->runtime->channels == 1)
+			regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 1 << 7, 1 << 7);
+		else
+			regmap_update_bits(codec->regmap, SUNXI_ADC_FIFOC, 1 << 7, 0 << 7);
 	}
+	return 0;
 }
-#endif
-
-
 
-/**
- *	codec_reset - reset the codec
- * @codec	SoC Audio Codec
- * Reset the codec, set the register of codec default value
- * Return 0 for success
- */
-static int codec_init(struct card_data *priv)
+static int sunxi_codec_dai_probe(struct snd_soc_dai *dai)
 {
-	//enable dac digital
-	regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x1 << DAC_EN, 0x1 << DAC_EN);
+	struct sunxi_codec *codec = snd_soc_dai_get_drvdata(dai);
 
-	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x1 << 28, 0x1 << 28);
-	//set digital volume to maximum
-	if (priv->id == SUN4A)
-		regmap_update_bits(priv->regmap, SUNXI_DAC_DPC, 0x6 << DIGITAL_VOL, 0x0 << DIGITAL_VOL);
+	printk("JDS - sunxi_codec_dai_probe\n");
+	snd_soc_dai_init_dma_data(dai, &codec->playback_dma_data, &codec->capture_dma_data);
 
-	//pa mute
-	regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x1 << PA_MUTE, 0x0 << PA_MUTE);
-	//enable PA
-	regmap_update_bits(priv->regmap, SUNXI_ADC_ACTL, 0x1 << PA_ENABLE, 0x1 << PA_ENABLE);
-	regmap_update_bits(priv->regmap, SUNXI_DAC_FIFOC, 0x3 << DRA_LEVEL, 0x3 << DRA_LEVEL);
-	//set volume
-	if ((priv->id == SUN4A) || (priv->id == SUN4I)) {
-		int device_lr_change = 0;
-		if (priv->id == SUN4A)
-			regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x01 << VOLUME);
-		else 
-			regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x3b << VOLUME);
-#ifdef JDS
-		rc = script_parser_fetch("audio_para", "audio_lr_change", &device_lr_change, 1);
-		if (rc != SCRIPT_AUDIO_OK) {
-			pr_err("No audio_lr_change in fex audio_para\n");
-			return -1;
-		}
-#endif
-		if (device_lr_change)
-			regmap_update_bits(priv->regmap, SUNXI_DAC_DEBUG, 0x1 << DAC_CHANNEL, 0x1 << DAC_CHANNEL);
-	} else {
-		regmap_update_bits(priv->regmap, SUNXI_DAC_ACTL, 0x6 << VOLUME, 0x3b << VOLUME);
-	}
 	return 0;
 }
 
+static int sunxi_codec_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct sunxi_codec *codec = snd_soc_dai_get_drvdata(dai);
+	int ret;
+	printk("JDS - sunxi_codec_startup %p %p\n", codec, codec->clk_module);
+#ifdef JDS
 
-/*	对sunxi-codec.c各寄存器的各种设定，或读取。主要实现函数有三个.
- * 	.info = snd_codec_info_volsw, .get = snd_codec_get_volsw,\.put = snd_codec_put_volsw,
- * It should be noted that the only difference between sunxi and sun5i is the Master Playback Volume
- */
-static const struct snd_kcontrol_new sun4i_dac[] = {
-	//FOR B C VERSION
-	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
-	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
-	SOC_SINGLE("Fm Volume", SUNXI_DAC_ACTL, 23, 7, 0), //Fm 音量
-	SOC_SINGLE("Line Volume", SUNXI_DAC_ACTL, 26, 1, 0), //Line音量
-	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
-	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
-	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
-	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
-	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
-	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
-	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
-	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
-};
-
-static const struct snd_kcontrol_new sun4a_dac[] = {
-	//For A VERSION
-	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_DPC, 12, 0x3f, 0), //62 steps, 3e + 1 = 3f 主音量控制
-	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
-	SOC_SINGLE("Fm Volume", SUNXI_DAC_ACTL, 23, 7, 0), //Fm 音量
-	SOC_SINGLE("Line Volume", SUNXI_DAC_ACTL, 26, 1, 0), //Line音量
-	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
-	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
-	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
-	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
-	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
-	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
-	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
-	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
-};
-
-static const struct snd_kcontrol_new sunxi_adc_controls[] = { 
-	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
-	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
-	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0),
-	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0), //录音音量
-	SOC_SINGLE("Line Capture Volume", SUNXI_ADC_ACTL, 13, 7, 0), 
-	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
-	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
-	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
-	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
-	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
-	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
-};
-
-static const struct snd_kcontrol_new sun7i_dac_ctls[] = {
-	/*SUNXI_DAC_ACTL = 0x10,PAVOL*/
-	SOC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
-	SOC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
-	SOC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
-	SOC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
-	SOC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
-	SOC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
-	SOC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
-	SOC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
-	SOC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0), 
-	SOC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
-	SOC_SINGLE("MIC output volume", SUNXI_DAC_ACTL, 20, 7, 0),
-	/*	FM Input to output mixer Gain Control
-	* 	From -4.5db to 6db,1.5db/step,default is 0db
-	*	-4.5db:0x0,-3.0db:0x1,-1.5db:0x2,0db:0x3
-	*	1.5db:0x4,3.0db:0x5,4.5db:0x6,6db:0x7
-	*/
-	SOC_SINGLE("Fm output Volume", SUNXI_DAC_ACTL, 23, 7, 0),
-	/*	Line-in gain stage to output mixer Gain Control
-	*	0:-1.5db,1:0db
-	*/
-	SOC_SINGLE("Line output Volume", SUNXI_DAC_ACTL, 26, 1, 0),
-};
-
-static const struct snd_kcontrol_new sun7i_adc_ctls[] = { 
-	SOC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
-	SOC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
-	SOC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0), 
-	SOC_SINGLE("Linein Pre-AMP", SUNXI_ADC_ACTL, 13, 7, 0), 
-	SOC_SINGLE("LINEIN APM Volume", SUNXI_MIC_CRT, 13, 0x7, 0),
-	/* ADC Input Gain Control, capture volume
-	* 000:-4.5db,001:-3db,010:-1.5db,011:0db,100:1.5db,101:3db,110:4.5db,111:6db
-	*/
-	SOC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0),
-	/*
-	*	MIC2 pre-amplifier Gain Control
-	*	00:0db,01:35db,10:38db,11:41db
-	*/
-	SOC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
-	SOC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
-	SOC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
-	SOC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
-	SOC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
-	SOC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
-	SOC_SINGLE("Mic2 gain Volume", SUNXI_MIC_CRT, 26, 7, 0),
-	/*
-	*	MIC1 pre-amplifier Gain Control
-	*	00:0db,01:35db,10:38db,11:41db
-	*/
-	SOC_SINGLE("Mic1 gain Volume", SUNXI_MIC_CRT, 29, 3, 0), 
-};
+	ret = snd_pcm_hw_constraint_ratnums(substream->runtime, 0,
+			   SNDRV_PCM_HW_PARAM_RATE,
+			   &codec->rate_constraints);
+	if (ret)
+		return ret;
 
+	regmap_update_bits(codec->regmap, SUNXI_SPDIF_REG_CTRL, SUNXI_SPDIF_CTRL_TXEN, SUNXI_SPDIF_CTRL_TXEN);
+#endif
+	ret = clk_prepare_enable(codec->clk_module);
+	if (ret)
+		return ret;
 
+	printk("JDS - sunxi_codec_startup - ok\n");
+	return 0;
+}
 
-static int sunxi_soc_dai_probe(struct snd_soc_dai *dai)
+static void sunxi_codec_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
 {
-	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
-	struct snd_dmaengine_dai_dma_data *playback_dma_data;
-	struct snd_dmaengine_dai_dma_data *capture_dma_data;
-
-	playback_dma_data = devm_kzalloc(dai->dev,
-					 sizeof(*playback_dma_data),
-					 GFP_KERNEL);
-	if (!playback_dma_data)
-		return -ENOMEM;
-
-	capture_dma_data = devm_kzalloc(dai->dev,
-					sizeof(*capture_dma_data),
-					GFP_KERNEL);
-	if (!capture_dma_data)
-		return -ENOMEM;
+	struct sunxi_codec *codec = snd_soc_dai_get_drvdata(dai);
 
-	playback_dma_data->addr = priv->codec_phys + SUNXI_DAC_TXDATA;
-	capture_dma_data->addr = priv->codec_phys + SUNXI_ADC_RXDATA;
+//JDS	regmap_update_bits(codec->regmap, SUNXI_SPDIF_REG_CTRL, SUNXI_SPDIF_CTRL_TXEN, 0);
 
-	playback_dma_data->maxburst = 4;
-	capture_dma_data->maxburst = 4;
-
-	playback_dma_data->addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-	playback_dma_data->addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-
-	snd_soc_dai_init_dma_data(dai, playback_dma_data, capture_dma_data);
-	return 0;
+	printk("JDS - sunxi_codec_shutdown\n");
+	clk_disable_unprepare(codec->clk_module);
 }
 
-static const struct snd_soc_dai_ops sunxi_dai_ops = {
-	.digital_mute	= sunxi_digital_mute,
-	.startup	= sunxi_startup,
-	.shutdown	= sunxi_shutdown,
-	.trigger	= sunxi_trigger,
-	.hw_params	= sunxi_hw_params,
+static const struct snd_soc_dai_ops sunxi_codec_dai_ops = {
+	.startup = sunxi_codec_startup,
+	.shutdown = sunxi_codec_shutdown,
+	.trigger = sunxi_codec_trigger,
+	.hw_params = sunxi_codec_hw_params,
+	.prepare = sunxi_codec_prepare,
 };
 
-static struct snd_soc_dai_driver sunxi_dai = {
-	.name		= "cat",
+static struct snd_soc_dai_driver sunxi_codec_dai = {
+	.probe = sunxi_codec_dai_probe,
 	.playback = {
-		.channels_min = 2,
+		.channels_min = 1,
 		.channels_max = 2,
-		.rates = (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
-				 SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | \
-				 SNDRV_PCM_RATE_192000),
 		.formats = SNDRV_PCM_FMTBIT_S16_LE,
-	},
-	.probe = sunxi_soc_dai_probe,
-	.ops = &sunxi_dai_ops,
-};
-
-static const struct snd_soc_component_driver sunxi_component = {
-	.name		= "horse",
-};
-
-#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
-#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
-			SNDRV_PCM_FMTBIT_S20_3LE | \
-			SNDRV_PCM_FMTBIT_S24_LE)
-
-unsigned int read(struct snd_soc_codec *codec, unsigned int reg);
-int write(struct snd_soc_codec *, unsigned int reg, unsigned int);
-
 
-static struct snd_soc_codec_driver soc_codec_sun4a_codec = {
-	.controls = sun4a_dac,
-	.num_controls = ARRAY_SIZE(sun4a_dac),
-};
-
-static struct snd_soc_codec_driver soc_codec_sun4i_codec = {
-	.controls = sun4i_dac,
-	.num_controls = ARRAY_SIZE(sun4i_dac),
-};
-
-static struct snd_soc_codec_driver soc_codec_sun7i_codec = {
-	.controls = sun7i_dac_ctls,
-	.num_controls = ARRAY_SIZE(sun7i_dac_ctls),
+		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_11025 |\
+			 SNDRV_PCM_RATE_22050| SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\
+			 SNDRV_PCM_RATE_48000 |SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000 |\
+			 SNDRV_PCM_RATE_KNOT),
+		.rate_min = 8000,
+		.rate_max = 192000,
+	},
+	.ops = &sunxi_codec_dai_ops,
 };
 
-static struct snd_soc_dai_driver dit_stub_dai = {
-	.name		= "dog",
-	.playback 	= {
-		.stream_name	= "Playback",
-		.channels_min	= 1,
-		.channels_max	= 384,
-		.rates		= STUB_RATES,
-		.formats	= STUB_FORMATS,
-	},
+static const struct snd_soc_component_driver sunxi_codec_component = {
+	.name = "sunxi-codec",
 };
 
-static const struct regmap_config sunxi_regmap_config = {
+static const struct regmap_config sunxi_codec_regmap_config = {
 	.reg_bits = 32,
 	.reg_stride = 4,
 	.val_bits = 32,
 	.max_register = SUNXI_MIC_CRT,
 };
 
-static const struct of_device_id snd_sunxi_codec_ids[] = {
+static const struct of_device_id sunxi_codec_of_match[] = {
 	{ .compatible = "allwinner,sun4i-a10a-codec", .data = (void *)SUN4A},
 	{ .compatible = "allwinner,sun4i-a10-codec", .data = (void *)SUN4I},
 	{ .compatible = "allwinner,sun5i-a13-codec", .data = (void *)SUN5I},
 	{ .compatible = "allwinner,sun7i-a20-codec", .data = (void *)SUN7I},
 	{}
 };
-MODULE_DEVICE_TABLE(of, snd_sunxi_codec_ids);
+MODULE_DEVICE_TABLE(of, sunxi_codec_of_match);
 
 static int sunxi_codec_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	const struct of_device_id *of_id;
 	struct device *dev = &pdev->dev;
-	struct card_data *priv;
-	struct resource res;
+	struct sunxi_codec *codec;
+	struct resource *res;
+	void __iomem *base;
 	int ret;
 
 	if (!of_device_is_available(np))
 		return -ENODEV;
 
-	of_id = of_match_device(snd_sunxi_codec_ids, &pdev->dev);
+	of_id = of_match_device(sunxi_codec_of_match, dev);
 	if (!of_id)
 		return -EINVAL;
 
-	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
-		dev_err(&pdev->dev, "could not allocate DAI object\n");
+	codec = devm_kzalloc(&pdev->dev, sizeof(*codec), GFP_KERNEL);
+	if (!codec)
 		return -ENOMEM;
-	}
-	
-	priv->id = (int)of_id->data;
 
-	/* Get the addresses and IRQ */
-	ret = of_address_to_resource(np, 0, &res);
-	if (ret) {
-		dev_err(&pdev->dev, "could not determine device resources\n");
-		return ret;
-	}
-	priv->baseaddr = of_iomap(np, 0);
-	if (!priv->baseaddr) {
-		dev_err(&pdev->dev, "could not map device resources\n");
-		return -ENOMEM;
-	}
-	priv->codec_phys = res.start;
+	platform_set_drvdata(pdev, codec);
+
+	codec->id = (int)of_id->data;
 
-	priv->regmap = devm_regmap_init_mmio(&pdev->dev, priv->baseaddr, &sunxi_regmap_config);
-	if (IS_ERR(priv->regmap))
-		return PTR_ERR(priv->regmap);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
 
-	priv->irq = irq_of_parse_and_map(np, 0);
-	if (!priv->irq) {
-		dev_err(&pdev->dev, "no irq for node %s\n", np->full_name);
+	codec->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					    &sunxi_codec_regmap_config);
+	if (IS_ERR(codec->regmap))
+		return PTR_ERR(codec->regmap);
+
+	codec->irq = irq_of_parse_and_map(np, 0);
+	if (!codec->irq) {
+		dev_err(dev, "no irq for node %s\n", np->full_name);
 		return -ENXIO;
 	}
 
 	/* Clock */
-	priv->codec_apbclk = devm_clk_get(dev, "apb");
-	if (IS_ERR(priv->codec_apbclk)) {
+	codec->clk_apb = devm_clk_get(dev, "apb");
+	if (IS_ERR(codec->clk_apb)) {
 		dev_err(dev, "failed to get apb clock.\n");
-		return PTR_ERR(priv->codec_apbclk);
+		return PTR_ERR(codec->clk_apb);
 	}
-	priv->codec_pll2clk = devm_clk_get(dev, "pll2");
-	if (IS_ERR(priv->codec_pll2clk)) {
+	codec->clk_pll2 = devm_clk_get(dev, "pll2");
+	if (IS_ERR(codec->clk_pll2)) {
 		dev_err(dev, "failed to get pll2 clock.\n");
-		return PTR_ERR(priv->codec_pll2clk);
+		return PTR_ERR(codec->clk_pll2);
 	}
-	priv->codec_moduleclk = devm_clk_get(dev, "codec");
-	if (IS_ERR(priv->codec_moduleclk)) {
+	codec->clk_module = devm_clk_get(dev, "codec");
+	if (IS_ERR(codec->clk_module)) {
 		dev_err(dev, "failed to get codec clock.\n");
-		return PTR_ERR(priv->codec_moduleclk);
+		return PTR_ERR(codec->clk_module);
 	}
-	ret = clk_set_rate(priv->codec_pll2clk, 24576000);
+
+	ret = clk_set_rate(codec->clk_pll2, 24576000);
 	if (ret) {
-		dev_err(dev, "set codec base clock failed!\n");
+		dev_err(dev, "set codec base clock rate failed!\n");
 		return ret;
 	}
-	if (clk_prepare_enable(priv->codec_pll2clk)) {
-		dev_err(dev, "try to enable codec_pll2clk failed\n");
+	if (clk_prepare_enable(codec->clk_pll2)) {
+		dev_err(dev, "try to enable clk_pll2 failed\n");
 		return -EINVAL;
 	}
-	if (clk_prepare_enable(priv->codec_apbclk)) {
-		dev_err(dev, "try to enable apb_codec_clk failed\n");
+	if (clk_prepare_enable(codec->clk_apb)) {
+		dev_err(dev, "try to enable clk_apb failed\n");
 		return -EINVAL;
 	}
-	if (clk_prepare_enable(priv->codec_moduleclk)) {
-		dev_err(dev, "try to enable codec failed\n");
-		ret = -EINVAL;
-		goto exit_clkdisable_apb_clk;
-	}
-	dev_set_drvdata(&pdev->dev, priv);
 
-	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_component, &sunxi_dai, 1);
-	if (ret)
-		return ret;
+	codec->playback_dma_data.addr = res->start + SUNXI_DAC_TXDATA;
+	codec->playback_dma_data.maxburst = 4;
+	codec->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 
-	switch (priv->id) {
-	case SUN4A:
-		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun4a_codec, &dit_stub_dai, 1);
-	case SUN4I:
-	case SUN5I:
-		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun4i_codec, &dit_stub_dai, 1);
-	case SUN7I:
-		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sun7i_codec, &dit_stub_dai, 1);
-	}
-	if (ret)
-		return ret;
-
-	snd_dmaengine_pcm_register(&pdev->dev, NULL, SND_DMAENGINE_PCM_FLAG_NO_RESIDUE);
-
-	codec_init(priv);
-#ifdef JDS
-	if (gpio_pa_shutdown)
-		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+	codec->capture_dma_data.addr = res->start + SUNXI_ADC_RXDATA;
+	codec->capture_dma_data.maxburst = 4;
+	codec->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 
-	resume_work_queue = create_singlethread_workqueue("codec_resume");
-	if (resume_work_queue == NULL) {
-		printk("[su4i-codec] try to create workqueue for codec failed!\n");
-		ret = -ENOMEM;
-		goto err_resume_work_queue;
-	}
-#endif
-	printk("JDS - codec driver success registered\n");
-	return ret;
-
-err_resume_work_queue:
-exit_clkdisable_apb_clk:
-	return ret;
-}
+//	printk("JDS - clk_get_rate(codec->clk_module) %lu\n", clk_get_rate(codec->clk_module));
+//	codec->ratnum.num = clk_get_rate(codec->clk_module) / 128;
+	codec->ratnum.den_step = 1;
+	codec->ratnum.den_min = 1;
+	codec->ratnum.den_max = 64;
 
-#ifdef CONFIG_PM
-static int snd_sunxi_codec_suspend(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct card_data *priv = dev_get_drvdata(&pdev->dev);
+	codec->rate_constraints.rats = &codec->ratnum;
+	codec->rate_constraints.nrats = 1;
 
-	if (priv->running)
-		clk_disable(priv->codec_moduleclk);
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_codec_component,
+					 &sunxi_codec_dai, 1);
+	if (ret)
+		goto err_clk_disable;
 
-	return 0;
-}
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret)
+		goto err_clk_disable;
 
-static int snd_sunxi_codec_resume(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct card_data *priv = dev_get_drvdata(&pdev->dev);
-
-	if (priv->running) {
-		clk_enable(priv->codec_moduleclk);
-		sunxi_configure(priv);
-		sunxi_clock(priv, priv->saved_params.core_freq,
-				priv->saved_params.rate);
-	}
 	return 0;
-}
 
-static SIMPLE_DEV_PM_OPS(sunxi_dev_pm_ops, snd_sunxi_codec_suspend, \
-		snd_sunxi_codec_resume);
-
-#define sunxi_DEV_PM_OPS (&sunxi_dev_pm_ops)
-
-#else
-#define sunxi_DEV_PM_OPS NULL
-
-#endif
-
-static int sunxi_codec_remove(struct platform_device *pdev)
-{
-#ifdef JDS
-	clk_disable(codec_moduleclk);
-	//释放codec_pll2clk时钟句柄
-	clk_put(codec_pll2clk);
-	//释放codec_apbclk时钟句柄
-	clk_put(codec_apbclk);
-
-	snd_card_free(platform_get_drvdata(devptr));
-	platform_set_drvdata(devptr, NULL);
-#endif
-	return 0;
-	snd_dmaengine_pcm_unregister(&pdev->dev);
+err_clk_disable:
+	clk_disable_unprepare(codec->clk_module);
+	clk_disable_unprepare(codec->clk_apb);
+	clk_disable_unprepare(codec->clk_pll2);
+	return ret;
 }
 
-static void sunxi_codec_shutdown(struct platform_device *devptr)
+static int sunxi_codec_dev_remove(struct platform_device *pdev)
 {
-#ifdef JDS
-	if (gpio_pa_shutdown) {
-//JDS		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
-		mdelay(50);
-	}
-	regmap_update_bits(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x0);
-	mdelay(100);
-	//pa mute
-	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
-	mdelay(500);
-	//disable dac analog
-	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x0);
-	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x0);
+	struct sunxi_codec *codec = platform_get_drvdata(pdev);
 
-	//disable dac to pa
-	regmap_update_bits(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x0);
-	regmap_update_bits(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x0);
+	clk_disable_unprepare(codec->clk_module);
+	clk_disable_unprepare(codec->clk_apb);
+	clk_disable_unprepare(codec->clk_pll2);
 
-	clk_disable(codec_moduleclk);
-#endif
+	return 0;
 }
 
-/*method relating*/
-static struct platform_driver sunxi_codec_driver =
-{
-	.probe = sunxi_codec_probe,
-	.remove = sunxi_codec_remove,
-	.shutdown = sunxi_codec_shutdown,
-#ifdef CONFIG_PM
-//JDS	.suspend = snd_sunxi_codec_suspend,
-//JDS	.resume = snd_sunxi_codec_resume,
-#endif
+static struct platform_driver sunxi_codec_driver = {
 	.driver = {
 		.name = "sunxi-codec",
-		.of_match_table = snd_sunxi_codec_ids,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_codec_of_match,
 	},
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_dev_remove,
 };
-
 module_platform_driver(sunxi_codec_driver);
 
 MODULE_ALIAS("platform:sunxi-codec-dai");
