Bottom: d22fa85c89dd5ccbba8bfe9c1474dc49a025a04a
Top:    63620f7ddfbb7170a2a3474aad51468589784e47
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-11-29 23:30:19 -0500

Refresh of 0040-i2s.patch

---

diff --git a/drivers/dma/lpc31xx-dma.c b/drivers/dma/lpc31xx-dma.c
index 8c4c009..a569188 100644
--- a/drivers/dma/lpc31xx-dma.c
+++ b/drivers/dma/lpc31xx-dma.c
@@ -28,6 +28,7 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/dma-mapping.h>
+#include <linux/io.h>
 
 #include <mach/dma.h>
 #include <mach/clock.h>
@@ -38,17 +39,17 @@ struct lpc31xx_dma_engine;
 /***********************************************************************
  * DMA register definitions
  **********************************************************************/
-#define DMACH_SRC_ADDR(ch)    __REG (DMA_PHYS + ((ch) << 5) + 0x00)
-#define DMACH_DST_ADDR(ch)    __REG (DMA_PHYS + ((ch) << 5) + 0x04)
-#define DMACH_LEN(ch)         __REG (DMA_PHYS + ((ch) << 5) + 0x08)
-#define DMACH_CFG(ch)         __REG (DMA_PHYS + ((ch) << 5) + 0x0C)
-#define DMACH_EN(ch)          __REG (DMA_PHYS + ((ch) << 5) + 0x10)
-#define DMACH_TCNT(ch)        __REG (DMA_PHYS + ((ch) << 5) + 0x1C)
-#define DMACH_ALT_EN          __REG (DMA_PHYS + 0x400)
-#define DMACH_IRQ_STATUS      __REG (DMA_PHYS + 0x404)
-#define DMACH_IRQ_MASK        __REG (DMA_PHYS + 0x408)
-#define DMACH_ALT_PHYS(ch)    (DMA_PHYS + 0x200 + ((ch) << 4))
-#define DMACH_SOFT_INT_PHYS   (DMA_PHYS + 0x40C )
+#define DMACH_SRC_ADDR(edmac)		(edmac->edma->regs + (edmac->number << 5) + 0x00)
+#define DMACH_DST_ADDR(edmac)		(edmac->edma->regs + (edmac->number << 5) + 0x04)
+#define DMACH_LEN(edmac)		(edmac->edma->regs + (edmac->number << 5) + 0x08)
+#define DMACH_CFG(edmac)		(edmac->edma->regs + (edmac->number << 5) + 0x0C)
+#define DMACH_EN(edmac)			(edmac->edma->regs + (edmac->number << 5) + 0x10)
+#define DMACH_TCNT(edmac)		(edmac->edma->regs + (edmac->number << 5) + 0x1C)
+#define DMACH_ALT_EN(edma)		(edma->regs + 0x400)
+#define DMACH_IRQ_STATUS(edma)		(edma->regs + 0x404)
+#define DMACH_IRQ_MASK(edma)		(edma->regs + 0x408)
+#define DMACH_ALT_PHYS(edmac)		(edmac->edma->regs + 0x200 + (edmac->number << 4))
+#define DMACH_SOFT_INT_PHYS(edma)	(edma->regs + 0x40C )
 
 /***********************************************************************
 * Channel CONFIGURATION register defines
@@ -119,6 +120,7 @@ struct lpc31xx_dma_engine;
 struct lpc31xx_dma_desc {
 	uint32_t src_addr;
 	uint32_t dst_addr;
+	uint32_t cfg;
 	size_t size;
 	bool complete;
 	struct dma_async_tx_descriptor txd;
@@ -162,7 +164,6 @@ struct lpc31xx_dma_chan {
 	struct dma_chan chan;
 	int number;
 	const struct lpc31xx_dma_engine	*edma;
-	void __iomem *regs;
 	struct tasklet_struct tasklet;
 	unsigned long flags;
 /* Channel is configured for cyclic transfers */
@@ -190,6 +191,8 @@ struct lpc31xx_dma_engine {
 
 	struct lpc31xx_dma_chan	channels[DMA_MAX_CHANNELS];
 	int irq;
+	void __iomem *regs;
+	struct resource *mem;
 };
 
 static inline struct device *chan2dev(struct lpc31xx_dma_chan *edmac)
@@ -311,66 +314,52 @@ static bool lpc31xx_dma_advance_active(struct lpc31xx_dma_chan *edmac)
  * M2P DMA implementation
  */
 
-static void m2p_set_control(struct lpc31xx_dma_chan *edmac, uint32_t control)
-{
-	printk("jds - m2p_set_control\n");
-#if 0
-	writel(control, edmac->regs + M2P_CONTROL);
-	/*
-	 * LPC31xx User's Guide states that we must perform a dummy read after
-	 * write to the control register.
-	 */
-	readl(edmac->regs + M2P_CONTROL);
-#endif
-}
-
 static int m2p_hw_setup(struct lpc31xx_dma_chan *edmac)
 {
 	struct lpc31xx_dma_data *data = edmac->chan.private;
 	uint32_t control;
 
 	printk("jds - m2p_hw_setup\n");
-#if 0
-	writel(data->port & 0xf, edmac->regs + M2P_PPALLOC);
 
-	control = M2P_CONTROL_CH_ERROR_INT | M2P_CONTROL_ICE
-		| M2P_CONTROL_ENABLE;
-	m2p_set_control(edmac, control);
-#endif
+	//writel(data->port & 0xf, edmac->regs + M2P_PPALLOC);
+
+	//control = M2P_CONTROL_CH_ERROR_INT | M2P_CONTROL_ICE
+	//	| M2P_CONTROL_ENABLE;
+	//m2p_set_control(edmac, control);
+
 	return 0;
 }
 
 static inline uint32_t m2p_channel_state(struct lpc31xx_dma_chan *edmac)
 {
 	printk("jds - m2p_channel_state\n");
-#if 0
-	return (readl(edmac->regs + M2P_STATUS) >> 4) & 0x3;
-#endif
+
+	//return (readl(edmac->regs + M2P_STATUS) >> 4) & 0x3;
+	return 0;
 }
 
 static void m2p_hw_shutdown(struct lpc31xx_dma_chan *edmac)
 {
 	uint32_t control;
-	printk("jds - m2p_channel_state\n");
-#if 0
-	control = readl(edmac->regs + M2P_CONTROL);
-	control &= ~(M2P_CONTROL_STALLINT | M2P_CONTROL_NFBINT);
-	m2p_set_control(edmac, control);
+	printk("jds - m2p_channel_stutdown\n");
 
-	while (m2p_channel_state(edmac) >= M2P_STATE_ON)
-		cpu_relax();
+	//control = readl(edmac->regs + M2P_CONTROL);
+	//control &= ~(M2P_CONTROL_STALLINT | M2P_CONTROL_NFBINT);
+	//m2p_set_control(edmac, control);
 
-	m2p_set_control(edmac, 0);
+	//while (m2p_channel_state(edmac) >= M2P_STATE_ON)
+	//	cpu_relax();
+
+	//m2p_set_control(edmac, 0);
+
+	//while (m2p_channel_state(edmac) == M2P_STATE_STALL)
+	//	cpu_relax();
 
-	while (m2p_channel_state(edmac) == M2P_STATE_STALL)
-		cpu_relax();
-#endif
 }
 
 static void m2p_fill_desc(struct lpc31xx_dma_chan *edmac)
 {
 	struct lpc31xx_dma_desc *desc;
-	uint32_t bus_addr;
 
 	printk("jds - m2p_fill_desc\n");
 	desc = lpc31xx_dma_get_active(edmac);
@@ -378,47 +367,24 @@ static void m2p_fill_desc(struct lpc31xx_dma_chan *edmac)
 		dev_warn(chan2dev(edmac), "M2P: empty descriptor list\n");
 		return;
 	}
-#if 0
-	if (lpc31xx_dma_chan_direction(&edmac->chan) == DMA_MEM_TO_DEV)
-		bus_addr = desc->src_addr;
-	else
-		bus_addr = desc->dst_addr;
-
-	if (edmac->buffer == 0) {
-		writel(desc->size, edmac->regs + M2P_MAXCNT0);
-		writel(bus_addr, edmac->regs + M2P_BASE0);
-	} else {
-		writel(desc->size, edmac->regs + M2P_MAXCNT1);
-		writel(bus_addr, edmac->regs + M2P_BASE1);
-	}
-#endif
-	edmac->buffer ^= 1;
+	__raw_writel(desc->src_addr, DMACH_SRC_ADDR(edmac));
+	__raw_writel(desc->dst_addr, DMACH_DST_ADDR(edmac));
+	__raw_writel(desc->size, DMACH_LEN(edmac));
+	__raw_writel(desc->cfg, DMACH_CFG(edmac));
 }
 
 static void m2p_hw_submit(struct lpc31xx_dma_chan *edmac)
 {
 	printk("jds - m2p_hw_submit\n");
-#if 0
-	uint32_t control = readl(edmac->regs + M2P_CONTROL);
 
 	m2p_fill_desc(edmac);
-	control |= M2P_CONTROL_STALLINT;
-
-	if (lpc31xx_dma_advance_active(edmac)) {
-		m2p_fill_desc(edmac);
-		control |= M2P_CONTROL_NFBINT;
-	}
-
-	m2p_set_control(edmac, control);
-#endif
 }
 
 static int m2p_hw_interrupt(struct lpc31xx_dma_chan *edmac)
 {
 	printk("jds - m2p_hw_interrupt\n");
-#if 0
+#ifdef JDS
 	uint32_t irq_status = readl(edmac->regs + M2P_INTERRUPT);
-	uint32_t control;
 
 	if (irq_status & M2P_INTERRUPT_ERROR) {
 		struct lpc31xx_dma_desc *desc = lpc31xx_dma_get_active(edmac);
@@ -1142,6 +1108,7 @@ static void lpc31xx_dma_issue_pending(struct dma_chan *chan)
 
 static int __init lpc31xx_dma_probe(struct platform_device *pdev)
 {
+	struct resource *res;
 	struct lpc31xx_dma_engine *edma;
 	int ret, i;
 
@@ -1187,27 +1154,48 @@ static int __init lpc31xx_dma_probe(struct platform_device *pdev)
 	edma->dma_dev.device_control = lpc31xx_dma_control;
 	edma->dma_dev.device_issue_pending = lpc31xx_dma_issue_pending;
 
-	platform_set_drvdata(pdev, edma);
-
-	ret = dma_async_device_register(&edma->dma_dev);
-	if (ret) {
-		dev_err(&pdev->dev, "unable to register\n");
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
 		goto err_init;
 	}
 
+	edma->mem = request_mem_region(res->start, resource_size(res), pdev->name);
+	edma->regs = ioremap(res->start, resource_size(res));
+	if (!edma->regs) {
+		ret = -ENXIO;
+		goto fail_release_mem;
+	}
+
 	edma->irq = platform_get_irq(pdev, 0);
 	if (edma->irq < 0) {
 		dev_err(&pdev->dev, "failed to get irq resources\n");
-		goto err_init;
+		goto fail_release_unmap;
 	}
 	dma_irq_mask = 0xFFFFFFFF;
-	DMACH_IRQ_MASK = dma_irq_mask;
+	__raw_writel(dma_irq_mask, DMACH_IRQ_MASK(edma));
 	ret = request_irq (edma->irq, lpc31xx_dma_irq_handler, 0, "DMAC", edma);
-	if (ret)
-		printk (KERN_ERR "request_irq() returned error %d\n", ret);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get irq resources\n");
+		goto fail_release_unmap;
+	}
+
+	platform_set_drvdata(pdev, edma);
+
+	ret = dma_async_device_register(&edma->dma_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to register\n");
+		goto fail_release_irq;
+	}
 
 	return 0;
 
+fail_release_irq:
+	free_irq(edma->irq, edma);
+fail_release_unmap:
+	iounmap(edma->regs);
+fail_release_mem:
+	release_mem_region(res->start, resource_size(res));
 err_init:
 	kfree(edma);
 	printk("JDS - lpc31xx_dma_probe err %d\n", ret);
diff --git a/sound/soc/lpc31xx/lpc31xx-i2s.c b/sound/soc/lpc31xx/lpc31xx-i2s.c
index 7ee1d29..3125535 100644
--- a/sound/soc/lpc31xx/lpc31xx-i2s.c
+++ b/sound/soc/lpc31xx/lpc31xx-i2s.c
@@ -62,29 +62,29 @@ lpc31xx_i2s_read(void __iomem *regs, uint32_t reg)
 static void lpc31xx_i2s_shutdown(struct snd_pcm_substream *substream,
 									struct snd_soc_dai *dai)
 {
-	struct lpc31xx_i2s_channel *channel = snd_soc_dai_get_drvdata(dai);
-	struct lpc31xx_i2s_sub *sub;
+	struct lpc31xx_i2s_pair *pair = snd_soc_dai_get_drvdata(dai);
+	struct lpc31xx_i2s_channel *chan;
 
-	sub = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? &channel->tx : &channel->rx);
+	chan = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? &pair->tx : &pair->rx);
 
-	if (sub->ch_on == 0) {
+	if (chan->ch_on == 0) {
 		/* This channel is not enabled! */
 		pr_warning("%s: I2S channel is not on!\n", "fixme");
 		return;
 	}
 
 	/* Channel specific shutdown */
-	lpc31xx_chan_clk_enable(sub->chclk, 0, 0);
-	sub->ch_on = 0;
+	lpc31xx_chan_clk_enable(chan->chclk, 0, 0);
+	chan->ch_on = 0;
 
 	/* Can we shutdown I2S interface to save some power? */
-	if (sub->ch_on != 0) {
+	if (chan->ch_on != 0) {
 		/* Other channel is busy, exit without shutting down main clock */
 		return;
 	}
 
 	/* Safe to shut down */
-	if (channel->initialized == 0) {
+	if (pair->initialized == 0) {
 		/* Nothing is enabled! */
 		pr_warning("I2S shutdown (%s) when nothing is enabled!\n",
 				"fixme");
@@ -95,63 +95,63 @@ static void lpc31xx_i2s_shutdown(struct snd_pcm_substream *substream,
 	cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 0);
 	cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 0);
 
-	channel->initialized = 0;
+	pair->initialized = 0;
 }
 
 static int lpc31xx_i2s_startup(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)
 {
-	struct lpc31xx_i2s_channel *channel = snd_soc_dai_get_drvdata(dai);
-	struct lpc31xx_i2s_sub *sub;
+	struct lpc31xx_i2s_pair *pair = snd_soc_dai_get_drvdata(dai);
+	struct lpc31xx_i2s_channel *chan;
 
-	sub = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? &channel->tx : &channel->rx);
-	if (sub->ch_on != 0) {
+	chan = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? &pair->tx : &pair->rx);
+	if (chan->ch_on != 0) {
 		/* This channel already enabled! */
 		pr_warning("%s: I2S channel is busy!\n", "fixme");
 		return -EBUSY;
 	}
 
 	/* Initialize I2S interface */
-	if (channel->initialized == 0) {
+	if (pair->initialized == 0) {
 		/* Enable I2S register access clock */
 		cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 1);
 		cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 1);
 
-		channel->initialized = 1;
+		pair->initialized = 1;
 	}
 
 	/* Channel specific init, ok to leave the clocks off for now */
-	sub->ch_on = 1;
-	lpc31xx_chan_clk_enable(sub->chclk, 0, 0);
+	chan->ch_on = 1;
+	lpc31xx_chan_clk_enable(chan->chclk, 0, 0);
 
 	/* Mask all interrupts for the I2S channel */
 	//lpc31xx_i2s_write(info, I2S_CH_INT_MASK(channel->dir_info[dir].i2s_ch), I2S_FIFO_ALL_MASK);
 
 	/* Tx/Rx DMA config */
-	snd_soc_dai_set_dma_data(dai, substream, &sub->dma_params);
+	snd_soc_dai_set_dma_data(dai, substream, &chan->dma_params);
 	return 0;
 }
 
 static int lpc31xx_i2s_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
 				      int clk_id, unsigned int freq, int dir)
 {
-	struct lpc31xx_i2s_channel *channel = snd_soc_dai_get_drvdata(cpu_dai);
+	struct lpc31xx_i2s_pair *pair = snd_soc_dai_get_drvdata(cpu_dai);
 
 	/* Will use in HW params later */
-//	channel->dir_info[cpu_dai->id].ws_freq = freq;
-	channel->tx.ws_freq = freq;
-	channel->rx.ws_freq = freq;
+//	pair->dir_info[cpu_dai->id].ws_freq = freq;
+	pair->tx.ws_freq = freq;
+	pair->rx.ws_freq = freq;
 	return 0;
 }
 
 static int lpc31xx_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,
 				   unsigned int fmt)
 {
-	struct lpc31xx_i2s_channel *channel = snd_soc_dai_get_drvdata(cpu_dai);
+	struct lpc31xx_i2s_pair *pair = snd_soc_dai_get_drvdata(cpu_dai);
 
 	/* Will use in HW params later */
-//	channel->dir_info[cpu_dai->id].daifmt = fmt;
-	channel->tx.daifmt = fmt;
-	channel->rx.daifmt = fmt;
+//	pair->dir_info[cpu_dai->id].daifmt = fmt;
+	pair->tx.daifmt = fmt;
+	pair->rx.daifmt = fmt;
 
 	return 0;
 }
@@ -171,23 +171,23 @@ static int lpc31xx_i2s_hw_params(struct snd_pcm_substream *substream,
 			         struct snd_pcm_hw_params *params,
 					 struct snd_soc_dai *dai)
 {
-	struct lpc31xx_i2s_channel *channel = snd_soc_dai_get_drvdata(dai);
-	struct lpc31xx_i2s_sub *sub;
+	struct lpc31xx_i2s_pair *pair = snd_soc_dai_get_drvdata(dai);
+	struct lpc31xx_i2s_channel *chan;
 	uint32_t tmp;
 
-	sub = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? &channel->tx : &channel->rx);
+	chan = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? &pair->tx : &pair->rx);
 
 	/* Setup the I2S data format */
 	tmp = 0;
-	switch (sub->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	switch (chan->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) {
 		case SND_SOC_DAIFMT_I2S:
-			spin_lock_irq(&channel->lock);
+			spin_lock_irq(&pair->lock);
 			tmp = lpc31xx_i2s_read(lpc31xx_regs, I2S_FORMAT_SETTINGS) &
-				~I2S_SET_FORMAT(sub->i2s_ch,
+				~I2S_SET_FORMAT(chan->i2s_ch,
 				I2S_FORMAT_MASK);
-			lpc31xx_i2s_write(lpc31xx_regs, I2S_FORMAT_SETTINGS, tmp | I2S_SET_FORMAT(sub->i2s_ch,
+			lpc31xx_i2s_write(lpc31xx_regs, I2S_FORMAT_SETTINGS, tmp | I2S_SET_FORMAT(chan->i2s_ch,
 				I2S_FORMAT_I2S));
-			spin_unlock_irq(&channel->lock);
+			spin_unlock_irq(&pair->lock);
 			break;
 
 		default:
@@ -196,27 +196,27 @@ static int lpc31xx_i2s_hw_params(struct snd_pcm_substream *substream,
 	}
 
 #if defined (CONFIG_SND_DEBUG_VERBOSE)
-	pr_info("Desired clock rate : %d\n", sub->ws_freq);
+	pr_info("Desired clock rate : %d\n", chan->ws_freq);
 	pr_info("Channels           : %d\n", params_channels(params));
-	pr_info("Data format        : %d\n", sub->daifmt);
+	pr_info("Data format        : %d\n", chan->daifmt);
 #endif
 
 	/* The playback and record rates are shared, so just set the CODEC clock
 	   to the selected rate (will actually generate 256 * rate) */
-	channel->freq = sub->ws_freq;
-	if (lpc31xx_main_clk_rate(channel->freq) == 0)
+	pair->freq = chan->ws_freq;
+	if (lpc31xx_main_clk_rate(pair->freq) == 0)
 	{
 		pr_warning("Unsupported audio data rate (%d)\n",
-			channel->freq);
+			pair->freq);
 		return -EINVAL;
 	}
 
 	/* Now setup the selected channel clocks (WS and BCK) */
-	if (lpc31xx_chan_clk_enable(sub->chclk, channel->freq,
-		(channel->freq * 32)) == 0)
+	if (lpc31xx_chan_clk_enable(chan->chclk, pair->freq,
+		(pair->freq * 32)) == 0)
 	{
 		pr_warning("Unsupported channel data rates (ws=%d, bck=%d)\n",
-			channel->freq, (channel->freq * 32));
+			pair->freq, (pair->freq * 32));
 		return -EINVAL;
 	}
 
@@ -249,14 +249,14 @@ static int lpc31xx_i2s_trigger(struct snd_pcm_substream *substream, int cmd, str
 #ifdef CONFIG_PM
 static int lpc31xx_i2s_suspend(struct snd_soc_dai *cpu_dai)
 {
-	struct lpc31xx_i2s_channel *channel = snd_soc_dai_get_drvdata(cpu_dai);
+	struct lpc31xx_i2s_pair *pair = snd_soc_dai_get_drvdata(cpu_dai);
 
 	/* Shutdown active clocks */
-	if (channel->tx.ch_on != 0) {
-		lpc31xx_chan_clk_enable(channel->tx.chclk, 0, 0);
+	if (pair->tx.ch_on != 0) {
+		lpc31xx_chan_clk_enable(pair->tx.chclk, 0, 0);
 	}
-	if (channel->rx.ch_on != 0) {
-		lpc31xx_chan_clk_enable(channel->rx.chclk, 0, 0);
+	if (pair->rx.ch_on != 0) {
+		lpc31xx_chan_clk_enable(pair->rx.chclk, 0, 0);
 	}
 
 	/* Disable I2S register access clock */
@@ -270,22 +270,22 @@ static int lpc31xx_i2s_suspend(struct snd_soc_dai *cpu_dai)
 
 static int lpc31xx_i2s_resume(struct snd_soc_dai *cpu_dai)
 {
-	struct lpc31xx_i2s_channel *channel = snd_soc_dai_get_drvdata(cpu_dai);
+	struct lpc31xx_i2s_pair *pair = snd_soc_dai_get_drvdata(cpu_dai);
 
 	/* resume main clocks */
-	lpc31xx_main_clk_rate(channel->freq);
+	lpc31xx_main_clk_rate(pair->freq);
 	/* Enable I2S register access clock */
 	cgu_clk_en_dis(CGU_SB_I2S_CFG_PCLK_ID, 1);
 	cgu_clk_en_dis(CGU_SB_EDGE_DET_PCLK_ID, 1);
 
 	/* resume active clocks */
-	if (channel->tx.ch_on != 0) {
-		lpc31xx_chan_clk_enable(channel->tx.chclk,
-		channel->tx.ws_freq, (channel->freq * 32));
+	if (pair->tx.ch_on != 0) {
+		lpc31xx_chan_clk_enable(pair->tx.chclk,
+		pair->tx.ws_freq, (pair->freq * 32));
 	}
-	if (channel->rx.ch_on != 0) {
-		lpc31xx_chan_clk_enable(channel->rx.chclk,
-		channel->rx.ws_freq, (channel->freq * 32));
+	if (pair->rx.ch_on != 0) {
+		lpc31xx_chan_clk_enable(pair->rx.chclk,
+		pair->rx.ws_freq, (pair->freq * 32));
 	}
 
 	return 0;
@@ -331,11 +331,11 @@ static struct device i2s[2];
 
 static __devinit int lpc31xx_i2s_dev_probe(struct platform_device *pdev)
 {
-	struct lpc31xx_i2s_channel *channel;
+	struct lpc31xx_i2s_pair *pair;
 	struct device_node *child;
 	const __be32 *prop;
 	struct resource *res;
-	int i, err, len, tx, rx, slave, val;
+	int i, err, len, tx, rx, slave;
 
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -378,27 +378,28 @@ static __devinit int lpc31xx_i2s_dev_probe(struct platform_device *pdev)
 			slave |= (tx == 0x80 ? I2S_RXO_SELECT_MASTER : I2S_RX1_SELECT_MASTER);
 		lpc31xx_i2s_write(lpc31xx_regs, I2S_CFG_MUX_SETTINGS, slave);
 
-		channel = kzalloc(sizeof(*channel), GFP_KERNEL);
-		if (channel == NULL) {
+		pair = kzalloc(sizeof(*pair), GFP_KERNEL);
+		if (pair == NULL) {
 			err = ENOMEM;
 			goto fail_unmap_mem;
 		}
-		spin_lock_init(&channel->lock);
+		spin_lock_init(&pair->lock);
 		i2s[i] = pdev->dev;
 		i2s[i].of_node = child;
 
 		if (tx == 0x80) {
-			channel->tx.cfg = res->start + 0x080;
-			channel->tx.fifo = res->start + 0x0E0;
-			channel->rx.cfg = res->start + 0x180;
-			channel->rx.fifo = res->start + 0x1E0;
+			pair->tx.cfg = res->start + 0x080;
+			pair->tx.dma_addr = res->start + 0x0E0;
+			pair->tx.dma_params.port = 0;
+			pair->rx.cfg = res->start + 0x180;
+			pair->rx.dma_addr = res->start + 0x1E0;
 		} else {
-			channel->tx.cfg = res->start + 0x100;
-			channel->tx.fifo = res->start + 0x160;
-			channel->rx.cfg = res->start + 0x200;
-			channel->rx.fifo = res->start + 0x260;
+			pair->tx.cfg = res->start + 0x100;
+			pair->tx.dma_addr = res->start + 0x160;
+			pair->rx.cfg = res->start + 0x200;
+			pair->rx.dma_addr = res->start + 0x260;
 		}
-		dev_set_drvdata(&i2s[i], channel);
+		dev_set_drvdata(&i2s[i], pair);
 
 		err = snd_soc_register_dai(&i2s[i], &dai_driver);
 		if (err)
@@ -420,15 +421,15 @@ fail:
 
 static __devexit int lpc31xx_i2s_dev_remove(struct platform_device *pdev)
 {
-	struct lpc31xx_i2s_channel *channel;
+	struct lpc31xx_i2s_pair *pair;
 
 	snd_soc_unregister_dai(&i2s[0]);
-	channel = dev_get_drvdata(&i2s[0]);
-	kfree(channel);
+	pair = dev_get_drvdata(&i2s[0]);
+	kfree(pair);
 
 	snd_soc_unregister_dai(&i2s[1]);
-	channel = dev_get_drvdata(&i2s[1]);
-	kfree(channel);
+	pair = dev_get_drvdata(&i2s[1]);
+	kfree(pair);
 
 	iounmap(lpc31xx_regs);
 	if (lpc31xx_mem)
diff --git a/sound/soc/lpc31xx/lpc31xx-i2s.h b/sound/soc/lpc31xx/lpc31xx-i2s.h
index ce0b4ff..496f69e 100644
--- a/sound/soc/lpc31xx/lpc31xx-i2s.h
+++ b/sound/soc/lpc31xx/lpc31xx-i2s.h
@@ -102,30 +102,32 @@
      SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | \
      SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_176400| \
      SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000)
-#define LPC31XX_I2S_FORMATS (SNDRV_PCM_FMTBIT_S16 | SNDRV_PCM_FMTBIT_S24)
+//#define LPC31XX_I2S_FORMATS (SNDRV_PCM_FMTBIT_S16 | SNDRV_PCM_FMTBIT_S24)
+#define LPC31XX_I2S_FORMATS (SNDRV_PCM_FMTBIT_S16)
 
 #define CH_PLAY 0
 #define CH_REC  1
 
 /* Structure that keeps I2S direction data */
-struct lpc31xx_i2s_sub {
+struct lpc31xx_i2s_channel {
 	unsigned short ch_on;       /* Flag used to indicate if clocks are on */
 	unsigned short daifmt;
 	uint32_t ws_freq;
 	int i2s_ch, slave;
 	enum i2s_supp_clks chclk;
-	long fifo, cfg;
+	long cfg;
+	uint32_t dma_addr;
 	struct lpc31xx_dma_data dma_params;
 };
 
 
 /* Common I2S structure data */
-struct lpc31xx_i2s_channel {
+struct lpc31xx_i2s_pair {
 	spinlock_t lock;
 	unsigned short initialized;
 	uint32_t freq;
-	struct lpc31xx_i2s_sub tx;
-	struct lpc31xx_i2s_sub rx;
+	struct lpc31xx_i2s_channel tx;
+	struct lpc31xx_i2s_channel rx;
 };
 
 #endif
diff --git a/sound/soc/lpc31xx/lpc31xx-pcm.c b/sound/soc/lpc31xx/lpc31xx-pcm.c
index 42277c4..d39e7b0 100644
--- a/sound/soc/lpc31xx/lpc31xx-pcm.c
+++ b/sound/soc/lpc31xx/lpc31xx-pcm.c
@@ -180,26 +180,22 @@ static int snd_lpc31xx_pcm_hw_params(struct snd_pcm_substream *substream,
 	struct dma_slave_config slave_config;
 	int ret;
 
-	printk("JDS1 %p %p %p\n", substream, rtd, chan);
 	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
-	printk("JDS2 %p\n", dma_params);
 	ret = snd_hwparams_to_dma_slave_config(substream, params, &slave_config);
 	if (ret)
 		return ret;
 
-	printk("JDS3\n");
 	slave_config.device_fc = false;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		slave_config.dst_addr = dma_params->dma_addr;
-		slave_config.dst_maxburst = dma_params->burstsize;
+		//slave_config.dst_addr = dma_params->dma_addr;
+		//slave_config.dst_maxburst = dma_params->burstsize;
 	} else {
-		slave_config.src_addr = dma_params->dma_addr;
-		slave_config.src_maxburst = dma_params->burstsize;
+		//slave_config.src_addr = dma_params->dma_addr;
+		//slave_config.src_maxburst = dma_params->burstsize;
 	}
 
-	printk("JDS4\n");
 	ret = dmaengine_slave_config(chan, &slave_config);
 	if (ret)
 		return ret;
@@ -221,20 +217,16 @@ static int snd_lpc31xx_open(struct snd_pcm_substream *substream)
 	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
 	dma_data = kzalloc(sizeof(*dma_data), GFP_KERNEL);
-#ifdef FIXME
-	dma_data->priority = DMA_PRIO_HIGH;
-	dma_data->dma_request = dma_params->dma;
-#endif
+	dma_data->port = 0;
+	dma_data->direction = 0;
+	dma_data->name = 0;
 
 	ret = snd_dmaengine_pcm_open(substream, filter, dma_data);
 	if (ret) {
 		kfree(dma_data);
 		return 0;
 	}
-
-	printk("JDS pcm_set_data %p %p\n", substream, dma_data);
 	snd_dmaengine_pcm_set_data(substream, dma_data);
-
 	return 0;
 }
 
diff --git a/sound/soc/lpc31xx/lpc31xx-pcm.h b/sound/soc/lpc31xx/lpc31xx-pcm.h
index b353da6..2134499 100644
--- a/sound/soc/lpc31xx/lpc31xx-pcm.h
+++ b/sound/soc/lpc31xx/lpc31xx-pcm.h
@@ -23,11 +23,5 @@
 #ifndef __SOUND_SOC_LPC31XX_PCM_H
 #define __SOUND_SOC_LPC31XX_PCM_H
 
-struct lpc31xx_pcm_dma_params {
-	int dma;
-	unsigned long dma_addr;
-	int burstsize;
-};
-
 #endif
