Bottom: 0d57ae63ae80a9efd3d2d69cf82b879e7a3caf05
Top:    938fd572688f0713aa928117576cfaef24e7c0eb
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-04-15 16:19:41 -0400

Refresh of irq.patch

---

diff --git a/arch/arm/boot/dts/ea3131.dts b/arch/arm/boot/dts/ea3131.dts
index 3413798..87746f5 100644
--- a/arch/arm/boot/dts/ea3131.dts
+++ b/arch/arm/boot/dts/ea3131.dts
@@ -60,7 +60,8 @@
 			vref_delay_usecs = <100>;
 			x-plate-ohms = <419>;
 			y-plate-ohms = <486>;
-			pen-irq = <37>;
+			interrupt-parent = <&evtr>;
+			pen-irq = <7 4>;
 			gpio-pendown = <&gpio_gpio 4 0>;
 		};
 	};
@@ -85,6 +86,8 @@
 				&gpio_ebi_i2stx_0 5 0 /* power, broken hardware design */
 				0 /* slot select, no hardware */
 			>;
+			interrupt-parent = <&evtr>;
+			interrupt = <6 8>;
 		};
 	};
 	usb@19000000 {
@@ -104,7 +107,7 @@
 			compatible = "davicom,dm9000";
 			reg = <0x20020000 0x100 0x20030000 0x100>;
 			interrupt-parent = <&evtr>;
-			interrupts = <4>;
+			interrupts = <4 4>;
 			gpios = <
 				&gpio_ebi_i2stx_0 2 0 /* main irq, map gpio to irq */
 				0  /* WOL irq, map gpio to irq */
diff --git a/arch/arm/boot/dts/lpc3131.dtsi b/arch/arm/boot/dts/lpc3131.dtsi
index c487022..096fe21 100644
--- a/arch/arm/boot/dts/lpc3131.dtsi
+++ b/arch/arm/boot/dts/lpc3131.dtsi
@@ -33,7 +33,7 @@
 		#event-cells = <3>;
 		compatible = "nxp,lpc31xx-evtr";
 		interrupt-controller;
-		#interrupt-cells = <1>;
+		#interrupt-cells = <2>;
 		reg = <0x13000000 0x800>;
 		interrupt-parent = <&intc>;
 		interrupts = <1 2 3 4>;  /* cascaded */
@@ -47,7 +47,7 @@
 		compatible = "nxp,lpc31xx-wdt";
 		reg = <0x13002400 0x400>;
 		interrupt-parent = <&evtr>;
-		interrupts = <0>;
+		interrupts = <0 1>;
 	};
 	sys@13002800 {
 		compatible = "nxp,lpc31xx-sys";
diff --git a/arch/arm/mach-lpc31xx/evtr.c b/arch/arm/mach-lpc31xx/evtr.c
index d1f84f8..3966c84 100644
--- a/arch/arm/mach-lpc31xx/evtr.c
+++ b/arch/arm/mach-lpc31xx/evtr.c
@@ -29,6 +29,7 @@
 #include <linux/irqdomain.h>
 #include <linux/of_platform.h>
 #include <linux/slab.h>
+#include <linux/gpio.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
@@ -343,6 +344,7 @@ static IRQ_EVENT_MAP_T irq_2_event[] = BOARD_IRQ_EVENT_MAP;
 
 static void evt_mask_irq(struct irq_data *data)
 {
+	printk("mask irq %d\n", data->irq);
 	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
 	u32 bit_pos = irq_2_event[data->irq - IRQ_EVT_START].event_pin & 0x1F;
 
@@ -351,6 +353,7 @@ static void evt_mask_irq(struct irq_data *data)
 
 static void evt_unmask_irq(struct irq_data *data)
 {
+	printk("unmask irq %d\n", data->irq);
 	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
 	u32 bit_pos = irq_2_event[data->irq - IRQ_EVT_START].event_pin & 0x1F;
 
@@ -370,6 +373,7 @@ static int evt_set_type(struct irq_data *data, unsigned int flow_type)
 	u32 bank = EVT_GET_BANK(irq_2_event[data->irq - IRQ_EVT_START].event_pin);
 	u32 bit_pos = irq_2_event[data->irq - IRQ_EVT_START].event_pin & 0x1F;
 
+	printk("set type %d %x\n", data->irq, flow_type);
 	switch (flow_type) {
 	case IRQ_TYPE_EDGE_RISING:
 		EVRT_APR(bank) |= _BIT(bit_pos);
@@ -412,6 +416,13 @@ static int evt_set_wake(struct irq_data *data, unsigned int on)
 	return 0;
 }
 
+static int set_input(unsigned irq);
+
+unsigned int evt_startup(struct irq_data *data)
+{
+	evt_unmask_irq(data);
+	return set_input(data->irq);
+}
 
 static struct irq_chip lpc31xx_evtr_chip = {
 	.name = "EVENTROUTER",
@@ -420,6 +431,7 @@ static struct irq_chip lpc31xx_evtr_chip = {
 	.irq_unmask = evt_unmask_irq,
 	.irq_set_type = evt_set_type,
 	.irq_set_wake = evt_set_wake,
+	//.irq_startup = evt_startup,
 };
 
 
@@ -430,6 +442,7 @@ static struct irq_chip lpc31xx_evtr_chip = {
 		if (IRQ_EVTR##n##_START == IRQ_EVTR##n##_END) { \
 			/* translate IRQ number */ \
 			irq = IRQ_EVTR##n##_START; \
+			printk("handle a irq %d\n", irq); \
 			generic_handle_irq(irq); \
 		} else { \
 			for (irq = IRQ_EVTR##n##_START; irq <= IRQ_EVTR##n##_END; irq++) {  \
@@ -437,8 +450,10 @@ static struct irq_chip lpc31xx_evtr_chip = {
 				bank = EVT_GET_BANK(irq_2_event[irq - IRQ_EVT_START].event_pin); \
 				bit_pos = irq_2_event[irq - IRQ_EVT_START].event_pin & 0x1F; \
 				status = EVRT_OUT_PEND(n, bank); \
-				if (status & _BIT(bit_pos)) \
+				if (status & _BIT(bit_pos)) { \
 					generic_handle_irq(irq); \
+					printk("handle b irq %d\n", irq); \
+				} \
 			} \
 		} \
 	}
@@ -482,7 +497,7 @@ void __init lpc31xx_init_evtr(void)
 	}
 
 	/* Now configure external/board interrupts using event router */
-	for (irq = IRQ_EVT_START; irq <= IRQ_EVT_START + NR_IRQ_CHIP_EVT + NR_IRQ_EBOARD; irq++) {
+	for (irq = IRQ_EVT_START; irq < IRQ_EVT_START + NR_IRQ_CHIP_EVT + NR_IRQ_EBOARD; irq++) {
 		/* compute bank & bit position for the event_pin */
 		bank = EVT_GET_BANK(irq_2_event[irq - IRQ_EVT_START].event_pin);
 		bit_pos = irq_2_event[irq - IRQ_EVT_START].event_pin & 0x1F;
@@ -571,20 +586,62 @@ void __init lpc31xx_init_evtr(void)
 #endif
 }
 
-struct event {
-	int bit;
+/* table to map from event to gpio bit */
+/* mask 0x1E0 reg, mask 0x1F bit */
+int event_to_gpioreg[] = {
+	0x000,0x00A,0x00D,0x004,0x011,0x003,0x012,0x013,
+	0x002,0x014,0x015,0x016,0x017,0x018,0x019,0x01A,
+	0x01B,0x00F,0x00C,0x00E,0x010,0x005,0x020,0x021,
+	0x022,0x0C7,0x0C8,0x0C9,0x0CA,0x0C6,0x0CB,0x0CC,
+	0x0CD,0x0CE,0x0C0,0x0C1,0x0C2,0x0C3,0x0C4,0x0C5,
+	0x0CF,0x029,0x028,0x008,0x00B,0x009,0x027,0x0E1,
+	0x0E0,0x0E2,0x0E3,0x0E4,0x01C,0x001,0x01D,0x01E,
+	0x000,0x01F,0x0E5,0x0E6,0x0E7,0x0E8,0x0E9,0x0EA,
+	0x0EB,0x0EC,0x141,0x142,0x143,0x140,0x120,0x121,
+	0x122,0x123,0x124,0x180,0x181,0x023,0x024,0x006,
+	0x007,0x025,0x026,0x060,0x061,0x062,0x080,0x081,
+	0x082,0x0A0,0x0A1,0x0A2,0x0A3,0x100,0x101,0x160,
+	0x0ED,0x0EE,0x000,0x000,0x000,0x000,0x000,0x000,
+	0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,
+	0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,
+	0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,
+};
+
+struct event_data {
+	int event;
 	int group;
 	int edge;
 };
 
-static struct event *events;
+static struct event_data *events;
 static int num_events;
 
+extern int lpc3131_reg_to_gpio(unsigned index, unsigned gpio);
+
+/* when a gpio pin is request as an interrupt source,
+ * make sure it is input mode
+ */
+static int set_input(unsigned irq)
+{
+	int ret, reg, gpio, event;
+
+	event = events[irq - 30].event;
+	reg  = event_to_gpioreg[event];
+	if (!reg) /* not a gpio pin */
+		return 0;
+	gpio = lpc3131_reg_to_gpio(reg >> 5, reg & 0x1F);
+	printk("setting to input %d\n", gpio);
+	ret = gpio_request(gpio, "IRQ");
+	if (ret)
+		return ret;
+	return gpio_direction_input(gpio);
+}
+
 int event_to_irq(int event)
 {
 	int i;
 	for (i = 0; i < num_events; i++) {
-		if (events[i].bit == event) {
+		if (events[i].event == event) {
 			return i + 30; /* fixme */
 		}
 	}
@@ -619,9 +676,10 @@ static int __devinit lpc313x_evtr_probe(struct platform_device *pdev)
 	events = kzalloc(sizeof(*events) * num_events, GFP_KERNEL);
 	for (i = 0; i < num_events; i++) {
 		events[i].group = be32_to_cpup(ip++);
-		events[i].bit = be32_to_cpup(ip++);
+		events[i].event = be32_to_cpup(ip++);
 		events[i].edge = be32_to_cpup(ip++);
-		printk("group %d bit %02x edge %d\n", events[i].group, events[i].bit, events[i].edge);
+		printk("group %d bit %02x edge %d\n", events[i].group, events[i].event, events[i].edge);
+		//set_input(events[i].event);
 	}
 	return 0;
 }
diff --git a/arch/arm/mach-lpc31xx/irq.c b/arch/arm/mach-lpc31xx/irq.c
index 4d74141..cf172f9 100644
--- a/arch/arm/mach-lpc31xx/irq.c
+++ b/arch/arm/mach-lpc31xx/irq.c
@@ -129,13 +129,13 @@ void __init lpc31xx_init_irq(void)
 					 handle_level_irq);
 		set_irq_flags(irq, IRQF_VALID);
 	}
+	lpc31xx_init_evtr();
 
 	/* Set the priority threshold to 0, i.e. don't mask any interrupt */
 	/* on the basis of priority level, for both targets (IRQ/FIQ)    */
 	INTC_IRQ_PRI_MASK = 0;
 	INTC_FIQ_PRI_MASK = 0;
 
-	lpc31xx_init_evtr();
 }
 
 
diff --git a/drivers/gpio/gpio-lpc31xx.c b/drivers/gpio/gpio-lpc31xx.c
index a5ab721..9d57e60 100644
--- a/drivers/gpio/gpio-lpc31xx.c
+++ b/drivers/gpio/gpio-lpc31xx.c
@@ -31,28 +31,34 @@
 #define GPIO_M1_SET	0x24
 #define GPIO_M1_RESET	0x28
 
+struct lpc31xx_gpio_chip {
+	struct of_mm_gpio_chip mmchip;
+	int index;
+};
+
 /* this table maps from gpio register bits into event router bits
  * the numbers correspond to the 128 event bits in the event router
  * look up the gpio bit in this table to get an event bit then
  * ask the event router driver to tell you which irq it is mapped to
  */
-static uint8_t ebi_mci[] = {0x38,0x35,0x08,0x05,0x03,0x15,0x4F,0x50,0x2B,0x2D,0x01,0x2C,0x12,0x02,0x13,0x11,
+static const uint8_t ebi_mci[] = {0x38,0x35,0x08,0x05,0x03,0x15,0x4F,0x50,0x2B,0x2D,0x01,0x2C,0x12,0x02,0x13,0x11,
 	0x14,0x04,0x06,0x07,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x34,0x36,0x37,0x39};
-static uint8_t ebi_i2stx_0[] = {0x16,0x17,0x18,0x4D,0x4E,0x51,0x52,0x2E,0x2A,0x29};
-static uint8_t i2srx_0[] = {0x53,0x54,0x55};
-static uint8_t i2srx_1[] = {0x56,0x57,0x58};
-static uint8_t i2stx_1[] = {0x59,0x5A,0x5B,0x5C};
-static uint8_t ebi[] = {0x22,0x23,0x24,0x25,0x26,0x27,0x1D,0x19,0x1A,0x1B,0x1C,0x1E,0x1F,0x20,0x21,0x28};
-static uint8_t gpio[] = {0x30,0x2F,0x31,0x32,0x33,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x60,0x61};
-static uint8_t i2c1[] = {0x5D,0x5E};
-static uint8_t spi[] = {0x46,0x47,0x48,0x49,0x4A};
-static uint8_t nand_ctrl[] = {0x45,0x42,0x43,0x44};
-static uint8_t pwm[] = {0x5F};
-static uint8_t uart[] = {0x4B,0x4C};
+static const uint8_t ebi_i2stx_0[] = {0x16,0x17,0x18,0x4D,0x4E,0x51,0x52,0x2E,0x2A,0x29};
+static const uint8_t i2srx_0[] = {0x53,0x54,0x55};
+static const uint8_t i2srx_1[] = {0x56,0x57,0x58};
+static const uint8_t i2stx_1[] = {0x59,0x5A,0x5B,0x5C};
+static const uint8_t ebi[] = {0x22,0x23,0x24,0x25,0x26,0x27,0x1D,0x19,0x1A,0x1B,0x1C,0x1E,0x1F,0x20,0x21,0x28};
+static const uint8_t gpio[] = {0x30,0x2F,0x31,0x32,0x33,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x60,0x61};
+static const uint8_t i2c1[] = {0x5D,0x5E};
+static const uint8_t spi[] = {0x46,0x47,0x48,0x49,0x4A};
+static const uint8_t nand_ctrl[] = {0x45,0x42,0x43,0x44};
+static const uint8_t pwm[] = {0x5F};
+static const uint8_t uart[] = {0x4B,0x4C};
 
 static struct {
-	uint8_t *evt;
+	const uint8_t *evt;
 	int count;
+	struct lpc31xx_gpio_chip *chip;
 } gpio_evt[] = {
 	{ebi_mci, 	sizeof(ebi_mci)},
 	{ebi_i2stx_0, 	sizeof(ebi_i2stx_0)},
@@ -77,7 +83,7 @@ static struct {
  * @config: special function and pull-resistor control information.
  * @pm_save: Save information for suspend/resume support.
  *
- * This wrapper provides the necessary information for the Samsung
+ * This wrapper provides the necessary information for the NXP
  * specific gpios being registered with gpiolib.
  */
 struct lpc313x_gpio_chip {
@@ -91,11 +97,6 @@ struct lpc313x_gpio_chip {
 };
 #endif
 
-struct lpc31xx_gpio_chip {
-	struct of_mm_gpio_chip mmchip;
-	int index;
-};
-
 static int inline *gpc(void __iomem *base, int reg)
 {
 	return (int *)(base + reg);
@@ -161,14 +162,19 @@ static int lpc3131_gpio_to_irq(struct gpio_chip *gc, unsigned gpio)
 {
 	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
 	struct lpc31xx_gpio_chip *chip = container_of(mm_gc, struct lpc31xx_gpio_chip, mmchip);
-	int irq;
 
-	printk("------------- implement lpc3131_gpio_to_irq -------------\n");
-	printk("index %d gpio %d event %02x\n", chip->index, gpio, gpio_evt[chip->index].evt[gpio]);
-	irq = event_to_irq(gpio_evt[chip->index].evt[gpio]);
-	printk("irq %d\n", irq);
-	return irq;
+	return event_to_irq(gpio_evt[chip->index].evt[gpio]);
+}
+
+int lpc3131_reg_to_gpio(unsigned index, unsigned gpio)
+{
+	struct lpc31xx_gpio_chip *chip;
+
+	chip = gpio_evt[index].chip;
+	return chip->mmchip.gc.base + gpio;
 }
+EXPORT_SYMBOL(lpc3131_reg_to_gpio);
+
 
 static int lpc313x_gpiochip_remove(struct platform_device *ofdev)
 {
@@ -188,6 +194,7 @@ static int __devinit lpc313x_simple_gpiochip_probe(struct platform_device *pdev)
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	chip->index = (res->start >> 6) & 7;
+	gpio_evt[chip->index].chip = chip;
 
 	gc = &chip->mmchip.gc;
 	gc->ngpio            = gpio_evt[chip->index].count;
diff --git a/drivers/net/ethernet/davicom/dm9000.c b/drivers/net/ethernet/davicom/dm9000.c
index b1e6632..761926c 100644
--- a/drivers/net/ethernet/davicom/dm9000.c
+++ b/drivers/net/ethernet/davicom/dm9000.c
@@ -63,7 +63,7 @@ MODULE_PARM_DESC(watchdog, "transmit timeout in milliseconds");
 /*
  * Debug messages level
  */
-static int debug;
+static int debug = 4;
 module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug, "dm9000 debug level (0-4)");
 
@@ -662,6 +662,7 @@ dm9000_poll_work(struct work_struct *w)
 	board_info_t *db = container_of(dw, board_info_t, phy_poll);
 	struct net_device *ndev = db->ndev;
 
+printk("dm9000_poll_work\n");
 	if (db->flags & DM9000_PLATF_SIMPLE_PHY &&
 	    !(db->flags & DM9000_PLATF_EXT_PHY)) {
 		unsigned nsr = dm9000_read_locked(db, DM9000_NSR);
@@ -1070,6 +1071,7 @@ static irqreturn_t dm9000_interrupt(int irq, void *dev_id)
 	unsigned long flags;
 	u8 reg_save;
 
+	printk("dm9000_interrupt\n");
 	dm9000_dbg(db, 3, "entering %s\n", __func__);
 
 	/* A real interrupt coming */
@@ -1179,6 +1181,8 @@ dm9000_open(struct net_device *dev)
 	/* If there is no IRQ type specified, default to something that
 	 * may work, and tell the user that this is a problem */
 
+	irqflags |= IRQ_TYPE_LEVEL_HIGH;
+
 	if (irqflags == IRQF_TRIGGER_NONE)
 		dev_warn(db->dev, "WARNING: no IRQ resource flags set.\n");
 
diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 9cf0060..bdded99 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -336,6 +336,7 @@ EXPORT_SYMBOL_GPL(of_irq_map_one);
  */
 int of_irq_to_resource(struct device_node *dev, int index, struct resource *r)
 {
+	int type;
 	int irq = irq_of_parse_and_map(dev, index);
 
 	/* Only dereference the resource if both the
