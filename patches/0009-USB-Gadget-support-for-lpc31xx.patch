Bottom: 2aa7dea4ea78d71239c765b0350c9ed2a9a9d5d8
Top:    9e170393f52efdfaeefcac5903d0480bc5459f83
Author: Jon Smirl (none) <jonsmirl@terra>
Date:   2012-09-09 14:57:45 -0400

From 8e87d9f6c23e6d1a38f14a823e20da3911e9dd41 Mon Sep 17 00:00:00 2001

Subject: USB Gadget support for lpc31xx


---

diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 51ab5fd..63d17db 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -160,13 +160,19 @@ config USB_ATMEL_USBA
 	  USBA is the integrated high-speed USB Device controller on
 	  the AT32AP700x, some AT91SAM9 and AT91CAP9 processors from Atmel.
 
+config USB_ATMEL_USBA
+	tristate
+	depends on USB_GADGET_ATMEL_USBA
+	default USB_GADGET
+	select USB_GADGET_SELECTED
+
 config USB_FSL_USB2
 	tristate "Freescale Highspeed USB DR Peripheral Controller"
-	depends on FSL_SOC || ARCH_MXC
+	depends on FSL_SOC || ARCH_MXC || ARCH_LPC31XX
 	select USB_GADGET_DUALSPEED
 	select USB_FSL_MPH_DR_OF if OF
 	help
-	   Some of Freescale PowerPC and i.MX processors have a High Speed
+	   Some of Freescale PowerPCm LPC31xx and i.MX processors have a High Speed
 	   Dual-Role(DR) USB controller, which supports device mode.
 
 	   The number of programmable endpoints is different through
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 3fd8cd0..a017aca 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_USB_ATMEL_USBA)	+= atmel_usba_udc.o
 obj-$(CONFIG_USB_FSL_USB2)	+= fsl_usb2_udc.o
 fsl_usb2_udc-y			:= fsl_udc_core.o
 fsl_usb2_udc-$(CONFIG_ARCH_MXC)	+= fsl_mxc_udc.o
+fsl_usb2_udc-$(CONFIG_ARCH_LPC31XX) += fsl_lpc_udc.o
 obj-$(CONFIG_USB_M66592)	+= m66592-udc.o
 obj-$(CONFIG_USB_R8A66597)	+= r8a66597-udc.o
 obj-$(CONFIG_USB_FSL_QE)	+= fsl_qe_udc.o
diff --git a/drivers/usb/gadget/fsl_lpc_udc.c b/drivers/usb/gadget/fsl_lpc_udc.c
new file mode 100644
index 0000000..68d862b
--- /dev/null
+++ b/drivers/usb/gadget/fsl_lpc_udc.c
@@ -0,0 +1,40 @@
+/*
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Description:
+ * Helper routines for LPC313x/4x/5x SoCs from NXP, needed by the fsl_udc_core.c
+ * driver to function correctly on these systems.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/fsl_devices.h>
+#include <linux/platform_device.h>
+
+int fsl_udc_clk_init(struct platform_device *pdev)
+{
+	return 0;
+}
+
+void fsl_udc_clk_finalize(struct platform_device *pdev)
+{
+}
+
+void fsl_udc_clk_release(void)
+{
+}
diff --git a/drivers/usb/gadget/fsl_udc_core.c b/drivers/usb/gadget/fsl_udc_core.c
index 3def828..74176de 100644
--- a/drivers/usb/gadget/fsl_udc_core.c
+++ b/drivers/usb/gadget/fsl_udc_core.c
@@ -17,7 +17,9 @@
  * option) any later version.
  */
 
-#undef VERBOSE
+//#define VERBOSE
+//#define VERBOSE_DEBUG
+//#define DEBUG
 
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -75,6 +77,8 @@ fsl_ep0_desc = {
 };
 
 static void fsl_ep_fifo_flush(struct usb_ep *_ep);
+static int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state);
+static int fsl_udc_resume(struct platform_device *pdev);
 
 #ifdef CONFIG_PPC32
 /*
@@ -535,9 +539,9 @@ static void ep0_setup(struct fsl_udc *udc)
 	/* the intialization of an ep includes: fields in QH, Regs,
 	 * fsl_ep struct */
 	struct_ep_qh_setup(udc, 0, USB_RECV, USB_ENDPOINT_XFER_CONTROL,
-			USB_MAX_CTRL_PAYLOAD, 0, 0);
+			USB_MAX_CTRL_PAYLOAD, 1, 0);
 	struct_ep_qh_setup(udc, 0, USB_SEND, USB_ENDPOINT_XFER_CONTROL,
-			USB_MAX_CTRL_PAYLOAD, 0, 0);
+			USB_MAX_CTRL_PAYLOAD, 1, 0);
 	dr_ep_setup(0, USB_RECV, USB_ENDPOINT_XFER_CONTROL);
 	dr_ep_setup(0, USB_SEND, USB_ENDPOINT_XFER_CONTROL);
 
@@ -564,6 +568,7 @@ static int fsl_ep_enable(struct usb_ep *_ep,
 	unsigned char mult = 0, zlt;
 	int retval = -EINVAL;
 	unsigned long flags = 0;
+	unsigned char dir = 0;
 
 	ep = container_of(_ep, struct fsl_ep, ep);
 
@@ -615,17 +620,20 @@ static int fsl_ep_enable(struct usb_ep *_ep,
 	/* Controller related setup */
 	/* Init EPx Queue Head (Ep Capabilites field in QH
 	 * according to max, zlt, mult) */
-	struct_ep_qh_setup(udc, (unsigned char) ep_index(ep),
-			(unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)
-					?  USB_SEND : USB_RECV),
+	dir = (unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)
+			          ? USB_SEND : USB_RECV);
+	struct_ep_qh_setup(udc, (unsigned char) ep_index(ep), dir,
 			(unsigned char) (desc->bmAttributes
 					& USB_ENDPOINT_XFERTYPE_MASK),
 			max, zlt, mult);
 
+	/* Clear endpoint stall if set */
+	if(dr_ep_get_stall((unsigned char) ep_index(ep), dir)) {
+		dr_ep_change_stall((unsigned char) ep_index(ep), dir, 0);
+	}
+
 	/* Init endpoint ctrl register */
-	dr_ep_setup((unsigned char) ep_index(ep),
-			(unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)
-					? USB_SEND : USB_RECV),
+	dr_ep_setup((unsigned char) ep_index(ep), dir,
 			(unsigned char) (desc->bmAttributes
 					& USB_ENDPOINT_XFERTYPE_MASK));
 
@@ -1447,15 +1455,20 @@ static void setup_received_irq(struct fsl_udc *udc,
 				== (USB_RECIP_ENDPOINT | USB_TYPE_STANDARD)) {
 			int pipe = get_pipe_by_windex(wIndex);
 			struct fsl_ep *ep;
+			unsigned long flags = 0;
 
 			if (wValue != 0 || wLength != 0 || pipe >= udc->max_ep)
 				break;
 			ep = get_ep_by_pipe(udc, pipe);
 
 			spin_unlock(&udc->lock);
-			rc = fsl_ep_set_halt(&ep->ep,
-					(setup->bRequest == USB_REQ_SET_FEATURE)
-						? 1 : 0);
+			spin_lock_irqsave(&ep->udc->lock, flags);
+			dr_ep_change_stall((unsigned char)(ep_index(ep)),
+					(ep_is_in(ep) ? USB_SEND : USB_RECV),
+					((setup->bRequest == USB_REQ_SET_FEATURE)
+					             ? 1 : 0));
+			rc = 0;
+			spin_unlock_irqrestore(&ep->udc->lock, flags);
 			spin_lock(&udc->lock);
 
 		} else if ((setup->bRequestType & (USB_RECIP_MASK
@@ -2479,7 +2492,6 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 			goto err_kfree;
 		}
 	}
-
 	dr_regs = ioremap(res->start, resource_size(res));
 	if (!dr_regs) {
 		ret = -ENOMEM;
@@ -2520,6 +2532,11 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 	/* DEN is bidirectional ep number, max_ep doubles the number */
 	udc_controller->max_ep = (dccparams & DCCPARAMS_DEN_MASK) * 2;
 
+#ifdef CONFIG_USB_OTG
+	udc_controller->transceiver = otg_get_transceiver();
+	VDBG("udc: otg_get_transceiver returns 0x%p", udc_controller->transceiver);
+#endif
+
 	udc_controller->irq = platform_get_irq(pdev, 0);
 	if (!udc_controller->irq) {
 		ret = -ENODEV;
@@ -2646,6 +2663,12 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 
 	fsl_udc_clk_release();
 
+#ifdef CONFIG_USB_OTG
+	if (udc_controller->transceiver) {
+		otg_put_transceiver(udc_controller->transceiver);
+		udc_controller->transceiver = 0;
+	}
+#endif
 	/* DR has been stopped in usb_gadget_unregister_driver() */
 	remove_proc_file();
 
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index b8b3a34..7e803d4 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -38,6 +38,7 @@
 #define gadget_is_imx(g)		(!strcmp("imx_udc", (g)->name))
 #define gadget_is_langwell(g)		(!strcmp("langwell_udc", (g)->name))
 #define gadget_is_lpc32xx(g)		(!strcmp("lpc32xx_udc", (g)->name))
+#define gadget_is_lpc313x(g)		(!strcmp("lpc313x_udc", (g)->name))
 #define gadget_is_m66592(g)		(!strcmp("m66592_udc", (g)->name))
 #define gadget_is_musbhdrc(g)		(!strcmp("musb-hdrc", (g)->name))
 #define gadget_is_net2272(g)		(!strcmp("net2272", (g)->name))
@@ -119,7 +120,11 @@ static inline int usb_gadget_controller_number(struct usb_gadget *gadget)
 		return 0x31;
 	else if (gadget_is_dwc3(gadget))
 		return 0x32;
+<<<<<<< current
 	else if (gadget_is_lpc32xx(gadget))
+=======
+	else if (gadget_is_lpc313x(gadget))
+>>>>>>> patched
 		return 0x33;
 
 	return -ENOENT;
