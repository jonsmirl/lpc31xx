Bottom: 9bfcd77a0fcc7e4e4fef667733c1dc4ce667313c
Top:    02cc1ff1c0e3a587be9bffd9aa717ff49c06906b
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-05-06 19:12:03 -0400

intr domain irq


---

diff --git a/arch/arm/mach-lpc31xx/evtr.c b/arch/arm/mach-lpc31xx/evtr.c
index 853f04d..b1c8985 100644
--- a/arch/arm/mach-lpc31xx/evtr.c
+++ b/arch/arm/mach-lpc31xx/evtr.c
@@ -28,8 +28,10 @@
 #include <linux/module.h>
 #include <linux/irqdomain.h>
 #include <linux/of_platform.h>
+#include <linux/of_address.h>
 #include <linux/slab.h>
 #include <linux/gpio.h>
+#include <linux/io.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
@@ -37,6 +39,28 @@
 #include <mach/irqs.h>
 #include <mach/clock.h>
 
+/***********************************************************************
+ * Event router register definitions
+ **********************************************************************/
+#define EVTR_INT_PEND(bank)  (0xC00 + ((bank) << 2))
+#define EVTR_INT_CLR(bank)   (0xC20 + ((bank) << 2))
+#define EVTR_INT_SET(bank)   (0xC40 + ((bank) << 2))
+#define EVTR_MASK(bank)      (0xC60 + ((bank) << 2))
+#define EVTR_MASK_CLR(bank)  (0xC80 + ((bank) << 2))
+#define EVTR_MASK_SET(bank)  (0xCA0 + ((bank) << 2))
+#define EVTR_APR(bank)       (0xCC0 + ((bank) << 2))
+#define EVTR_ATR(bank)       (0xCE0 + ((bank) << 2))
+#define EVTR_RSR(bank)       (0xD20 + ((bank) << 2))
+#define EVTR_OUT_PEND(vec,bank)     (0x1000 + ((vec) << 5) + ((bank) << 2))
+#define EVTR_OUT_MASK(vec,bank)     (0x1400 + ((vec) << 5) + ((bank) << 2))
+#define EVTR_OUT_MASK_CLR(vec,bank) (0x1800 + ((vec) << 5) + ((bank) << 2))
+#define EVTR_OUT_MASK_SET(vec,bank) (0x1C00 + ((vec) << 5) + ((bank) << 2))
+
+#define IRQ_EVT_ROUTER0	1	/*interrupts from Event router 0*/
+#define IRQ_EVT_ROUTER1	2	/*interrupts from Event router 1*/
+#define IRQ_EVT_ROUTER2	3	/*interrupts from Event router 2*/
+#define IRQ_EVT_ROUTER3	4	/*interrupts from Event router 3*/
+
 /* External interrupt type enumerations */
 typedef enum
 {
@@ -79,6 +103,12 @@ static struct irq_domain *evtr_domain;
 static struct event_data *events;
 static int num_events;
 
+static void __iomem *evtr_regs;
+#define evtr_read(reg) \
+	__raw_readl(evtr_regs + reg)
+#define evtr_write(reg, value) \
+	__raw_writel(value, evtr_regs + reg);
+
 /* table to map from event to gpio bit */
 /* mask 0x1E0 reg, mask 0x1F bit */
 int event_to_gpioreg[] = {
@@ -105,7 +135,7 @@ static void evt_mask_irq(struct irq_data *data)
 	uint32_t bank = EVT_GET_BANK(events[data->hwirq].event);
 	uint32_t bit_pos = events[data->hwirq].event& 0x1F;
 
-	EVRT_MASK_CLR(bank) = _BIT(bit_pos);
+	evtr_write(EVTR_MASK_CLR(bank), _BIT(bit_pos));
 }
 
 static void evt_unmask_irq(struct irq_data *data)
@@ -113,7 +143,7 @@ static void evt_unmask_irq(struct irq_data *data)
 	uint32_t bank = EVT_GET_BANK(events[data->hwirq].event);
 	uint32_t bit_pos = events[data->hwirq].event & 0x1F;
 
-	EVRT_MASK_SET(bank) = _BIT(bit_pos);
+	evtr_write(EVTR_MASK_SET(bank), _BIT(bit_pos));
 }
 
 static void evt_ack_irq(struct irq_data *data)
@@ -121,7 +151,7 @@ static void evt_ack_irq(struct irq_data *data)
 	uint32_t bank = EVT_GET_BANK(events[data->hwirq].event);
 	uint32_t bit_pos = events[data->hwirq].event & 0x1F;
 	//EVRT_MASK_CLR(bank) = _BIT(bit_pos);
-	EVRT_INT_CLR(bank) = _BIT(bit_pos);
+	evtr_write(EVTR_INT_CLR(bank), _BIT(bit_pos));
 }
 
 static int evt_set_type(struct irq_data *data, unsigned int flow_type)
@@ -131,23 +161,28 @@ static int evt_set_type(struct irq_data *data, unsigned int flow_type)
 
 	switch (flow_type) {
 	case IRQ_TYPE_EDGE_RISING:
-		EVRT_APR(bank) |= _BIT(bit_pos);
-		EVRT_ATR(bank) |= _BIT(bit_pos);
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) | _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	case IRQ_TYPE_EDGE_FALLING:
-		EVRT_APR(bank) &= ~_BIT(bit_pos);
-		EVRT_ATR(bank) |= _BIT(bit_pos);
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) & ~_BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	case IRQ_TYPE_EDGE_BOTH:
-		EVRT_ATR(bank) |= _BIT(bit_pos);
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	case IRQ_TYPE_LEVEL_HIGH:
-		EVRT_APR(bank) |= _BIT(bit_pos);
-		EVRT_ATR(bank) &= ~_BIT(bit_pos);
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) | _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) &~ _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	case IRQ_TYPE_LEVEL_LOW:
-		EVRT_APR(bank) &= ~_BIT(bit_pos);
-		EVRT_ATR(bank) &= ~_BIT(bit_pos);
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) &~ _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) &~ _BIT(bit_pos));
+		irq_set_handler(data->irq, handle_level_irq);
 		break;
 	default:
 		return -EINVAL;
@@ -161,17 +196,17 @@ static int evt_set_wake(struct irq_data *data, unsigned int on)
 	uint32_t bank = EVT_GET_BANK(events[data->hwirq].event);
 	uint32_t bit_pos = events[data->hwirq].event & 0x1F;
 
-	if (on)
+	if (on) {
 		/* enable routing to CGU_WAKEUP */
-		EVRT_OUT_MASK_SET(4, bank) = _BIT(bit_pos);
-	else
+		evtr_write(EVTR_OUT_MASK_SET(4, bank), _BIT(bit_pos));
+	} else {
 		/* disable routing to CGU_WAKEUP */
-		EVRT_OUT_MASK_CLR(4, bank) = _BIT(bit_pos);
-
+		evtr_write(EVTR_OUT_MASK_CLR(4, bank), _BIT(bit_pos));
+	}
 	return 0;
 }
 
-extern int lpc3131_reg_to_gpio(unsigned index, unsigned gpio);
+extern int lpc31xx_reg_to_gpio(unsigned index, unsigned gpio);
 
 /* when a gpio pin is request as an interrupt source,
  * make sure it is input mode
@@ -186,7 +221,7 @@ static int set_input(unsigned virq)
 			reg  = event_to_gpioreg[event];
 			if (!reg) /* not a gpio pin */
 				return -EINVAL;
-			gpio = lpc3131_reg_to_gpio(reg >> 5, reg & 0x1F);
+			gpio = lpc31xx_reg_to_gpio(reg >> 5, reg & 0x1F);
 			printk("setting to input %d\n", gpio);
 			ret = gpio_request(gpio, "IRQ");
 			if (ret)
@@ -222,7 +257,7 @@ static struct irq_chip lpc31xx_evtr_chip = {
 			/* compute bank & bit position for the event_pin */ \
 			bank = EVT_GET_BANK(events[i].event); \
 			bit_pos = events[i].event & 0x1F; \
-			status = EVRT_OUT_PEND(n, bank); \
+			status = evtr_read(EVTR_OUT_PEND(n, bank)); \
 			if (status & _BIT(bit_pos)) { \
 				generic_handle_irq(events[i].virq); \
 				break; \
@@ -236,7 +271,7 @@ ROUTER_HDLR(1)
 ROUTER_HDLR(2)
 ROUTER_HDLR(3)
 
-int event_to_irq(int event)
+int lpc31xx_event_to_irq(int event)
 {
 	int i;
 	for (i = 0; i < num_events; i++) {
@@ -246,7 +281,23 @@ int event_to_irq(int event)
 	}
 	return -EINVAL;
 }
-EXPORT_SYMBOL(event_to_irq);
+EXPORT_SYMBOL(lpc31xx_event_to_irq);
+
+int lpc31xx_set_cgu_wakeup(int enable, int event)
+{
+	uint32_t bank = EVT_GET_BANK(event);
+	uint32_t bit_pos = event & 0x1F;
+
+	if (!evtr_regs)
+		return -EAGAIN;
+
+	if (enable)
+		evtr_write(EVTR_OUT_MASK_SET(4, bank), _BIT(bit_pos))
+	else
+		evtr_write(EVTR_OUT_MASK_CLR(4, bank), _BIT(bit_pos))
+	return 0;
+}
+EXPORT_SYMBOL(lpc31xx_set_cgu_wakeup);
 
 static const struct of_device_id evtr_of_match[] __initconst = {
 	{ .compatible = "nxp,lpc31xx-evtr", },
@@ -257,8 +308,6 @@ static int evtr_irq_map(struct irq_domain *h, unsigned int virq, irq_hw_number_t
 {
 	uint32_t bank, bit_pos;
 	/* compute bank & bit position for the event_pin */
-	//bank = EVT_GET_BANK(irq_2_event[irq].event_pin);
-	//bit_pos = irq_2_event[irq].event_pin & 0x1F;
 	bank = EVT_GET_BANK(events[hw].event);
 	bit_pos = events[hw].event & 0x1F;
 
@@ -266,38 +315,38 @@ static int evtr_irq_map(struct irq_domain *h, unsigned int virq, irq_hw_number_t
 	set_irq_flags(virq, IRQF_VALID);
 	/* configure the interrupt sensitivity */
 	switch (events[hw].edge) {
-		case EVT_ACTIVE_LOW:
-			EVRT_APR(bank) &= ~_BIT(bit_pos);
-			EVRT_ATR(bank) &= ~_BIT(bit_pos);
-			irq_set_handler(virq, handle_level_irq);
-			break;
-		case EVT_ACTIVE_HIGH:
-			EVRT_APR(bank) |= _BIT(bit_pos);
-			EVRT_ATR(bank) &= ~_BIT(bit_pos);
-			irq_set_handler(virq, handle_level_irq);
-			break;
-		case EVT_FALLING_EDGE:
-			EVRT_APR(bank) &= ~_BIT(bit_pos);
-			EVRT_ATR(bank) |= _BIT(bit_pos);
-			irq_set_handler(virq, handle_edge_irq);
-			break;
-		case EVT_RISING_EDGE:
-			EVRT_APR(bank) |= _BIT(bit_pos);
-			EVRT_ATR(bank) |= _BIT(bit_pos);
-			irq_set_handler(virq, handle_edge_irq);
-			break;
-		case EVT_BOTH_EDGE:
-			EVRT_ATR(bank) |= _BIT(bit_pos);
-			irq_set_handler(virq, handle_edge_irq);
-			break;
-		default:
-			printk("Invalid Event type.\r\n");
-			break;
+	case EVT_RISING_EDGE:
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) | _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(virq, handle_edge_irq);
+		break;
+	case EVT_FALLING_EDGE:
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) & ~_BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(virq, handle_edge_irq);
+		break;
+	case EVT_BOTH_EDGE:
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) | _BIT(bit_pos));
+		irq_set_handler(virq, handle_edge_irq);
+		break;
+	case EVT_ACTIVE_HIGH:
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) | _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) &~ _BIT(bit_pos));
+		irq_set_handler(virq, handle_level_irq);
+		break;
+	case EVT_ACTIVE_LOW:
+		evtr_write(EVTR_APR(bank), evtr_read(EVTR_APR(bank)) &~ _BIT(bit_pos));
+		evtr_write(EVTR_ATR(bank), evtr_read(EVTR_ATR(bank)) &~ _BIT(bit_pos));
+		irq_set_handler(virq, handle_level_irq);
+		break;
+	default:
+		printk("Invalid Event type.\r\n");
+		break;
 	}
-	EVRT_OUT_MASK_SET(events[hw].group, bank) = _BIT(bit_pos);
-	printk("evtr hw=%ld virq=%d Event=0x%02x bank:%d bit:%02d type:%d vector %d\n", hw, virq,
+	evtr_write(EVTR_OUT_MASK_SET(events[hw].group, bank), _BIT(bit_pos));
+	/*printk("evtr hw=%ld virq=%d Event=0x%02x bank:%d bit:%02d type:%d vector %d\n", hw, virq,
 		events[hw].event, bank,
-		bit_pos, events[hw].edge, events[hw].group);
+		bit_pos, events[hw].edge, events[hw].group); */
 	events[hw].virq = virq;
 
 	return 0;
@@ -310,13 +359,14 @@ static struct irq_domain_ops evtr_ops = {
 
 static int __devinit lpc31xx_evtr_probe(struct platform_device *pdev)
 {
-	unsigned int irq;
 	int i, j;
 	const __be32 *ip;
 	struct device_node *np = pdev->dev.of_node;
 	int cells, length;
 
-	printk("###### Event router probe ######\n");
+	evtr_regs = of_iomap(np, 0);
+	if (!evtr_regs)
+		return -EINVAL;
 
 	ip = of_get_property(np, "#event-cells", NULL);
 	if (!ip)
@@ -332,30 +382,31 @@ static int __devinit lpc31xx_evtr_probe(struct platform_device *pdev)
 		events[i].group = be32_to_cpup(ip++);
 		events[i].event = be32_to_cpup(ip++);
 		events[i].edge = be32_to_cpup(ip++);
-		printk("group %d bit %02x edge %d\n", events[i].group, events[i].event, events[i].edge);
-		//set_input(events[i].event);
+		if ((events[i].group < 0) || (events[i].group >= EVT_MAX_VALID_BANKS))
+			panic("Event router groups must be 0-3");
 	}
+	/* enable clock to Event router */
+	cgu_clk_en_dis(CGU_SB_EVENT_ROUTER_PCLK_ID, 1);
 
 	/* mask all external events */
-	for (i = 0; i < EVT_MAX_VALID_BANKS; i++)
-	{
+	for (i = 0; i < EVT_MAX_VALID_BANKS; i++) {
 		/* mask all events */
-		EVRT_MASK_CLR(i) = 0xFFFFFFFF;
+		evtr_write(EVTR_MASK_CLR(i), 0xFFFFFFFF);
 		/* clear all pending events */
-		EVRT_INT_CLR(i) = 0xFFFFFFFF;
+		evtr_write(EVTR_INT_CLR(i), 0xFFFFFFFF);
 
-		for (j = 0; j < EVT_MAX_VALID_INT_OUT; j++)
-		{
+		for (j = 0; j < EVT_MAX_VALID_INT_OUT; j++) {
 			/* mask all events */
-			EVRT_OUT_MASK_CLR(j,i) = 0xFFFFFFFF;
+			evtr_write(EVTR_OUT_MASK_CLR(j,i), 0xFFFFFFFF);
 		}
 	}
-	evtr_domain = irq_domain_add_linear(np, num_events, &evtr_ops, NULL);
+	//evtr_domain = irq_domain_add_linear(np, num_events, &evtr_ops, NULL);
+	evtr_domain = irq_domain_add_legacy(np, num_events, 30, 0, &evtr_ops, NULL);
 
 	/* for power management. Wake from internal irqs */
-	EVRT_APR(3) &= ~_BIT(12);
-	EVRT_ATR(3) &= ~_BIT(12);
-	EVRT_MASK_SET(3) = _BIT(12);
+	evtr_write(EVTR_APR(3), evtr_read(EVTR_APR(3)) & ~_BIT(12));
+	evtr_write(EVTR_ATR(3), evtr_read(EVTR_ATR(3)) & ~_BIT(12));
+	evtr_write(EVTR_MASK_SET(3), _BIT(12));
 
 	/* install IRQ_EVT_ROUTER0  chain handler */
 	irq_set_chained_handler (IRQ_EVT_ROUTER0, router0_handler);
diff --git a/arch/arm/mach-lpc31xx/generic.c b/arch/arm/mach-lpc31xx/generic.c
index d257d47..a59ead8 100644
--- a/arch/arm/mach-lpc31xx/generic.c
+++ b/arch/arm/mach-lpc31xx/generic.c
@@ -27,6 +27,8 @@
 #include <linux/string.h>
 #include <linux/console.h>
 #include <linux/serial_8250.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 
 #include <asm/errno.h>
 #include <mach/hardware.h>
@@ -36,6 +38,11 @@
 
 /* local functions */
 
+static struct of_device_id uart_ids[] = {
+	{ .compatible = "nxp,lpc31xx-uart" },
+	{ /* sentinel */ }
+};
+
 static void lpc31xx_uart_pm(struct uart_port * port, unsigned int state,
 			      unsigned int oldstate)
 {
@@ -90,7 +97,8 @@ static struct plat_serial8250_port platform_serial_ports[] = {
 	{
 		.membase = (void *)io_p2v(UART_PHYS),
 		.mapbase = (unsigned long)UART_PHYS,
-		.irq = IRQ_UART,
+		//.irq = IRQ_UART,
+		.irq = 13,
 		.uartclk = XTAL_CLOCK,
 		.regshift = 2,
 		.iotype = UPIO_MEM,
@@ -188,6 +196,24 @@ void __init lpc31xx_uart_init(void)
 {
 	int mul, div;
 
+	struct device_node *node;
+	int irq;
+
+	node = of_find_matching_node(NULL, uart_ids);
+	if (!node)
+		return;
+
+	/* Get the interrupts property */
+	irq = irq_of_parse_and_map(node, 0);
+	if (!irq) {
+		pr_crit("LPC31xx: UART -  unable to get IRQ from DT\n");
+		return;
+	}
+	of_node_put(node);
+
+	platform_serial_ports[0].irq = irq;
+	printk("JDS - Uart IRQ %d\n", irq);
+
 	/* check what FDR bootloader is using */
 	mul = (UART_FDR_REG >> 4) & 0xF;
 	div = UART_FDR_REG & 0xF;
@@ -213,8 +239,8 @@ void __init lpc31xx_init(void)
 	/* Disable ring oscillators used by Random number generators */
 	SYS_RNG_OSC_CFG = 0;
 
+	/* fixme */
 #if 0
-	/* fix me */
 	/* Mux I2S signals based on selected channel */
 #if defined (CONFIG_SND_I2S_TX0_MASTER)
 	/* I2S TX0 WS, DATA */
@@ -264,22 +290,17 @@ static int __init lpc31xx_init_console(void)
  	 */
 	memset(&up, 0, sizeof(up));
 
+	lpc31xx_uart_init();
+	up.uartclk = platform_serial_ports[0].uartclk;
+	up.irq = platform_serial_ports[0].irq;
+
 	up.membase = (char *) io_p2v(UART_PHYS);
 	up.mapbase = (unsigned long)UART_PHYS,
-	up.irq = IRQ_UART;
-	up.uartclk = XTAL_CLOCK;
-	/* check what FDR bootloader is using */
-	mul = (UART_FDR_REG >> 4) & 0xF;
-	div = UART_FDR_REG & 0xF;
-	if (div != 0)  {
-		up.uartclk = (XTAL_CLOCK * mul) / (mul + div);
-	}
 	up.regshift = 2;
 	up.iotype = UPIO_MEM;
 	up.type	= PORT_NXP16750;
 	up.flags = UPF_BOOT_AUTOCONF | UPF_BUGGY_UART | UPF_SKIP_TEST;
 	up.line	= 0;
-	platform_serial_ports[0].uartclk = up.uartclk;
 	if (early_serial_setup(&up))
 		printk(serr, up.line);
 
diff --git a/arch/arm/mach-lpc31xx/include/mach/irqs.h b/arch/arm/mach-lpc31xx/include/mach/irqs.h
index 7ded119..f650c47 100644
--- a/arch/arm/mach-lpc31xx/include/mach/irqs.h
+++ b/arch/arm/mach-lpc31xx/include/mach/irqs.h
@@ -25,39 +25,6 @@
 #ifndef __ASM_ARCH_IRQS_H
 #define __ASM_ARCH_IRQS_H
 
-#define IRQ_EVT_ROUTER0	1	/*interrupts from Event router 0*/
-#define IRQ_EVT_ROUTER1	2	/*interrupts from Event router 1*/
-#define IRQ_EVT_ROUTER2	3	/*interrupts from Event router 2*/
-#define IRQ_EVT_ROUTER3	4	/*interrupts from Event router 3*/
-#define IRQ_TIMER0	5	/*Timer 0 IRQ */
-#define IRQ_TIMER1	6	/*Timer 1 IRQ */
-#define IRQ_TIMER2	7	/*Timer 2 IRQ */
-#define IRQ_TIMER3	8	/*Timer 3 IRQ */
-#define IRQ_ADC		9	/*10bit ADC IRQ*/
-#define IRQ_UART	10	/*UART IRQ */
-#define IRQ_I2C0	11	/*I2C 0 IRQ */
-#define IRQ_I2C1	12	/*I2C 1 IRQ */
-#define IRQ_I2S0_OUT	13	/*I2S 0 out IRQ */
-#define IRQ_I2S1_OUT	14	/*I2S 1 out IRQ */
-#define IRQ_I2S0_IN	15	/*I2S 0 IN IRQ */
-#define IRQ_I2S1_IN	16	/*I2S 1 IN IRQ */
-#define IRQ_LCD		18	/*LCD IRQ */
-#define IRQ_SPI_SMS	19	/*SPI SMS IRQ */
-#define IRQ_SPI_TX	20	/*SPI Transmit IRQ */
-#define IRQ_SPI_RX	21	/*SPI Receive IRQ */
-#define IRQ_SPI_OVR	22	/*SPI overrun IRQ */
-#define IRQ_SPI		23	/*SPI interrupt IRQ */
-#define IRQ_DMA		24	/*DMA IRQ */
-#define IRQ_NAND_FLASH	25	/*NAND flash IRQ */
-#define IRQ_MCI		26	/*MCI IRQ */
-#define IRQ_USB		27	/*USB IRQ */
-#define IRQ_ISRAM0	28	/*ISRAM0 IRQ */
-#define IRQ_ISRAM1	29	/*ISRAM1 IRQ */
-
-#define NR_IRQ_CPU	30	/* IRQs directly recognized by CPU */
-
-#define NR_IRQ_BOARD	34	/* Leave room for board specific IRQs */
-
-#define NR_IRQS		(NR_IRQ_CPU + NR_IRQ_BOARD)
+#define NR_IRQS 64
 
 #endif
diff --git a/arch/arm/mach-lpc31xx/include/mach/registers.h b/arch/arm/mach-lpc31xx/include/mach/registers.h
index 456f5c6..beb6f77 100644
--- a/arch/arm/mach-lpc31xx/include/mach/registers.h
+++ b/arch/arm/mach-lpc31xx/include/mach/registers.h
@@ -24,47 +24,6 @@
 #ifndef __ASM_ARCH_REGISTERS_H
 #define __ASM_ARCH_REGISTERS_H
 
-
-/***********************************************************************
- * Interrupt controller register definitions
- **********************************************************************/
-#define INTC_IRQ_PRI_MASK     __REG(INTC_PHYS + 0x000)
-#define INTC_FIQ_PRI_MASK     __REG(INTC_PHYS + 0x004)
-#define INTC_IRQ_VEC_BASE     __REG(INTC_PHYS + 0x100)
-#define INTC_FIQ_VEC_BASE     __REG(INTC_PHYS + 0x104)
-#define INTC_REQ_REG(irq)     __REG(INTC_PHYS + 0x400 + ((irq) << 2))
-
-#define INTC_REQ_PEND         _BIT(31)
-#define INTC_REQ_SET_SWINT    _BIT(30)
-#define INTC_REQ_CLR_SWINT    _BIT(29)
-#define INTC_REQ_WE_PRIO_LVL  _BIT(28)
-#define INTC_REQ_WE_TARGET    _BIT(27)
-#define INTC_REQ_WE_ENABLE    _BIT(26)
-#define INTC_REQ_WE_ACT_LOW   _BIT(25)
-#define INTC_REQ_ACT_LOW      _BIT(17)
-#define INTC_REQ_ENABLE       _BIT(16)
-#define INTC_REQ_TARGET(n)    _SBF(8, ((n) & 0x3F))
-#define INTC_REQ_PRIO_LVL(n)  ((n) & 0xFF)
-#define INTC_REQ_TARGET_IRQ   (INTC_REQ_WE_TARGET)
-#define INTC_REQ_TARGET_FIQ   (INTC_REQ_WE_TARGET | _BIT(8))
-
-/***********************************************************************
- * Event router register definitions
- **********************************************************************/
-#define EVRT_INT_PEND(bank)  __REG (EVTR_PHYS + 0xC00 + ((bank) << 2))
-#define EVRT_INT_CLR(bank)   __REG (EVTR_PHYS + 0xC20 + ((bank) << 2))
-#define EVRT_INT_SET(bank)   __REG (EVTR_PHYS + 0xC40 + ((bank) << 2))
-#define EVRT_MASK(bank)      __REG (EVTR_PHYS + 0xC60 + ((bank) << 2))
-#define EVRT_MASK_CLR(bank)  __REG (EVTR_PHYS + 0xC80 + ((bank) << 2))
-#define EVRT_MASK_SET(bank)  __REG (EVTR_PHYS + 0xCA0 + ((bank) << 2))
-#define EVRT_APR(bank)       __REG (EVTR_PHYS + 0xCC0 + ((bank) << 2))
-#define EVRT_ATR(bank)       __REG (EVTR_PHYS + 0xCE0 + ((bank) << 2))
-#define EVRT_RSR(bank)       __REG (EVTR_PHYS + 0xD20 + ((bank) << 2))
-#define EVRT_OUT_PEND(vec,bank)     __REG (EVTR_PHYS + 0x1000 + ((vec) << 5) + ((bank) << 2))
-#define EVRT_OUT_MASK(vec,bank)     __REG (EVTR_PHYS + 0x1400 + ((vec) << 5) + ((bank) << 2))
-#define EVRT_OUT_MASK_CLR(vec,bank) __REG (EVTR_PHYS + 0x1800 + ((vec) << 5) + ((bank) << 2))
-#define EVRT_OUT_MASK_SET(vec,bank) __REG (EVTR_PHYS + 0x1C00 + ((vec) << 5) + ((bank) << 2))
-
 /***********************************************************************
  * WDT register definitions
  **********************************************************************/
diff --git a/arch/arm/mach-lpc31xx/irq.c b/arch/arm/mach-lpc31xx/irq.c
index 8de96b1..623cdfb 100644
--- a/arch/arm/mach-lpc31xx/irq.c
+++ b/arch/arm/mach-lpc31xx/irq.c
@@ -26,6 +26,8 @@
 #include <linux/timer.h>
 #include <linux/of_irq.h>
 #include <linux/irqdomain.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
@@ -33,43 +35,70 @@
 #include <mach/irqs.h>
 #include <mach/clock.h>
 
+/***********************************************************************
+ * Interrupt controller register definitions
+ **********************************************************************/
+#define INTC_IRQ_PRI_MASK     0x000
+#define INTC_FIQ_PRI_MASK     0x004
+#define INTC_IRQ_VEC_BASE     0x100
+#define INTC_FIQ_VEC_BASE     0x104
+#define INTC_REQ_REG(irq)     (0x400 + ((irq) << 2))
+
+#define INTC_REQ_PEND         _BIT(31)
+#define INTC_REQ_SET_SWINT    _BIT(30)
+#define INTC_REQ_CLR_SWINT    _BIT(29)
+#define INTC_REQ_WE_PRIO_LVL  _BIT(28)
+#define INTC_REQ_WE_TARGET    _BIT(27)
+#define INTC_REQ_WE_ENABLE    _BIT(26)
+#define INTC_REQ_WE_ACT_LOW   _BIT(25)
+#define INTC_REQ_ACT_LOW      _BIT(17)
+#define INTC_REQ_ENABLE       _BIT(16)
+#define INTC_REQ_TARGET(n)    _SBF(8, ((n) & 0x3F))
+#define INTC_REQ_PRIO_LVL(n)  ((n) & 0xFF)
+#define INTC_REQ_TARGET_IRQ   (INTC_REQ_WE_TARGET)
+#define INTC_REQ_TARGET_FIQ   (INTC_REQ_WE_TARGET | _BIT(8))
+
+#define NR_IRQ_CPU	30	/* IRQs directly recognized by CPU */
+
+static void __iomem *intc_regs;
+#define intc_read(reg) \
+	__raw_readl(intc_regs + reg)
+#define intc_write(reg, value) \
+	__raw_writel(value, intc_regs + reg);
+
+
 /* Macros to compute the bank based on EVENT_T */
-#define EVT_GET_BANK(evt)	(((evt) >> 5) & 0x3)
 #define EVT_arm926_nirq		0x6C
 
-extern void __init lpc31xx_init_evtr(void);
+static struct irq_domain *intc_domain;
 
 static void intc_mask_irq(struct irq_data *data)
 {
-	INTC_REQ_REG(data->irq) = INTC_REQ_WE_ENABLE;
+	intc_write(INTC_REQ_REG(data->hwirq), INTC_REQ_WE_ENABLE);
 }
 
 static void intc_unmask_irq(struct irq_data *data)
 {
-	INTC_REQ_REG(data->irq) = INTC_REQ_ENABLE | INTC_REQ_WE_ENABLE;
+	intc_write(INTC_REQ_REG(data->hwirq), INTC_REQ_ENABLE | INTC_REQ_WE_ENABLE);
 }
 
+extern int lpc31xx_set_cgu_wakeup(int enable, int event);
+
 static int intc_set_wake(struct irq_data *data, unsigned int on)
 {
-	static u32 wake_ints = 0;
+	static uint32_t wake_ints = 0;
 
 	if (on)
 		/* save the irqs which wake */
-		wake_ints |= _BIT(data->irq);
+		wake_ints |= _BIT(data->hwirq);
 	else
 		/* clear the irqs which don't wake */
-		wake_ints &= ~_BIT(data->irq);
+		wake_ints &= ~_BIT(data->hwirq);
 
 	/* Note: the clocks to corresponding blocks shouldn't be suspended
 	 * by individual drivers for this logic to work.
 	 */
-	if (wake_ints) {
-		/* enable ARM_IRQ routing to CGU_WAKEUP */
-		EVRT_OUT_MASK_SET(4, EVT_GET_BANK(EVT_arm926_nirq)) = _BIT((EVT_arm926_nirq & 0x1F));
-	} else {
-		/* disable ARM_IRQ routing to CGU_WAKEUP */
-		EVRT_OUT_MASK_CLR(4, EVT_GET_BANK(EVT_arm926_nirq)) = _BIT((EVT_arm926_nirq & 0x1F));
-	}
+	lpc31xx_set_cgu_wakeup(EVT_arm926_nirq, wake_ints);
 
 	//printk("wake on irq=%d value=%d 0x%08x/0x%08x/0x%08x 0x%08x/0x%08x\r\n", irq, value, 
 	//	EVRT_MASK(3), EVRT_APR(3), EVRT_ATR(3),
@@ -80,7 +109,7 @@ static int intc_set_wake(struct irq_data *data, unsigned int on)
 
 static struct irq_chip lpc31xx_internal_chip = {
 	.name = "INTC",
-	.irq_ack = intc_mask_irq,
+	//.irq_ack = intc_mask_irq,
 	.irq_mask = intc_mask_irq,
 	.irq_unmask = intc_unmask_irq,
 	.irq_set_wake = intc_set_wake,
@@ -91,11 +120,41 @@ static const struct of_device_id intc_of_match[] __initconst = {
 	{},
 };
 
+static int intc_irq_map(struct irq_domain *h, unsigned int virq, irq_hw_number_t hw)
+{
+	/* Set the initial control values */
+	intc_write(INTC_REQ_REG(hw), INTC_REQ_WE_ENABLE);
+
+	/* Initialize as high-active, Disable the interrupt,
+	* Set target to IRQ , Set priority level to 1 (= lowest) for
+	* all the interrupt lines */
+	intc_write(INTC_REQ_REG(hw), INTC_REQ_WE_ACT_LOW |
+		INTC_REQ_WE_ENABLE |
+		INTC_REQ_TARGET_IRQ |
+		INTC_REQ_PRIO_LVL(1) |
+		INTC_REQ_WE_PRIO_LVL);
+
+	irq_set_chip_and_handler(virq, &lpc31xx_internal_chip, handle_level_irq);
+	set_irq_flags(virq, IRQF_VALID);
+
+	//printk("intc hw=%ld virq=%d\n", hw, virq);
+	return 0;
+}
+
+static struct irq_domain_ops intc_ops = {
+	.map	= intc_irq_map,
+	.xlate	= irq_domain_xlate_onecell,
+};
+
 void __init lpc31xx_init_irq(void)
 {
-	unsigned int irq;
+	struct device_node *node;
 
-	irq_domain_generate_simple(intc_of_match, 0x60000000, 0);
+	/* Remap the necessary zones */
+	node = of_find_matching_node(NULL, intc_of_match);
+	intc_regs = of_iomap(node, 0);
+	if (!intc_regs)
+		panic(__FILE__	": find_and_map failed on 'lpc31xx-intc'");
 
 	/* enable clock to interrupt controller */
 	cgu_clk_en_dis(CGU_SB_AHB2INTC_CLK_ID, 1);
@@ -104,37 +163,22 @@ void __init lpc31xx_init_irq(void)
 	cgu_clk_en_dis(CGU_SB_EVENT_ROUTER_PCLK_ID, 1);
 
 	/* Set the vector base (we don't use direct vectoring, so this is 0) */
-	INTC_IRQ_VEC_BASE = 0x00000000;
-	INTC_FIQ_VEC_BASE = 0x00000000;
+	intc_write(INTC_IRQ_VEC_BASE, 0x00000000);
+	intc_write(INTC_FIQ_VEC_BASE, 0x00000000);
 
 	/* mask all interrupt by setting high priority until init is done*/
-	INTC_IRQ_PRI_MASK = 0xFF;
-	INTC_FIQ_PRI_MASK = 0xFF;
-
-	/* Clear and disable all interrupts. Start from index 1 since 0 is unused.*/
-	for (irq = 1; irq < NR_IRQ_CPU; irq++) {
-		/* Set the initial control values */
-		INTC_REQ_REG(irq) = INTC_REQ_WE_ENABLE;
-
-		/* Initialize as high-active, Disable the interrupt,
-		* Set target to IRQ , Set priority level to 1 (= lowest) for
-		* all the interrupt lines */
-		INTC_REQ_REG(irq) = INTC_REQ_WE_ACT_LOW |
-			INTC_REQ_WE_ENABLE |
-			INTC_REQ_TARGET_IRQ |
-			INTC_REQ_PRIO_LVL(1) |
-			INTC_REQ_WE_PRIO_LVL;
-
-		irq_set_chip_and_handler(irq, &lpc31xx_internal_chip,
-					 handle_level_irq);
-		set_irq_flags(irq, IRQF_VALID);
-	}
+	intc_write(INTC_IRQ_PRI_MASK, 0xFF);
+	intc_write(INTC_FIQ_PRI_MASK, 0xFF);
+
+	node = of_find_matching_node_by_address(NULL, intc_of_match, INTC_PHYS);
+	intc_domain = irq_domain_add_legacy(node, NR_IRQ_CPU, 0, 0, &intc_ops, NULL);
+
+	irq_set_default_host(intc_domain);
 
 	/* Set the priority threshold to 0, i.e. don't mask any interrupt */
 	/* on the basis of priority level, for both targets (IRQ/FIQ)    */
-	INTC_IRQ_PRI_MASK = 0;
-	INTC_FIQ_PRI_MASK = 0;
-
+	intc_write(INTC_IRQ_PRI_MASK, 0);
+	intc_write(INTC_FIQ_PRI_MASK, 0);
 }
 
 
diff --git a/arch/arm/mach-lpc31xx/time.c b/arch/arm/mach-lpc31xx/time.c
index d16dfc9..d17779d 100644
--- a/arch/arm/mach-lpc31xx/time.c
+++ b/arch/arm/mach-lpc31xx/time.c
@@ -100,7 +100,7 @@ static struct of_device_id timer_ids[] = {
 static void __init lpc31xx_timer_init(void)
 {
 	struct device_node *node;
-	int ret;
+	int irq;
 
 	node = of_find_matching_node(NULL, timer_ids);
 	if (!node)
@@ -111,8 +111,8 @@ static void __init lpc31xx_timer_init(void)
 		goto node_err;
 
 	/* Get the interrupts property */
-	ret = irq_of_parse_and_map(node, 0);
-	if (!ret) {
+	irq = irq_of_parse_and_map(node, 0);
+	if (!irq) {
 		pr_crit("LPC31xx: Timer -  unable to get IRQ from DT\n");
 		goto ioremap_err;
 	}
@@ -130,7 +130,7 @@ static void __init lpc31xx_timer_init(void)
 	timer_write(TIMER_LOAD, LATCH);
 	timer_write(TIMER_CONTROL, (TM_CTRL_ENABLE | TM_CTRL_PERIODIC));
 	timer_write(TIMER_CLEAR, 0);
-	setup_irq (IRQ_TIMER0, &lpc31xx_timer_irq);
+	setup_irq (irq, &lpc31xx_timer_irq);
 
 	return;
 
diff --git a/arch/arm/mach-lpc31xx/usb.c b/arch/arm/mach-lpc31xx/usb.c
index 35c7186..4596c65 100644
--- a/arch/arm/mach-lpc31xx/usb.c
+++ b/arch/arm/mach-lpc31xx/usb.c
@@ -45,6 +45,9 @@
 #include <mach/board.h>
 #include <mach/gpio.h>
 
+#define EVRT_RSR(bank)       __REG (EVTR_PHYS + 0xD20 + ((bank) << 2))
+
+
 /****************************************************************************
 * USBOTG register definition
 ****************************************************************************/
diff --git a/drivers/gpio/gpio-lpc31xx.c b/drivers/gpio/gpio-lpc31xx.c
index 0f25f73..aa51274 100644
--- a/drivers/gpio/gpio-lpc31xx.c
+++ b/drivers/gpio/gpio-lpc31xx.c
@@ -102,7 +102,7 @@ static int inline *gpc(void __iomem *base, int reg)
 	return (int *)(base + reg);
 }
 
-static int lpc3131_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
+static int lpc31xx_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
 {
 	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(chip);
 	void __iomem *base = mm_gc->regs;
@@ -116,7 +116,7 @@ static int lpc3131_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
 	return 0;
 }
 
-static int lpc3131_gpio_direction_output(struct gpio_chip *chip, unsigned gpio, int value)
+static int lpc31xx_gpio_direction_output(struct gpio_chip *chip, unsigned gpio, int value)
 {
 	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(chip);
 	int __iomem *base = mm_gc->regs;
@@ -133,7 +133,7 @@ static int lpc3131_gpio_direction_output(struct gpio_chip *chip, unsigned gpio,
 	return 0;
 }
 
-static int lpc3131_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
+static int lpc31xx_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
 {
 	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(chip);
 	int __iomem *base = mm_gc->regs;
@@ -144,7 +144,7 @@ static int lpc3131_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
 	return value;
 }
 
-static void lpc3131_gpio_set_value(struct gpio_chip *chip, unsigned gpio, int value)
+static void lpc31xx_gpio_set_value(struct gpio_chip *chip, unsigned gpio, int value)
 {
 	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(chip);
 	int __iomem *base = mm_gc->regs;
@@ -156,24 +156,24 @@ static void lpc3131_gpio_set_value(struct gpio_chip *chip, unsigned gpio, int va
 		*gpc(base, GPIO_M0_RESET) = pin;
 }
 
-extern int event_to_irq(int event);
+extern int lpc31xx_event_to_irq(int event);
 
-static int lpc3131_gpio_to_irq(struct gpio_chip *gc, unsigned gpio)
+static int lpc31xx_gpio_to_irq(struct gpio_chip *gc, unsigned gpio)
 {
 	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
 	struct lpc31xx_gpio_chip *chip = container_of(mm_gc, struct lpc31xx_gpio_chip, mmchip);
 
-	return event_to_irq(gpio_evt[chip->index].evt[gpio]);
+	return lpc31xx_event_to_irq(gpio_evt[chip->index].evt[gpio]);
 }
 
-int lpc3131_reg_to_gpio(unsigned index, unsigned gpio)
+int lpc31xx_reg_to_gpio(unsigned index, unsigned gpio)
 {
 	struct lpc31xx_gpio_chip *chip;
 
 	chip = gpio_evt[index].chip;
 	return chip->mmchip.gc.base + gpio;
 }
-EXPORT_SYMBOL(lpc3131_reg_to_gpio);
+EXPORT_SYMBOL(lpc31xx_reg_to_gpio);
 
 
 static int lpc31xx_gpiochip_remove(struct platform_device *ofdev)
@@ -198,11 +198,11 @@ static int __devinit lpc31xx_simple_gpiochip_probe(struct platform_device *pdev)
 
 	gc = &chip->mmchip.gc;
 	gc->ngpio            = gpio_evt[chip->index].count;
-	gc->direction_input  = lpc3131_gpio_direction_input;
-	gc->direction_output = lpc3131_gpio_direction_output;
-	gc->get              = lpc3131_gpio_get_value;
-	gc->set              = lpc3131_gpio_set_value;
-	gc->to_irq	     = lpc3131_gpio_to_irq;
+	gc->direction_input  = lpc31xx_gpio_direction_input;
+	gc->direction_output = lpc31xx_gpio_direction_output;
+	gc->get              = lpc31xx_gpio_get_value;
+	gc->set              = lpc31xx_gpio_set_value;
+	gc->to_irq	     = lpc31xx_gpio_to_irq;
 
 	ret = of_mm_gpiochip_add(pdev->dev.of_node, &chip->mmchip);
 	if (ret)
