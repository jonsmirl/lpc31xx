Bottom: 79070f160fcfe92a3df0ffe38b2ebc8533c03365
Top:    a70594678e8964209edeb4462062f31135063fb7
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-06-22 11:54:42 -0400

temp breakage


---

diff --git a/arch/arm/boot/dts/sun7i-a20.dtsi b/arch/arm/boot/dts/sun7i-a20.dtsi
index 4fbd64a..4677fef 100644
--- a/arch/arm/boot/dts/sun7i-a20.dtsi
+++ b/arch/arm/boot/dts/sun7i-a20.dtsi
@@ -870,7 +870,7 @@
 			interrupts = <0 13 4>;
 			clocks = <&pll2>, <&apb0_gates 1>, <&spdif_clk>;
 			clock-names = "pll2", "apb", "spdif";
-			dmas = <&dma 0 2>, <&dma 0 2>;
+			dmas = <&dma 1 2>, <&dma 1 2>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
@@ -881,7 +881,7 @@
 			interrupts = <0 14 4>;
 			clocks = <&pll2>, <&apb0_gates 2>, <&ac97_clk>;
 			clock-names = "pll2", "apb", "ac97";
-			dmas = <&dma 0 5>, <&dma 0 5>;
+			dmas = <&dma 1 5>, <&dma 1 5>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
@@ -892,7 +892,7 @@
 			interrupts = <0 16 4>;
 			clocks = <&pll2>, <&apb0_gates 3>, <&i2s0_clk>;
 			clock-names = "pll2", "apb", "i2s";
-			dmas = <&dma 0 3>, <&dma 0 3>;
+			dmas = <&dma 1 3>, <&dma 1 3>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
@@ -903,7 +903,7 @@
 			interrupts = <0 87 4>;
 			clocks = <&pll2>, <&apb0_gates 4>, <&i2s1_clk>;
 			clock-names = "pll2", "apb", "i2s";
-			dmas = <&dma 0 4>, <&dma 0 4>;
+			dmas = <&dma 1 4>, <&dma 1 4>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
@@ -914,29 +914,20 @@
 			interrupts = <0 90 4>;
 			clocks = <&pll2>, <&apb0_gates 8>, <&i2s2_clk>;
 			clock-names = "pll2", "apb", "i2s";
-			dmas = <&dma 0 6>, <&dma 0 6>;
+			dmas = <&dma 1 6>, <&dma 1 6>;
 			dma-names = "rx", "tx";
 			status = "disabled";
 		};
 
-		codec@1c22c00 {
+		codec: codec@1c22c00 {
+			#sound-dai-cells = <0>;
 			compatible = "allwinner,sun7i-a20-codec";
 			reg = <0x01C22c00 0x40>;
 			interrupts = <0 30 4>;
 			clocks = <&pll2>, <&apb0_gates 0>, <&codec_clk>;
 			clock-names = "pll2", "apb", "codec";
-			dmas = <&dma 0 19>, <&dma 0 19>;
+			dmas = <&dma 1 19>, <&dma 1 19>;
 			dma-names = "rx", "tx";
-			widgets =
-				"Microphone", "Microphone Jack",
-				"Headphone", "Headphone Jack",
-				"Line", "Line In Jack";
-			routing =
-				"MIC_IN", "Microphone Jack",
-				"Microphone Jack", "Mic Bias",
-				"LINE_IN", "Line In Jack",
-				"Headphone Jack", "HP_OUT";
-			status = "disabled";
 		};
 
 		ir0: ir@01c21800 {
@@ -1162,4 +1153,32 @@
 			interrupts = <1 9 0xf04>;
 		};
 	};
+
+	sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,widgets =
+			"Microphone", "Microphone Jack",
+			"Headphone", "Headphone Jack",
+			"Line", "Line In Jack";
+		simple-audio-card,routing =
+			"MIC_IN", "Microphone Jack",
+			"Microphone Jack", "Mic Bias",
+			"LINE_IN", "Line In Jack",
+			"Headphone Jack", "HP_OUT";
+
+		simple-audio-card,cpu {
+			sound-dai = <&codec>;
+			master-clkdir-out;
+			frame-master;
+			bitclock-master;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&codec>;
+			frame-master;
+			bitclock-master;
+		};
+	};
+	
 };
diff --git a/drivers/dma/of-dma.c b/drivers/dma/of-dma.c
index e8fe9dc..4fb133c 100644
--- a/drivers/dma/of-dma.c
+++ b/drivers/dma/of-dma.c
@@ -159,6 +159,7 @@ struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
 		return ERR_PTR(-ENODEV);
 	}
 
+	printk("JDS = of_dma_request_slave_channel %s %s\n", name, np->full_name);
 	count = of_property_count_strings(np, "dma-names");
 	if (count < 0) {
 		pr_err("%s: dma-names property of node '%s' missing or empty\n",
diff --git a/drivers/dma/sun4i-dma.c b/drivers/dma/sun4i-dma.c
index 7b986bd..5c8cdd7 100644
--- a/drivers/dma/sun4i-dma.c
+++ b/drivers/dma/sun4i-dma.c
@@ -8,6 +8,8 @@
  * (at your option) any later version.
  */
 
+#define DEBUG
+
 #include <linux/bitmap.h>
 #include <linux/bitops.h>
 #include <linux/clk.h>
@@ -286,6 +288,7 @@ static struct sun4i_dma_pchan *find_and_use_pchan(struct sun4i_ddma_dev *priv,
 	unsigned long flags;
 	int i, max;
 
+	printk("JDS - find_and_use_pchan\n");
 	spin_lock_irqsave(&priv->lock, flags);
 
 	/* pchans 0-NDMA_NR_MAX_CHANNELS are normal, and
@@ -327,6 +330,7 @@ static void release_pchan(struct sun4i_ddma_dev *priv,
 static void configure_pchan(struct sun4i_dma_pchan *pchan,
 			    struct sun4i_ddma_promise *d)
 {
+	printk("JDS - configure_pchan\n");
 	if (pchan->is_dedicated) {
 		/* Configure addresses and misc parameters */
 		writel_relaxed(d->src, pchan->base + DDMA_SRC_ADDR_REG);
@@ -383,6 +387,7 @@ static int execute_vchan_pending(struct sun4i_ddma_dev *priv,
 	unsigned long flags;
 	int ret = 0;
 
+	printk("JDS - execute_vchan_pending\n");
 	/* We need a pchan to do anything, so secure one if available */
 	pchan = find_and_use_pchan(priv, vchan);
 	if (!pchan)
@@ -456,6 +461,7 @@ generate_ndma_promise(struct dma_chan *chan, dma_addr_t src, dma_addr_t dest,
 	struct sun4i_ddma_promise *promise;
 	int ret;
 
+	printk("JDS - generate_ndma_promise\n");
 	promise = kzalloc(sizeof(*promise), GFP_NOWAIT);
 	if (!promise)
 		return NULL;
@@ -512,6 +518,7 @@ generate_ddma_promise(struct dma_chan *chan, dma_addr_t src, dma_addr_t dest,
 	struct sun4i_ddma_promise *promise;
 	int ret;
 
+	printk("JDS - generate_ddma_promise\n");
 	promise = kzalloc(sizeof(*promise), GFP_NOWAIT);
 	if (!promise)
 		return NULL;
@@ -603,6 +610,7 @@ sun4i_dma_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest,
 	struct sun4i_ddma_promise *promise;
 	struct sun4i_ddma_contract *contract;
 
+	printk("JDS - sun4i_dma_prep_dma_memcpy\n");
 	contract = generate_ddma_contract();
 	if (!contract)
 		return NULL;
@@ -651,6 +659,7 @@ sun4i_dma_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 	u32 endpoints, para;
 	int i;
 
+	printk("JDS - sun4i_dma_prep_slave_sg\n");
 	if (!sgl)
 		return NULL;
 
@@ -751,6 +760,8 @@ static int sun4i_dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 	struct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);
 	int ret = 0;
 
+	printk("JDS - sun4i_dma_control cmd %d\n", cmd);
+
 	switch (cmd) {
 	case DMA_RESUME:
 	case DMA_PAUSE:
@@ -771,6 +782,7 @@ static int sun4i_dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 		break;
 	}
 
+	printk("JDS - sun4i_dma_control, %d\n", ret);
 	return ret;
 }
 
diff --git a/sound/soc/generic/simple-card.c b/sound/soc/generic/simple-card.c
index 21f1ccb..917db58 100644
--- a/sound/soc/generic/simple-card.c
+++ b/sound/soc/generic/simple-card.c
@@ -8,6 +8,9 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+
+#define DEBUG
+
 #include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/module.h>
@@ -96,7 +99,7 @@ asoc_simple_card_sub_parse_of(struct device_node *np,
 	struct device_node *node;
 	struct clk *clk;
 	int ret;
-
+printk("JDS - asoc_simple_card_sub_parse_of\n");
 	/*
 	 * get node via "sound-dai = <&phandle port>"
 	 * it will be used as xxx_of_node on soc_bind_dai_link()
@@ -105,16 +108,19 @@ asoc_simple_card_sub_parse_of(struct device_node *np,
 	if (!node)
 		return -ENODEV;
 	*p_node = node;
+printk("JDS - asoc_simple_card_sub_parse_of 1\n");
 
 	/* get dai->name */
 	ret = snd_soc_of_get_dai_name(np, name);
 	if (ret < 0)
 		return ret;
+printk("JDS - asoc_simple_card_sub_parse_of 2\n");
 
 	/* parse TDM slot */
 	ret = snd_soc_of_parse_tdm_slot(np, &dai->slots, &dai->slot_width);
 	if (ret)
 		return ret;
+printk("JDS - asoc_simple_card_sub_parse_of 3\n");
 
 	/*
 	 * bitclock-inversion, frame-inversion
@@ -135,6 +141,7 @@ asoc_simple_card_sub_parse_of(struct device_node *np,
 		if (IS_ERR(clk)) {
 			ret = PTR_ERR(clk);
 			return ret;
+printk("JDS - asoc_simple_card_sub_parse_of 4\n");
 		}
 
 		dai->sysclk = clk_get_rate(clk);
@@ -148,6 +155,7 @@ asoc_simple_card_sub_parse_of(struct device_node *np,
 			dai->sysclk = clk_get_rate(clk);
 	}
 
+printk("JDS - asoc_simple_card_sub_parse_of 5\n");
 	return 0;
 }
 
@@ -158,7 +166,7 @@ static int simple_card_cpu_codec_of(struct device_node *node,
 {
 	struct device_node *np;
 	int ret;
-
+printk("JDS - simple_card_cpu_codec_of\n");
 	/* CPU sub-node */
 	ret = -EINVAL;
 	np = of_get_child_by_name(node, "simple-audio-card,cpu");
@@ -169,6 +177,7 @@ static int simple_card_cpu_codec_of(struct device_node *node,
 						&dai_link->cpu_dai_name);
 		of_node_put(np);
 	}
+printk("JDS - simple_card_cpu_codec_of  %d\n", ret);
 	if (ret < 0)
 		return ret;
 
@@ -182,6 +191,7 @@ static int simple_card_cpu_codec_of(struct device_node *node,
 						&dai_link->codec_dai_name);
 		of_node_put(np);
 	}
+printk("JDS - simple_card_cpu_codec_of 2 %d\n", ret);
 	return ret;
 }
 
@@ -196,7 +206,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 	char *name;
 	unsigned int daifmt;
 	int ret;
-
+printk("JDS - asoc_simple_card_parse_of 1\n");
 	/* parsing the card name from DT */
 	snd_soc_of_parse_card_name(&priv->snd_card, "simple-audio-card,name");
 
@@ -204,7 +214,8 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 	daifmt = snd_soc_of_parse_daifmt(node, "simple-audio-card,") &
 		(SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_INV_MASK);
 
-	/* off-codec widgets */
+printk("JDS - asoc_simple_card_parse_of 2\n");
+	/* off-codec widgets */ 
 	if (of_property_read_bool(node, "simple-audio-card,widgets")) {
 		ret = snd_soc_of_parse_audio_simple_widgets(&priv->snd_card,
 					"simple-audio-card,widgets");
@@ -212,6 +223,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 			return ret;
 	}
 
+printk("JDS - asoc_simple_card_parse_of 3\n");
 	/* DAPM routes */
 	if (of_property_read_bool(node, "simple-audio-card,routing")) {
 		ret = snd_soc_of_parse_audio_routing(&priv->snd_card,
@@ -220,6 +232,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 			return ret;
 	}
 
+printk("JDS - asoc_simple_card_parse_of 4\n");
 	/* loop on the DAI links */
 	np = NULL;
 	for (;;) {
@@ -234,6 +247,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 		if (ret < 0)
 			goto err;
 
+printk("JDS - asoc_simple_card_parse_of 5\n");
 		/*
 		 * overwrite cpu_dai->fmt as its DAIFMT_MASTER bit is based on CODEC
 		 * while the other bits should be identical unless buggy SW/HW design.
@@ -283,6 +297,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 	return 0;
 
 err:
+printk("JDS - asoc_simple_card_parse_of err\n");
 	of_node_put(np);
 	return ret;
 }
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 051c006..e351821 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -21,7 +21,7 @@
  *   o Add more codecs and platforms to ensure good API coverage.
  *   o Support TDM on PCM and I2S
  */
-
+#define DEBUG
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
diff --git a/sound/soc/soc-generic-dmaengine-pcm.c b/sound/soc/soc-generic-dmaengine-pcm.c
index 5bace12..4440d49 100644
--- a/sound/soc/soc-generic-dmaengine-pcm.c
+++ b/sound/soc/soc-generic-dmaengine-pcm.c
@@ -65,6 +65,7 @@ int snd_dmaengine_pcm_prepare_slave_config(struct snd_pcm_substream *substream,
 	struct snd_dmaengine_dai_dma_data *dma_data;
 	int ret;
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config\n");
 	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
 	ret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);
@@ -90,6 +91,7 @@ static int dmaengine_pcm_hw_params(struct snd_pcm_substream *substream,
 	struct dma_slave_config slave_config;
 	int ret;
 
+	printk("JDS - dmaengine_pcm_hw_params\n");
 	memset(&slave_config, 0, sizeof(slave_config));
 
 	if (!pcm->config)
@@ -121,6 +123,7 @@ static int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substrea
 	struct snd_pcm_hardware hw;
 	int ret;
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams\n");
 	if (pcm->config && pcm->config->pcm_hardware)
 		return snd_soc_set_runtime_hwparams(substream,
 				pcm->config->pcm_hardware);
@@ -158,6 +161,7 @@ static int dmaengine_pcm_open(struct snd_pcm_substream *substream)
 	struct dma_chan *chan = pcm->chan[substream->stream];
 	int ret;
 
+	printk("JDS - dmaengine_pcm_open\n");
 	ret = dmaengine_pcm_set_runtime_hwparams(substream);
 	if (ret)
 		return ret;
@@ -178,6 +182,7 @@ static struct dma_chan *dmaengine_pcm_compat_request_channel(
 	struct snd_dmaengine_dai_dma_data *dma_data;
 	dma_filter_fn fn = NULL;
 
+	printk("JDS - dmaengine_pcm_compat_request_channel\n");
 	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
 	if ((pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX) && pcm->chan[0])
@@ -219,6 +224,7 @@ static int dmaengine_pcm_new(struct snd_soc_pcm_runtime *rtd)
 	unsigned int i;
 	int ret;
 
+	printk("JDS - dmaengine_pcm_new\n");
 	if (config && config->prealloc_buffer_size) {
 		prealloc_buffer_size = config->prealloc_buffer_size;
 		max_buffer_size = config->pcm_hardware->buffer_bytes_max;
@@ -319,6 +325,7 @@ static int dmaengine_pcm_request_chan_of(struct dmaengine_pcm *pcm,
 	const char *name;
 	struct dma_chan *chan;
 
+	printk("JDS - dmaengine_pcm_request_chan_of\n");
 	if ((pcm->flags & (SND_DMAENGINE_PCM_FLAG_NO_DT |
 			   SND_DMAENGINE_PCM_FLAG_CUSTOM_CHANNEL_NAME)) ||
 	    !dev->of_node)
@@ -388,6 +395,7 @@ int snd_dmaengine_pcm_register(struct device *dev,
 	struct dmaengine_pcm *pcm;
 	int ret;
 
+	printk("JDS - snd_dmaengine_pcm_register\n");
 	pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
 	if (!pcm)
 		return -ENOMEM;
diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
index ccdbee3..72bb3c4 100644
--- a/sound/soc/sunxi/Kconfig
+++ b/sound/soc/sunxi/Kconfig
@@ -2,3 +2,8 @@ config SND_SUNXI_SOC_CODEC
 	tristate "APB On-Chip sun4i and sun5i Codec"
 	select SND_SOC_GENERIC_DMAENGINE_PCM
 	default y
+
+config SND_SUNXI_SOC_CODEC_JDS
+	tristate "JDS version - APB On-Chip sun4i and sun5i Codec"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	default y
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
index b8950d3..86f7223 100644
--- a/sound/soc/sunxi/Makefile
+++ b/sound/soc/sunxi/Makefile
@@ -1,2 +1,4 @@
 obj-$(CONFIG_SND_SUNXI_SOC_CODEC) += sunxi-codec.o
+obj-$(CONFIG_SND_SUNXI_SOC_CODEC_JDS) += sunxi_codec_main.o sunxi_codec_dma.o
+
 
diff --git a/sound/soc/sunxi/sunxi-codec.c b/sound/soc/sunxi/sunxi-codec.c
index a7f0f72..e82997d 100644
--- a/sound/soc/sunxi/sunxi-codec.c
+++ b/sound/soc/sunxi/sunxi-codec.c
@@ -37,8 +37,6 @@
 #include <linux/timer.h>
 #include "sunxi-codec.h"
 
-enum sunxi_device_id {SUN4A, SUN4I, SUN5I, SUN7I}; 
-
 /* Structure/enum declaration ------------------------------- */
 struct card_data {
 	struct device *dev; /* parent device */
diff --git a/sound/soc/sunxi/sunxi-codec.h b/sound/soc/sunxi/sunxi-codec.h
index 4e12b42..78380dc 100644
--- a/sound/soc/sunxi/sunxi-codec.h
+++ b/sound/soc/sunxi/sunxi-codec.h
@@ -102,7 +102,7 @@ enum m1_codec_config {
 #define ST_RUNNING		(1<<0)
 #define ST_OPENED		(1<<1)
 
-void  __iomem *baseaddr;
+extern void  __iomem *baseaddr;
 #define codec_rdreg(reg)	    readl((baseaddr+(reg)))
 #define codec_wrreg(reg,val)  writel((val),(baseaddr+(reg)))
 
@@ -134,4 +134,35 @@ struct	codec_mixer_control{
 	unsigned int value;
 };
 
+struct sunxi_codec_dma_params {
+	unsigned int data_size;
+	dma_addr_t tx_rx_addr;
+//JDS	struct stedma40_chan_cfg *dma_cfg;
+};
+
+enum sunxi_device_id {SUN4A, SUN4I, SUN5I, SUN7I}; 
+
+extern int devm_sunxi_pcm_platform_register(struct platform_device *pdev);
+
+/* Structure/enum declaration ------------------------------- */
+struct card_data {
+//	struct device *dev; /* parent device */
+//	struct resource *codec_base_res; /* resources found */
+//	struct resource *codec_base_req; /* resources found */
+
+//	spinlock_t lock;
+
+//	long samplerate;
+//	struct snd_card *card;
+//	struct snd_pcm *pcm;
+	
+	enum sunxi_device_id id;
+	struct dma_chan		*rx_dma_chan;
+	struct dma_chan		*tx_dma_chan;
+	int irq;
+	unsigned int codec_phys;
+	void  __iomem *baseaddr;
+	struct clk *codec_apbclk, *codec_pll2clk, *codec_moduleclk;
+};
+
 #endif
diff --git a/sound/soc/sunxi/sunxi_codec_codec.c b/sound/soc/sunxi/sunxi_codec_codec.c
new file mode 100644
index 0000000..a078aa3
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_codec_codec.c
@@ -0,0 +1,93 @@
+/*
+ * ALSA SoC SPDIF DIT driver
+ *
+ *  This driver is used by controllers which can operate in DIT (SPDI/F) where
+ *  no codec is needed.  This file provides stub codec that can be used
+ *  in these configurations. TI DaVinci Audio controller uses this driver.
+ *
+ * Author:      Steve Chen,  <schen@mvista.com>
+ * Copyright:   (C) 2009 MontaVista Software, Inc., <source@mvista.com>
+ * Copyright:   (C) 2009  Texas Instruments, India
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <linux/of.h>
+
+#define DRV_NAME "spdif-dit"
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S20_3LE | \
+			SNDRV_PCM_FMTBIT_S24_LE)
+
+static const struct snd_soc_dapm_widget dit_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("spdif-out"),
+};
+
+static const struct snd_soc_dapm_route dit_routes[] = {
+	{ "spdif-out", NULL, "Playback" },
+};
+
+static struct snd_soc_codec_driver soc_codec_spdif_dit = {
+	.dapm_widgets = dit_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(dit_widgets),
+	.dapm_routes = dit_routes,
+	.num_dapm_routes = ARRAY_SIZE(dit_routes),
+};
+
+static struct snd_soc_dai_driver dit_stub_dai = {
+	.name		= "dit-hifi",
+	.playback 	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 384,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+};
+
+static int spdif_dit_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_spdif_dit,
+			&dit_stub_dai, 1);
+}
+
+static int spdif_dit_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id spdif_dit_dt_ids[] = {
+	{ .compatible = "linux,spdif-dit", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, spdif_dit_dt_ids);
+#endif
+
+static struct platform_driver spdif_dit_driver = {
+	.probe		= spdif_dit_probe,
+	.remove		= spdif_dit_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(spdif_dit_dt_ids),
+	},
+};
+
+module_platform_driver(spdif_dit_driver);
+
+MODULE_AUTHOR("Steve Chen <schen@mvista.com>");
+MODULE_DESCRIPTION("SPDIF dummy codec driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/sunxi/sunxi_codec_dma.c b/sound/soc/sunxi/sunxi_codec_dma.c
new file mode 100644
index 0000000..f633535
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_codec_dma.c
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2012
+ *
+ * Author: Ola Lilja <ola.o.lilja@stericsson.com>,
+ *         Roger Nilsson <roger.xr.nilsson@stericsson.com>
+ *         for ST-Ericsson.
+ *
+ * License terms:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <asm/page.h>
+
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/slab.h>
+#include <linux/platform_data/dma-ste-dma40.h>
+
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "sunxi-codec.h"
+
+#define SUNXI_PLATFORM_PERIODS_BYTES_MIN	128
+#define SUNXI_PLATFORM_PERIODS_BYTES_MAX	(64 * PAGE_SIZE)
+#define SUNXI_PLATFORM_PERIODS_MIN		2
+#define SUNXI_PLATFORM_PERIODS_MAX		48
+#define SUNXI_PLATFORM_BUFFER_BYTES_MAX		(2048 * PAGE_SIZE)
+
+static const struct snd_pcm_hardware sunxi_pcm_hw = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_RESUME |
+		SNDRV_PCM_INFO_PAUSE,
+	.buffer_bytes_max = SUNXI_PLATFORM_BUFFER_BYTES_MAX,
+	.period_bytes_min = SUNXI_PLATFORM_PERIODS_BYTES_MIN,
+	.period_bytes_max = SUNXI_PLATFORM_PERIODS_BYTES_MAX,
+	.periods_min = SUNXI_PLATFORM_PERIODS_MIN,
+	.periods_max = SUNXI_PLATFORM_PERIODS_MAX,
+};
+
+static struct dma_chan *sunxi_pcm_request_chan(struct snd_soc_pcm_runtime *rtd,
+	struct snd_pcm_substream *substream)
+{
+	struct snd_soc_dai *dai = rtd->cpu_dai;
+	u16 per_data_width, mem_data_width;
+//jds	struct stedma40_chan_cfg *dma_cfg;
+	struct sunxi_codec_dma_params *dma_params;
+
+	printk("JDS - sunxi_pcm_request_chan\n");
+
+#ifdef JDS
+	/* DMA */
+	priv->tx_dma_chan = dma_request_slave_channel_reason(&pdev->dev, "tx");
+	if (IS_ERR(priv->tx_dma_chan)) {
+		dev_err(dev, "Unable to acquire DMA channel TX\n");
+		ret = PTR_ERR(priv->tx_dma_chan);
+		goto err_free_master;
+	}
+
+	dma_sconfig.direction = DMA_MEM_TO_DEV;
+	dma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	dma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	dma_sconfig.dst_addr = priv->codec_phys + SUNXI_DAC_TXDATA;
+	dma_sconfig.src_maxburst = 1;
+	dma_sconfig.dst_maxburst = 1;
+
+	ret = dmaengine_slave_config(priv->tx_dma_chan, &dma_sconfig);
+	if (ret) {
+		dev_err(dev, "Unable to configure TX DMA slave\n");
+		goto err_tx_dma_release;
+	}
+
+	priv->rx_dma_chan = dma_request_slave_channel_reason(&pdev->dev, "rx");
+	if (IS_ERR(priv->rx_dma_chan)) {
+		dev_err(dev, "Unable to acquire DMA channel RX\n");
+		ret = PTR_ERR(priv->rx_dma_chan);
+		goto err_tx_dma_release;
+	}
+
+	dma_sconfig.direction = DMA_DEV_TO_MEM;
+	dma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	dma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	dma_sconfig.src_addr = priv->codec_phys + SUNXI_ADC_RXDATA;
+	dma_sconfig.src_maxburst = 1;
+	dma_sconfig.dst_maxburst = 1;
+
+	ret = dmaengine_slave_config(priv->rx_dma_chan, &dma_sconfig);
+	if (ret) {
+		dev_err(dev, "Unable to configure RX DMA slave\n");
+		goto err_rx_dma_release;
+	}
+#endif
+	dma_params = snd_soc_dai_get_dma_data(dai, substream);
+//JDS	dma_cfg = dma_params->dma_cfg;
+
+	mem_data_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	switch (dma_params->data_size) {
+	case 32:
+		per_data_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+	case 16:
+		per_data_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	case 8:
+		per_data_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+		break;
+	default:
+		per_data_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+//JDS		dma_cfg->src_info.data_width = mem_data_width;
+//JDS		dma_cfg->dst_info.data_width = per_data_width;
+	} else {
+//JDS		dma_cfg->src_info.data_width = per_data_width;
+//JDS		dma_cfg->dst_info.data_width = mem_data_width;
+	}
+
+//JDS	return snd_dmaengine_pcm_request_channel(stedma40_filter, dma_cfg);
+	printk("JDS - sunxi_pcm_request_chan ret\n");
+	return 0;
+}
+
+static int sunxi_pcm_prepare_slave_config(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params,
+		struct dma_slave_config *slave_config)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct card_data *priv = rtd->cpu_dai->dev->platform_data;
+	struct snd_dmaengine_dai_dma_data *snd_dma_params;
+	struct sunxi_msp_dma_params *ste_dma_params;
+	dma_addr_t dma_addr;
+	int ret;
+
+	printk("JDS - sunxi_pcm_prepare_slave_config\n");
+	ret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);
+	if (ret)
+		return ret;
+	
+	slave_config->src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	slave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	slave_config->src_maxburst = 1;
+	slave_config->dst_maxburst = 1;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		slave_config->direction = DMA_MEM_TO_DEV;
+		slave_config->dst_addr = priv->codec_phys + SUNXI_DAC_TXDATA;
+	} else {
+		slave_config->direction = DMA_DEV_TO_MEM;
+		slave_config->src_addr = priv->codec_phys + SUNXI_ADC_RXDATA;
+	}
+
+	printk("JDS - sunxi_pcm_prepare_slave_config ret\n");
+	return 0;
+}
+
+static const struct snd_dmaengine_pcm_config sunxi_dmaengine_pcm_config = {
+	.pcm_hardware = &sunxi_pcm_hw,
+	.compat_request_channel = sunxi_pcm_request_chan,
+	.prealloc_buffer_size = 128 * 1024,
+	.prepare_slave_config = sunxi_pcm_prepare_slave_config,
+};
+
+static const struct snd_dmaengine_pcm_config sunxi_dmaengine_of_pcm_config = {
+	.compat_request_channel = sunxi_pcm_request_chan,
+	.prepare_slave_config = sunxi_pcm_prepare_slave_config,
+};
+
+int devm_sunxi_pcm_platform_register(struct platform_device *pdev)
+{
+	const struct snd_dmaengine_pcm_config *pcm_config;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	printk("JDS - devm_sunxi_pcm_platform_register\n");
+	if (np)
+		pcm_config = &sunxi_dmaengine_of_pcm_config;
+	else
+		pcm_config = &sunxi_dmaengine_pcm_config;
+
+	ret = snd_dmaengine_pcm_register(&pdev->dev, pcm_config,
+					 SND_DMAENGINE_PCM_FLAG_NO_RESIDUE);
+	if (ret < 0) {
+		dev_err(&pdev->dev,
+			"%s: ERROR: Failed to register platform '%s' (%d)!\n",
+			__func__, pdev->name, ret);
+		return ret;
+	}
+
+	printk("JDS - devm_sunxi_pcm_platform_register ret\n");
+	return 0;
+}
+EXPORT_SYMBOL_GPL(devm_sunxi_pcm_platform_register);
+
+int sunxi_pcm_unregister_platform(struct platform_device *pdev)
+{
+	snd_dmaengine_pcm_unregister(&pdev->dev);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sunxi_pcm_unregister_platform);
diff --git a/sound/soc/sunxi/sunxi_codec_main.c b/sound/soc/sunxi/sunxi_codec_main.c
new file mode 100644
index 0000000..7733468
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_codec_main.c
@@ -0,0 +1,522 @@
+/*
+ * ALSA SoC codec Out Audio Layer for spear processors
+ *
+ * Copyright (C) 2012 ST Microelectronics
+ * Vipin Kumar <vipin.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/soc.h>
+#include "sunxi-codec.h"
+
+struct sunxi_params {
+	u32 rate;
+	u32 core_freq;
+	u32 mute;
+};
+
+struct sunxi_dev {
+	struct clk *clk;
+	struct sunxi_codec_dma_params dma_params;
+	struct sunxi_params saved_params;
+	u32 running;
+	void __iomem *io_base;
+	struct snd_dmaengine_dai_dma_data dma_params_tx;
+	struct snd_dmaengine_pcm_config config;
+};
+
+
+static void sunxi_configure(struct sunxi_dev *host)
+{
+#ifdef JDS
+	writel(sunxi_RESET, host->io_base + sunxi_SOFT_RST);
+	mdelay(1);
+	writel(readl(host->io_base + sunxi_SOFT_RST) & ~sunxi_RESET,
+			host->io_base + sunxi_SOFT_RST);
+
+	writel(sunxi_FDMA_TRIG_16 | sunxi_MEMFMT_16_16 |
+			sunxi_VALID_HW | sunxi_USER_HW |
+			sunxi_CHNLSTA_HW | sunxi_PARITY_HW,
+			host->io_base + sunxi_CFG);
+
+	writel(0x7F, host->io_base + sunxi_INT_STA_CLR);
+	writel(0x7F, host->io_base + sunxi_INT_EN_CLR);
+#endif 
+}
+
+static int sunxi_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_dev *host = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	ret = clk_enable(host->clk);
+	if (ret)
+		return ret;
+
+	host->running = true;
+	sunxi_configure(host);
+
+	return 0;
+}
+
+static void sunxi_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct sunxi_dev *host = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return;
+
+	clk_disable(host->clk);
+	host->running = false;
+}
+
+static void sunxi_clock(struct sunxi_dev *host, u32 core_freq,
+		u32 rate)
+{
+#ifdef JDS
+	u32 divider, ctrl;
+	clk_set_rate(host->clk, core_freq);
+	divider = DIV_ROUND_CLOSEST(clk_get_rate(host->clk), (rate * 128));
+
+	ctrl = readl(host->io_base + sunxi_CTRL);
+	ctrl &= ~codec_DIVIDER_MASK;
+	ctrl |= (divider << codec_DIVIDER_SHIFT) & codec_DIVIDER_MASK;
+	writel(ctrl, host->io_base + sunxi_CTRL);
+#endif
+}
+
+static int sunxi_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params,
+		struct snd_soc_dai *dai)
+{
+	struct sunxi_dev *host = snd_soc_dai_get_drvdata(dai);
+	u32 rate, core_freq;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	rate = params_rate(params);
+
+	switch (rate) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64000:
+		/*
+		 * The clock is multiplied by 10 to bring it to feasible range
+		 * of frequencies for sscg
+		 */
+		core_freq = 64000 * 128 * 10;	/* 81.92 MHz */
+		break;
+	case 5512:
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		core_freq = 176400 * 128;	/* 22.5792 MHz */
+		break;
+	case 48000:
+	case 96000:
+	case 192000:
+	default:
+		core_freq = 192000 * 128;	/* 24.576 MHz */
+		break;
+	}
+
+	sunxi_clock(host, core_freq, rate);
+	host->saved_params.core_freq = core_freq;
+	host->saved_params.rate = rate;
+
+	return 0;
+}
+
+static int sunxi_trigger(struct snd_pcm_substream *substream, int cmd,
+		struct snd_soc_dai *dai)
+{
+#ifdef JDS
+	struct sunxi_dev *host = snd_soc_dai_get_drvdata(dai);
+	u32 ctrl;
+#endif
+	int ret = 0;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+#ifdef JDS		
+			ctrl = readl(host->io_base + sunxi_CTRL);
+			ctrl &= ~codec_OPMODE_MASK;
+			if (!host->saved_params.mute)
+				ctrl |= codec_OPMODE_AUD_DATA |
+					codec_STATE_NORMAL;
+			else
+				ctrl |= codec_OPMODE_MUTE_PCM;
+			writel(ctrl, host->io_base + sunxi_CTRL);
+#endif
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+#ifdef JDS		
+		ctrl = readl(host->io_base + sunxi_CTRL);
+		ctrl &= ~codec_OPMODE_MASK;
+		ctrl |= codec_OPMODE_OFF;
+		writel(ctrl, host->io_base + sunxi_CTRL);
+#endif
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sunxi_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+#ifdef JDS
+	struct sunxi_dev *host = snd_soc_dai_get_drvdata(dai);
+	u32 val;
+
+	host->saved_params.mute = mute;
+	val = readl(host->io_base + sunxi_CTRL);
+	val &= ~codec_OPMODE_MASK;
+
+	if (mute)
+		val |= codec_OPMODE_MUTE_PCM;
+	else {
+		if (host->running)
+			val |= codec_OPMODE_AUD_DATA | codec_STATE_NORMAL;
+		else
+			val |= codec_OPMODE_OFF;
+	}
+
+	writel(val, host->io_base + sunxi_CTRL);
+#endif
+	return 0;
+}
+
+static int codec_mute_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct sunxi_dev *host = snd_soc_dai_get_drvdata(cpu_dai);
+
+	ucontrol->value.integer.value[0] = host->saved_params.mute;
+	return 0;
+}
+
+static int codec_mute_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct sunxi_dev *host = snd_soc_dai_get_drvdata(cpu_dai);
+
+	if (host->saved_params.mute == ucontrol->value.integer.value[0])
+		return 0;
+
+	sunxi_digital_mute(cpu_dai, ucontrol->value.integer.value[0]);
+
+	return 1;
+}
+static const struct snd_kcontrol_new sunxi_controls[] = {
+	SOC_SINGLE_BOOL_EXT("IEC958 Playback Switch", 0,
+			codec_mute_get, codec_mute_put),
+};
+
+static int sunxi_soc_dai_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_dev *host = snd_soc_dai_get_drvdata(dai);
+
+	host->dma_params_tx.filter_data = &host->dma_params;
+	dai->playback_dma_data = &host->dma_params_tx;
+
+	return snd_soc_add_dai_controls(dai, sunxi_controls,
+				ARRAY_SIZE(sunxi_controls));
+}
+
+static const struct snd_soc_dai_ops sunxi_dai_ops = {
+	.digital_mute	= sunxi_digital_mute,
+	.startup	= sunxi_startup,
+	.shutdown	= sunxi_shutdown,
+	.trigger	= sunxi_trigger,
+	.hw_params	= sunxi_hw_params,
+};
+
+static struct snd_soc_dai_driver sunxi_dai = {
+	.name		= "cat",
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+				 SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | \
+				 SNDRV_PCM_RATE_192000),
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.probe = sunxi_soc_dai_probe,
+	.ops = &sunxi_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_component = {
+	.name		= "horse",
+};
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S20_3LE | \
+			SNDRV_PCM_FMTBIT_S24_LE)
+
+static const struct snd_soc_dapm_widget dit_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("spdif-out"),
+};
+
+static const struct snd_soc_dapm_route dit_routes[] = {
+	{ "spdif-out", NULL, "Playback" },
+};
+
+static struct snd_soc_codec_driver soc_codec_sunxi_codec = {
+	.dapm_widgets = dit_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(dit_widgets),
+	.dapm_routes = dit_routes,
+	.num_dapm_routes = ARRAY_SIZE(dit_routes),
+};
+
+static struct snd_soc_dai_driver dit_stub_dai = {
+	.name		= "dog",
+	.playback 	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 384,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+};
+
+static const struct of_device_id snd_sunxi_codec_ids[] = {
+	{ .compatible = "allwinner,sun4i-a10a-codec", .data = (void *)SUN4A},
+	{ .compatible = "allwinner,sun4i-a10-codec", .data = (void *)SUN4I},
+	{ .compatible = "allwinner,sun5i-a13-codec", .data = (void *)SUN5I},
+	{ .compatible = "allwinner,sun7i-a20-codec", .data = (void *)SUN7I},
+	{}
+};
+MODULE_DEVICE_TABLE(of, snd_sunxi_codec_ids);
+
+static int sunxi_codec_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct card_data *priv;
+	struct resource res;
+	int ret;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	of_id = of_match_device(snd_sunxi_codec_ids, &pdev->dev);
+	if (!of_id)
+		return -EINVAL;
+#ifdef JDS
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "could not allocate DAI object\n");
+		return -ENOMEM;
+	}
+	
+	priv->id = (int)of_id->data;
+
+	/* Get the addresses and IRQ */
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		dev_err(&pdev->dev, "could not determine device resources\n");
+		return ret;
+	}
+	priv->baseaddr = of_iomap(np, 0);
+	if (!priv->baseaddr) {
+		dev_err(&pdev->dev, "could not map device resources\n");
+		return -ENOMEM;
+	}
+	priv->codec_phys = res.start;
+
+	priv->irq = irq_of_parse_and_map(np, 0);
+	if (!priv->irq) {
+		dev_err(&pdev->dev, "no irq for node %s\n", np->full_name);
+		return -ENXIO;
+	}
+
+	/* Clock */
+	priv->codec_apbclk = devm_clk_get(dev, "apb");
+	if (IS_ERR(priv->codec_apbclk)) {
+		dev_err(dev, "failed to get apb clock.\n");
+		return PTR_ERR(priv->codec_apbclk);
+	}
+	priv->codec_pll2clk = devm_clk_get(dev, "pll2");
+	if (IS_ERR(priv->codec_pll2clk)) {
+		dev_err(dev, "failed to get pll2 clock.\n");
+		return PTR_ERR(priv->codec_pll2clk);
+	}
+	priv->codec_moduleclk = devm_clk_get(dev, "codec");
+	if (IS_ERR(priv->codec_moduleclk)) {
+		dev_err(dev, "failed to get codec clock.\n");
+		return PTR_ERR(priv->codec_moduleclk);
+	}
+	ret = clk_set_rate(priv->codec_pll2clk, 24576000);
+	if (ret) {
+		dev_err(dev, "set codec base clock failed!\n");
+		return ret;
+	}
+	if (clk_prepare_enable(priv->codec_pll2clk)) {
+		dev_err(dev, "try to enable codec_pll2clk failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(priv->codec_apbclk)) {
+		dev_err(dev, "try to enable apb_codec_clk failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(priv->codec_moduleclk)) {
+		dev_err(dev, "try to enable codec failed\n");
+		ret = -EINVAL;
+		goto exit_clkdisable_apb_clk;
+	}
+	dev_set_drvdata(&pdev->dev, priv);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_component, &sunxi_dai, 1);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sunxi_codec, &dit_stub_dai, 1);
+	if (ret)
+		return ret;
+#endif
+//JDS	ret =  devm_sunxi_pcm_platform_register(pdev);
+	printk("JDS - codec driver success registered\n");
+	return ret;
+
+exit_clkdisable_apb_clk:
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int snd_sunxi_codec_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sunxi_dev *host = dev_get_drvdata(&pdev->dev);
+
+	if (host->running)
+		clk_disable(host->clk);
+
+	return 0;
+}
+
+static int snd_sunxi_codec_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sunxi_dev *host = dev_get_drvdata(&pdev->dev);
+
+	if (host->running) {
+		clk_enable(host->clk);
+		sunxi_configure(host);
+		sunxi_clock(host, host->saved_params.core_freq,
+				host->saved_params.rate);
+	}
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(sunxi_dev_pm_ops, snd_sunxi_codec_suspend, \
+		snd_sunxi_codec_resume);
+
+#define sunxi_DEV_PM_OPS (&sunxi_dev_pm_ops)
+
+#else
+#define sunxi_DEV_PM_OPS NULL
+
+#endif
+
+static int sunxi_codec_remove(struct platform_device *devptr)
+{
+#ifdef JDS
+	clk_disable(codec_moduleclk);
+	//释放codec_pll2clk时钟句柄
+	clk_put(codec_pll2clk);
+	//释放codec_apbclk时钟句柄
+	clk_put(codec_apbclk);
+
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+#endif
+	return 0;
+}
+
+static void sunxi_codec_shutdown(struct platform_device *devptr)
+{
+#ifdef JDS
+	if (gpio_pa_shutdown) {
+//JDS		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+		mdelay(50);
+	}
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x0);
+	mdelay(100);
+	//pa mute
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	mdelay(500);
+	//disable dac analog
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x0);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x0);
+
+	//disable dac to pa
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x0);
+	codec_wr_control(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x0);
+
+	clk_disable(codec_moduleclk);
+#endif
+}
+
+/*method relating*/
+static struct platform_driver sunxi_codec_driver =
+{
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_remove,
+	.shutdown = sunxi_codec_shutdown,
+#ifdef CONFIG_PM
+//JDS	.suspend = snd_sunxi_codec_suspend,
+//JDS	.resume = snd_sunxi_codec_resume,
+#endif
+	.driver = {
+		.name = "sunxi-codec",
+		.of_match_table = snd_sunxi_codec_ids,
+	},
+};
+
+module_platform_driver(sunxi_codec_driver);
+
+MODULE_ALIAS("platform:sunxi-codec-dai");
+MODULE_DESCRIPTION("sunxi CODEC ALSA codec driver");
+MODULE_AUTHOR("software");
+MODULE_LICENSE("GPL v2");
+
