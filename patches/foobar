Bottom: 79070f160fcfe92a3df0ffe38b2ebc8533c03365
Top:    02982b8f53314dbeff967e01b61a60305a29affc
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-06-22 11:54:42 -0400

temp breakage


---

diff --git a/arch/arm/boot/dts/sun7i-a20.dtsi b/arch/arm/boot/dts/sun7i-a20.dtsi
index 4fbd64a..a07fa08 100644
--- a/arch/arm/boot/dts/sun7i-a20.dtsi
+++ b/arch/arm/boot/dts/sun7i-a20.dtsi
@@ -919,7 +919,8 @@
 			status = "disabled";
 		};
 
-		codec@1c22c00 {
+		codec: codec@1c22c00 {
+			#sound-dai-cells = <0>;
 			compatible = "allwinner,sun7i-a20-codec";
 			reg = <0x01C22c00 0x40>;
 			interrupts = <0 30 4>;
@@ -927,16 +928,6 @@
 			clock-names = "pll2", "apb", "codec";
 			dmas = <&dma 0 19>, <&dma 0 19>;
 			dma-names = "rx", "tx";
-			widgets =
-				"Microphone", "Microphone Jack",
-				"Headphone", "Headphone Jack",
-				"Line", "Line In Jack";
-			routing =
-				"MIC_IN", "Microphone Jack",
-				"Microphone Jack", "Mic Bias",
-				"LINE_IN", "Line In Jack",
-				"Headphone Jack", "HP_OUT";
-			status = "disabled";
 		};
 
 		ir0: ir@01c21800 {
@@ -982,8 +973,8 @@
 			reg-shift = <2>;
 			reg-io-width = <4>;
 			clocks = <&apb1_gates 16>;
-			dmas = <&dma 0 8>, <&dma 0 8>;
-			dma-names = "rx", "tx";
+			/*dmas = <&dma 0 8>, <&dma 0 8>;
+			dma-names = "rx", "tx"; */
 			status = "disabled";
 		};
 
@@ -1162,4 +1153,32 @@
 			interrupts = <1 9 0xf04>;
 		};
 	};
+
+	sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,widgets =
+			"Microphone", "Microphone Jack",
+			"Headphone", "Headphone Jack",
+			"Line", "Line In Jack";
+		simple-audio-card,routing =
+			"MIC_IN", "Microphone Jack",
+			"Microphone Jack", "Mic Bias",
+			"LINE_IN", "Line In Jack",
+			"Headphone Jack", "HP_OUT";
+
+		simple-audio-card,cpu {
+			sound-dai = <&codec>;
+			master-clkdir-out;
+			frame-master;
+			bitclock-master;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&codec>;
+			frame-master;
+			bitclock-master;
+		};
+	};
+	
 };
diff --git a/cop b/cop
new file mode 100755
index 0000000..727aee3
--- /dev/null
+++ b/cop
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+
+make zImage modules uImage dtbs
+cp /work/hans/sound/soc/sunxi/sunxi-codec.ko /work/root/lib/modules/3.15.0+/kernel/sound/soc/sunxi
+
diff --git a/drivers/dma/of-dma.c b/drivers/dma/of-dma.c
index e8fe9dc..4fb133c 100644
--- a/drivers/dma/of-dma.c
+++ b/drivers/dma/of-dma.c
@@ -159,6 +159,7 @@ struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
 		return ERR_PTR(-ENODEV);
 	}
 
+	printk("JDS = of_dma_request_slave_channel %s %s\n", name, np->full_name);
 	count = of_property_count_strings(np, "dma-names");
 	if (count < 0) {
 		pr_err("%s: dma-names property of node '%s' missing or empty\n",
diff --git a/drivers/dma/sun4i-dma.c b/drivers/dma/sun4i-dma.c
index 7b986bd..21b62a2 100644
--- a/drivers/dma/sun4i-dma.c
+++ b/drivers/dma/sun4i-dma.c
@@ -8,6 +8,8 @@
  * (at your option) any later version.
  */
 
+#define DEBUG
+
 #include <linux/bitmap.h>
 #include <linux/bitops.h>
 #include <linux/clk.h>
@@ -286,6 +288,7 @@ static struct sun4i_dma_pchan *find_and_use_pchan(struct sun4i_ddma_dev *priv,
 	unsigned long flags;
 	int i, max;
 
+	printk("JDS - find_and_use_pchan\n");
 	spin_lock_irqsave(&priv->lock, flags);
 
 	/* pchans 0-NDMA_NR_MAX_CHANNELS are normal, and
@@ -327,6 +330,7 @@ static void release_pchan(struct sun4i_ddma_dev *priv,
 static void configure_pchan(struct sun4i_dma_pchan *pchan,
 			    struct sun4i_ddma_promise *d)
 {
+	printk("JDS - configure_pchan\n");
 	if (pchan->is_dedicated) {
 		/* Configure addresses and misc parameters */
 		writel_relaxed(d->src, pchan->base + DDMA_SRC_ADDR_REG);
@@ -383,6 +387,7 @@ static int execute_vchan_pending(struct sun4i_ddma_dev *priv,
 	unsigned long flags;
 	int ret = 0;
 
+	printk("JDS - execute_vchan_pending\n");
 	/* We need a pchan to do anything, so secure one if available */
 	pchan = find_and_use_pchan(priv, vchan);
 	if (!pchan)
@@ -456,6 +461,7 @@ generate_ndma_promise(struct dma_chan *chan, dma_addr_t src, dma_addr_t dest,
 	struct sun4i_ddma_promise *promise;
 	int ret;
 
+	printk("JDS - generate_ndma_promise\n");
 	promise = kzalloc(sizeof(*promise), GFP_NOWAIT);
 	if (!promise)
 		return NULL;
@@ -512,6 +518,7 @@ generate_ddma_promise(struct dma_chan *chan, dma_addr_t src, dma_addr_t dest,
 	struct sun4i_ddma_promise *promise;
 	int ret;
 
+	printk("JDS - generate_ddma_promise\n");
 	promise = kzalloc(sizeof(*promise), GFP_NOWAIT);
 	if (!promise)
 		return NULL;
@@ -603,6 +610,7 @@ sun4i_dma_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest,
 	struct sun4i_ddma_promise *promise;
 	struct sun4i_ddma_contract *contract;
 
+	printk("JDS - sun4i_dma_prep_dma_memcpy\n");
 	contract = generate_ddma_contract();
 	if (!contract)
 		return NULL;
@@ -637,6 +645,73 @@ sun4i_dma_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest,
 	return vchan_tx_prep(&vchan->vc, &contract->vd, flags);
 }
 
+static struct dma_async_tx_descriptor *sun4i_dma_prep_dma_cyclic(
+		struct dma_chan *chan, dma_addr_t buf, size_t len,
+		size_t period_len, enum dma_transfer_direction dir,
+		unsigned long flags, void *context) {
+	struct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);
+	struct dma_slave_config *sconfig = &vchan->cfg;
+	struct sun4i_ddma_promise *promise;
+	struct sun4i_ddma_contract *contract;
+	dma_addr_t src, dest;
+
+	printk("JDS - sun4i_dma_prep_dma_cyclic\n");
+	if (!is_slave_direction(dir)) {
+		dev_err(chan2dev(chan), "Invalid DMA direction\n");
+		return NULL;
+	}
+
+	contract = generate_ddma_contract();
+	if (!contract)
+		return NULL;
+
+	/* Figure out addresses */
+	if (dir == DMA_MEM_TO_DEV) {
+		src = buf;
+		dest = sconfig->dst_addr;
+	} else {
+		src = sconfig->src_addr;
+		dest = buf;
+	}
+
+	if (vchan->is_dedicated)
+		promise = generate_ddma_promise(chan, src, dest, len, sconfig);
+	else
+		promise = generate_ndma_promise(chan, src, dest, len, sconfig);
+
+	if (!promise) {
+		kfree(contract);
+		return NULL;
+	}
+
+	/* Figure out endpoints */
+	if (vchan->is_dedicated && dir == DMA_MEM_TO_DEV) {
+		promise->cfg |= DDMA_CFG_CONT_MODE | DDMA_CFG_SRC_DRQ_TYPE(DDMA_DRQ_TYPE_SDRAM) |
+			    DDMA_CFG_SRC_ADDR_MODE(DDMA_ADDR_MODE_LINEAR) |
+			    DDMA_CFG_DEST_DRQ_TYPE(vchan->endpoint) |
+			    DDMA_CFG_DEST_ADDR_MODE(DDMA_ADDR_MODE_IO);
+	} else if (!vchan->is_dedicated && dir == DMA_MEM_TO_DEV) {
+		promise->cfg |= NDMA_CFG_CONT_MODE | NDMA_CFG_SRC_DRQ_TYPE(NDMA_DRQ_TYPE_SDRAM) |
+			    NDMA_CFG_DEST_DRQ_TYPE(vchan->endpoint) |
+			    NDMA_CFG_DEST_FIXED_ADDR;
+	} else if (vchan->is_dedicated) {
+		promise->cfg |= DDMA_CFG_CONT_MODE | DDMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |
+			    DDMA_CFG_SRC_ADDR_MODE(DDMA_ADDR_MODE_IO) |
+			    DDMA_CFG_DEST_DRQ_TYPE(DDMA_DRQ_TYPE_SDRAM) |
+			    DDMA_CFG_DEST_ADDR_MODE(DDMA_ADDR_MODE_LINEAR);
+	} else {
+		promise->cfg |= NDMA_CFG_CONT_MODE | NDMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |
+			    NDMA_CFG_SRC_FIXED_ADDR |
+			    NDMA_CFG_DEST_DRQ_TYPE(NDMA_DRQ_TYPE_SDRAM);
+	}
+
+	/* Fill the contract with our only promise */
+	list_add_tail(&promise->list, &contract->demands);
+
+	/* And add it to the vchan */
+	return vchan_tx_prep(&vchan->vc, &contract->vd, flags);
+}
+
 static struct dma_async_tx_descriptor *
 sun4i_dma_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 			unsigned int sg_len, enum dma_transfer_direction dir,
@@ -651,6 +726,7 @@ sun4i_dma_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 	u32 endpoints, para;
 	int i;
 
+	printk("JDS - sun4i_dma_prep_slave_sg\n");
 	if (!sgl)
 		return NULL;
 
@@ -723,6 +799,7 @@ static void sun4i_ddma_terminate_all(struct sun4i_dma_vchan *vchan)
 	u32 n_busy = NDMA_CFG_LOADING;
 
 
+	printk("sun4i_ddma_terminate_all\n");
 	spin_lock_irqsave(&vchan->vc.lock, flags);
 	vchan_get_all_descriptors(&vchan->vc, &head);
 	spin_unlock_irqrestore(&vchan->vc.lock, flags);
@@ -751,6 +828,8 @@ static int sun4i_dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 	struct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);
 	int ret = 0;
 
+	printk("JDS - sun4i_dma_control cmd %d\n", cmd);
+
 	switch (cmd) {
 	case DMA_RESUME:
 	case DMA_PAUSE:
@@ -771,6 +850,7 @@ static int sun4i_dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 		break;
 	}
 
+	printk("JDS - sun4i_dma_control, %d\n", ret);
 	return ret;
 }
 
@@ -962,6 +1042,7 @@ static int sun4i_dma_probe(struct platform_device *pdev)
 	priv->slave.device_issue_pending	= sun4i_dma_issue_pending;
 	priv->slave.device_prep_slave_sg	= sun4i_dma_prep_slave_sg;
 	priv->slave.device_prep_dma_memcpy	= sun4i_dma_prep_dma_memcpy;
+	priv->slave.device_prep_dma_cyclic	= sun4i_dma_prep_dma_cyclic;
 	priv->slave.device_control		= sun4i_dma_control;
 	priv->slave.chancnt			= DDMA_NR_MAX_VCHANS;
 
diff --git a/sound/core/pcm_dmaengine.c b/sound/core/pcm_dmaengine.c
index 76cbb9e..fd420af 100644
--- a/sound/core/pcm_dmaengine.c
+++ b/sound/core/pcm_dmaengine.c
@@ -148,10 +148,12 @@ static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 	enum dma_transfer_direction direction;
 	unsigned long flags = DMA_CTRL_ACK;
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit\n");
 	direction = snd_pcm_substream_to_dma_direction(substream);
 
 	if (!substream->runtime->no_period_wakeup)
 		flags |= DMA_PREP_INTERRUPT;
+	printk("JDS - dmaengine_pcm_prepare_and_submit a\n");
 
 	prtd->pos = 0;
 	desc = dmaengine_prep_dma_cyclic(chan,
@@ -159,13 +161,16 @@ static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 		snd_pcm_lib_buffer_bytes(substream),
 		snd_pcm_lib_period_bytes(substream), direction, flags);
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit b\n");
 	if (!desc)
 		return -ENOMEM;
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit c\n");
 	desc->callback = dmaengine_pcm_dma_complete;
 	desc->callback_param = substream;
 	prtd->cookie = dmaengine_submit(desc);
 
+	printk("JDS - dmaengine_pcm_prepare_and_submit d\n");
 	return 0;
 }
 
@@ -185,12 +190,17 @@ int snd_dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int ret;
 
+	printk("JDS = snd_dmaengine_pcm_trigger cmd %d prtd %p runtime %p\n", cmd, prtd, runtime);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
+	printk("JDS = snd_dmaengine_pcm_trigger a\n");
 		ret = dmaengine_pcm_prepare_and_submit(substream);
+	printk("JDS = snd_dmaengine_pcm_trigger b\n");
 		if (ret)
 			return ret;
+	printk("JDS = snd_dmaengine_pcm_trigger c\n");
 		dma_async_issue_pending(prtd->dma_chan);
+	printk("JDS = snd_dmaengine_pcm_trigger d\n");
 		break;
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
@@ -212,6 +222,7 @@ int snd_dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		return -EINVAL;
 	}
 
+	printk("JDS = snd_dmaengine_pcm_trigger f\n");
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_dmaengine_pcm_trigger);
diff --git a/sound/soc/generic/simple-card.c b/sound/soc/generic/simple-card.c
index 21f1ccb..917db58 100644
--- a/sound/soc/generic/simple-card.c
+++ b/sound/soc/generic/simple-card.c
@@ -8,6 +8,9 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+
+#define DEBUG
+
 #include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/module.h>
@@ -96,7 +99,7 @@ asoc_simple_card_sub_parse_of(struct device_node *np,
 	struct device_node *node;
 	struct clk *clk;
 	int ret;
-
+printk("JDS - asoc_simple_card_sub_parse_of\n");
 	/*
 	 * get node via "sound-dai = <&phandle port>"
 	 * it will be used as xxx_of_node on soc_bind_dai_link()
@@ -105,16 +108,19 @@ asoc_simple_card_sub_parse_of(struct device_node *np,
 	if (!node)
 		return -ENODEV;
 	*p_node = node;
+printk("JDS - asoc_simple_card_sub_parse_of 1\n");
 
 	/* get dai->name */
 	ret = snd_soc_of_get_dai_name(np, name);
 	if (ret < 0)
 		return ret;
+printk("JDS - asoc_simple_card_sub_parse_of 2\n");
 
 	/* parse TDM slot */
 	ret = snd_soc_of_parse_tdm_slot(np, &dai->slots, &dai->slot_width);
 	if (ret)
 		return ret;
+printk("JDS - asoc_simple_card_sub_parse_of 3\n");
 
 	/*
 	 * bitclock-inversion, frame-inversion
@@ -135,6 +141,7 @@ asoc_simple_card_sub_parse_of(struct device_node *np,
 		if (IS_ERR(clk)) {
 			ret = PTR_ERR(clk);
 			return ret;
+printk("JDS - asoc_simple_card_sub_parse_of 4\n");
 		}
 
 		dai->sysclk = clk_get_rate(clk);
@@ -148,6 +155,7 @@ asoc_simple_card_sub_parse_of(struct device_node *np,
 			dai->sysclk = clk_get_rate(clk);
 	}
 
+printk("JDS - asoc_simple_card_sub_parse_of 5\n");
 	return 0;
 }
 
@@ -158,7 +166,7 @@ static int simple_card_cpu_codec_of(struct device_node *node,
 {
 	struct device_node *np;
 	int ret;
-
+printk("JDS - simple_card_cpu_codec_of\n");
 	/* CPU sub-node */
 	ret = -EINVAL;
 	np = of_get_child_by_name(node, "simple-audio-card,cpu");
@@ -169,6 +177,7 @@ static int simple_card_cpu_codec_of(struct device_node *node,
 						&dai_link->cpu_dai_name);
 		of_node_put(np);
 	}
+printk("JDS - simple_card_cpu_codec_of  %d\n", ret);
 	if (ret < 0)
 		return ret;
 
@@ -182,6 +191,7 @@ static int simple_card_cpu_codec_of(struct device_node *node,
 						&dai_link->codec_dai_name);
 		of_node_put(np);
 	}
+printk("JDS - simple_card_cpu_codec_of 2 %d\n", ret);
 	return ret;
 }
 
@@ -196,7 +206,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 	char *name;
 	unsigned int daifmt;
 	int ret;
-
+printk("JDS - asoc_simple_card_parse_of 1\n");
 	/* parsing the card name from DT */
 	snd_soc_of_parse_card_name(&priv->snd_card, "simple-audio-card,name");
 
@@ -204,7 +214,8 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 	daifmt = snd_soc_of_parse_daifmt(node, "simple-audio-card,") &
 		(SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_INV_MASK);
 
-	/* off-codec widgets */
+printk("JDS - asoc_simple_card_parse_of 2\n");
+	/* off-codec widgets */ 
 	if (of_property_read_bool(node, "simple-audio-card,widgets")) {
 		ret = snd_soc_of_parse_audio_simple_widgets(&priv->snd_card,
 					"simple-audio-card,widgets");
@@ -212,6 +223,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 			return ret;
 	}
 
+printk("JDS - asoc_simple_card_parse_of 3\n");
 	/* DAPM routes */
 	if (of_property_read_bool(node, "simple-audio-card,routing")) {
 		ret = snd_soc_of_parse_audio_routing(&priv->snd_card,
@@ -220,6 +232,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 			return ret;
 	}
 
+printk("JDS - asoc_simple_card_parse_of 4\n");
 	/* loop on the DAI links */
 	np = NULL;
 	for (;;) {
@@ -234,6 +247,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 		if (ret < 0)
 			goto err;
 
+printk("JDS - asoc_simple_card_parse_of 5\n");
 		/*
 		 * overwrite cpu_dai->fmt as its DAIFMT_MASTER bit is based on CODEC
 		 * while the other bits should be identical unless buggy SW/HW design.
@@ -283,6 +297,7 @@ static int asoc_simple_card_parse_of(struct device_node *node,
 	return 0;
 
 err:
+printk("JDS - asoc_simple_card_parse_of err\n");
 	of_node_put(np);
 	return ret;
 }
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 051c006..e351821 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -21,7 +21,7 @@
  *   o Add more codecs and platforms to ensure good API coverage.
  *   o Support TDM on PCM and I2S
  */
-
+#define DEBUG
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
diff --git a/sound/soc/soc-generic-dmaengine-pcm.c b/sound/soc/soc-generic-dmaengine-pcm.c
index 5bace12..f64f2f4 100644
--- a/sound/soc/soc-generic-dmaengine-pcm.c
+++ b/sound/soc/soc-generic-dmaengine-pcm.c
@@ -65,15 +65,19 @@ int snd_dmaengine_pcm_prepare_slave_config(struct snd_pcm_substream *substream,
 	struct snd_dmaengine_dai_dma_data *dma_data;
 	int ret;
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config\n");
 	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config 1\n");
 	ret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);
 	if (ret)
 		return ret;
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config 2\n");
 	snd_dmaengine_pcm_set_config_from_dai_data(substream, dma_data,
 		slave_config);
 
+	printk("JDS - snd_dmaengine_pcm_prepare_slave_config 3\n");
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_dmaengine_pcm_prepare_slave_config);
@@ -90,6 +94,7 @@ static int dmaengine_pcm_hw_params(struct snd_pcm_substream *substream,
 	struct dma_slave_config slave_config;
 	int ret;
 
+	printk("JDS - dmaengine_pcm_hw_params pcm %p\n", pcm);
 	memset(&slave_config, 0, sizeof(slave_config));
 
 	if (!pcm->config)
@@ -107,6 +112,7 @@ static int dmaengine_pcm_hw_params(struct snd_pcm_substream *substream,
 			return ret;
 	}
 
+	printk("JDS - dmaengine_pcm_hw_params ret\n");
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
 }
 
@@ -121,12 +127,14 @@ static int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substrea
 	struct snd_pcm_hardware hw;
 	int ret;
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams pcm %p\n", pcm);
 	if (pcm->config && pcm->config->pcm_hardware)
 		return snd_soc_set_runtime_hwparams(substream,
 				pcm->config->pcm_hardware);
 
 	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams dma_data %p\n", dma_data);
 	memset(&hw, 0, sizeof(hw));
 	hw.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
 			SNDRV_PCM_INFO_INTERLEAVED;
@@ -137,6 +145,7 @@ static int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substrea
 	hw.buffer_bytes_max = SIZE_MAX;
 	hw.fifo_size = dma_data->fifo_size;
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams dma_data 2  %p\n", dma_data);
 	if (pcm->flags & SND_DMAENGINE_PCM_FLAG_NO_RESIDUE)
 		hw.info |= SNDRV_PCM_INFO_BATCH;
 
@@ -148,6 +157,7 @@ static int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substrea
 			hw.info |= SNDRV_PCM_INFO_BATCH;
 	}
 
+	printk("JDS - dmaengine_pcm_set_runtime_hwparams dma_data 3 %p\n", dma_data);
 	return snd_soc_set_runtime_hwparams(substream, &hw);
 }
 
@@ -158,6 +168,7 @@ static int dmaengine_pcm_open(struct snd_pcm_substream *substream)
 	struct dma_chan *chan = pcm->chan[substream->stream];
 	int ret;
 
+	printk("JDS - dmaengine_pcm_open\n");
 	ret = dmaengine_pcm_set_runtime_hwparams(substream);
 	if (ret)
 		return ret;
@@ -178,6 +189,7 @@ static struct dma_chan *dmaengine_pcm_compat_request_channel(
 	struct snd_dmaengine_dai_dma_data *dma_data;
 	dma_filter_fn fn = NULL;
 
+	printk("JDS - dmaengine_pcm_compat_request_channel\n");
 	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
 
 	if ((pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX) && pcm->chan[0])
@@ -219,6 +231,7 @@ static int dmaengine_pcm_new(struct snd_soc_pcm_runtime *rtd)
 	unsigned int i;
 	int ret;
 
+	printk("JDS - dmaengine_pcm_new\n");
 	if (config && config->prealloc_buffer_size) {
 		prealloc_buffer_size = config->prealloc_buffer_size;
 		max_buffer_size = config->pcm_hardware->buffer_bytes_max;
@@ -319,6 +332,7 @@ static int dmaengine_pcm_request_chan_of(struct dmaengine_pcm *pcm,
 	const char *name;
 	struct dma_chan *chan;
 
+	printk("JDS - dmaengine_pcm_request_chan_of\n");
 	if ((pcm->flags & (SND_DMAENGINE_PCM_FLAG_NO_DT |
 			   SND_DMAENGINE_PCM_FLAG_CUSTOM_CHANNEL_NAME)) ||
 	    !dev->of_node)
@@ -388,6 +402,7 @@ int snd_dmaengine_pcm_register(struct device *dev,
 	struct dmaengine_pcm *pcm;
 	int ret;
 
+	printk("JDS - snd_dmaengine_pcm_register\n");
 	pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
 	if (!pcm)
 		return -ENOMEM;
diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
index ccdbee3..72bb3c4 100644
--- a/sound/soc/sunxi/Kconfig
+++ b/sound/soc/sunxi/Kconfig
@@ -2,3 +2,8 @@ config SND_SUNXI_SOC_CODEC
 	tristate "APB On-Chip sun4i and sun5i Codec"
 	select SND_SOC_GENERIC_DMAENGINE_PCM
 	default y
+
+config SND_SUNXI_SOC_CODEC_JDS
+	tristate "JDS version - APB On-Chip sun4i and sun5i Codec"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	default y
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
index b8950d3..c15cb8b 100644
--- a/sound/soc/sunxi/Makefile
+++ b/sound/soc/sunxi/Makefile
@@ -1,2 +1,4 @@
 obj-$(CONFIG_SND_SUNXI_SOC_CODEC) += sunxi-codec.o
+obj-$(CONFIG_SND_SUNXI_SOC_CODEC_JDS) += sunxi_codec_main.o
+
 
diff --git a/sound/soc/sunxi/sunxi-codec.c b/sound/soc/sunxi/sunxi-codec.c
index a7f0f72..e82997d 100644
--- a/sound/soc/sunxi/sunxi-codec.c
+++ b/sound/soc/sunxi/sunxi-codec.c
@@ -37,8 +37,6 @@
 #include <linux/timer.h>
 #include "sunxi-codec.h"
 
-enum sunxi_device_id {SUN4A, SUN4I, SUN5I, SUN7I}; 
-
 /* Structure/enum declaration ------------------------------- */
 struct card_data {
 	struct device *dev; /* parent device */
diff --git a/sound/soc/sunxi/sunxi-codec.h b/sound/soc/sunxi/sunxi-codec.h
index 4e12b42..7a0a898 100644
--- a/sound/soc/sunxi/sunxi-codec.h
+++ b/sound/soc/sunxi/sunxi-codec.h
@@ -102,7 +102,7 @@ enum m1_codec_config {
 #define ST_RUNNING		(1<<0)
 #define ST_OPENED		(1<<1)
 
-void  __iomem *baseaddr;
+extern void  __iomem *baseaddr;
 #define codec_rdreg(reg)	    readl((baseaddr+(reg)))
 #define codec_wrreg(reg,val)  writel((val),(baseaddr+(reg)))
 
@@ -134,4 +134,33 @@ struct	codec_mixer_control{
 	unsigned int value;
 };
 
+struct sunxi_codec_dma_params {
+	unsigned int data_size;
+	dma_addr_t tx_rx_addr;
+//JDS	struct stedma40_chan_cfg *dma_cfg;
+};
+
+enum sunxi_device_id {SUN4A, SUN4I, SUN5I, SUN7I}; 
+
+extern int devm_sunxi_pcm_platform_register(struct platform_device *pdev);
+
+struct sunxi_params {
+	u32 rate;
+	u32 core_freq;
+	u32 mute;
+};
+
+/* Structure/enum declaration ------------------------------- */
+struct card_data {
+	struct sunxi_params saved_params;
+	enum sunxi_device_id id;
+	struct dma_chan		*rx_dma_chan;
+	struct dma_chan		*tx_dma_chan;
+	int irq;
+	unsigned int codec_phys;
+	void  __iomem *baseaddr;
+	struct clk *codec_apbclk, *codec_pll2clk, *codec_moduleclk;
+	u32 running;
+};
+
 #endif
diff --git a/sound/soc/sunxi/sunxi_codec_main.c b/sound/soc/sunxi/sunxi_codec_main.c
new file mode 100644
index 0000000..a0df55d
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_codec_main.c
@@ -0,0 +1,529 @@
+/*
+ * ALSA SoC codec Out Audio Layer for spear processors
+ *
+ * Copyright (C) 2012 ST Microelectronics
+ * Vipin Kumar <vipin.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/soc.h>
+#include "sunxi-codec.h"
+
+
+static void sunxi_configure(struct card_data *priv)
+{
+#ifdef JDS
+	writel(sunxi_RESET, priv->io_base + sunxi_SOFT_RST);
+	mdelay(1);
+	writel(readl(priv->io_base + sunxi_SOFT_RST) & ~sunxi_RESET,
+			priv->io_base + sunxi_SOFT_RST);
+
+	writel(sunxi_FDMA_TRIG_16 | sunxi_MEMFMT_16_16 |
+			sunxi_VALID_HW | sunxi_USER_HW |
+			sunxi_CHNLSTA_HW | sunxi_PARITY_HW,
+			priv->io_base + sunxi_CFG);
+
+	writel(0x7F, priv->io_base + sunxi_INT_STA_CLR);
+	writel(0x7F, priv->io_base + sunxi_INT_EN_CLR);
+#endif 
+}
+
+static int sunxi_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *cpu_dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	ret = clk_enable(priv->codec_moduleclk);
+	if (ret)
+		return ret;
+
+	priv->running = true;
+	sunxi_configure(priv);
+
+	return 0;
+}
+
+static void sunxi_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return;
+
+	clk_disable(priv->codec_moduleclk);
+	priv->running = false;
+}
+
+static void sunxi_clock(struct card_data *priv, u32 core_freq,
+		u32 rate)
+{
+#ifdef JDS
+	u32 divider, ctrl;
+	clk_set_rate(priv->clk, core_freq);
+	divider = DIV_ROUND_CLOSEST(clk_get_rate(priv->clk), (rate * 128));
+
+	ctrl = readl(priv->io_base + sunxi_CTRL);
+	ctrl &= ~codec_DIVIDER_MASK;
+	ctrl |= (divider << codec_DIVIDER_SHIFT) & codec_DIVIDER_MASK;
+	writel(ctrl, priv->io_base + sunxi_CTRL);
+#endif
+}
+
+static int sunxi_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params,
+		struct snd_soc_dai *dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	u32 rate, core_freq;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	rate = params_rate(params);
+
+	switch (rate) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64000:
+		/*
+		 * The clock is multiplied by 10 to bring it to feasible range
+		 * of frequencies for sscg
+		 */
+		core_freq = 64000 * 128 * 10;	/* 81.92 MHz */
+		break;
+	case 5512:
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		core_freq = 176400 * 128;	/* 22.5792 MHz */
+		break;
+	case 48000:
+	case 96000:
+	case 192000:
+	default:
+		core_freq = 192000 * 128;	/* 24.576 MHz */
+		break;
+	}
+
+	sunxi_clock(priv, core_freq, rate);
+	priv->saved_params.core_freq = core_freq;
+	priv->saved_params.rate = rate;
+
+	return 0;
+}
+
+static int sunxi_trigger(struct snd_pcm_substream *substream, int cmd,
+		struct snd_soc_dai *dai)
+{
+#ifdef JDS
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	u32 ctrl;
+#endif
+	int ret = 0;
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -EINVAL;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+#ifdef JDS		
+			ctrl = readl(priv->io_base + sunxi_CTRL);
+			ctrl &= ~codec_OPMODE_MASK;
+			if (!priv->saved_params.mute)
+				ctrl |= codec_OPMODE_AUD_DATA |
+					codec_STATE_NORMAL;
+			else
+				ctrl |= codec_OPMODE_MUTE_PCM;
+			writel(ctrl, priv->io_base + sunxi_CTRL);
+#endif
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+#ifdef JDS		
+		ctrl = readl(priv->io_base + sunxi_CTRL);
+		ctrl &= ~codec_OPMODE_MASK;
+		ctrl |= codec_OPMODE_OFF;
+		writel(ctrl, priv->io_base + sunxi_CTRL);
+#endif
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sunxi_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+#ifdef JDS
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	u32 val;
+
+	priv->saved_params.mute = mute;
+	val = readl(priv->io_base + sunxi_CTRL);
+	val &= ~codec_OPMODE_MASK;
+
+	if (mute)
+		val |= codec_OPMODE_MUTE_PCM;
+	else {
+		if (priv->running)
+			val |= codec_OPMODE_AUD_DATA | codec_STATE_NORMAL;
+		else
+			val |= codec_OPMODE_OFF;
+	}
+
+	writel(val, priv->io_base + sunxi_CTRL);
+#endif
+	return 0;
+}
+
+static int codec_mute_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	ucontrol->value.integer.value[0] = priv->saved_params.mute;
+	return 0;
+}
+
+static int codec_mute_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct card_data *priv = snd_soc_dai_get_drvdata(cpu_dai);
+
+	if (priv->saved_params.mute == ucontrol->value.integer.value[0])
+		return 0;
+
+	sunxi_digital_mute(cpu_dai, ucontrol->value.integer.value[0]);
+
+	return 1;
+}
+static const struct snd_kcontrol_new sunxi_controls[] = {
+	SOC_SINGLE_BOOL_EXT("IEC958 Playback Switch", 0,
+			codec_mute_get, codec_mute_put),
+};
+
+static int sunxi_soc_dai_probe(struct snd_soc_dai *dai)
+{
+	struct card_data *priv = snd_soc_dai_get_drvdata(dai);
+	struct snd_dmaengine_dai_dma_data *playback_dma_data;
+	struct snd_dmaengine_dai_dma_data *capture_dma_data;
+
+	playback_dma_data = devm_kzalloc(dai->dev,
+					 sizeof(*playback_dma_data),
+					 GFP_KERNEL);
+	if (!playback_dma_data)
+		return -ENOMEM;
+
+	capture_dma_data = devm_kzalloc(dai->dev,
+					sizeof(*capture_dma_data),
+					GFP_KERNEL);
+	if (!capture_dma_data)
+		return -ENOMEM;
+
+	playback_dma_data->addr = priv->codec_phys + SUNXI_DAC_TXDATA;
+	capture_dma_data->addr = priv->codec_phys + SUNXI_ADC_RXDATA;
+
+	playback_dma_data->maxburst = 4;
+	capture_dma_data->maxburst = 4;
+
+	playback_dma_data->addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	playback_dma_data->addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	snd_soc_dai_init_dma_data(dai, playback_dma_data, capture_dma_data);
+
+	return snd_soc_add_dai_controls(dai, sunxi_controls,
+				ARRAY_SIZE(sunxi_controls));
+}
+
+static const struct snd_soc_dai_ops sunxi_dai_ops = {
+	.digital_mute	= sunxi_digital_mute,
+	.startup	= sunxi_startup,
+	.shutdown	= sunxi_shutdown,
+	.trigger	= sunxi_trigger,
+	.hw_params	= sunxi_hw_params,
+};
+
+static struct snd_soc_dai_driver sunxi_dai = {
+	.name		= "cat",
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+				 SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | \
+				 SNDRV_PCM_RATE_192000),
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.probe = sunxi_soc_dai_probe,
+	.ops = &sunxi_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_component = {
+	.name		= "horse",
+};
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S20_3LE | \
+			SNDRV_PCM_FMTBIT_S24_LE)
+
+static const struct snd_soc_dapm_widget dit_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("spdif-out"),
+};
+
+static const struct snd_soc_dapm_route dit_routes[] = {
+	{ "spdif-out", NULL, "Playback" },
+};
+
+static struct snd_soc_codec_driver soc_codec_sunxi_codec = {
+	.dapm_widgets = dit_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(dit_widgets),
+	.dapm_routes = dit_routes,
+	.num_dapm_routes = ARRAY_SIZE(dit_routes),
+};
+
+static struct snd_soc_dai_driver dit_stub_dai = {
+	.name		= "dog",
+	.playback 	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 384,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+};
+
+static const struct of_device_id snd_sunxi_codec_ids[] = {
+	{ .compatible = "allwinner,sun4i-a10a-codec", .data = (void *)SUN4A},
+	{ .compatible = "allwinner,sun4i-a10-codec", .data = (void *)SUN4I},
+	{ .compatible = "allwinner,sun5i-a13-codec", .data = (void *)SUN5I},
+	{ .compatible = "allwinner,sun7i-a20-codec", .data = (void *)SUN7I},
+	{}
+};
+MODULE_DEVICE_TABLE(of, snd_sunxi_codec_ids);
+
+static int sunxi_codec_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct card_data *priv;
+	struct resource res;
+	int ret;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	of_id = of_match_device(snd_sunxi_codec_ids, &pdev->dev);
+	if (!of_id)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "could not allocate DAI object\n");
+		return -ENOMEM;
+	}
+	
+	priv->id = (int)of_id->data;
+
+	/* Get the addresses and IRQ */
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		dev_err(&pdev->dev, "could not determine device resources\n");
+		return ret;
+	}
+	priv->baseaddr = of_iomap(np, 0);
+	if (!priv->baseaddr) {
+		dev_err(&pdev->dev, "could not map device resources\n");
+		return -ENOMEM;
+	}
+	priv->codec_phys = res.start;
+
+	priv->irq = irq_of_parse_and_map(np, 0);
+	if (!priv->irq) {
+		dev_err(&pdev->dev, "no irq for node %s\n", np->full_name);
+		return -ENXIO;
+	}
+
+	/* Clock */
+	priv->codec_apbclk = devm_clk_get(dev, "apb");
+	if (IS_ERR(priv->codec_apbclk)) {
+		dev_err(dev, "failed to get apb clock.\n");
+		return PTR_ERR(priv->codec_apbclk);
+	}
+	priv->codec_pll2clk = devm_clk_get(dev, "pll2");
+	if (IS_ERR(priv->codec_pll2clk)) {
+		dev_err(dev, "failed to get pll2 clock.\n");
+		return PTR_ERR(priv->codec_pll2clk);
+	}
+	priv->codec_moduleclk = devm_clk_get(dev, "codec");
+	if (IS_ERR(priv->codec_moduleclk)) {
+		dev_err(dev, "failed to get codec clock.\n");
+		return PTR_ERR(priv->codec_moduleclk);
+	}
+	ret = clk_set_rate(priv->codec_pll2clk, 24576000);
+	if (ret) {
+		dev_err(dev, "set codec base clock failed!\n");
+		return ret;
+	}
+	if (clk_prepare_enable(priv->codec_pll2clk)) {
+		dev_err(dev, "try to enable codec_pll2clk failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(priv->codec_apbclk)) {
+		dev_err(dev, "try to enable apb_codec_clk failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(priv->codec_moduleclk)) {
+		dev_err(dev, "try to enable codec failed\n");
+		ret = -EINVAL;
+		goto exit_clkdisable_apb_clk;
+	}
+	dev_set_drvdata(&pdev->dev, priv);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_component, &sunxi_dai, 1);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_register_codec(&pdev->dev, &soc_codec_sunxi_codec, &dit_stub_dai, 1);
+	if (ret)
+		return ret;
+
+	snd_dmaengine_pcm_register(&pdev->dev, NULL, SND_DMAENGINE_PCM_FLAG_NO_RESIDUE);
+	printk("JDS - codec driver success registered\n");
+	return ret;
+
+exit_clkdisable_apb_clk:
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int snd_sunxi_codec_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct card_data *priv = dev_get_drvdata(&pdev->dev);
+
+	if (priv->running)
+		clk_disable(priv->codec_moduleclk);
+
+	return 0;
+}
+
+static int snd_sunxi_codec_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct card_data *priv = dev_get_drvdata(&pdev->dev);
+
+	if (priv->running) {
+		clk_enable(priv->codec_moduleclk);
+		sunxi_configure(priv);
+		sunxi_clock(priv, priv->saved_params.core_freq,
+				priv->saved_params.rate);
+	}
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(sunxi_dev_pm_ops, snd_sunxi_codec_suspend, \
+		snd_sunxi_codec_resume);
+
+#define sunxi_DEV_PM_OPS (&sunxi_dev_pm_ops)
+
+#else
+#define sunxi_DEV_PM_OPS NULL
+
+#endif
+
+static int sunxi_codec_remove(struct platform_device *pdev)
+{
+#ifdef JDS
+	clk_disable(codec_moduleclk);
+	//释放codec_pll2clk时钟句柄
+	clk_put(codec_pll2clk);
+	//释放codec_apbclk时钟句柄
+	clk_put(codec_apbclk);
+
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+#endif
+	return 0;
+	snd_dmaengine_pcm_unregister(&pdev->dev);
+}
+
+static void sunxi_codec_shutdown(struct platform_device *devptr)
+{
+#ifdef JDS
+	if (gpio_pa_shutdown) {
+//JDS		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+		mdelay(50);
+	}
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x0);
+	mdelay(100);
+	//pa mute
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	mdelay(500);
+	//disable dac analog
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x0);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x0);
+
+	//disable dac to pa
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x0);
+	codec_wr_control(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x0);
+
+	clk_disable(codec_moduleclk);
+#endif
+}
+
+/*method relating*/
+static struct platform_driver sunxi_codec_driver =
+{
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_remove,
+	.shutdown = sunxi_codec_shutdown,
+#ifdef CONFIG_PM
+//JDS	.suspend = snd_sunxi_codec_suspend,
+//JDS	.resume = snd_sunxi_codec_resume,
+#endif
+	.driver = {
+		.name = "sunxi-codec",
+		.of_match_table = snd_sunxi_codec_ids,
+	},
+};
+
+module_platform_driver(sunxi_codec_driver);
+
+MODULE_ALIAS("platform:sunxi-codec-dai");
+MODULE_DESCRIPTION("sunxi CODEC ALSA codec driver");
+MODULE_AUTHOR("software");
+MODULE_LICENSE("GPL v2");
+
