Bottom: a4240b98ad4d7c76c3b92e4980011beaf302d5d7
Top:    c5fffa809222793e8c5d16f62eb8fa146a4a31ba
Author: Jon Smirl <jonsmirl@terra>
Date:   2012-03-19 23:01:41 -0400

arm:lpc313x: UART DMA support fixes

The DMA buffer allocation/deallocation fixed. The receive
function SW timer handling is fixed. The clock divider calculation
fixed when console support disabled

Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>


---

diff --git a/arch/arm/mach-lpc31xx/generic.c b/arch/arm/mach-lpc31xx/generic.c
index 8ed8230..4980a58 100644
--- a/arch/arm/mach-lpc31xx/generic.c
+++ b/arch/arm/mach-lpc31xx/generic.c
@@ -94,6 +94,7 @@ static struct plat_serial8250_port platform_serial_ports[] = {
 		.uartclk = XTAL_CLOCK,
 		.regshift = 2,
 		.iotype = UPIO_MEM,
+		.type	= PORT_NXP16750,
 		.flags = UPF_BOOT_AUTOCONF | UPF_BUGGY_UART | UPF_SKIP_TEST,
 		.pm = lpc313x_uart_pm,
 	},
@@ -180,6 +181,18 @@ void __init lpc313x_map_io(void)
 }
 extern int __init cgu_init(char *str);
 
+void __init lpc313x_uart_init(void)
+{
+	int mul, div;
+
+	/* check what FDR bootloader is using */
+	mul = (UART_FDR_REG >> 4) & 0xF;
+	div = UART_FDR_REG & 0xF;
+	if (div != 0)  {
+		platform_serial_ports[0].uartclk = (XTAL_CLOCK * mul) / (mul + div);
+	}
+}
+
 int __init lpc313x_init(void)
 {
 	/* cgu init */
@@ -221,6 +234,8 @@ int __init lpc313x_init(void)
 	/* AUDIO CODEC CLOCK (256FS) */
 	GPIO_DRV_IP(IOCONF_I2STX_1, 0x8);
 
+	lpc313x_uart_init();
+
 	return platform_add_devices(devices, ARRAY_SIZE(devices));
 }
 
@@ -251,8 +266,8 @@ static int __init lpc313x_init_console(void)
 	mul = (UART_FDR_REG >> 4) & 0xF;
 	div = UART_FDR_REG & 0xF;
 	if (div != 0)  {
-		up.uartclk = (XTAL_CLOCK * mul) / (mul + div); 
-	} 
+		up.uartclk = (XTAL_CLOCK * mul) / (mul + div);
+	}
 	up.regshift = 2;
 	up.iotype = UPIO_MEM;
 	up.type	= PORT_NXP16750;
diff --git a/drivers/tty/serial/8250/8250.c b/drivers/tty/serial/8250/8250.c
index c4f09ac..5f6ebf5 100644
--- a/drivers/tty/serial/8250/8250.c
+++ b/drivers/tty/serial/8250/8250.c
@@ -39,7 +39,7 @@
  *  RX side modifications
  *   1) RX FIFO based mechanism replaced with DMA based circ
  *      buffer logic.The DMA nevers stops servicing the FIFO
- *      event when the DMA buffer is 
+ *      event when the DMA buffer is
  *
  *
  *  TX side modifications
@@ -1385,7 +1385,7 @@ static void lpc31xx_dma_lock(struct uart_8250_port *up)
 
 static void lpc31xx_dma_unlock(struct uart_8250_port *up)
 {
-	mutex_unlock(&dma_mutex);	
+	mutex_unlock(&dma_mutex);
 }
 
 static void lpc31xx_uart_tx_dma_start(struct uart_8250_port *up);
@@ -1439,7 +1439,7 @@ static void serial8250_dma_rx_timer_check(unsigned long data)
 	struct uart_8250_port *up = (struct uart_8250_port *) data;
 
 	/* Emulate RX timeout when DMA buffer is not full */
-	if (lpc31xx_get_readl_rx_dma_count(up))
+	if ((lpc31xx_get_readl_rx_dma_count(up)) && (up->dma_rx.active))
 		tasklet_schedule(&up->dma_rx.tasklet);
 	else
 		mod_timer(&up->dma_rx.timer, jiffies +
@@ -1547,9 +1547,6 @@ static void lpc31xx_dma_rx_tasklet_func(unsigned long data)
 			ch = serial_inp(up, UART_RX);
 	}
 	else {
-		dma_sync_single_for_device(up->port.dev, (u32) pbuf,
-			   count, DMA_FROM_DEVICE);
-
 		for (i = 0; i < (count - 1); i++) {
 			up->port.icount.rx++;
 			if (uart_handle_sysrq_char(&up->port, buf[i]))
@@ -2144,6 +2141,7 @@ static int serial_link_irq_chain(struct uart_8250_port *up)
 			lpc31xx_dma_rx_interrupt, up);
 		if (up->dma_rx.dmach < 0)
 		{
+			dma_release_channel(up->dma_tx.dmach);
 			printk(KERN_ERR "serial: error getting RX DMA channel.\n");
 			return -EBUSY;
 		}
@@ -2151,16 +2149,15 @@ static int serial_link_irq_chain(struct uart_8250_port *up)
 		/* dma_map_single() can be used for the TX buffer, but the RX
 		  buffer needs it's own buffer */
 		up->dma_rx.dma_buff_v = dma_alloc_coherent(NULL, UART_DMABUF_RX_SIZE,
-			&dma_handle, GFP_DMA);
+			&dma_handle, GFP_KERNEL);
 		if (up->dma_rx.dma_buff_v == NULL)
 		{
+			dma_release_channel(up->dma_tx.dmach);
+			dma_release_channel(up->dma_rx.dmach);
 			printk(KERN_ERR "serial: error getting DMA region.\n");
 			return -ENOMEM;
 		}
 		up->dma_rx.dma_buff_p = dma_handle;
-		printk(KERN_INFO "serial: UART RX buffer: P0x%08x, V0x%08x, size:%ld.\n",
-			(u32) up->dma_rx.dma_buff_p, (u32) up->dma_rx.dma_buff_v,
-			UART_DMABUF_RX_SIZE);
 
 		tasklet_init(&up->dma_tx.tasklet, lpc31xx_dma_tx_tasklet_func,
 				(unsigned long) up);
@@ -2174,11 +2171,20 @@ static int serial_link_irq_chain(struct uart_8250_port *up)
 					       UART_XMIT_SIZE,
 					       DMA_TO_DEVICE);
 
-		printk(KERN_INFO "serual: UART TX buffer: P0x%08x, V0x%08x, size:%ld.\n",
-			(u32) up->dma_tx.dma_buff_p, (u32) xmit->buf, UART_XMIT_SIZE);
+		if (dma_mapping_error(up->port.dev, up->dma_tx.dma_buff_p)){
+			dma_release_channel(up->dma_tx.dmach);
+			dma_release_channel(up->dma_rx.dmach);
+			dma_free_coherent(NULL, UART_DMABUF_RX_SIZE,
+				(void *) up->dma_rx.dma_buff_v,
+				up->dma_rx.dma_buff_p);
+			printk(KERN_ERR "serial: error mapping DMA region.\n");
+			return -ENOMEM;
+		}
+ 
+ 		dma_set_irq_mask(up->dma_tx.dmach, 1, 1);
+ 		dma_set_irq_mask(up->dma_rx.dmach, 1, 0);
 
-		dma_set_irq_mask(up->dma_tx.dmach, 1, 1);
-		dma_set_irq_mask(up->dma_rx.dmach, 1, 0);
+		up->dma_rx.active = 1;
 #endif
 		irq_flags |= up->port.irqflags;
 		ret = request_irq(up->port.irq, serial8250_interrupt,
@@ -2211,9 +2217,14 @@ static void serial_unlink_irq_chain(struct uart_8250_port *up)
 	   always point to that channel. This logic isn't quite right,
 	   but its ok for a single UART */
 
+	up->dma_rx.active = 0;
+
+	/* Delete Rx Timer */
+	del_timer(&up->dma_rx.timer);
+
 	/* Disable DMA channels */
-	dma_set_irq_mask(up->dma_tx.dmach, 0, 0);
-	dma_set_irq_mask(up->dma_rx.dmach, 0, 0);
+	dma_set_irq_mask(up->dma_tx.dmach, 1, 1);
+	dma_set_irq_mask(up->dma_rx.dmach, 1, 1);
 	dma_stop_channel(up->dma_tx.dmach);
 	dma_stop_channel(up->dma_rx.dmach);
 	dma_release_channel(up->dma_tx.dmach);
@@ -2222,7 +2233,7 @@ static void serial_unlink_irq_chain(struct uart_8250_port *up)
 	dma_unmap_single(up->port.dev, up->dma_tx.dma_buff_p, UART_XMIT_SIZE,
 		DMA_TO_DEVICE);
 
-	dma_free_coherent(up->port.dev, UART_XMIT_SIZE,
+	dma_free_coherent(NULL, UART_DMABUF_RX_SIZE,
 		(void *) up->dma_rx.dma_buff_v,
 		up->dma_rx.dma_buff_p);
 #endif
@@ -2593,11 +2604,6 @@ static int serial8250_startup(struct uart_port *port)
 		mod_timer(&up->timer, jiffies +
 			uart_poll_timeout(port) + HZ / 5);
 	}
-#else
-	init_timer(&up->dma_rx.timer);
-	up->dma_rx.timer.function = serial8250_dma_rx_timer_check;
-	up->dma_rx.timer.data = (unsigned long)up;
-	mod_timer(&up->dma_rx.timer, jiffies + 5);
 #endif
 
 	/*
@@ -2614,6 +2620,13 @@ static int serial8250_startup(struct uart_port *port)
 			return retval;
 	}
 
+#ifdef CONFIG_LPC31XX_SERIAL_DMA_SUPPORT
+	init_timer(&up->dma_rx.timer);
+	up->dma_rx.timer.function = serial8250_dma_rx_timer_check;
+	up->dma_rx.timer.data = (unsigned long)up;
+	mod_timer(&up->dma_rx.timer, jiffies + 5);
+#endif
+
 	/*
 	 * Now, initialize the UART
 	 */
