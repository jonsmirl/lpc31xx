Bottom: 583a553a0415b1375bd98c545adc4fa6e7a6cae9
Top:    0e96646ae5abcc893f7a437e50c41b3a0f30817f
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-05-21 13:47:58 -0400

clean out val315x code


---

diff --git a/arch/arm/mach-lpc31xx/Kconfig b/arch/arm/mach-lpc31xx/Kconfig
index 7b0478d..04fb90a 100644
--- a/arch/arm/mach-lpc31xx/Kconfig
+++ b/arch/arm/mach-lpc31xx/Kconfig
@@ -16,17 +16,6 @@ config MACH_EA3152
 	help
 	  Say Y here if you are using Embedded Artist's EA3152 board
 	  
-config MACH_VAL3153
-	bool "val3153 board"
-	help
-	  Say Y here if you are using the NXP val3153 board
-
-config MACH_VAL3154
-	bool "val3154 board"
-	select LPC3152_AD
-	help
-	  Say Y here if you are using the NXP val3154 board
-	  
 endchoice
 
 config LPC3152_AD
diff --git a/arch/arm/mach-lpc31xx/Makefile b/arch/arm/mach-lpc31xx/Makefile
index 12522c0..d307a1a 100644
--- a/arch/arm/mach-lpc31xx/Makefile
+++ b/arch/arm/mach-lpc31xx/Makefile
@@ -9,10 +9,8 @@ obj-$(CONFIG_OF) += dt.o
 
 
 # Specific board support
-obj-$(CONFIG_MACH_VAL3153) += board-val3153.o leds.o
 obj-$(CONFIG_MACH_EA313X) += board-ea313x.o
 obj-$(CONFIG_MACH_EA3152) += board-ea313x.o
-obj-$(CONFIG_MACH_VAL3154) += board-val3154.o leds.o
 obj-$(CONFIG_LPC3152_AD) += psu.o
 
 # Power Management
diff --git a/arch/arm/mach-lpc31xx/clock.c b/arch/arm/mach-lpc31xx/clock.c
index 51d623b..4c143bb 100644
--- a/arch/arm/mach-lpc31xx/clock.c
+++ b/arch/arm/mach-lpc31xx/clock.c
@@ -39,7 +39,7 @@
 /***********************************************************************
 * CGU driver package data
 ***********************************************************************/
-static u32 g_clkin_freq[CGU_FIN_SELECT_MAX];
+static uint32_t g_clkin_freq[CGU_FIN_SELECT_MAX];
 
 /***********************************************************************
 * CGU driver private functions
@@ -52,9 +52,9 @@ static u32 g_clkin_freq[CGU_FIN_SELECT_MAX];
 *     This is used to calculate the madd and msub width in frac div
 *     registers.Reasonably fast.
 **********************************************************************/
-static u32 cgu_fdiv_num_bits(unsigned int i)
+static uint32_t cgu_fdiv_num_bits(unsigned int i)
 {
-	u32 x = 0, y = 16;
+	uint32_t x = 0, y = 16;
 
 	for (; y > 0; y = y >> 1) {
 		if (i >> y) {
@@ -69,9 +69,9 @@ static u32 cgu_fdiv_num_bits(unsigned int i)
 	return x;
 }
 
-static inline u32 f_mult_m_div_n(u32 f_in, u32 m, u32 n)
+static inline uint32_t f_mult_m_div_n(uint32_t f_in, uint32_t m, uint32_t n)
 {
-	u32 temp;
+	uint32_t temp;
 	union {
 		unsigned long word[2];
 		unsigned long long longword;
@@ -173,9 +173,9 @@ static unsigned int pl550_p(int x)
 /***********************************************************************
 *     Finds ESR index corresponding to the requested clock Id.
 **********************************************************************/
-u32 cgu_clkid2esrid(CGU_CLOCK_ID_T clkid)
+uint32_t cgu_clkid2esrid(CGU_CLOCK_ID_T clkid)
 {
-	u32 esrIndex = (u32)clkid;
+	uint32_t esrIndex = (uint32_t)clkid;
 
 	switch (clkid)
 	{
@@ -200,9 +200,9 @@ u32 cgu_clkid2esrid(CGU_CLOCK_ID_T clkid)
 /***********************************************************************
 *     Finds BCR index corresponding to the requested domain Id.
 **********************************************************************/
-u32 cgu_DomainId2bcrid(CGU_DOMAIN_ID_T domainid)
+uint32_t cgu_DomainId2bcrid(CGU_DOMAIN_ID_T domainid)
 {
-	u32 bcridx = CGU_INVALID_ID;
+	uint32_t bcridx = CGU_INVALID_ID;
 	switch (domainid)
 	{
 	case CGU_SB_SYS_BASE_ID:
@@ -225,10 +225,10 @@ u32 cgu_DomainId2bcrid(CGU_DOMAIN_ID_T domainid)
 *	   clock.
 **********************************************************************/
 void cgu_ClkId2DomainId(CGU_CLOCK_ID_T clkid, CGU_DOMAIN_ID_T* pDomainId,
-                        u32* pSubdomainId)
+                        uint32_t* pSubdomainId)
 {
-	u32 esrIndex, esrReg;
-	u32 fracdiv_base = CGU_INVALID_ID;
+	uint32_t esrIndex, esrReg;
+	uint32_t fracdiv_base = CGU_INVALID_ID;
 
 	/*    1. Get the domain ID */
 
@@ -304,9 +304,9 @@ void cgu_ClkId2DomainId(CGU_CLOCK_ID_T clkid, CGU_DOMAIN_ID_T* pDomainId,
 * Configure the selected fractional divider
 *********************************************************************/
 /* frac divider config function */
-u32 cgu_fdiv_config(u32 fdId, CGU_FDIV_SETUP_T fdivCfg, u32 enable)
+uint32_t cgu_fdiv_config(uint32_t fdId, CGU_FDIV_SETUP_T fdivCfg, uint32_t enable)
 {
-	u32 conf, maddw, msubw, maxw, fdWidth;
+	uint32_t conf, maddw, msubw, maxw, fdWidth;
 	int madd, msub;
 
 	/* calculating program values to see if they fit in fractional divider*/
@@ -314,8 +314,8 @@ u32 cgu_fdiv_config(u32 fdId, CGU_FDIV_SETUP_T fdivCfg, u32 enable)
 	msub = -fdivCfg.n;
 
 	/* Find required bit width of madd & msub:*/
-	maddw = cgu_fdiv_num_bits((u32)madd);
-	msubw = cgu_fdiv_num_bits((u32)fdivCfg.n);
+	maddw = cgu_fdiv_num_bits((uint32_t)madd);
+	msubw = cgu_fdiv_num_bits((uint32_t)fdivCfg.n);
 	maxw = (maddw > msubw) ? maddw : msubw;
 	fdWidth = CGU_SB_BASE0_FDIV0_W;
 
@@ -352,7 +352,7 @@ u32 cgu_fdiv_config(u32 fdId, CGU_FDIV_SETUP_T fdivCfg, u32 enable)
 /***********************************************************************
 * Get frequency of requested base domain clock.
 **********************************************************************/
-u32 cgu_get_base_freq(CGU_DOMAIN_ID_T baseid)
+uint32_t cgu_get_base_freq(CGU_DOMAIN_ID_T baseid)
 {
 	/* get base frequency for the domain */
 	return g_clkin_freq[CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[baseid])];
@@ -361,9 +361,9 @@ u32 cgu_get_base_freq(CGU_DOMAIN_ID_T baseid)
 /***********************************************************************
 * Set frequency of requested base domain.
 **********************************************************************/
-void cgu_set_base_freq(CGU_DOMAIN_ID_T baseid, u32 fin_sel)
+void cgu_set_base_freq(CGU_DOMAIN_ID_T baseid, uint32_t fin_sel)
 {
-	u32 baseSCR;
+	uint32_t baseSCR;
 
 	/* Switch configuration register*/
 	baseSCR = CGU_SB->base_scr[baseid] & ~CGU_SB_SCR_FS_MASK;
@@ -395,7 +395,7 @@ void cgu_set_base_freq(CGU_DOMAIN_ID_T baseid, u32 fin_sel)
 void cgu_hpll_config(CGU_HPLL_ID_T pllid, CGU_HPLL_SETUP_T* pllsetup)
 {
 	CGU_HP_CFG_REGS* hppll;
-	u32 switched_domains = 0;
+	uint32_t switched_domains = 0;
 	CGU_DOMAIN_ID_T domainId;
 
 	/**********************************************************
@@ -466,7 +466,7 @@ void cgu_hpll_config(CGU_HPLL_ID_T pllid, CGU_HPLL_SETUP_T* pllsetup)
 /***********************************************************************
 * Set external enable feature for the requested clock
 **********************************************************************/
-void cgu_clk_set_exten(CGU_CLOCK_ID_T clkid, u32 enable)
+void cgu_clk_set_exten(CGU_CLOCK_ID_T clkid, uint32_t enable)
 {
 	switch (clkid)
 	{
@@ -519,13 +519,13 @@ void cgu_clk_set_exten(CGU_CLOCK_ID_T clkid, u32 enable)
 * Notes: None
 *
 **********************************************************************/
-u32 cgu_get_clk_freq(CGU_CLOCK_ID_T clkid)
+uint32_t cgu_get_clk_freq(CGU_CLOCK_ID_T clkid)
 {
-	u32 freq = 0;
+	uint32_t freq = 0;
 	CGU_DOMAIN_ID_T domainId;
-	u32 subDomainId;
+	uint32_t subDomainId;
 	int n, m;
-	u32 fdcVal;
+	uint32_t fdcVal;
 
 	/* get domain and frac div info for the clock */
 	cgu_ClkId2DomainId(clkid, &domainId, &subDomainId);
@@ -580,7 +580,7 @@ u32 cgu_get_clk_freq(CGU_CLOCK_ID_T clkid)
 void cgu_set_subdomain_freq(CGU_CLOCK_ID_T clkid, CGU_FDIV_SETUP_T fdiv_cfg)
 {
 	CGU_DOMAIN_ID_T domainId;
-	u32 subDomainId, base_freq, bcrId;
+	uint32_t subDomainId, base_freq, bcrId;
 
 	/* get domain and frac div info for the clock */
 	cgu_ClkId2DomainId(clkid, &domainId, &subDomainId);
@@ -611,16 +611,16 @@ void cgu_set_subdomain_freq(CGU_CLOCK_ID_T clkid, CGU_FDIV_SETUP_T fdiv_cfg)
 /***********************************************************************
 * Get frequency of requested PLL clock.
 **********************************************************************/
-u32 cgu_get_pll_freq(CGU_HPLL_ID_T pll_id, u32 infreq)
+uint32_t cgu_get_pll_freq(CGU_HPLL_ID_T pll_id, uint32_t infreq)
 {
-	u32 mdec;     /* 17 bits */
-	u32 ndec;     /* 10 bits */
-	u32 pdec;     /*  7 bits */
-	u32 mode;
-	u32 M = 0;
-	u32 N = 0;
-	u32 P = 0;
-	u32 ofreq = 0;
+	uint32_t mdec;     /* 17 bits */
+	uint32_t ndec;     /* 10 bits */
+	uint32_t pdec;     /*  7 bits */
+	uint32_t mode;
+	uint32_t M = 0;
+	uint32_t N = 0;
+	uint32_t P = 0;
+	uint32_t ofreq = 0;
 
 
 	mdec = CGU_CFG->hp[pll_id].mdec;  /* dec val feedback divider */
@@ -694,8 +694,8 @@ u32 cgu_get_pll_freq(CGU_HPLL_ID_T pll_id, u32 infreq)
  */
 static int lpc31xx_cgu_clocks_show(struct seq_file *s, void *v)
 {
-	u32 clk_id = CGU_SYS_FIRST;
-	u32 end_id = (CGU_SYSCLK_O_LAST + 1);
+	uint32_t clk_id = CGU_SYS_FIRST;
+	uint32_t end_id = (CGU_SYSCLK_O_LAST + 1);
 	char* str[2] = { "OFF", " ON"}; 
 
 	while (clk_id < end_id) {
@@ -743,7 +743,7 @@ static void lpc31xx_cgu_init_debugfs(void) {}
 int __init cgu_init(char *str)
 {
 	int i, j;
-	u32 flags;
+	uint32_t flags;
 	/* disable all non-essential clocks, enabel main clocks and wakeup
 	 * enables.
 	 */
@@ -804,7 +804,7 @@ static unsigned long local_return_parent_rate(struct clk *clk)
 
 static int local_onoff_enable(struct clk *clk, int enable)
 {
-	u32 tmp;
+	uint32_t tmp;
 
 	tmp = __raw_readl(clk->enable_reg);
 
diff --git a/arch/arm/mach-lpc31xx/dma.c b/arch/arm/mach-lpc31xx/dma.c
index e4bdcc1..389418d 100644
--- a/arch/arm/mach-lpc31xx/dma.c
+++ b/arch/arm/mach-lpc31xx/dma.c
@@ -324,7 +324,7 @@ int dma_read_counter (unsigned int chn, unsigned int * pcnt)
 	return 0;
 }
 
-int dma_write_counter (unsigned int chn, u32 cnt)
+int dma_write_counter (unsigned int chn, uint32_t cnt)
 {
 	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
 		return -EINVAL;
@@ -458,9 +458,9 @@ int dma_request_specific_sg_channel (int chn, char *name, dma_cb_t cb,
 	return sg_higher_channel[chn];
 }
 
-int dma_prog_sg_channel(int chn, u32 dma_sg_list)
+int dma_prog_sg_channel(int chn, uint32_t dma_sg_list)
 {
-	u32 dma_config;
+	uint32_t dma_config;
 
 	if (chn >= DMA_MAX_CHANNELS)
 		return -EINVAL;
@@ -553,9 +553,9 @@ int dma_release_sg_channel (unsigned int chn){return 0;}
 int dma_prog_channel (unsigned int chn, dma_setup_t *dma_setup){return 0;}
 int dma_start_channel (unsigned int chn){return 0;}
 int dma_stop_channel (unsigned int chn){return 0;}
-int dma_prog_sg_channel(int chn, u32 dma_sg_list){return 0;}
+int dma_prog_sg_channel(int chn, uint32_t dma_sg_list){return 0;}
 int dma_set_irq_mask(unsigned int chn, int half_int, int fin_int){return 0;}
-int dma_write_counter (unsigned int chn, u32 cnt){return 0;}
+int dma_write_counter (unsigned int chn, uint32_t cnt){return 0;}
 int dma_stop_channel_sg (unsigned int chn){return 0;}
 int dma_channel_enabled(unsigned int chn){return 0;}
 int dma_current_state (unsigned int   chn, unsigned int * psrc, unsigned int * pdst, unsigned int * plen, unsigned int * pcfg, unsigned int * pena, unsigned int * pcnt){return 0;}
diff --git a/arch/arm/mach-lpc31xx/include/mach/board.h b/arch/arm/mach-lpc31xx/include/mach/board.h
index f17126f..1792189 100644
--- a/arch/arm/mach-lpc31xx/include/mach/board.h
+++ b/arch/arm/mach-lpc31xx/include/mach/board.h
@@ -54,19 +54,19 @@ extern struct sys_timer lpc31xx_timer;
  */
 struct lpc31xx_nand_timing
 {
-	u32 ns_trsd;
-	u32 ns_tals;
-	u32 ns_talh;
-	u32 ns_tcls;
-	u32 ns_tclh;
-	u32 ns_tdrd;
-	u32 ns_tebidel;
-	u32 ns_tch;
-	u32 ns_tcs;
-	u32 ns_treh;
-	u32 ns_trp;
-	u32 ns_trw;
-	u32 ns_twp;
+	uint32_t ns_trsd;
+	uint32_t ns_tals;
+	uint32_t ns_talh;
+	uint32_t ns_tcls;
+	uint32_t ns_tclh;
+	uint32_t ns_tdrd;
+	uint32_t ns_tebidel;
+	uint32_t ns_tch;
+	uint32_t ns_tcs;
+	uint32_t ns_treh;
+	uint32_t ns_trp;
+	uint32_t ns_trw;
+	uint32_t ns_twp;
 };
 
 /*
@@ -109,7 +109,7 @@ struct lpc31xx_spics_cfg {
  * Defines the number of chip selects and the cs data
  */
 struct lpc31xx_spi_cfg {
-	u32 num_cs; /* Number of CS supported on this board */
+	uint32_t num_cs; /* Number of CS supported on this board */
 	/* Array of cs setup data (num_cs entries) */
 	struct lpc31xx_spics_cfg *spics_cfg;
 };
diff --git a/arch/arm/mach-lpc31xx/include/mach/clock.h b/arch/arm/mach-lpc31xx/include/mach/clock.h
index 96a28cf..d065e74 100644
--- a/arch/arm/mach-lpc31xx/include/mach/clock.h
+++ b/arch/arm/mach-lpc31xx/include/mach/clock.h
@@ -77,21 +77,21 @@
 typedef volatile struct
 {
   /* Switches controls */
-  volatile u32 base_scr[12]; /* Switch control */
-  volatile u32 base_fs1[12]; /* Frequency select side 1 */
-  volatile u32 base_fs2[12]; /* Frequency select side 2 */
-  volatile u32 base_ssr[12]; /* Switch status */
+  volatile uint32_t base_scr[12]; /* Switch control */
+  volatile uint32_t base_fs1[12]; /* Frequency select side 1 */
+  volatile uint32_t base_fs2[12]; /* Frequency select side 2 */
+  volatile uint32_t base_ssr[12]; /* Switch status */
   /* Clock enable controls (positive and inverted clock pairs share control register)*/
-  volatile u32 clk_pcr[92]; /* power control */
-  volatile u32 clk_psr[92]; /* power status */
+  volatile uint32_t clk_pcr[92]; /* power control */
+  volatile uint32_t clk_psr[92]; /* power status */
   /* enable select from fractional dividers (positive and inverted clock pairs share esr)*/
-  volatile u32 clk_esr[89]; /* enable select */
+  volatile uint32_t clk_esr[89]; /* enable select */
   /* Base controls, currently only fd_run (base wide fractional divider enable) bit.*/
-  volatile u32 base_bcr[5]; /* Base control */
+  volatile uint32_t base_bcr[5]; /* Base control */
   /* Fractional divider controls & configuration*/
-  volatile u32 base_fdc[24]; /* Fractional divider config & ctrl */
-  volatile u32 base_dyn_fdc[7]; /* Fractional divider config & ctrl for dynamic fracdivs */
-  volatile u32 base_dyn_sel[7]; /* Fractional divider register for selecting an external signal to trigger high-speed operation*/
+  volatile uint32_t base_fdc[24]; /* Fractional divider config & ctrl */
+  volatile uint32_t base_dyn_fdc[7]; /* Fractional divider config & ctrl for dynamic fracdivs */
+  volatile uint32_t base_dyn_sel[7]; /* Fractional divider register for selecting an external signal to trigger high-speed operation*/
 } CGU_SB_REGS_T;
 
 /* ----------------
@@ -100,29 +100,29 @@ typedef volatile struct
 */
 typedef volatile struct
 {
-  volatile u32 fin_select;
-  volatile u32 mdec;
-  volatile u32 ndec;
-  volatile u32 pdec;
-  volatile u32 mode;
-  volatile u32 status;
-  volatile u32 ack;
-  volatile u32 req;
-  volatile u32 inselr;
-  volatile u32 inseli;
-  volatile u32 inselp;
-  volatile u32 selr;
-  volatile u32 seli;
-  volatile u32 selp;
+  volatile uint32_t fin_select;
+  volatile uint32_t mdec;
+  volatile uint32_t ndec;
+  volatile uint32_t pdec;
+  volatile uint32_t mode;
+  volatile uint32_t status;
+  volatile uint32_t ack;
+  volatile uint32_t req;
+  volatile uint32_t inselr;
+  volatile uint32_t inseli;
+  volatile uint32_t inselp;
+  volatile uint32_t selr;
+  volatile uint32_t seli;
+  volatile uint32_t selp;
 } CGU_HP_CFG_REGS;
 
 typedef volatile struct
 {
-  volatile u32 powermode;
-  volatile u32 wd_bark;
-  volatile u32 ffast_on;
-  volatile u32 ffast_bypass;
-  volatile u32 resetn_soft[56];
+  volatile uint32_t powermode;
+  volatile uint32_t wd_bark;
+  volatile uint32_t ffast_on;
+  volatile uint32_t ffast_bypass;
+  volatile uint32_t resetn_soft[56];
   CGU_HP_CFG_REGS hp[2];
 } CGU_CONFIG_REGS;
 
@@ -551,15 +551,15 @@ typedef enum
 /* CGU HPLL config settings structure type */
 typedef struct
 {
-  u32 fin_select;
-  u32 ndec;
-  u32 mdec;
-  u32 pdec;
-  u32 selr;
-  u32 seli;
-  u32 selp;
-  u32 mode;
-  u32 freq; /* in MHz for driver internal data */
+  uint32_t fin_select;
+  uint32_t ndec;
+  uint32_t mdec;
+  uint32_t pdec;
+  uint32_t selr;
+  uint32_t seli;
+  uint32_t selp;
+  uint32_t mode;
+  uint32_t freq; /* in MHz for driver internal data */
 } CGU_HPLL_SETUP_T;
 
 /* CGU fractional divider settings structure type */
@@ -574,13 +574,13 @@ typedef struct
 * CGU driver functions
 **********************************************************************/
 /* Return the current base frequecy of the requested domain*/
-u32 cgu_get_base_freq(CGU_DOMAIN_ID_T baseid);
+uint32_t cgu_get_base_freq(CGU_DOMAIN_ID_T baseid);
 
 /* Change the base frequency for the requested domain */
-void cgu_set_base_freq(CGU_DOMAIN_ID_T baseid, u32 fin_sel);
+void cgu_set_base_freq(CGU_DOMAIN_ID_T baseid, uint32_t fin_sel);
 
 /* Return the current frequecy of the requested clock*/
-u32 cgu_get_clk_freq(CGU_CLOCK_ID_T clkid);
+uint32_t cgu_get_clk_freq(CGU_CLOCK_ID_T clkid);
 
 /* Change the sub-domain frequency for the requested clock */
 void cgu_set_subdomain_freq(CGU_CLOCK_ID_T clkid, CGU_FDIV_SETUP_T fdiv_cfg);
@@ -589,16 +589,16 @@ void cgu_set_subdomain_freq(CGU_CLOCK_ID_T clkid, CGU_FDIV_SETUP_T fdiv_cfg);
 void cgu_hpll_config(CGU_HPLL_ID_T id, CGU_HPLL_SETUP_T* pllsetup);
 
 /* enable / disable external enabling of the requested clock in CGU */
-void cgu_clk_set_exten(CGU_CLOCK_ID_T clkid, u32 enable);
+void cgu_clk_set_exten(CGU_CLOCK_ID_T clkid, uint32_t enable);
 
 /* frac divider config function */
-u32 cgu_fdiv_config(u32 fdId, CGU_FDIV_SETUP_T fdivCfg, u32 enable);
+uint32_t cgu_fdiv_config(uint32_t fdId, CGU_FDIV_SETUP_T fdivCfg, uint32_t enable);
 
 /***********************************************************************
 * CGU driver inline (ANSI C99 based) functions
 **********************************************************************/
 /* enable / disable the requested clock in CGU */
-static inline void cgu_clk_en_dis(CGU_CLOCK_ID_T clkid, u32 enable)
+static inline void cgu_clk_en_dis(CGU_CLOCK_ID_T clkid, uint32_t enable)
 {
   if (enable)
   {
@@ -613,7 +613,7 @@ static inline void cgu_clk_en_dis(CGU_CLOCK_ID_T clkid, u32 enable)
 /* Issue a software reset to the requested module */
 static inline void cgu_soft_reset_module(CGU_MOD_ID_T modId)
 {
-  volatile u32 i;
+  volatile uint32_t i;
 
   /* clear and set the register */
   CGU_CFG->resetn_soft[modId] = 0;
@@ -640,8 +640,8 @@ static inline void cgu_endis_base_freq(CGU_DOMAIN_ID_T baseid, int en)
 struct clk {
 	struct list_head node;
 	struct clk *parent;
-	u32 rate;
-	u32 usecount;
+	uint32_t rate;
+	uint32_t usecount;
 
 	int (*set_rate) (struct clk *, unsigned long);
 	unsigned long (*round_rate) (struct clk *, unsigned long);
@@ -650,7 +650,7 @@ struct clk {
 
 	/* Register address and bit mask for simple clocks */
 	void __iomem *enable_reg;
-	u32 enable_mask;
+	uint32_t enable_mask;
 
 	CGU_CLOCK_ID_T id;
 };
diff --git a/arch/arm/mach-lpc31xx/include/mach/dma.h b/arch/arm/mach-lpc31xx/include/mach/dma.h
index ca1a854..2767695 100644
--- a/arch/arm/mach-lpc31xx/include/mach/dma.h
+++ b/arch/arm/mach-lpc31xx/include/mach/dma.h
@@ -130,7 +130,7 @@ typedef union __dma_config_t{
 		unsigned int circular_buffer:1;
 		unsigned int rsrvd1:12;
 	} s;
-	u32 value;
+	uint32_t value;
 } dma_config_t;
 
 /*
@@ -139,14 +139,14 @@ typedef union __dma_config_t{
 typedef struct dma_setup
 {
 	/* source address for transfer*/
-	u32 src_address;
+	uint32_t src_address;
 	/* source address for transfer*/
-	u32 dest_address;
+	uint32_t dest_address;
 	/* toatl transfer length*/
-	u32 trans_length;
+	uint32_t trans_length;
 	/* channel configuration */
 	//dma_config_t cfg;
-	u32 cfg;
+	uint32_t cfg;
 } dma_setup_t;
 
 /*
@@ -155,7 +155,7 @@ typedef struct dma_setup
 typedef struct dma_sg_ll
 {
 	dma_setup_t setup;
-	u32 next_entry;
+	uint32_t next_entry;
 } dma_sg_ll_t;
 
 
@@ -268,7 +268,7 @@ int dma_read_counter (unsigned int, unsigned int *);
  *
  * Returns: 0 on success, otherwise failure
  */
-int dma_write_counter (unsigned int, u32);
+int dma_write_counter (unsigned int, uint32_t);
 
 /*
  * Read current channel state
@@ -368,7 +368,7 @@ int dma_prepare_sg_list(int, dma_sg_ll_t *);
  *
  * Returns: 0 on success, otherwise failure
  */
-int dma_prog_sg_channel(int, u32 );
+int dma_prog_sg_channel(int, uint32_t );
 
 /*
  * Release SDMA SG channel
diff --git a/arch/arm/mach-lpc31xx/include/mach/hardware.h b/arch/arm/mach-lpc31xx/include/mach/hardware.h
index a612cdb..5b4c2da 100644
--- a/arch/arm/mach-lpc31xx/include/mach/hardware.h
+++ b/arch/arm/mach-lpc31xx/include/mach/hardware.h
@@ -41,7 +41,7 @@
 #else
 
 # if 0
-#  define __REG(x)	(*((volatile u32 *)io_p2v(x)))
+#  define __REG(x)	(*((volatile uint32_t *)io_p2v(x)))
 # else
 /*
  * This __REG() version gives the same results as the one above,  except
@@ -49,7 +49,7 @@
  * assembly code for access to contiguous registers.
  */
 #include <asm/types.h>
-typedef struct { volatile u32 offset[4096]; } __regbase;
+typedef struct { volatile uint32_t offset[4096]; } __regbase;
 # define __REGP(x)	((__regbase *)((x)&~4095))->offset[((x)&4095)>>2]
 # define __REG(x)	__REGP(io_p2v(x))
 typedef struct { volatile u16 offset[4096]; } __regbase16;
@@ -62,9 +62,9 @@ typedef struct { volatile u8 offset[4096]; } __regbase8;
 
 # define __REG2(x,y)	\
 	( __builtin_constant_p(y) ? (__REG((x) + (y))) \
-				  : (*(volatile u32 *)((u32)&__REG(x) + (y))) )
+				  : (*(volatile uint32_t *)((uint32_t)&__REG(x) + (y))) )
 
-# define __PREG(x)	(io_v2p((u32)&(x)))
+# define __PREG(x)	(io_v2p((uint32_t)&(x)))
 
 /* include CGU header */
 #include "clock.h"
diff --git a/arch/arm/mach-lpc31xx/include/mach/registers.h b/arch/arm/mach-lpc31xx/include/mach/registers.h
index 4f4757e2..33b3f1d 100644
--- a/arch/arm/mach-lpc31xx/include/mach/registers.h
+++ b/arch/arm/mach-lpc31xx/include/mach/registers.h
@@ -69,95 +69,6 @@
 #define UART_ICR_REG      __REG (UART_PHYS + 0x24)
 #define UART_FDR_REG      __REG (UART_PHYS + 0x28)
 
-#if 0
-/***********************************************************************
- * SPI register definitions
- **********************************************************************/
-#define SPI_CONFIG_REG    __REG (SPI_PHYS + 0x00)
-#define SPI_SLV_ENAB_REG  __REG (SPI_PHYS + 0x04)
-#define SPI_TXF_FLUSH_REG __REG (SPI_PHYS + 0x08)
-#define SPI_FIFO_DATA_REG __REG (SPI_PHYS + 0x0C)
-#define SPI_NHP_POP_REG   __REG (SPI_PHYS + 0x10)
-#define SPI_NHP_MODE_REG  __REG (SPI_PHYS + 0x14)
-#define SPI_DMA_SET_REG   __REG (SPI_PHYS + 0x18)
-#define SPI_STS_REG       __REG (SPI_PHYS + 0x1C)
-#define SPI_HWINFO_REG    __REG (SPI_PHYS + 0x20)
-#define SPI_SLV_SET1_REG(slv) __REG (SPI_PHYS + 0x24 + (8 * slv))
-#define SPI_SLV_SET2_REG(slv) __REG (SPI_PHYS + 0x28 + (8 * slv))
-#define SPI_INT_TRSH_REG  __REG (SPI_PHYS + 0xFD4)
-#define SPI_INT_CLRE_REG  __REG (SPI_PHYS + 0xFD8)
-#define SPI_INT_SETE_REG  __REG (SPI_PHYS + 0xFDC)
-#define SPI_INT_STS_REG   __REG (SPI_PHYS + 0xFE0)
-#define SPI_INT_ENAB_REG  __REG (SPI_PHYS + 0xFE4)
-#define SPI_INT_CLRS_REG  __REG (SPI_PHYS + 0xFE8)
-#define SPI_INT_SETS_REG  __REG (SPI_PHYS + 0xFEC)
-#define SPI_MOD_ID_REG    __REG (SPI_PHYS + 0xFFC)
-
-/* SPI device contants */
-#define SPI_FIFO_DEPTH  64 /* 64 words (16bit) deep */
-#define SPI_NUM_SLAVES  3  /* number of slaves supported */
-#define SPI_MAX_DIV2    254
-#define SPI_MAX_DIVIDER 65024 /* = 254 * (255 + 1) */
-#define SPI_MIN_DIVIDER 2
-
-/* SPI Configuration register definitions (SPI_CONFIG_REG) */
-#define SPI_CFG_INTER_DLY(n)      _SBF(16, ((n) & 0xFFFF))
-#define SPI_CFG_INTER_DLY_GET(n)  (((n) >> 16) & 0xFFFF)
-#define SPI_CFG_UPDATE_EN         _BIT(7)
-#define SPI_CFG_SW_RESET          _BIT(6)
-#define SPI_CFG_SLAVE_DISABLE     _BIT(4)
-#define SPI_CFG_MULTI_SLAVE       _BIT(3)
-#define SPI_CFG_LOOPBACK          _BIT(2)
-#define SPI_CFG_SLAVE_MODE        _BIT(1)
-#define SPI_CFG_ENABLE            _BIT(0)
-
-/* SPI slave_enable register definitions (SPI_SLV_ENAB_REG) */
-#define SPI_SLV_EN(n)             _SBF(((n) << 1), 0x1)
-#define SPI_SLV_SUSPEND(n)        _SBF(((n) << 1), 0x3)
-
-/* SPI tx_fifo_flush register definitions (SPI_TXF_FLUSH_REG) */
-#define SPI_TXFF_FLUSH            _BIT(1)
-
-/* SPI dma_settings register definitions (SPI_DMA_SET_REG) */
-#define SPI_DMA_TX_EN             _BIT(1)
-#define SPI_DMA_RX_EN             _BIT(0)
-
-/* SPI status register definitions (SPI_STS_REG) */
-#define SPI_ST_SMS_BUSY           _BIT(5)
-#define SPI_ST_BUSY               _BIT(4)
-#define SPI_ST_RX_FF              _BIT(3)
-#define SPI_ST_RX_EMPTY           _BIT(2)
-#define SPI_ST_TX_FF              _BIT(1)
-#define SPI_ST_TX_EMPTY           _BIT(0)
-
-/* SPI slv_setting registers definitions (SPI_SLV_SET1_REG) */
-#define SPI_SLV1_INTER_TX_DLY(n)  _SBF(24, ((n) & 0xFF))
-#define SPI_SLV1_NUM_WORDS(n)     _SBF(16, ((n) & 0xFF))
-#define SPI_SLV1_CLK_PS(n)        _SBF(8, ((n) & 0xFF))
-#define SPI_SLV1_CLK_PS_GET(n)    (((n) >> 8) & 0xFF)
-#define SPI_SLV1_CLK_DIV1(n)      ((n) & 0xFF)
-#define SPI_SLV1_CLK_DIV1_GET(n)  ((n) & 0xFF)
-
-/* SPI slv_setting registers definitions (SPI_SLV_SET2_REG) */
-#define SPI_SLV2_PPCS_DLY(n)      _SBF(9, ((n) & 0xFF))
-#define SPI_SLV2_CS_HIGH          _BIT(8)
-#define SPI_SLV2_SSI_MODE         _BIT(7)
-#define SPI_SLV2_SPO              _BIT(6)
-#define SPI_SLV2_SPH              _BIT(5)
-#define SPI_SLV2_WD_SZ(n)         ((n) & 0x1F)
-
-/* SPI int_threshold registers definitions (SPI_INT_TRSH_REG) */
-#define SPI_INT_TSHLD_TX(n)       _SBF(8, ((n) & 0xFF))
-#define SPI_INT_TSHLD_RX(n)       ((n) & 0xFF)
-
-/* SPI intterrupt registers definitions ( SPI_INT_xxx) */
-#define SPI_SMS_INT               _BIT(4)
-#define SPI_TX_INT                _BIT(3)
-#define SPI_RX_INT                _BIT(2)
-#define SPI_TO_INT                _BIT(1)
-#define SPI_OVR_INT               _BIT(0)
-#define SPI_ALL_INTS              (SPI_SMS_INT | SPI_TX_INT | SPI_RX_INT | SPI_TO_INT | SPI_OVR_INT)
-#endif
 
 /***********************************************************************
  * ADC_REG register definitions
@@ -197,24 +108,6 @@
 #define SYS_MUX_GPIO_MCI    __REG (SYS_PHYS + 0x94)
 #define SYS_MUX_NAND_MCI    __REG (SYS_PHYS + 0x98)
 
-/***********************************************************************
- * GPIO register definitions
- **********************************************************************/
-#if 0
-#define GPIO_STATE(port)     __REG (GPIO_PHYS + (port) + 0x00)
-#define GPIO_STATE_M0(port)  __REG (GPIO_PHYS + (port) + 0x10)
-#define GPIO_M0_SET(port)    __REG (GPIO_PHYS + (port) + 0x14)
-#define GPIO_M0_RESET(port)  __REG (GPIO_PHYS + (port) + 0x18)
-#define GPIO_STATE_M1(port)  __REG (GPIO_PHYS + (port) + 0x20)
-#define GPIO_M1_SET(port)    __REG (GPIO_PHYS + (port) + 0x24)
-#define GPIO_M1_RESET(port)  __REG (GPIO_PHYS + (port) + 0x28)
-#endif
-
-#define GPIO_OUT_LOW(port, pin)  do { GPIO_M1_SET(port) = pin; GPIO_M0_RESET(port) = pin;} while(0)
-#define GPIO_OUT_HIGH(port, pin) do { GPIO_M1_SET(port) = pin; GPIO_M0_SET(port) = pin;} while(0)
-#define GPIO_IN(port, pin)       do { GPIO_M1_RESET(port) = pin; GPIO_M0_RESET(port) = pin;} while(0)
-#define GPIO_DRV_IP(port, pin)   do { GPIO_M1_RESET(port) = pin; GPIO_M0_SET(port) = pin;} while(0)
-
 #define IOCONF_EBI_MCI       (0x000)
 #define IOCONF_EBI_I2STX_0   (0x040)
 #define IOCONF_CGU           (0x080)
diff --git a/arch/arm/mach-lpc31xx/include/mach/uncompress.h b/arch/arm/mach-lpc31xx/include/mach/uncompress.h
index 320ab47..fa0867a 100644
--- a/arch/arm/mach-lpc31xx/include/mach/uncompress.h
+++ b/arch/arm/mach-lpc31xx/include/mach/uncompress.h
@@ -26,7 +26,7 @@
 
 
 #undef __REG
-#define __REG(x)	(*((volatile u32 *)(x)))
+#define __REG(x)	(*((volatile uint32_t *)(x)))
 /***********************************************************************
  * UART register definitions
  **********************************************************************/
diff --git a/arch/arm/mach-lpc31xx/leds.c b/arch/arm/mach-lpc31xx/leds.c
deleted file mode 100644
index 26ab4ca..0000000
--- a/arch/arm/mach-lpc31xx/leds.c
+++ /dev/null
@@ -1,102 +0,0 @@
-/*  linux/arch/arm/mach-lpc31xx/leds.c
- *
- *  Author:	Durgesh Pattamatta
- *  Copyright (C) 2009 NXP semiconductors
- *
- * LED driver for val3153-based boards.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-
-#include <asm/leds.h>
-#include <mach/gpio.h>
-
-
-static inline void val3153_led_on(unsigned int led)
-{
-	gpio_set_value(led, 0);
-}
-
-static inline void val3153_led_off(unsigned int led)
-{
-	gpio_set_value(led, 1);
-}
-
-static inline void val3153_led_toggle(unsigned int led)
-{
-	unsigned long is_off = gpio_get_value(led);
-	if (is_off)
-		val3153_led_on(led);
-	else
-		val3153_led_off(led);
-}
-
-
-/*
- * Handle LED events.
- */
-static void val3153_leds_event(led_event_t evt)
-{
-	unsigned long flags;
-
-	local_irq_save(flags);
-
-	switch(evt) {
-	case led_start:		/* System startup */
-		val3153_led_on(GPIO_GPIO0);
-		break;
-
-	case led_stop:		/* System stop / suspend */
-		val3153_led_off(GPIO_GPIO0);
-		break;
-
-#ifdef CONFIG_LEDS_TIMER
-	case led_timer:		/* Every 50 timer ticks */
-		val3153_led_toggle(GPIO_GPIO2);
-		break;
-#endif
-
-#ifdef CONFIG_LEDS_CPU
-	case led_idle_start:	/* Entering idle state */
-		val3153_led_off(GPIO_GPIO0);
-		break;
-
-	case led_idle_end:	/* Exit idle state */
-		val3153_led_on(GPIO_GPIO0);
-		break;
-#endif
-
-	default:
-		break;
-	}
-
-	local_irq_restore(flags);
-}
-
-
-int __init leds_init(void)
-{
-	leds_event = val3153_leds_event;
-
-	leds_event(led_start);
-	return 0;
-}
-
-__initcall(leds_init);
diff --git a/arch/arm/mach-lpc31xx/pm.c b/arch/arm/mach-lpc31xx/pm.c
index 194c02d..4b8999d 100644
--- a/arch/arm/mach-lpc31xx/pm.c
+++ b/arch/arm/mach-lpc31xx/pm.c
@@ -82,7 +82,7 @@ static int lpc31xx_pm_begin(suspend_state_t state)
 static void lpc31xx_clk_debug(void)
 {
 #ifdef CONFIG_PM_DEBUG
-	u32 i, clk_pcr;
+	uint32_t i, clk_pcr;
 	/* print all clocks which are not auto_wake enabled and are still
 	 * running before entering low-power states.
 	 */
@@ -95,11 +95,11 @@ static void lpc31xx_clk_debug(void)
 #endif
 }
 
-static int lpc31xx_enter_sleep(u32 standby)
+static int lpc31xx_enter_sleep(uint32_t standby)
 {
-	int (*lpc31xx_suspend_ptr) (u32);
+	int (*lpc31xx_suspend_ptr) (uint32_t);
 	int i;
-	u32 base_clk_state = 0;
+	uint32_t base_clk_state = 0;
 
 #if defined(BACKUP_ISRAM)
 	void *iram_swap_area;
diff --git a/arch/arm/mach-lpc31xx/psu.c b/arch/arm/mach-lpc31xx/psu.c
index 5385fea..b8a8bff 100644
--- a/arch/arm/mach-lpc31xx/psu.c
+++ b/arch/arm/mach-lpc31xx/psu.c
@@ -1,4 +1,4 @@
-/*  linux/arch/arm/mach-lpc31xx/leds.c
+/*  linux/arch/arm/mach-lpc31xx/psu.c
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
@@ -63,9 +63,9 @@ static struct psu_data g_pca_data;
  */
 struct i2c_client *lpc315x_ad_get_i2c_client_struct(void)
 {
-	/* Check if psu_data structure is initialised */
+	/* Check if psu_data structure is initialized */
 	if(!g_pca_data.client) {
-		printk(KERN_ERR "I2C not initialised \r\n");
+		printk(KERN_ERR "I2C not initialized \r\n");
 		return NULL;
 	}
 
@@ -80,7 +80,7 @@ static ssize_t psu_show(struct device *dev, struct device_attribute *attr,
 	struct sensor_device_attribute *psa = to_sensor_dev_attr(attr);
 	struct i2c_client *client = to_i2c_client(dev);
 	char reg_adr[2];
-	u32 reg_val = 0;
+	uint32_t reg_val = 0;
 
 	reg_adr[0] = (psa->index >> 8) & 0xFF;
 	reg_adr[1] = psa->index & 0xFF;
diff --git a/arch/arm/mach-lpc31xx/sram.c b/arch/arm/mach-lpc31xx/sram.c
index 27f78ea..a272840 100644
--- a/arch/arm/mach-lpc31xx/sram.c
+++ b/arch/arm/mach-lpc31xx/sram.c
@@ -39,7 +39,7 @@ static int lpc31xx_sram_probe(struct platform_device *pdev)
 	const unsigned int *prop;
 	const unsigned int *ranges;
 	int len, count, i;
-	volatile u32 *base;
+	volatile uint32_t *base;
 
 	prop = of_get_property(pdev->dev.of_node, "mpmc-config", &len);
 	if (!prop)
diff --git a/arch/arm/mach-lpc31xx/time.c b/arch/arm/mach-lpc31xx/time.c
index d17779d..b36894c 100644
--- a/arch/arm/mach-lpc31xx/time.c
+++ b/arch/arm/mach-lpc31xx/time.c
@@ -78,7 +78,7 @@ static struct irqaction lpc31xx_timer_irq = {
  */
 static unsigned long lpc31xx_gettimeoffset(void)
 {
-	u32 elapsed = LATCH - timer_read(TIMER_VALUE);
+	uint32_t elapsed = LATCH - timer_read(TIMER_VALUE);
 	return ((elapsed * 100) / (XTAL_CLOCK / 20000));
 }
 
diff --git a/arch/arm/mach-lpc31xx/usb.c b/arch/arm/mach-lpc31xx/usb.c
index 4596c65..45ad7e6 100644
--- a/arch/arm/mach-lpc31xx/usb.c
+++ b/arch/arm/mach-lpc31xx/usb.c
@@ -102,8 +102,8 @@
 #if defined(CONFIG_USB_GADGET_FSL_USB2) || defined(CONFIG_USB_OTG)
 static struct resource lpc31xx_usb_resource[] = {
 	[0] = {
-		.start = (u32) (USBOTG_PHYS),
-		.end   = (u32) (USBOTG_PHYS + SZ_4K),
+		.start = (uint32_t) (USBOTG_PHYS),
+		.end   = (uint32_t) (USBOTG_PHYS + SZ_4K),
 		.flags = IORESOURCE_MEM,
 	},
 	[1] = {
@@ -188,8 +188,8 @@ static void lpc31xx_vbusen_timer(unsigned long data)
 int __init usbotg_init(void)
 {
 	int over;
-	u32 bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
-	u32 bit_pos = EVT_usb_atx_pll_lock & 0x1F;
+	uint32_t bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
+	uint32_t bit_pos = EVT_usb_atx_pll_lock & 0x1F;
 	int retval = 0;
 
 	/* enable USB to AHB clock */
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 6e4e0a5..e60254e 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1206,8 +1206,6 @@ elite_ulk		MACH_ELITE_ULK		ELITE_ULK		3888
 pov2			MACH_POV2		POV2			3889
 ipod_touch_2g		MACH_IPOD_TOUCH_2G	IPOD_TOUCH_2G		3890
 da850_pqab		MACH_DA850_PQAB		DA850_PQAB		3891
-val3153			MACH_VAL3153		VAL3153			9999
-val3154			MACH_VAL3154		VAL3154			9997
 ea3152			MACH_EA3152		EA3152			9996
 
 
diff --git a/drivers/misc/lpc31xx/lpc31xx-adc.c b/drivers/misc/lpc31xx/lpc31xx-adc.c
index fd5b6ef..f765a43 100644
--- a/drivers/misc/lpc31xx/lpc31xx-adc.c
+++ b/drivers/misc/lpc31xx/lpc31xx-adc.c
@@ -302,7 +302,7 @@ u16 lpc31xx_adc_read(int channel, int resolution) {
 
 int lpc31xx_init_adc(void) {
 	int dummy;
-	u32 timeout;
+	uint32_t timeout;
 	
 	SYS_ADC_PD = 0;
 	
@@ -316,8 +316,8 @@ int lpc31xx_init_adc(void) {
 	ADC_INT_ENABLE_REG = ADC_INT_ENABLE_DEFAULT;
 	ADC_INT_CLEAR_REG = ADC_INT_CLEAR_DEFAULT;
 
-	/* dummy interupt status register read */
-	/** TODO: here we have to use a timeout, find out why and change, if neccessary. 
+	/* dummy interrupt status register read */
+	/** TODO: here we have to use a timeout, find out why and change, if necessary.
 	    if you re-enable the adc the whole board freezes without this timeout. **/
 	dummy = ADC_INT_STATUS_REG;
 	timeout = 0x2ffff;	// if timeout is too high, we have to wait a bit (system freezes for this time) 
diff --git a/drivers/mmc/host/lpc31xx_mmc.c b/drivers/mmc/host/lpc31xx_mmc.c
index 0dd758c..ffeeba6 100644
--- a/drivers/mmc/host/lpc31xx_mmc.c
+++ b/drivers/mmc/host/lpc31xx_mmc.c
@@ -99,18 +99,18 @@ struct lpc31xx_mci {
 	dma_addr_t		sg_dma;
 	dma_sg_ll_t		*sg_cpu;
 #endif
-	u32			cmd_status;
-	u32			data_status;
-	u32			stop_cmdr;
-	u32			dir_status;
+	uint32_t			cmd_status;
+	uint32_t			data_status;
+	uint32_t			stop_cmdr;
+	uint32_t			dir_status;
 	struct tasklet_struct	tasklet;
 	unsigned long		pending_events;
 	unsigned long		completed_events;
 	enum lpc31xx_mci_state	state;
 	struct list_head	queue;
 
-	u32			bus_hz;
-	u32			current_speed;
+	uint32_t			bus_hz;
+	uint32_t			current_speed;
 	struct platform_device	*pdev;
 	int slot_count;
 	struct lpc31xx_mci_slot	*slot[MAX_MCI_SLOTS];
@@ -120,7 +120,7 @@ struct lpc31xx_mci_slot {
 	struct mmc_host		*mmc;
 	struct lpc31xx_mci	*host;
 
-	u32			ctype;
+	uint32_t			ctype;
 
 	struct mmc_request	*mrq;
 	struct list_head	queue_node;
@@ -266,17 +266,17 @@ static void lpc31xx_mci_init_debugfs(struct lpc31xx_mci_slot *slot)
 	if (!node)
 		goto err;
 
-	node = debugfs_create_u32("state", S_IRUSR, root, (u32 *)&host->state);
+	node = debugfs_create_u32("state", S_IRUSR, root, (uint32_t *)&host->state);
 	if (!node)
 		goto err;
 
 	node = debugfs_create_x32("pending_events", S_IRUSR, root,
-				     (u32 *)&host->pending_events);
+				     (uint32_t *)&host->pending_events);
 	if (!node)
 		goto err;
 
 	node = debugfs_create_x32("completed_events", S_IRUSR, root,
-				     (u32 *)&host->completed_events);
+				     (uint32_t *)&host->completed_events);
 	if (!node)
 		goto err;
 
@@ -289,7 +289,7 @@ err:
 
 static inline unsigned ns_to_clocks(unsigned clkrate, unsigned ns)
 {
-	u32 clks;
+	uint32_t clks;
 	if (clkrate > 1000000)
 		clks =  (ns * (clkrate / 1000000) + 999) / 1000;
 	else
@@ -313,11 +313,11 @@ static void lpc31xx_mci_set_timeout(struct lpc31xx_mci *host,
 	mci_writel(host, SDMMC_TMOUT, /*0xffffffff); */ (timeout << 8) | (70));
 }
 
-static u32 lpc31xx_mci_prepare_command(struct mmc_host *mmc,
+static uint32_t lpc31xx_mci_prepare_command(struct mmc_host *mmc,
 				 struct mmc_command *cmd)
 {
 	struct mmc_data	*data;
-	u32		cmdr;
+	uint32_t		cmdr;
 
 	cmd->error = -EINPROGRESS;
 	cmdr = cmd->opcode;
@@ -355,7 +355,7 @@ static u32 lpc31xx_mci_prepare_command(struct mmc_host *mmc,
 
 
 static void lpc31xx_mci_start_command(struct lpc31xx_mci *host,
-		struct mmc_command *cmd, u32 cmd_flags)
+		struct mmc_command *cmd, uint32_t cmd_flags)
 {
  	int tmo = 50;
  	host->cmd = cmd;
@@ -455,11 +455,11 @@ static int lpc31xx_mci_submit_data_dma(struct lpc31xx_mci *host, struct mmc_data
 				   direction);
 
 	dev_vdbg(&host->pdev->dev, "sd sg_cpu: 0x%08x sg_dma:0x%08x sg_len:%d \n",
-		(u32)host->sg_cpu, (u32)host->sg_dma, sg_len);
+		(uint32_t)host->sg_cpu, (uint32_t)host->sg_dma, sg_len);
 
 	for (i = 0, j = 0; i < sg_len; i++) {
 		unsigned int length = sg_dma_len(&data->sg[i]);
-		u32 mem_addr = sg_dma_address(&data->sg[i]);
+		uint32_t mem_addr = sg_dma_address(&data->sg[i]);
 
 		while (length) {
 
@@ -571,7 +571,7 @@ static void lpc31xx_mci_submit_data(struct lpc31xx_mci *host, struct mmc_data *d
 void lpc31xx_mci_setup_bus(struct lpc31xx_mci_slot *slot)
 {
 	struct lpc31xx_mci *host = slot->host;
-	u32 div;
+	uint32_t div;
 
 	if (slot->clock != host->current_speed) {
 		div  = (((host->bus_hz + (host->bus_hz / 5)) / slot->clock)) >> 1;
@@ -628,7 +628,7 @@ static void lpc31xx_mci_start_request(struct lpc31xx_mci *host,
 	struct mmc_request	*mrq;
 	struct mmc_command	*cmd;
 	struct mmc_data		*data;
-	u32			cmdflags;
+	uint32_t			cmdflags;
 
 	mrq = slot->mrq;
 	/* now select the proper slot */
@@ -831,7 +831,7 @@ static void lpc31xx_mci_request_end(struct lpc31xx_mci *host, struct mmc_request
 static void lpc31xx_mci_command_complete(struct lpc31xx_mci *host,
 			struct mmc_command *cmd)
 {
-	u32		status = host->cmd_status;
+	uint32_t		status = host->cmd_status;
 
 	host->cmd_status = 0;
 
@@ -888,7 +888,7 @@ static void lpc31xx_mci_tasklet_func(unsigned long priv)
 	struct mmc_command	*cmd = host->cmd;
 	enum lpc31xx_mci_state	state = host->state;
 	enum lpc31xx_mci_state	prev_state;
-	u32			status;
+	uint32_t			status;
 
 	spin_lock(&host->lock);
 
@@ -1010,7 +1010,7 @@ unlock:
 
 inline static void lpc31xx_mci_push_data(struct lpc31xx_mci *host, void *buf, int cnt)
 {
-    u32* pData = (u32*)buf;
+    uint32_t* pData = (uint32_t*)buf;
 
     if (cnt % 4 != 0)
 	    printk("error not align 4\n");
@@ -1024,7 +1024,7 @@ inline static void lpc31xx_mci_push_data(struct lpc31xx_mci *host, void *buf, in
 
 inline static void lpc31xx_mci_pull_data(struct lpc31xx_mci *host, void *buf,int cnt)
 {
-    u32* pData = (u32*)buf;
+    uint32_t* pData = (uint32_t*)buf;
 
     if (cnt % 4 != 0)
 	    printk("error not align 4\n");
@@ -1041,7 +1041,7 @@ static void lpc31xx_mci_read_data_pio(struct lpc31xx_mci *host)
 	void			*buf = sg_virt(sg);
 	unsigned int		offset = host->pio_offset;
 	struct mmc_data		*data = host->data;
-	u32			status;
+	uint32_t			status;
 	unsigned int		nbytes = 0,len,old_len,count =0;
 
 	do {
@@ -1106,7 +1106,7 @@ static void lpc31xx_mci_write_data_pio(struct lpc31xx_mci *host)
 	void			*buf = sg_virt(sg);
 	unsigned int		offset = host->pio_offset;
 	struct mmc_data		*data = host->data;
-	u32			status;
+	uint32_t			status;
 	unsigned int		nbytes = 0,len;
 
 	do {
@@ -1165,7 +1165,7 @@ done:
 	lpc31xx_mci_set_pending(host, EVENT_XFER_COMPLETE);
 }
 
-static void lpc31xx_mci_cmd_interrupt(struct lpc31xx_mci *host, u32 status)
+static void lpc31xx_mci_cmd_interrupt(struct lpc31xx_mci *host, uint32_t status)
 {
 	if(!host->cmd_status)
 		host->cmd_status = status;
@@ -1178,7 +1178,7 @@ static void lpc31xx_mci_cmd_interrupt(struct lpc31xx_mci *host, u32 status)
 static irqreturn_t lpc31xx_mci_interrupt(int irq, void *dev_id)
 {
 	struct lpc31xx_mci	*host = dev_id;
-	u32			status,  pending;
+	uint32_t			status,  pending;
 	unsigned int		pass_count = 0;
 
 	spin_lock(&host->lock);
@@ -1374,7 +1374,7 @@ lpc31xx_mci_init_slot(struct lpc31xx_mci *host, struct device_node *np)
 {
 	struct mmc_host			*mmc;
 	struct lpc31xx_mci_slot		*slot;
-	const u32 *voltage_ranges;
+	const uint32_t *voltage_ranges;
 	const int *width;
 	int i, ret, num_ranges, level;
 	enum of_gpio_flags flags;
@@ -1425,7 +1425,7 @@ lpc31xx_mci_init_slot(struct lpc31xx_mci *host, struct device_node *np)
 
 	for (i = 0; i < num_ranges; i++) {
 		const int j = i * 2;
-		u32 mask;
+		uint32_t mask;
 
 		mask = mmc_vddrange_to_ocrmask(be32_to_cpu(voltage_ranges[j]),
 					       be32_to_cpu(voltage_ranges[j + 1]));
diff --git a/drivers/net/ethernet/cirrus/cs89x0.c b/drivers/net/ethernet/cirrus/cs89x0.c
index f7e0595..b9406cb 100644
--- a/drivers/net/ethernet/cirrus/cs89x0.c
+++ b/drivers/net/ethernet/cirrus/cs89x0.c
@@ -321,12 +321,6 @@ struct net_device * __init cs89x0_probe(int unit)
 	if (net_debug)
 		printk("cs89x0:cs89x0_probe(0x%x)\n", io);
 
-#ifdef CONFIG_MACH_VAL3153
-	if(unit > 0) {
-		err = -ENODEV;
-		goto out;
-	}
-#endif
 	if (io > 0x1ff)	{	/* Check a single specified location. */
 		err = cs89x0_probe1(dev, io, 0);
 	} else if (io != 0) {	/* Don't probe at all. */
@@ -375,37 +369,6 @@ writeword(unsigned long base_addr, int portno, u16 value)
 {
 	__raw_writel(value, base_addr + (portno << 1));
 }
-#elif defined(CONFIG_ARCH_PNX010X)
-static u16
-readword(unsigned long base_addr, int portno)
-{
-	return inw(base_addr + (portno << 1));
-}
-
-static void
-writeword(unsigned long base_addr, int portno, u16 value)
-{
-	outw(value, base_addr + (portno << 1));
-}
-#elif defined(CONFIG_MACH_VAL3153)
-static u16
-readword(unsigned long base_addr, int portno)
-{
-	u16 v;
-	CS8900_IOBARRIER;
-	v = inw(base_addr + portno);
-	CS8900_IOBARRIER;
-	return v;
-}
-
-static void
-writeword(unsigned long base_addr, int portno, u16 value)
-{
-	CS8900_IOBARRIER;
-	outw(value, base_addr + portno);
-	CS8900_IOBARRIER;
-}
-
 #else
 static u16
 readword(unsigned long base_addr, int portno)
@@ -578,12 +541,6 @@ cs89x0_probe1(struct net_device *dev, unsigned long ioaddr, int modular)
 		goto out1;
 	}
 
-#if defined(CONFIG_MACH_VAL3153)
-	/* truely reset the chip */
-	writeword(ioaddr, ADD_PORT, 0x0114);
-	writeword(ioaddr, DATA_PORT, 0x0040);
-#endif
-
 	/* if they give us an odd I/O address, then do ONE write to
            the address port, to get it back to address zero, where we
            expect to find the EISA signature word. An IO with a base of 0x3
@@ -649,12 +606,9 @@ cs89x0_probe1(struct net_device *dev, unsigned long ioaddr, int modular)
 	   the driver will always do *something* instead of complain that
 	   adapter_cnf is 0. */
 
-/* quick hack for VAL3153 boards to reuse the mac address set by boot loader */
-#if !defined(CONFIG_MACH_VAL3153)
+
         if ((readreg(dev, PP_SelfST) & (EEPROM_OK | EEPROM_PRESENT)) ==
-	      (EEPROM_OK|EEPROM_PRESENT)) 
-#endif
-	{
+	      (EEPROM_OK|EEPROM_PRESENT)) {
 	        /* Load the MAC. */
 		for (i=0; i < ETH_ALEN/2; i++) {
 	                unsigned int Addr;
diff --git a/drivers/usb/host/ehci-lpc.c b/drivers/usb/host/ehci-lpc.c
index fd51f01..18b908f 100644
--- a/drivers/usb/host/ehci-lpc.c
+++ b/drivers/usb/host/ehci-lpc.c
@@ -243,7 +243,7 @@ static int lpc_ehci_suspend(struct device *dev, pm_message_t state)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	u32 cmd;
+	uint32_t cmd;
 
 	dev_dbg(dev, "%s pdev=0x%p  ehci=0x%p  hcd=0x%p\n",
 		 __FUNCTION__, pdev, ehci, hcd);
@@ -277,7 +277,7 @@ static int lpc_ehci_resume(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	u32 tmp;
+	uint32_t tmp;
 
 	dbg("%s pdev=0x%p  pdata=0x%p  ehci=0x%p  hcd=0x%p\n",
 	    __FUNCTION__, pdev, pdata, ehci, hcd);
@@ -337,8 +337,8 @@ static int lpc31xx_ehci_suspend(struct platform_device *pdev, pm_message_t state
 static int lpc31xx_ehci_resume(struct platform_device * pdev)
 {
 #ifdef CONFIG_PM
-	u32 bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
-	u32 bit_pos = EVT_usb_atx_pll_lock & 0x1F;
+	uint32_t bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
+	uint32_t bit_pos = EVT_usb_atx_pll_lock & 0x1F;
 	int tout = 100;
 
 	/* Turn on IP Clock */
diff --git a/drivers/usb/host/lpc-ehset.c b/drivers/usb/host/lpc-ehset.c
index aa76b7e5..0e8e413 100644
--- a/drivers/usb/host/lpc-ehset.c
+++ b/drivers/usb/host/lpc-ehset.c
@@ -88,7 +88,7 @@ static struct usb_driver hset_driver;
 /* Test routines */
 static inline void test_se0_nak(struct usb_hset *hset)
 {
-	u32 temp = USB_DEV_PORTSC1;
+	uint32_t temp = USB_DEV_PORTSC1;
 	printk(KERN_INFO "%s\n", __FUNCTION__);
 	
 	temp &= ~(0xF << 16);
@@ -98,7 +98,7 @@ static inline void test_se0_nak(struct usb_hset *hset)
 
 static inline void test_j(struct usb_hset *hset)
 {
-	u32 temp = USB_DEV_PORTSC1;
+	uint32_t temp = USB_DEV_PORTSC1;
 	printk(KERN_INFO "%s\n", __FUNCTION__);
 	
 	temp &= ~(0xF << 16);
@@ -108,7 +108,7 @@ static inline void test_j(struct usb_hset *hset)
 
 static inline void test_k(struct usb_hset *hset)
 {
-	u32 temp = USB_DEV_PORTSC1;
+	uint32_t temp = USB_DEV_PORTSC1;
 	printk(KERN_INFO "%s\n", __FUNCTION__);
 	
 	temp &= ~(0xF << 16);
@@ -118,7 +118,7 @@ static inline void test_k(struct usb_hset *hset)
 
 static inline void test_packet(struct usb_hset *hset)
 {
-	u32 temp = USB_DEV_PORTSC1;
+	uint32_t temp = USB_DEV_PORTSC1;
 	printk(KERN_INFO "%s\n", __FUNCTION__);
 	
 	temp &= ~(0xF << 16);
@@ -128,7 +128,7 @@ static inline void test_packet(struct usb_hset *hset)
 
 static inline void test_force_enable(struct usb_hset *hset)
 {
-	u32 temp = USB_DEV_PORTSC1;
+	uint32_t temp = USB_DEV_PORTSC1;
 	printk(KERN_INFO "%s\n", __FUNCTION__);
 	
 	temp &= ~(0xF << 16);
diff --git a/dt_config b/dt_config
index 9a449e2..0998c92 100644
--- a/dt_config
+++ b/dt_config
@@ -1,6 +1,6 @@
 #
 # Automatically generated file; DO NOT EDIT.
-# Linux/arm 3.3.0 Kernel Configuration
+# Linux/arm 3.4.0-rc4 Kernel Configuration
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -36,9 +36,11 @@ CONFIG_LOCALVERSION=""
 # CONFIG_LOCALVERSION_AUTO is not set
 CONFIG_HAVE_KERNEL_GZIP=y
 CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
 CONFIG_HAVE_KERNEL_LZO=y
 CONFIG_KERNEL_GZIP=y
 # CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
 # CONFIG_KERNEL_LZO is not set
 CONFIG_DEFAULT_HOSTNAME="(none)"
 # CONFIG_SWAP is not set
@@ -55,17 +57,15 @@ CONFIG_HAVE_GENERIC_HARDIRQS=y
 # IRQ subsystem
 #
 CONFIG_GENERIC_HARDIRQS=y
-CONFIG_HAVE_SPARSE_IRQ=y
 CONFIG_GENERIC_IRQ_SHOW=y
 CONFIG_IRQ_DOMAIN=y
-# CONFIG_SPARSE_IRQ is not set
+CONFIG_IRQ_DOMAIN_DEBUG=y
 
 #
 # RCU Subsystem
 #
 CONFIG_TINY_RCU=y
 # CONFIG_PREEMPT_RCU is not set
-# CONFIG_RCU_TRACE is not set
 # CONFIG_TREE_RCU_TRACE is not set
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=14
@@ -124,11 +124,13 @@ CONFIG_SLAB=y
 # CONFIG_PROFILING is not set
 CONFIG_HAVE_OPROFILE=y
 # CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
 CONFIG_HAVE_KPROBES=y
 CONFIG_HAVE_KRETPROBES=y
 CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
 CONFIG_HAVE_CLK=y
 CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
 
 #
 # GCOV-based kernel profiling
@@ -170,7 +172,6 @@ CONFIG_DEFAULT_IOSCHED="noop"
 # CONFIG_INLINE_SPIN_LOCK_BH is not set
 # CONFIG_INLINE_SPIN_LOCK_IRQ is not set
 # CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
-CONFIG_INLINE_SPIN_UNLOCK=y
 # CONFIG_INLINE_SPIN_UNLOCK_BH is not set
 CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
 # CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
@@ -239,7 +240,7 @@ CONFIG_MMU=y
 # CONFIG_ARCH_SHMOBILE is not set
 # CONFIG_ARCH_RPC is not set
 # CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C24XX is not set
 # CONFIG_ARCH_S3C64XX is not set
 # CONFIG_ARCH_S5P64X0 is not set
 # CONFIG_ARCH_S5PC100 is not set
@@ -262,12 +263,10 @@ CONFIG_ARCH_LPC31XX=y
 #
 
 #
-# LPC313x Implementations
+# LPC31xx Implementations
 #
 CONFIG_MACH_EA313X=y
 # CONFIG_MACH_EA3152 is not set
-# CONFIG_MACH_VAL3153 is not set
-# CONFIG_MACH_VAL3154 is not set
 # CONFIG_HZ_100 is not set
 CONFIG_HZ_250=y
 # CONFIG_HZ_300 is not set
@@ -495,6 +494,8 @@ CONFIG_IEEE802154=y
 # CONFIG_BATMAN_ADV is not set
 # CONFIG_OPENVSWITCH is not set
 CONFIG_BQL=y
+CONFIG_HAVE_BPF_JIT=y
+# CONFIG_BPF_JIT is not set
 
 #
 # Network testing
@@ -526,7 +527,6 @@ CONFIG_MAC80211_RC_MINSTREL_HT=y
 CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
 CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
 # CONFIG_MAC80211_MESH is not set
-# CONFIG_MAC80211_LEDS is not set
 # CONFIG_MAC80211_DEBUGFS is not set
 # CONFIG_MAC80211_DEBUG_MENU is not set
 # CONFIG_WIMAX is not set
@@ -556,98 +556,9 @@ CONFIG_EXTRA_FIRMWARE=""
 # CONFIG_GENERIC_CPU_DEVICES is not set
 CONFIG_REGMAP=y
 CONFIG_REGMAP_I2C=y
-CONFIG_REGMAP_SPI=y
 # CONFIG_DMA_SHARED_BUFFER is not set
 # CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_REDBOOT_PARTS is not set
-# CONFIG_MTD_CMDLINE_PARTS is not set
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_OF_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_SM_FTL is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-# CONFIG_MTD_CFI is not set
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-CONFIG_MTD_DATAFLASH=y
-# CONFIG_MTD_DATAFLASH_WRITE_VERIFY is not set
-# CONFIG_MTD_DATAFLASH_OTP is not set
-CONFIG_MTD_M25P80=y
-CONFIG_M25PXX_USE_FAST_READ=y
-# CONFIG_MTD_SST25L is not set
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_DOCG3 is not set
-CONFIG_MTD_NAND_ECC=y
-# CONFIG_MTD_NAND_ECC_SMC is not set
-CONFIG_MTD_NAND=y
-# CONFIG_MTD_NAND_VERIFY_WRITE is not set
-# CONFIG_MTD_NAND_ECC_BCH is not set
-# CONFIG_MTD_SM_COMMON is not set
-# CONFIG_MTD_NAND_MUSEUM_IDS is not set
-# CONFIG_MTD_NAND_GPIO is not set
-CONFIG_MTD_NAND_IDS=y
-# CONFIG_MTD_NAND_DISKONCHIP is not set
-# CONFIG_MTD_NAND_NANDSIM is not set
-# CONFIG_MTD_NAND_PLATFORM is not set
-# CONFIG_MTD_ALAUDA is not set
-CONFIG_MTD_NAND_LPC313X=y
-# CONFIG_MTD_ONENAND is not set
-
-#
-# LPDDR flash memory drivers
-#
-# CONFIG_MTD_LPDDR is not set
-# CONFIG_MTD_UBI is not set
+# CONFIG_MTD is not set
 CONFIG_DTC=y
 CONFIG_OF=y
 
@@ -664,7 +575,6 @@ CONFIG_OF_DEVICE=y
 CONFIG_OF_GPIO=y
 CONFIG_OF_I2C=y
 CONFIG_OF_NET=y
-CONFIG_OF_SPI=y
 # CONFIG_PARPORT is not set
 CONFIG_BLK_DEV=y
 # CONFIG_BLK_DEV_COW_COMMON is not set
@@ -676,7 +586,6 @@ CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
 # DRBD disabled because PROC_FS, INET or CONNECTOR not selected
 #
 # CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_UB is not set
 CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=8192
@@ -703,7 +612,6 @@ CONFIG_BLK_DEV_XIP=y
 # CONFIG_SENSORS_APDS990X is not set
 # CONFIG_HMC6352 is not set
 # CONFIG_DS1682 is not set
-# CONFIG_TI_DAC7512 is not set
 # CONFIG_BMP085 is not set
 # CONFIG_USB_SWITCH_FSA9480 is not set
 # CONFIG_C2PORT is not set
@@ -712,27 +620,24 @@ CONFIG_BLK_DEV_XIP=y
 # EEPROM support
 #
 # CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_AT25 is not set
 # CONFIG_EEPROM_LEGACY is not set
 # CONFIG_EEPROM_MAX6875 is not set
 # CONFIG_EEPROM_93CX6 is not set
-# CONFIG_EEPROM_93XX46 is not set
 # CONFIG_IWMC3200TOP is not set
 
 #
 # Texas Instruments shared transport line discipline
 #
 # CONFIG_TI_ST is not set
-# CONFIG_SENSORS_LIS3_SPI is not set
 # CONFIG_SENSORS_LIS3_I2C is not set
 
 #
 # Altera FPGA firmware download module
 #
 # CONFIG_ALTERA_STAPL is not set
-CONFIG_NEW_LPC313x_IO=y
-CONFIG_LPC313x_ADC=y
-CONFIG_LPC313x_PWM=y
+CONFIG_NEW_LPC31xx_IO=y
+CONFIG_LPC31xx_ADC=y
+CONFIG_LPC31xx_PWM=y
 
 #
 # SCSI device support
@@ -804,6 +709,7 @@ CONFIG_NET_VENDOR_BROADCOM=y
 # CONFIG_B44 is not set
 # CONFIG_NET_CALXEDA_XGMAC is not set
 CONFIG_NET_VENDOR_CHELSIO=y
+# CONFIG_NET_VENDOR_CIRRUS is not set
 CONFIG_DM9000=y
 # CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL is not set
 # CONFIG_DNET is not set
@@ -814,10 +720,7 @@ CONFIG_NET_VENDOR_INTEL=y
 CONFIG_NET_VENDOR_I825XX=y
 CONFIG_NET_VENDOR_MARVELL=y
 CONFIG_NET_VENDOR_MICREL=y
-# CONFIG_KS8851 is not set
 # CONFIG_KS8851_MLL is not set
-CONFIG_NET_VENDOR_MICROCHIP=y
-# CONFIG_ENC28J60 is not set
 CONFIG_NET_VENDOR_NATSEMI=y
 CONFIG_NET_VENDOR_8390=y
 # CONFIG_AX88796 is not set
@@ -831,25 +734,10 @@ CONFIG_NET_VENDOR_SMSC=y
 CONFIG_NET_VENDOR_STMICRO=y
 # CONFIG_STMMAC_ETH is not set
 # CONFIG_PHYLIB is not set
-# CONFIG_MICREL_KS8995MA is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-
-#
-# USB Network Adapters
-#
-# CONFIG_USB_CATC is not set
-# CONFIG_USB_KAWETH is not set
-# CONFIG_USB_PEGASUS is not set
-# CONFIG_USB_RTL8150 is not set
-# CONFIG_USB_USBNET is not set
-# CONFIG_USB_IPHETH is not set
 CONFIG_WLAN=y
 # CONFIG_LIBERTAS_THINFIRM is not set
-# CONFIG_AT76C50X_USB is not set
-# CONFIG_USB_ZD1201 is not set
-# CONFIG_USB_NET_RNDIS_WLAN is not set
-# CONFIG_RTL8187 is not set
 # CONFIG_MAC80211_HWSIM is not set
 # CONFIG_ATH_COMMON is not set
 # CONFIG_B43 is not set
@@ -860,24 +748,8 @@ CONFIG_WLAN=y
 # CONFIG_LIBERTAS is not set
 # CONFIG_P54_COMMON is not set
 CONFIG_RT2X00=y
-CONFIG_RT2500USB=y
-CONFIG_RT73USB=y
-CONFIG_RT2800USB=y
-CONFIG_RT2800USB_RT33XX=y
-CONFIG_RT2800USB_RT35XX=y
-# CONFIG_RT2800USB_RT53XX is not set
-# CONFIG_RT2800USB_UNKNOWN is not set
-CONFIG_RT2800_LIB=y
-CONFIG_RT2X00_LIB_USB=y
-CONFIG_RT2X00_LIB=y
-CONFIG_RT2X00_LIB_FIRMWARE=y
-CONFIG_RT2X00_LIB_CRYPTO=y
-CONFIG_RT2X00_LIB_LEDS=y
-# CONFIG_RT2X00_DEBUG is not set
-# CONFIG_RTL8192CU is not set
 # CONFIG_WL1251 is not set
 # CONFIG_WL12XX_MENU is not set
-# CONFIG_ZD1211RW is not set
 # CONFIG_MWIFIEX is not set
 
 #
@@ -885,7 +757,6 @@ CONFIG_RT2X00_LIB_LEDS=y
 #
 # CONFIG_WAN is not set
 # CONFIG_ISDN is not set
-# CONFIG_PHONE is not set
 
 #
 # Input device support
@@ -914,18 +785,18 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TABLET is not set
 CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_ADS7846=y
-# CONFIG_TOUCHSCREEN_AD7877 is not set
 # CONFIG_TOUCHSCREEN_AD7879 is not set
 # CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
 # CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
 # CONFIG_TOUCHSCREEN_BU21013 is not set
 # CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
 # CONFIG_TOUCHSCREEN_DYNAPRO is not set
 # CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
 # CONFIG_TOUCHSCREEN_EETI is not set
 # CONFIG_TOUCHSCREEN_EGALAX is not set
 # CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
 # CONFIG_TOUCHSCREEN_GUNZE is not set
 # CONFIG_TOUCHSCREEN_ELO is not set
 # CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
@@ -938,10 +809,8 @@ CONFIG_TOUCHSCREEN_ADS7846=y
 # CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
 # CONFIG_TOUCHSCREEN_TOUCHWIN is not set
 # CONFIG_TOUCHSCREEN_PIXCIR is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
 # CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
 # CONFIG_TOUCHSCREEN_TSC_SERIO is not set
-# CONFIG_TOUCHSCREEN_TSC2005 is not set
 # CONFIG_TOUCHSCREEN_TSC2007 is not set
 # CONFIG_TOUCHSCREEN_W90X900 is not set
 # CONFIG_TOUCHSCREEN_ST1232 is not set
@@ -980,15 +849,12 @@ CONFIG_SERIAL_8250_RUNTIME_UARTS=1
 #
 # Non-8250 serial port support
 #
-# CONFIG_SERIAL_MAX3100 is not set
-# CONFIG_SERIAL_MAX3107 is not set
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
 # CONFIG_SERIAL_OF_PLATFORM is not set
 # CONFIG_SERIAL_TIMBERDALE is not set
 # CONFIG_SERIAL_ALTERA_JTAGUART is not set
 # CONFIG_SERIAL_ALTERA_UART is not set
-# CONFIG_SERIAL_IFX6X60 is not set
 # CONFIG_SERIAL_XILINX_PS_UART is not set
 # CONFIG_TTY_PRINTK is not set
 # CONFIG_HVC_DCC is not set
@@ -1000,8 +866,8 @@ CONFIG_SERIAL_CORE_CONSOLE=y
 # CONFIG_RAMOOPS is not set
 CONFIG_I2C=y
 CONFIG_I2C_BOARDINFO=y
-# CONFIG_I2C_COMPAT is not set
-CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
 # CONFIG_I2C_MUX is not set
 CONFIG_I2C_HELPER_AUTO=y
 
@@ -1024,10 +890,8 @@ CONFIG_I2C_PNX=y
 #
 # External I2C/SMBus adapter drivers
 #
-# CONFIG_I2C_DIOLAN_U2C is not set
 # CONFIG_I2C_PARPORT_LIGHT is not set
 # CONFIG_I2C_TAOS_EVM is not set
-# CONFIG_I2C_TINY_USB is not set
 
 #
 # Other I2C/SMBus bus drivers
@@ -1036,27 +900,8 @@ CONFIG_I2C_PNX=y
 # CONFIG_I2C_DEBUG_CORE is not set
 # CONFIG_I2C_DEBUG_ALGO is not set
 # CONFIG_I2C_DEBUG_BUS is not set
-CONFIG_SPI=y
-# CONFIG_SPI_DEBUG is not set
-CONFIG_SPI_MASTER=y
-
-#
-# SPI Master Controller Drivers
-#
-# CONFIG_SPI_ALTERA is not set
-# CONFIG_SPI_BITBANG is not set
-# CONFIG_SPI_GPIO is not set
-# CONFIG_SPI_OC_TINY is not set
-# CONFIG_SPI_PXA2XX_PCI is not set
-# CONFIG_SPI_XILINX is not set
-CONFIG_SPI_LPC313X=y
-# CONFIG_SPI_DESIGNWARE is not set
-
-#
-# SPI Protocol Masters
-#
-CONFIG_SPI_SPIDEV=y
-# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI is not set
+# CONFIG_HSI is not set
 
 #
 # PPS support
@@ -1100,10 +945,7 @@ CONFIG_GPIO_SYSFS=y
 #
 # SPI GPIO expanders:
 #
-# CONFIG_GPIO_MAX7301 is not set
 # CONFIG_GPIO_MCP23S08 is not set
-# CONFIG_GPIO_MC33880 is not set
-# CONFIG_GPIO_74X164 is not set
 
 #
 # AC97 GPIO expanders:
@@ -1127,11 +969,6 @@ CONFIG_WATCHDOG=y
 # CONFIG_DW_WATCHDOG is not set
 # CONFIG_MAX63XX_WATCHDOG is not set
 CONFIG_LPC31XX_WATCHDOG=y
-
-#
-# USB-based Watchdog Cards
-#
-# CONFIG_USBPCWATCHDOG is not set
 CONFIG_SSB_POSSIBLE=y
 
 #
@@ -1158,11 +995,12 @@ CONFIG_BCMA_POSSIBLE=y
 # CONFIG_TPS6105X is not set
 # CONFIG_TPS65010 is not set
 # CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65217 is not set
 # CONFIG_MFD_TPS6586X is not set
 # CONFIG_MFD_TPS65910 is not set
 # CONFIG_MFD_TPS65912_I2C is not set
-# CONFIG_MFD_TPS65912_SPI is not set
 # CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
 # CONFIG_MFD_STMPE is not set
 # CONFIG_MFD_TC3589X is not set
 # CONFIG_MFD_TMIO is not set
@@ -1170,7 +1008,6 @@ CONFIG_BCMA_POSSIBLE=y
 # CONFIG_MFD_TC6387XB is not set
 # CONFIG_MFD_TC6393XB is not set
 # CONFIG_PMIC_DA903X is not set
-# CONFIG_MFD_DA9052_SPI is not set
 # CONFIG_MFD_DA9052_I2C is not set
 # CONFIG_PMIC_ADP5520 is not set
 # CONFIG_MFD_MAX8925 is not set
@@ -1179,15 +1016,14 @@ CONFIG_BCMA_POSSIBLE=y
 # CONFIG_MFD_S5M_CORE is not set
 # CONFIG_MFD_WM8400 is not set
 # CONFIG_MFD_WM831X_I2C is not set
-# CONFIG_MFD_WM831X_SPI is not set
 # CONFIG_MFD_WM8350_I2C is not set
 # CONFIG_MFD_WM8994 is not set
 # CONFIG_MFD_PCF50633 is not set
-# CONFIG_MFD_MC13XXX is not set
 # CONFIG_ABX500_CORE is not set
-# CONFIG_EZX_PCAP is not set
 # CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_TPS65090 is not set
 # CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_RC5T583 is not set
 # CONFIG_REGULATOR is not set
 # CONFIG_MEDIA_SUPPORT is not set
 
@@ -1222,12 +1058,11 @@ CONFIG_FB_DEFERRED_IO=y
 # Frame buffer hardware drivers
 #
 # CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_SMSCUFX is not set
-# CONFIG_FB_UDL is not set
 # CONFIG_FB_VIRTUAL is not set
 # CONFIG_FB_METRONOME is not set
 # CONFIG_FB_BROADSHEET is not set
 CONFIG_FB_SSD1289=y
+# CONFIG_EXYNOS_VIDEO is not set
 # CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 # CONFIG_LOGO is not set
 CONFIG_SOUND=y
@@ -1240,7 +1075,7 @@ CONFIG_SND_JACK=y
 # CONFIG_SND_MIXER_OSS is not set
 # CONFIG_SND_PCM_OSS is not set
 # CONFIG_SND_DYNAMIC_MINORS is not set
-# CONFIG_SND_SUPPORT_OLD_API is not set
+CONFIG_SND_SUPPORT_OLD_API=y
 CONFIG_SND_VERBOSE_PROCFS=y
 # CONFIG_SND_VERBOSE_PRINTK is not set
 # CONFIG_SND_DEBUG is not set
@@ -1251,11 +1086,9 @@ CONFIG_SND_VERBOSE_PROCFS=y
 # CONFIG_SND_EMU10K1_SEQ is not set
 # CONFIG_SND_DRIVERS is not set
 # CONFIG_SND_ARM is not set
-# CONFIG_SND_SPI is not set
-# CONFIG_SND_USB is not set
 CONFIG_SND_SOC=y
-CONFIG_SND_LPC313X_SOC=y
-CONFIG_SND_LPC313X_SOC_I2S=y
+CONFIG_SND_LPC31XX_SOC=y
+CONFIG_SND_LPC31XX_SOC_I2S=y
 CONFIG_SND_EA3131_SOC_I2S_UDA1380=y
 CONFIG_SND_USE_EA3131=y
 CONFIG_SND_I2C1_CHANNEL_UDA1380=y
@@ -1277,119 +1110,10 @@ CONFIG_SND_SOC_I2C_AND_SPI=y
 CONFIG_SND_SOC_UDA1380=y
 # CONFIG_SOUND_PRIME is not set
 # CONFIG_HID_SUPPORT is not set
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_COMMON=y
-CONFIG_USB_ARCH_HAS_HCD=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 CONFIG_USB_ARCH_HAS_EHCI=y
 # CONFIG_USB_ARCH_HAS_XHCI is not set
-CONFIG_USB=y
-CONFIG_USB_DEBUG=y
-CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
-
-#
-# Miscellaneous USB options
-#
-# CONFIG_USB_DEVICEFS is not set
-CONFIG_USB_DEVICE_CLASS=y
-# CONFIG_USB_DYNAMIC_MINORS is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-CONFIG_USB_MON=y
-# CONFIG_USB_WUSB_CBAF is not set
-
-#
-# USB Host Controller Drivers
-#
-# CONFIG_USB_C67X00_HCD is not set
-CONFIG_USB_EHCI_HCD=y
-# CONFIG_USB_EHCI_EHSET is not set
-CONFIG_USB_EHCI_ROOT_HUB_TT=y
-CONFIG_USB_EHCI_TT_NEWSCHED=y
-# CONFIG_USB_EHCI_MV is not set
-# CONFIG_USB_OXU210HP_HCD is not set
-CONFIG_USB_EHCI_LPC=y
-# CONFIG_USB_ISP116X_HCD is not set
-# CONFIG_USB_ISP1760_HCD is not set
-# CONFIG_USB_ISP1362_HCD is not set
-# CONFIG_USB_SL811_HCD is not set
-# CONFIG_USB_R8A66597_HCD is not set
-
-#
-# USB Device Class drivers
-#
-# CONFIG_USB_ACM is not set
-# CONFIG_USB_PRINTER is not set
-# CONFIG_USB_WDM is not set
-# CONFIG_USB_TMC is not set
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
-#
-
-#
-# also be needed; see USB_STORAGE Help for more info
-#
-CONFIG_USB_STORAGE=y
-CONFIG_USB_STORAGE_DEBUG=y
-# CONFIG_USB_STORAGE_REALTEK is not set
-# CONFIG_USB_STORAGE_DATAFAB is not set
-# CONFIG_USB_STORAGE_FREECOM is not set
-# CONFIG_USB_STORAGE_ISD200 is not set
-# CONFIG_USB_STORAGE_USBAT is not set
-# CONFIG_USB_STORAGE_SDDR09 is not set
-# CONFIG_USB_STORAGE_SDDR55 is not set
-# CONFIG_USB_STORAGE_JUMPSHOT is not set
-# CONFIG_USB_STORAGE_ALAUDA is not set
-# CONFIG_USB_STORAGE_ONETOUCH is not set
-# CONFIG_USB_STORAGE_KARMA is not set
-# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
-# CONFIG_USB_STORAGE_ENE_UB6250 is not set
-# CONFIG_USB_UAS is not set
-# CONFIG_USB_LIBUSUAL is not set
-
-#
-# USB Imaging devices
-#
-# CONFIG_USB_MDC800 is not set
-# CONFIG_USB_MICROTEK is not set
-
-#
-# USB port drivers
-#
-# CONFIG_USB_SERIAL is not set
-
-#
-# USB Miscellaneous drivers
-#
-# CONFIG_USB_EMI62 is not set
-# CONFIG_USB_EMI26 is not set
-# CONFIG_USB_ADUTUX is not set
-# CONFIG_USB_SEVSEG is not set
-# CONFIG_USB_RIO500 is not set
-# CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_LCD is not set
-# CONFIG_USB_LED is not set
-# CONFIG_USB_CYPRESS_CY7C63 is not set
-# CONFIG_USB_CYTHERM is not set
-# CONFIG_USB_IDMOUSE is not set
-# CONFIG_USB_FTDI_ELAN is not set
-# CONFIG_USB_APPLEDISPLAY is not set
-# CONFIG_USB_SISUSBVGA is not set
-# CONFIG_USB_LD is not set
-# CONFIG_USB_TRANCEVIBRATOR is not set
-# CONFIG_USB_IOWARRIOR is not set
-# CONFIG_USB_TEST is not set
-# CONFIG_USB_ISIGHTFW is not set
-# CONFIG_USB_YUREX is not set
-# CONFIG_USB_GADGET is not set
-
-#
-# OTG and related infrastructure
-#
-# CONFIG_USB_GPIO_VBUS is not set
-# CONFIG_USB_ULPI is not set
-# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_SUPPORT is not set
 CONFIG_MMC=y
 # CONFIG_MMC_DEBUG is not set
 # CONFIG_MMC_UNSAFE_RESUME is not set
@@ -1411,36 +1135,9 @@ CONFIG_MMC_LPC31XX=y
 # CONFIG_MMC_SDHCI is not set
 # CONFIG_MMC_SDHCI_PXAV3 is not set
 # CONFIG_MMC_SDHCI_PXAV2 is not set
-# CONFIG_MMC_SPI is not set
 # CONFIG_MMC_DW is not set
-# CONFIG_MMC_VUB300 is not set
-# CONFIG_MMC_USHC is not set
 # CONFIG_MEMSTICK is not set
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-
-#
-# LED drivers
-#
-# CONFIG_LEDS_LM3530 is not set
-CONFIG_LEDS_PCA9532=y
-CONFIG_LEDS_PCA9532_GPIO=y
-# CONFIG_LEDS_GPIO is not set
-# CONFIG_LEDS_LP3944 is not set
-# CONFIG_LEDS_LP5521 is not set
-# CONFIG_LEDS_LP5523 is not set
-# CONFIG_LEDS_PCA955X is not set
-# CONFIG_LEDS_DAC124S085 is not set
-# CONFIG_LEDS_BD2802 is not set
-# CONFIG_LEDS_LT3593 is not set
-# CONFIG_LEDS_RENESAS_TPU is not set
-# CONFIG_LEDS_TCA6507 is not set
-# CONFIG_LEDS_OT200 is not set
-# CONFIG_LEDS_TRIGGERS is not set
-
-#
-# LED Triggers
-#
+# CONFIG_NEW_LEDS is not set
 # CONFIG_ACCESSIBILITY is not set
 CONFIG_RTC_LIB=y
 # CONFIG_RTC_CLASS is not set
@@ -1464,6 +1161,14 @@ CONFIG_CLKDEV_LOOKUP=y
 # Hardware Spinlock drivers
 #
 CONFIG_IOMMU_SUPPORT=y
+
+#
+# Remoteproc drivers (EXPERIMENTAL)
+#
+
+#
+# Rpmsg drivers (EXPERIMENTAL)
+#
 # CONFIG_VIRT_DRIVERS is not set
 # CONFIG_PM_DEVFREQ is not set
 
@@ -1540,17 +1245,6 @@ CONFIG_MISC_FILESYSTEMS=y
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
-CONFIG_JFFS2_FS=y
-CONFIG_JFFS2_FS_DEBUG=0
-CONFIG_JFFS2_FS_WRITEBUFFER=y
-# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
-# CONFIG_JFFS2_SUMMARY is not set
-# CONFIG_JFFS2_FS_XATTR is not set
-# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
-CONFIG_JFFS2_ZLIB=y
-# CONFIG_JFFS2_LZO is not set
-CONFIG_JFFS2_RTIME=y
-# CONFIG_JFFS2_RUBIN is not set
 # CONFIG_LOGFS is not set
 CONFIG_CRAMFS=y
 # CONFIG_SQUASHFS is not set
@@ -1559,10 +1253,9 @@ CONFIG_CRAMFS=y
 # CONFIG_OMFS_FS is not set
 # CONFIG_HPFS_FS is not set
 # CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
 CONFIG_ROMFS_FS=y
 CONFIG_ROMFS_BACKED_BY_BLOCK=y
-# CONFIG_ROMFS_BACKED_BY_MTD is not set
-# CONFIG_ROMFS_BACKED_BY_BOTH is not set
 CONFIG_ROMFS_ON_BLOCK=y
 # CONFIG_PSTORE is not set
 # CONFIG_SYSV_FS is not set
@@ -1576,6 +1269,7 @@ CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_DEBUG is not set
 # CONFIG_CEPH_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
@@ -1674,13 +1368,13 @@ CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_CREDENTIALS is not set
 # CONFIG_BOOT_PRINTK_DELAY is not set
 # CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_TRACE is not set
 # CONFIG_BACKTRACE_SELF_TEST is not set
 # CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
 # CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
 # CONFIG_LKDTM is not set
 # CONFIG_FAULT_INJECTION is not set
 # CONFIG_LATENCYTOP is not set
-# CONFIG_SYSCTL_SYSCALL_CHECK is not set
 # CONFIG_DEBUG_PAGEALLOC is not set
 CONFIG_HAVE_FUNCTION_TRACER=y
 CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
@@ -1812,16 +1506,21 @@ CONFIG_CRYPTO_HW=y
 #
 CONFIG_BITREVERSE=y
 CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
 CONFIG_CRC_CCITT=y
 # CONFIG_CRC16 is not set
 # CONFIG_CRC_T10DIF is not set
 CONFIG_CRC_ITU_T=y
 CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
 # CONFIG_CRC7 is not set
 # CONFIG_LIBCRC32C is not set
 # CONFIG_CRC8 is not set
 CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
 CONFIG_LZO_COMPRESS=y
 CONFIG_LZO_DECOMPRESS=y
 # CONFIG_XZ_DEC is not set
diff --git a/sound/soc/codecs/lpc315x_codec.c b/sound/soc/codecs/lpc315x_codec.c
index a998f50..991d7ba 100644
--- a/sound/soc/codecs/lpc315x_codec.c
+++ b/sound/soc/codecs/lpc315x_codec.c
@@ -52,7 +52,7 @@ static struct snd_soc_codec *lpc315x_codec;
  * */
 struct lpc315x_codec_priv {
 	struct snd_soc_codec	codec;
-	u32			lpc315x_reg_cache[LPC315X_CODEC_NUM_REGS];
+	uint32_t			lpc315x_reg_cache[LPC315X_CODEC_NUM_REGS];
 	struct work_struct	work;
 };
 static struct lpc315x_codec_priv *lpc315x_codec_prv;
@@ -60,7 +60,7 @@ static struct lpc315x_codec_priv *lpc315x_codec_prv;
 /*
  * LPC315X CODEC register cache
  */
-static const u32 lpc315x_codec_regs[LPC315X_CODEC_NUM_REGS] = {
+static const uint32_t lpc315x_codec_regs[LPC315X_CODEC_NUM_REGS] = {
 	0x00000000, /* PGA */
 	0x0002FFFC, /* AIN_1 */
 	0x8000F5FB, /* AOUT */
@@ -77,10 +77,10 @@ static unsigned long lpc315x_codec_cache_dirty;
 /*
  * Read LPC315X CODEC register cache
  */
-static inline u32 lpc315x_codec_read_reg_cache(struct snd_soc_codec *codec,
+static inline uint32_t lpc315x_codec_read_reg_cache(struct snd_soc_codec *codec,
 		unsigned int reg)
 {
-	u32 *cache = codec->reg_cache;
+	uint32_t *cache = codec->reg_cache;
 
 	/* Check if register offset is valid */
 	if (reg > LPC315X_CODEC_DEC_STA) {
@@ -95,9 +95,9 @@ static inline u32 lpc315x_codec_read_reg_cache(struct snd_soc_codec *codec,
  * Write LPC315X CODEC register cache
  */
 static inline void lpc315x_codec_write_reg_cache(struct snd_soc_codec
-		*codec, unsigned int reg, u32 value)
+		*codec, unsigned int reg, uint32_t value)
 {
-	u32 *cache = codec->reg_cache;
+	uint32_t *cache = codec->reg_cache;
 
 	/* Check if register offset is valid */
 	if (reg > LPC315X_CODEC_DEC_STA)
@@ -118,11 +118,11 @@ static inline void lpc315x_codec_write_reg_cache(struct snd_soc_codec
  * Write to LPC315X CODEC registers using I2C functions
  */
 static int lpc315x_codec_register_rw(struct snd_soc_codec *codec,
-		unsigned int reg, u32 *value, int read)
+		unsigned int reg, uint32_t *value, int read)
 {
 	int ret = 0;
 	u8 off[2], data[6];
-	u32 val = 0;
+	uint32_t val = 0;
 
 	if(read) {
 		/*
@@ -215,7 +215,7 @@ static int lpc315x_codec_write(struct snd_soc_codec *codec,
 static void lpc315x_codec_work(struct work_struct *work)
 {
 	u16 bit, reg;
-	u32 data;
+	uint32_t data;
 
 	for_each_bit(bit, &lpc315x_codec_cache_dirty,
 			(LPC315X_CODEC_DEC_STA - LPC315X_CODEC_CODEC_START)) {
@@ -350,7 +350,7 @@ static int snd_soc_lpc315x_coa_put_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	u32 i, val, reg, avc_gain;
+	uint32_t i, val, reg, avc_gain;
 
 	val = (ucontrol->value.integer.value[0] & 0xF);
 	/* conversion to AVC Coarse volume bit pattern
@@ -397,7 +397,7 @@ static int snd_soc_lpc315x_coa_get_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	u32 reg, cnt;
+	uint32_t reg, cnt;
 
 	/* Get value from register */
 	reg = lpc315x_codec_read_reg_cache(codec, LPC315X_CODEC_AOUT);
@@ -443,7 +443,7 @@ static int snd_soc_lpc315x_fin_put_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	u32 val, reg, avc_gain;
+	uint32_t val, reg, avc_gain;
 
 	val = (ucontrol->value.integer.value[0] & 0x7);
 	/* conversion to AVC Fine volume bit pattern
@@ -473,7 +473,7 @@ static int snd_soc_lpc315x_fin_get_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	u32 reg, cnt;
+	uint32_t reg, cnt;
 
 	/* Get value from register */
 	reg = lpc315x_codec_read_reg_cache(codec, LPC315X_CODEC_AOUT);
@@ -705,7 +705,7 @@ static int lpc315x_codec_set_dai_fmt_both(struct snd_soc_dai *codec_dai,
 		unsigned int fmt)
 {
 	struct snd_soc_codec *codec = codec_dai->codec;
-	u32 i2s_mux_reg;
+	uint32_t i2s_mux_reg;
 
 	/* Set up DAI based upon fmt */
 	i2s_mux_reg = lpc315x_codec_read_reg_cache(codec,
@@ -741,7 +741,7 @@ static int lpc315x_codec_set_dai_fmt_playback(struct snd_soc_dai *codec_dai,
 		unsigned int fmt)
 {
 	struct snd_soc_codec *codec = codec_dai->codec;
-	u32 i2s_mux_reg;
+	uint32_t i2s_mux_reg;
 
 	/* Set up DAI based upon fmt */
 	i2s_mux_reg = lpc315x_codec_read_reg_cache(codec,
@@ -773,7 +773,7 @@ static int lpc315x_codec_set_dai_fmt_capture(struct snd_soc_dai *codec_dai,
 		unsigned int fmt)
 {
 	struct snd_soc_codec *codec = codec_dai->codec;
-	u32 i2s_mux_reg;
+	uint32_t i2s_mux_reg;
 
 	/* set up DAI based upon fmt */
 	i2s_mux_reg = lpc315x_codec_read_reg_cache(codec,
@@ -808,7 +808,7 @@ static int lpc315x_codec_trigger(struct snd_pcm_substream *substream,
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_codec *codec = socdev->card->codec;
 	struct lpc315x_codec_priv *prv = codec->private_data;
-	u32 int0_reg = lpc315x_codec_read_reg_cache(codec,
+	uint32_t int0_reg = lpc315x_codec_read_reg_cache(codec,
 			LPC315X_CODEC_INT0);
 
 	switch (cmd) {
@@ -839,7 +839,7 @@ static int lpc315x_codec_pcm_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_codec *codec = socdev->card->codec;
 	unsigned int cgu_reg = 0;
-	u32 aout_reg, ain_reg, int0_reg, dec_reg, i2srx1_reg, int1_reg;
+	uint32_t aout_reg, ain_reg, int0_reg, dec_reg, i2srx1_reg, int1_reg;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		/* Playback power up sequence */
@@ -1000,7 +1000,7 @@ static void lpc315x_codec_pcm_shutdown(struct snd_pcm_substream *substream,
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_codec *codec = socdev->card->codec;
 	unsigned int cgu_reg = 0;
-	u32 aout_reg, dec_reg, int0_reg, ain_reg, int1_reg, i2srx1_reg;
+	uint32_t aout_reg, dec_reg, int0_reg, ain_reg, int1_reg, i2srx1_reg;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		/* Playback power down sequence */
@@ -1141,7 +1141,7 @@ static int lpc315x_codec_mute(struct snd_soc_dai *codec_dai,
 		int mute)
 {
 	struct snd_soc_codec *codec = codec_dai->codec;
-	u32 int1_reg = lpc315x_codec_read_reg_cache(codec, LPC315X_CODEC_INT1)
+	uint32_t int1_reg = lpc315x_codec_read_reg_cache(codec, LPC315X_CODEC_INT1)
 		& ~LPC315X_CODEC_INT1_MAS_MUTE;
 
 	/* Mute */
@@ -1162,7 +1162,7 @@ static int lpc315x_codec_mute(struct snd_soc_dai *codec_dai,
 static int lpc315x_codec_set_bias_level(struct snd_soc_codec *codec,
 	enum snd_soc_bias_level level)
 {
-	u32 ain1_reg = lpc315x_codec_read_reg_cache(codec,
+	uint32_t ain1_reg = lpc315x_codec_read_reg_cache(codec,
 			LPC315X_CODEC_AIN1);
 
 	switch (level) {
@@ -1292,7 +1292,7 @@ static int lpc315x_codec_resume(struct platform_device *pdev)
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
 	struct snd_soc_codec *codec = socdev->card->codec;
 	u8 data[6];
-	u32 i, *cache = codec->reg_cache;
+	uint32_t i, *cache = codec->reg_cache;
 
 	/* Sync reg_cache with the hardware */
 	for (i = 0; i < ARRAY_SIZE(lpc315x_codec_regs); i++) {
@@ -1320,7 +1320,7 @@ static int lpc315x_codec_probe(struct platform_device *pdev)
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
 	struct snd_soc_codec *codec;
 	int ret = 0;
-	u32 cgu_reg = 0;
+	uint32_t cgu_reg = 0;
 
 	/* Check if LPC315X CODECX registered */
 	if (lpc315x_codec == NULL) {
diff --git a/sound/soc/lpc31xx/lpc31xx-i2s-clocking.c b/sound/soc/lpc31xx/lpc31xx-i2s-clocking.c
index 5251ec3..f8d9f35 100644
--- a/sound/soc/lpc31xx/lpc31xx-i2s-clocking.c
+++ b/sound/soc/lpc31xx/lpc31xx-i2s-clocking.c
@@ -53,8 +53,8 @@
 
 
 struct i2s_clk_setup {
-	u32 target_codec_rate;
-	u32 real_fs_codec_rate;
+	uint32_t target_codec_rate;
+	uint32_t real_fs_codec_rate;
 };
 static struct i2s_clk_setup i2s_clk_state;
 
@@ -187,14 +187,14 @@ static CGU_HPLL_SETUP_T *ppll_list[] = {
 
 #if defined(CONFIG_SND_LPC315X_SOC)
 /* For LPC315X Analog CODEC 128FS clock has to be used */
-static const u32 fsdiv =
+static const uint32_t fsdiv =
 #if defined (CONFIG_SND_CODEC_FS128)
 	128;
 #endif
 #endif
 
 #if defined(CONFIG_SND_LPC31XX_SOC)
-static const u32 fsdiv =
+static const uint32_t fsdiv =
 #if defined (CONFIG_SND_CODEC_FS256)
 	256;
 #elif defined (CONFIG_SND_CODEC_FS384)
@@ -208,10 +208,10 @@ static const u32 fsdiv =
 #endif
 #endif
 
-static u32 lpc31xx_set_best_rate(u32 freq)
+static uint32_t lpc31xx_set_best_rate(uint32_t freq)
 {
 	CGU_FDIV_SETUP_T clk_div;
-	u32 diff;
+	uint32_t diff;
 	int i = 0;
 
 	clk_div.stretch = 1;
@@ -252,7 +252,7 @@ static u32 lpc31xx_set_best_rate(u32 freq)
  * Sets up the audio PLL to generate a frequency as close as possible to
  * the target clkrate frequency
  */
-static u32 lpc31xx_set_codec_freq(u32 freq)
+static uint32_t lpc31xx_set_codec_freq(uint32_t freq)
 {
 	if (freq == 0)
 	{
@@ -301,7 +301,7 @@ static void lpc31xx_ch_clk_disen(enum i2s_supp_clks chclk, int en)
  * Sets up the channel bit clock to generate a rate as close as possible
  * to the target clkrate frequency
  */
-static u32 lpc31xx_set_ch_freq(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq)
+static uint32_t lpc31xx_set_ch_freq(enum i2s_supp_clks chclk, uint32_t ws_freq, uint32_t bit_freq)
 {
 	CGU_FDIV_SETUP_T ch_div;
 
@@ -345,9 +345,9 @@ static u32 lpc31xx_set_ch_freq(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_fr
  * the actual programmed clock rate. The programmed rate is generated on
  * the FS256 pin has a rate of (256 * clkrate).
  */
-u32 lpc31xx_main_clk_rate(u32 freq)
+uint32_t lpc31xx_main_clk_rate(uint32_t freq)
 {
-	u32 ret = 0;
+	uint32_t ret = 0;
 	/* Compute and set proper divider */
 	ret = lpc31xx_set_codec_freq(freq);
 #if defined (CONFIG_SND_DEBUG_VERBOSE)
@@ -363,7 +363,7 @@ u32 lpc31xx_main_clk_rate(u32 freq)
  * to the channel's WS and BCLK signals. Returns the actual programmed
  * WS clock rate.
  */
-u32 lpc31xx_chan_clk_enable(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq)
+uint32_t lpc31xx_chan_clk_enable(enum i2s_supp_clks chclk, uint32_t ws_freq, uint32_t bit_freq)
 {
 	/* Compute and set proper divider */
 	return lpc31xx_set_ch_freq(chclk, ws_freq, bit_freq);
diff --git a/sound/soc/lpc31xx/lpc31xx-i2s-clocking.h b/sound/soc/lpc31xx/lpc31xx-i2s-clocking.h
index 9241a2a..368e644 100644
--- a/sound/soc/lpc31xx/lpc31xx-i2s-clocking.h
+++ b/sound/soc/lpc31xx/lpc31xx-i2s-clocking.h
@@ -54,13 +54,13 @@ enum i2s_supp_clks {CLK_RX_0, CLK_TX_0, CLK_RX_1, CLK_TX_1};
  * the actual programmed clock rate. The programmed rate is generated on
  * the FS256 pin has a rate of (256 * clkrate).
  */
-u32 lpc31xx_main_clk_rate(u32 clkrate);
+uint32_t lpc31xx_main_clk_rate(uint32_t clkrate);
 
 /*
  * Set a specific channel's bit clock and word select rates. his applies
  * to the channel's WS and BCLK signals. Returns the actual programmed
  * WS clock rate.
  */
-u32 lpc31xx_chan_clk_enable(enum i2s_supp_clks chclk, u32 ws_freq, u32 bit_freq);
+uint32_t lpc31xx_chan_clk_enable(enum i2s_supp_clks chclk, uint32_t ws_freq, uint32_t bit_freq);
 
 #endif /* __LPC31XX_I2S_CLOCKING */
diff --git a/sound/soc/lpc31xx/lpc31xx-i2s.c b/sound/soc/lpc31xx/lpc31xx-i2s.c
index 00e8b4d..4bdb17c 100644
--- a/sound/soc/lpc31xx/lpc31xx-i2s.c
+++ b/sound/soc/lpc31xx/lpc31xx-i2s.c
@@ -60,7 +60,7 @@ struct lpc31xx_i2s_ch_info {
 	char *name;                 /* Name of this channel */
 	unsigned short ch_on;       /* Flag used to indicate if clocks are on */
 	unsigned short daifmt;
-	u32 ws_freq;
+	uint32_t ws_freq;
 	int i2s_ch;
 	enum i2s_supp_clks chclk;
 };
@@ -70,7 +70,7 @@ struct lpc31xx_i2s_info {
 	spinlock_t lock;
 	unsigned short initialized;
 	struct lpc31xx_i2s_ch_info ch_info[2];
-	u32 freq;
+	uint32_t freq;
 };
 
 /* Common I2S structure data */
@@ -265,7 +265,7 @@ static int lpc31xx_i2s_hw_params(struct snd_pcm_substream *substream,
 {
 	struct lpc31xx_i2s_res_info *info = snd_soc_dai_get_drvdata(dai);
 	int dir = lpc31xx_get_ch_dir(substream);
-	u32 tmp;
+	uint32_t tmp;
 
 	/* Setup the I2S data format */
 	tmp = 0;
diff --git a/sound/soc/lpc31xx/lpc31xx-pcm.c b/sound/soc/lpc31xx/lpc31xx-pcm.c
index fff64dc..fa2655e 100644
--- a/sound/soc/lpc31xx/lpc31xx-pcm.c
+++ b/sound/soc/lpc31xx/lpc31xx-pcm.c
@@ -93,7 +93,7 @@ struct lpc31xx_i2sdma_data {
 	/* DMA configuration and support */
 	int dmach;
 	volatile dma_addr_t dma_cur;
-	u32 dma_cfg_base;
+	uint32_t dma_cfg_base;
 #if defined (CONFIG_SND_USE_DMA_LINKLIST)
 	dma_sg_ll_t *p_sg_cpu;
 	dma_sg_ll_t *p_sg_dma;
@@ -289,7 +289,7 @@ static int lpc31xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 
 #if defined (CONFIG_SND_USE_DMA_LINKLIST)
 	int i, tch;
-	u32 addr;
+	uint32_t addr;
 	dma_sg_ll_t *p_sg_cpuw, *p_sg_dmaw;
 	unsigned long timeout;
 
@@ -307,11 +307,11 @@ static int lpc31xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		p_sg_dmaw = prtd->p_sg_dma;
 
 		/* Build a linked list that wraps around */
-		addr = (u32) prtd->dma_buffer;
+		addr = (uint32_t) prtd->dma_buffer;
 		for (i = 0; i < prtd->num_periods; i++) {
 			p_sg_cpuw->setup.trans_length = (prtd->period_size / 4) - 1;
 			p_sg_cpuw->setup.cfg = prtd->dma_cfg_base;
-			p_sg_cpuw->next_entry = (u32) (p_sg_dmaw + 1);
+			p_sg_cpuw->next_entry = (uint32_t) (p_sg_dmaw + 1);
 
 			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 				p_sg_cpuw->setup.src_address = addr;
@@ -324,7 +324,7 @@ static int lpc31xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 
 			/* Wrap end of list back to start? */
 			if (i == (prtd->num_periods - 1))
-				p_sg_cpuw->next_entry = (u32) prtd->p_sg_dma;
+				p_sg_cpuw->next_entry = (uint32_t) prtd->p_sg_dma;
 
 			p_sg_cpuw++;
 			p_sg_dmaw++;
@@ -339,7 +339,7 @@ static int lpc31xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		add_timer(&prtd->timer[tch]);
 
 		/* Program DMA channel and start it */
-		dma_prog_sg_channel(prtd->dmach, (u32) prtd->p_sg_dma);
+		dma_prog_sg_channel(prtd->dmach, (uint32_t) prtd->p_sg_dma);
 		dma_set_irq_mask(prtd->dmach, 1, 1);
 #else
 	dma_setup_t dmasetup;
@@ -349,11 +349,11 @@ static int lpc31xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		prtd->dma_cur = prtd->dma_buffer;
 
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			dmasetup.src_address = (u32) prtd->dma_buffer;
+			dmasetup.src_address = (uint32_t) prtd->dma_buffer;
 			dmasetup.dest_address = TX_FIFO_ADDR;
 		}
 		else {
-			dmasetup.dest_address = (u32) prtd->dma_buffer;
+			dmasetup.dest_address = (uint32_t) prtd->dma_buffer;
 			dmasetup.src_address = RX_FIFO_ADDR;
 		}
