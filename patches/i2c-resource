Bottom: 82d6dfaf114e6b7489b8e929cdf5b671646c329f
Top:    2a6d77e64e1b7937debfdb57e10a0981f644bc1a
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-03-24 15:38:34 -0400

Fix pnx driver to take standard driver resources


---

diff --git a/arch/arm/boot/dts/ea3131.dts b/arch/arm/boot/dts/ea3131.dts
index 020c063..f66d179 100644
--- a/arch/arm/boot/dts/ea3131.dts
+++ b/arch/arm/boot/dts/ea3131.dts
@@ -16,35 +16,95 @@
 		bootargs = "console=ttyS0,115200n8 root=/dev/mmcblk0p3 init=/etc/preinit rw rootwait loglevel=7";
 	};
 
-	ssd1289@20000000 {
-		compatible = "ssd,ssd1289";
-		reg = <0x20000000 0x10000 0x20010000 0x10000>;
-	};
-	dm9000@20000000 {
-		compatible = "davicom,dm9000";
-		reg = <0x20020000 0x100 0x20030000 0x100>;
-		interrupts = <37>;
-	};
-	memory@30000000 {
-		reg = <0x30000000 0x4000000>;
-	};
 	ahb {
 		apb@13008000 {
 			i2c@1300a000 {
-				rtc@51 {
-					compatible = "nxp,pcf8563";
-					reg = <0x51>;
+				slave-address = <0x6E>;
+				pca9532: leds@60 {
+					#gpio-cells = <2>;
+					compatible = "nxp,pca9532";
+					reg = <0x60>;
+					gpio-controller;
+				};
+				uda1380: codec@18 {
+					compatible = "nxp,uda1380";
+					reg = <0x18>;
+				};
+				gpio-leds {
+					compatible = "gpio-leds";
+					green {
+						label = "Green";
+						gpios = <&pca9532 0 1>;
+					};
+					yellow {
+						label = "Yellow";
+						gpios = <&pca9532 1 1>;
+					};
 				};
-				eeprom@52 {
-					compatible = "catalyst,24c32";
-					reg = <0x52>;
-					pagesize = <32>;
+
+			};
+		};
+		apb@15000000 {
+			spi@15002000 {
+				at45db321d@0 {
+					compatible = "atmel,at45db321d", "atmel,at45", "atmel,dataflash";
+					reg = <0>;
+				};
+				ads7846@1 {
+					compatible = "ti,ads7846";
+					reg = <1>;
 				};
 			};
 		};
+		apb@16000000 {
+			i2s@16000000 {
+				codec-handle = <&uda1380>;
+			};
+		};
+		apb@17000000 {
+			nand@17000800 {
+				bank-width = <2>;
+				device-width = <1>;				
+			};
+		};
 		sdmmc@18000000 {
 			cd-gpio = <&gpio 0x87 0>;
 			power-gpio = <&gpio 0x45 0>;
 		};
+		usb@19000000 {
+			vbus-over =  <&gpio 0xFF 0>;
+		};
+		sram@20000000 {
+			STCONFIG = <0x81>;
+			STWTWEN  = <0>;
+			STWTOEN  = <0>;
+			STWTRD   = <31>;
+			STWTPG   = <0>;
+			STWTWR   = <3>;
+			STWTTURN = <0>;
+			ssd1289@20000000 {
+				compatible = "ssd,ssd1289";
+				reg = <0x20000000 0x10000 0x20010000 0x10000>;
+			};
+		};
+		sram@20020000 {
+			STCONFIG = <0x81>;
+			STWTWEN = <1>;
+			STWTOEN = <1>;
+			STWTRD = <4>;
+			STWTPG = <1>;
+			STWTWR = <1>;
+			STWTTURN = <2>;
+			/* enable oe toggle between consec reads */
+			WTD_DEL = <0x24>;
+			dm9000@20020000 {
+				compatible = "davicom,dm9000";
+				reg = <0x20020000 0x100 0x20030000 0x100>;
+				interrupts = <37>;
+			};
+		};
+		memory@30000000 {
+			reg = <0x30000000 0x4000000>;
+		};
 	};
 };
diff --git a/arch/arm/boot/dts/lpc3131.dtsi b/arch/arm/boot/dts/lpc3131.dtsi
index a04f2aa..c201101 100644
--- a/arch/arm/boot/dts/lpc3131.dtsi
+++ b/arch/arm/boot/dts/lpc3131.dtsi
@@ -16,6 +16,9 @@
 	cpus {
 		cpu@0 {
 			compatible = "arm,arm926ejs";
+			timebase-frequency = <0>;	// from bootloader
+			bus-frequency = <0>;		// from bootloader
+			clock-frequency = <0>;		// from bootloader
 		};
 	};
 
@@ -35,7 +38,7 @@
 		};
 
 		apb@13000000 {
-			compatible = "simple-bus";
+			compatible = "nxp,lpc31xx-apb";
 			#address-cells = <1>;
 			#size-cells = <1>;
 			ranges = <0x13000000 0x13000000 0x8000>;
@@ -73,7 +76,7 @@
 			};
 		};
 		apb@13008000 {
-			compatible = "simple-bus";
+			compatible = "nxp,lpc31xx-apb";
 			#address-cells = <1>;
 			#size-cells = <1>;
 			ranges = <0x13008000 0x13008000 0x4000>;
@@ -82,21 +85,25 @@
 				compatible = "nxp,lpc31xx-timer";
 				reg = <0x13008000 0x400>;
 				interrupts = <5>;
+				cell-index = <0>;
 			};
 			timer@13008400 {
 				compatible = "nxp,lpc31xx-timer";
 				reg = <0x13008400 0x400>;
 				interrupts = <6>;
+				cell-index = <1>;
 			};
 			timer@13008800 {
 				compatible = "nxp,lpc31xx-timer";
 				reg = <0x13008800 0x400>;
 				interrupts = <7>;
+				cell-index = <2>;
 			};
 			timer@13008c00 {
 				compatible = "nxp,lpc31xx-timer";
 				reg = <0x13008c00 0x400>;
 				interrupts = <8>;
+				cell-index = <3>;
 			};
 			pwm@13009000 {
 				compatible = "nxp,lpc31xx-pwm";
@@ -108,6 +115,7 @@
 				compatible = "nxp,lpc31xx-i2c", "nxp,pnx-i2c";
 				reg = <0x1300a000 0x400>;
 				interrupts = <11>;
+				cell-index = <0>;
 			};
 			i2c@1300a400 {
 				#address-cells = <1>;
@@ -115,10 +123,11 @@
 				compatible = "nxp,lpc31xx-i2c", "nxp,pnx-i2c";
 				reg = <0x1300a400 0x400>;
 				interrupts = <12>;
+				cell-index = <1>;
 			};
 		};
 		apb@15000000 {
-			compatible = "simple-bus";
+			compatible = "nxp,lpc31xx-apb";
 			#address-cells = <1>;
 			#size-cells = <1>;
 			ranges = <0x15000000 0x15000000 0x3000>;
@@ -137,15 +146,18 @@
 				compatible = "nxp,lpc31xx-uart";
 				reg = <0x15001000 0x1000>;
 				interrupts = <10>;
+				clock-frequency = <0>;		// from bootloader
 			};
 			spi@15002000 {
 				compatible = "nxp,lpc31xx-spi";
 				reg = <0x15002000 0x1000>;
-				interrupts = <18 19 20 21 22 23>;
+				interrupts = <19 20 21 22 23>;
+				#address-cells = <1>;
+				#size-cells = <0>;				
 			};
 		};
 		apb@16000000 {
-			compatible = "simple-bus";
+			compatible = "nxp,lpc31xx-apb";
 			#address-cells = <1>;
 			#size-cells = <1>;
 			ranges = <0x16000000 0x16000000 0x1000>;
@@ -157,7 +169,7 @@
 			};
 		};
 		apb@17000000 {
-			compatible = "simple-bus";
+			compatible = "nxp,lpc31xx-apb";
 			#address-cells = <1>;
 			#size-cells = <1>;
 			ranges = <0x17000000 0x17000000 0x1000>;
@@ -188,6 +200,20 @@
 			reg = <0x19000000 0x1000>;
 			interrupts = <27>;
 		};
+		sram@20000000 {
+			compatible = "nxp,lpc31xx-sram";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x20000000 0x20000000 0x20000>;
+		};
+		sram@20020000 {
+			compatible = "nxp,lpc31xx-sram";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x20020000 0x20020000 0x20000>;
+		};
+		memory@30000000 {
+		};
 		intc: intc@60000000 {
 			compatible = "nxp,lpc31xx-intc";
 			reg = <0x60000000 0x1000>;
diff --git a/arch/arm/mach-lpc31xx/board-ea313x.c b/arch/arm/mach-lpc31xx/board-ea313x.c
index 6673805..83226a9 100644
--- a/arch/arm/mach-lpc31xx/board-ea313x.c
+++ b/arch/arm/mach-lpc31xx/board-ea313x.c
@@ -50,6 +50,273 @@
 #include <mach/system.h>
 #include <mach/dt.h>
 
+#ifdef CONFIG_OF
+
+static void __init ea_add_device_ssd1289(void)
+{
+	MPMC_STCONFIG0 = 0x81;
+	MPMC_STWTWEN0  = 0;
+	MPMC_STWTOEN0  = 0;
+	MPMC_STWTRD0   = 31;
+	MPMC_STWTPG0   = 0;
+	MPMC_STWTWR0   = 3;
+	MPMC_STWTTURN0 = 0;
+}
+
+/*
+ * DM9000 ethernet device
+ */
+
+/* ARM MPMC contoller as part of low power design doesn't de-assert nCS and nOE for consecutive
+reads but just changes address. But DM9000 requires nCS and nOE change between address. So access
+other chip select area (nCS0) to force de-assertion of nCS1 and nOE1. Or else wait for long time
+such as 80 usecs.
+LPC313x has external logic outside of MPMC IP to toggle nOE to split consecutive reads.
+The latest Apex bootloader pacth makes use of this feture.
+For this to work SYS_MPMC_WTD_DEL0 & SYS_MPMC_WTD_DEL1 should be programmed with MPMC_STWTRD0
+& MPMC_STWTRD1 values. The logic only deactivates the nOE for one clock cycle which is
+11nsec but DM9000 needs 80nsec between nOEs. So lets add some dummy instructions such as
+reading a GPIO register to compensate for extra 70nsec.
+*/
+# define DM_IO_DELAY()	do { gpio_get_value(GPIO_MNAND_RYBN3);} while(0)
+
+static void dm9000_dumpblk(void __iomem *reg, int count)
+{
+	int i;
+	int tmp;
+
+	count = (count + 1) >> 1;
+	for (i = 0; i < count; i++) {
+		DM_IO_DELAY();
+		tmp = readw(reg);
+	}
+}
+
+static void dm9000_inblk(void __iomem *reg, void *data, int count)
+{
+	int i;
+	u16* pdata = (u16*)data;
+	count = (count + 1) >> 1;
+	for (i = 0; i < count; i++) {
+		DM_IO_DELAY();
+		*pdata++ = readw(reg);
+	}
+}
+
+static struct dm9000_plat_data dm9000_platdata = {
+	.flags		= DM9000_PLATF_16BITONLY | DM9000_PLATF_NO_EEPROM | DM9000_PLATF_SIMPLE_PHY,
+	.dumpblk = dm9000_dumpblk,
+	.inblk = dm9000_inblk,
+};
+
+static void __init ea_add_device_dm9000(void)
+{
+	/*
+	 * Configure Chip-Select 2 on SMC for the DM9000.
+	 * Note: These timings were calculated for MASTER_CLOCK = 90000000
+	 *  according to the DM9000 timings.
+	 */
+	MPMC_STCONFIG1 = 0x81;
+	MPMC_STWTWEN1 = 1;
+	MPMC_STWTOEN1 = 1;
+	MPMC_STWTRD1 = 4;
+	MPMC_STWTPG1 = 1;
+	MPMC_STWTWR1 = 1;
+	MPMC_STWTTURN1 = 2;
+	/* enable oe toggle between consec reads */
+	SYS_MPMC_WTD_DEL1 = 0x24;
+
+}
+
+
+
+/* spi_board_info.controller_data for SPI slave devices,
+ * copied to spi_device.platform_data ... mostly for dma tuning
+ */
+struct lpc313x_spi_chip {
+	u8 tx_threshold;
+	u8 rx_threshold;
+	u8 dma_burst_size;
+	u32 timeout;
+	u8 enable_loopback;
+	int gpio_cs;
+	void (*cs_control)(u32 command);
+};
+
+static struct ads7846_platform_data ea313x_ads7846_info = {
+	.model			= 7846,
+	.vref_delay_usecs	= 100,
+	.x_plate_ohms		= 419,
+	.y_plate_ohms		= 486,
+	.gpio_pendown		= GPIO_GPIO4,
+};
+
+static struct lpc313x_spi_chip ea313x_ads7846_chip = {
+	.gpio_cs	= GPIO_MUART_CTS_N,
+};
+
+/* If both SPIDEV and MTD data flash are enabled with the same chip select, only 1 will work */
+#if defined(CONFIG_SPI_SPIDEV)
+/* SPIDEV driver registration */
+static int __init lpc313x_spidev_register(void)
+{
+	struct spi_board_info info[] = {
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 1000000,
+		.bus_num = 0,
+		.chip_select = 0,
+	}, {
+		.modalias	= "ads7846",
+		.max_speed_hz	= 1200000,
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.platform_data	= &ea313x_ads7846_info,
+		.controller_data= &ea313x_ads7846_chip,
+		.irq		= IRQ_PENDOWN,
+	}};
+	gpio_request(GPIO_MUART_CTS_N, "touchscreen CS");
+	gpio_direction_output(GPIO_MUART_CTS_N, 1);
+
+	return spi_register_board_info(info, 3);
+}
+arch_initcall(lpc313x_spidev_register);
+#endif
+
+#if defined(CONFIG_MTD_DATAFLASH)
+/* MTD Data FLASH driver registration */
+static int __init lpc313x_spimtd_register(void)
+{
+	struct spi_board_info info =
+	{
+		.modalias = "mtd_dataflash",
+		.max_speed_hz = 30000000,
+		.bus_num = 0,
+		.chip_select = 0,
+	};
+
+	return spi_register_board_info(&info, 1);
+}
+arch_initcall(lpc313x_spimtd_register);
+#endif
+
+
+#define PCA9532_GPIO_BASE 0x340
+#define VBUS_PWR_EN	(6 + PCA9532_GPIO_BASE)
+#define START_STOP_LED	8  /*led5 */
+#define IDLE_LED	9  /*led6 */
+
+static struct pca9532_platform_data ea313x_leds = {
+	.gpio_base = PCA9532_GPIO_BASE,
+	.leds = {
+	{	.type = PCA9532_TYPE_GPIO }, /* key joy 1 */
+	{	.type = PCA9532_TYPE_GPIO }, /* key joy 2 */
+	{	.type = PCA9532_TYPE_GPIO }, /* key joy 3 */
+	{	.type = PCA9532_TYPE_GPIO }, /* key joy 4 */
+	{	.type = PCA9532_TYPE_GPIO }, /* key joy 5 */
+	{	.type = PCA9532_TYPE_GPIO }, /* OTP gpio */
+	{	.type = PCA9532_TYPE_GPIO }, /* V_BUS_EN gpio */
+	{	.type = PCA9532_TYPE_GPIO }, /* V_PWR_CTRL gpio */
+
+	{	.name = "ea313x:red:led5",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "ea313x:red:led6",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "ea313x:red:led7",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "ea313x:red:led8",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "ea313x:red:led9",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "ea313x:red:led10",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "ea313x:red:led11",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "ea313x:red:led12",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	},
+	.psc = { 0, 0 },
+	.pwm = { 0, 0 },
+};
+
+static struct i2c_board_info ea313x_i2c_devices[] __initdata = {
+	{
+		I2C_BOARD_INFO("pca9532", 0x60),
+		.platform_data = &ea313x_leds,
+	},
+};
+
+#if defined(CONFIG_MACH_EA3152)
+static struct i2c_board_info ea3152_i2c1_devices[] __initdata = {
+	{
+		I2C_BOARD_INFO("lpc3152-psu", 0x0C),
+	},
+};
+#endif
+
+void lpc313x_vbus_power(int enable)
+{
+	printk (KERN_INFO "enabling USB host vbus_power %d\n", enable);
+	gpio_set_value(VBUS_PWR_EN, enable);
+}
+
+struct of_dev_auxdata ea3131_auxdata_lookup[] __initdata = {
+	OF_DEV_AUXDATA("davicom,dm9000", EXT_SRAM1_PHYS, "dm9000", &dm9000_platdata),
+	{}
+};
+
+static void __init ea3131_dt_init(void)
+{
+	lpc31xx_dt_init_common(ea3131_auxdata_lookup);
+	ea_add_device_ssd1289();
+	ea_add_device_dm9000();
+}
+
+#if defined(CONFIG_USB_EHCI_HCD)
+static int __init ea_usb_power(void)
+{
+	int ret;
+
+	ret = gpio_request(VBUS_PWR_EN, "vbus power");
+	ret = gpio_direction_output(VBUS_PWR_EN, 1);
+	return ret;
+}
+late_initcall(ea_usb_power);
+#endif
+
+static const char *ea3131_dt_match[] __initconst = {
+	"ea,ea3131",
+	NULL,
+};
+
+DT_MACHINE_START(EA313X, "NXP EA3131 (Device Tree Support)")
+	.map_io		= lpc313x_map_io,
+	.init_early	= lpc31xx_init_early,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= ea3131_dt_init,
+	.dt_compat	= ea3131_dt_match,
+	.restart	= arch_reset,
+MACHINE_END
+#endif
+
+#ifndef CONFIG_OF
 
 static u64 mci_dmamask = 0xffffffffUL;
 static struct platform_device	lpc313x_mci_device = {
@@ -61,7 +328,7 @@ static struct platform_device	lpc313x_mci_device = {
 };
 
 #if defined (CONFIG_FB_SSD1289)
-#ifndef CONFIG_OF
+
 static struct resource ssd1289_resource[] = {
 	[0] = {
 		.start = EXT_SRAM0_PHYS + 0x00000 + 0x0000,
@@ -81,7 +348,7 @@ static struct platform_device ssd1289_device = {
 	.num_resources = ARRAY_SIZE(ssd1289_resource),
 	.resource      = ssd1289_resource,
 };
-#endif
+
 
 static void __init ea_add_device_ssd1289(void)
 {
@@ -93,9 +360,7 @@ static void __init ea_add_device_ssd1289(void)
 	MPMC_STWTWR0   = 3;
 	MPMC_STWTTURN0 = 0;
 
-#ifndef CONFIG_OF
 	platform_device_register(&ssd1289_device);
-#endif
 }
 #else
 static void __init ea_add_device_ssd1289(void) {}
@@ -105,7 +370,7 @@ static void __init ea_add_device_ssd1289(void) {}
  * DM9000 ethernet device
  */
 #if defined(CONFIG_DM9000)
-#ifndef CONFIG_OF
+
 static struct resource dm9000_resource[] = {
 	[0] = {
 		.start	= EXT_SRAM1_PHYS,
@@ -123,7 +388,7 @@ static struct resource dm9000_resource[] = {
 		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
 	}
 };
-#endif
+
 /* ARM MPMC contoller as part of low power design doesn't de-assert nCS and nOE for consecutive 
 reads but just changes address. But DM9000 requires nCS and nOE change between address. So access
 other chip select area (nCS0) to force de-assertion of nCS1 and nOE1. Or else wait for long time 
@@ -166,7 +431,6 @@ static struct dm9000_plat_data dm9000_platdata = {
 	.inblk = dm9000_inblk,
 };
 
-#ifndef CONFIG_OF
 static struct platform_device dm9000_device = {
 	.name		= "dm9000",
 	.id		= 0,
@@ -176,7 +440,6 @@ static struct platform_device dm9000_device = {
 		.platform_data	= &dm9000_platdata,
 	}
 };
-#endif
 
 static void __init ea_add_device_dm9000(void)
 {
@@ -195,7 +458,7 @@ static void __init ea_add_device_dm9000(void)
 	/* enable oe toggle between consec reads */
 	SYS_MPMC_WTD_DEL1 = _BIT(5) | 4;
 
-#ifndef CONFIG_OF
+
 	/* Configure Interrupt pin as input, no pull-up */
 	if (gpio_request(GPIO_MNAND_RYBN3, "dm9000 interrupt"))
 		return;
@@ -203,7 +466,6 @@ static void __init ea_add_device_dm9000(void)
 	gpio_direction_input(GPIO_MNAND_RYBN3);
 
 	platform_device_register(&dm9000_device);
-#endif
 }
 #else
 static void __init ea_add_device_dm9000(void) {}
@@ -335,7 +597,7 @@ struct lpc313x_spics_cfg lpc313x_stdspics_cfg[] =
 	[1] =
 	{
 		.spi_spo	= 0, /* Low clock between transfers */
-		.spi_sph	= 0, /* Data capture on first clock edge (high edge with spi_spo=0) */
+		.spi_sph	= 0, /* Data capture on first clofck edge (high edge with spi_spo=0) */
 		.spi_cs_set	= spi_set_cs1_state,
 	},
 	[2] =
@@ -585,19 +847,6 @@ void lpc313x_vbus_power(int enable)
 	gpio_set_value(VBUS_PWR_EN, enable);
 }
 
-#ifdef CONFIG_OF
-struct of_dev_auxdata ea3131_auxdata_lookup[] __initdata = {
-	OF_DEV_AUXDATA("davicom,dm9000", EXT_SRAM1_PHYS, "dm9000", &dm9000_platdata),
-	{}
-};
-
-static void __init ea3131_dt_init(void)
-{
-	lpc31xx_dt_init_common(ea3131_auxdata_lookup);
-	ea_add_device_ssd1289();
-	ea_add_device_dm9000();
-}
-#else
 static void __init ea313x_init(void)
 {
 	lpc313x_init();
@@ -620,7 +869,6 @@ static void __init ea313x_init(void)
 		ARRAY_SIZE(ea3152_i2c1_devices));
 #endif
 }
-#endif
 
 #if defined(CONFIG_USB_EHCI_HCD)
 static int __init ea_usb_power(void)
@@ -652,7 +900,6 @@ MACHINE_END
 #endif
 
 #if defined(CONFIG_MACH_EA313X)
-#ifndef CONFIG_OF
 MACHINE_START(EA313X, "NXP EA313X")
 	/* Maintainer: Durgesh Pattamatta, NXP */
 	.map_io		= ea313x_map_io,
@@ -661,21 +908,9 @@ MACHINE_START(EA313X, "NXP EA313X")
 	.init_machine	= ea313x_init,
 	.restart	= arch_reset,
 MACHINE_END
-#else
-static const char *ea3131_dt_match[] __initconst = {
-	"ea,ea3131",
-	NULL,
-};
-DT_MACHINE_START(EA313X, "NXP EA3131 (Device Tree Support)")
-	.map_io		= lpc313x_map_io,
-	.init_early	= lpc31xx_init_early,
-	.init_irq	= lpc313x_init_irq,
-	.timer		= &lpc313x_timer,
-	.init_machine	= ea3131_dt_init,
-	.dt_compat	= ea3131_dt_match,
-	.restart	= arch_reset,
-MACHINE_END
 #endif
 #endif
 
 
+
+
diff --git a/arch/arm/mach-lpc31xx/clock.c b/arch/arm/mach-lpc31xx/clock.c
index 281a3f5..2bc3921 100644
--- a/arch/arm/mach-lpc31xx/clock.c
+++ b/arch/arm/mach-lpc31xx/clock.c
@@ -1062,6 +1062,8 @@ EXPORT_SYMBOL(clk_get_rate);
 static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("pnx-i2c.0", NULL, clk_i2c0)
 	_REGISTER_CLOCK("pnx-i2c.1", NULL, clk_i2c1)
+	_REGISTER_CLOCK("1300a000.i2c", NULL, clk_i2c0)
+	_REGISTER_CLOCK("1300a400.i2c", NULL, clk_i2c1)
 	_REGISTER_CLOCK(NULL, "nand_s0", clk_nand_s0)
 	_REGISTER_CLOCK(NULL, "nand_ecc", clk_nand_ecc)
 	_REGISTER_CLOCK(NULL, "nand_clk", clk_nand_clk)
diff --git a/arch/arm/mach-lpc31xx/generic.c b/arch/arm/mach-lpc31xx/generic.c
index 1c50945..8fe3326 100644
--- a/arch/arm/mach-lpc31xx/generic.c
+++ b/arch/arm/mach-lpc31xx/generic.c
@@ -147,14 +147,6 @@ static struct map_desc lpc313x_io_desc[] __initdata = {
 		.length		= IO_APB4_SIZE,
 		.type		= MT_DEVICE
 	},
-#if 0
-	{
-		.virtual	= io_p2v(IO_DMA_REG_PHYS),
-		.pfn		= __phys_to_pfn(IO_DMA_REG_PHYS),
-		.length		= IO_DMA_REG_SIZE,
-		.type		= MT_DEVICE
-	},
-#endif
 	{
 		.virtual	= io_p2v(IO_MPMC_CFG_PHYS),
 		.pfn		= __phys_to_pfn(IO_MPMC_CFG_PHYS),
@@ -187,6 +179,18 @@ static struct map_desc lpc313x_io_desc[] __initdata = {
 		.length		= IO_SDMMC_SIZE,
 		.type		= MT_DEVICE
 	},
+	{
+		.virtual	= io_p2v(EXT_SRAM0_PHYS),
+		.pfn		= __phys_to_pfn(EXT_SRAM0_PHYS),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= io_p2v(EXT_SRAM1_PHYS + 0x10000),
+		.pfn		= __phys_to_pfn(EXT_SRAM1_PHYS + 0x10000),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
 #endif
 };
 
diff --git a/arch/arm/mach-lpc31xx/i2c.c b/arch/arm/mach-lpc31xx/i2c.c
index 1515c3e..5b8b7de 100644
--- a/arch/arm/mach-lpc31xx/i2c.c
+++ b/arch/arm/mach-lpc31xx/i2c.c
@@ -80,19 +80,6 @@ static u32 calculate_input_freq(struct platform_device *pdev)
 	return (FFAST_CLOCK/1000000);
 }
 
-
-static struct i2c_pnx_data lpc_pnx_data0 = {
-	.name = I2C_CHIP_NAME "0",
-	.base = I2C0_PHYS,
-	.irq = IRQ_I2C0,
-};
-
-static struct i2c_pnx_data lpc_pnx_data1 = {
-	.name = I2C_CHIP_NAME "1",
-	.base = I2C1_PHYS,
-	.irq = IRQ_I2C1,
-};
-
 static struct i2c_pnx_algo_data i2c0_algo_data;
 static struct i2c_pnx_algo_data i2c1_algo_data;
 
@@ -101,7 +88,6 @@ static struct i2c_pnx_algo_data i2c0_algo_data = {
 		.name = I2C_CHIP_NAME "0",
 		.algo_data = &i2c0_algo_data,
 	},
-	.i2c_pnx = &lpc_pnx_data0,
 };
 
 static struct i2c_pnx_algo_data i2c1_algo_data = {
@@ -109,23 +95,46 @@ static struct i2c_pnx_algo_data i2c1_algo_data = {
 		.name = I2C_CHIP_NAME "1",
 		.algo_data = &i2c1_algo_data,
 	},
-	.i2c_pnx = &lpc_pnx_data1,
+};
+
+static struct resource i2c0_resource[] = {
+	[0] = {
+		.start = I2C0_PHYS,
+		.end   = I2C0_PHYS + 0x400,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_I2C0,
+		.end	= IRQ_I2C0,
+		.flags	= IORESOURCE_IRQ,
+	},
 };
 
 static struct platform_device i2c0_device = {
 	.name = "pnx-i2c",
 	.id = 0,
-	.dev = {
-		.platform_data = &lpc_pnx_data0,
+	.num_resources	= ARRAY_SIZE(i2c0_resource),
+	.resource	= i2c0_resource,
+};
+
+static struct resource i2c1_resource[] = {
+	[0] = {
+		.start = I2C1_PHYS,
+		.end   = I2C1_PHYS + 0x400,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_I2C1,
+		.end	= IRQ_I2C1,
+		.flags	= IORESOURCE_IRQ,
 	},
 };
 
 static struct platform_device i2c1_device = {
 	.name = "pnx-i2c",
 	.id = 1,
-	.dev = {
-		.platform_data = &lpc_pnx_data1,
-	},
+	.num_resources	= ARRAY_SIZE(i2c1_resource),
+	.resource	= i2c1_resource,
 };
 
 static struct platform_device *devices[] __initdata = {
diff --git a/drivers/i2c/busses/i2c-pnx.c b/drivers/i2c/busses/i2c-pnx.c
index bee912b..c0bf133 100644
--- a/drivers/i2c/busses/i2c-pnx.c
+++ b/drivers/i2c/busses/i2c-pnx.c
@@ -572,14 +572,8 @@ static int __devinit i2c_pnx_probe(struct platform_device *pdev)
 	int ret = 0;
 	struct i2c_pnx_algo_data *alg_data;
 	unsigned long freq;
-	struct i2c_pnx_data *i2c_pnx = pdev->dev.platform_data;
-
-	if (!i2c_pnx || !i2c_pnx->name) {
-		dev_err(&pdev->dev, "%s: no platform data supplied\n",
-		       __func__);
-		ret = -EINVAL;
-		goto out;
-	}
+	struct resource *res;
+	static char *name ="i2c-pnx";
 
 	alg_data = kzalloc(sizeof(*alg_data), GFP_KERNEL);
 	if (!alg_data) {
@@ -589,13 +583,14 @@ static int __devinit i2c_pnx_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, alg_data);
 
-	strlcpy(alg_data->adapter.name, i2c_pnx->name,
-		sizeof(alg_data->adapter.name));
 	alg_data->adapter.dev.parent = &pdev->dev;
 	alg_data->adapter.algo = &pnx_algorithm;
 	alg_data->adapter.algo_data = alg_data;
 	alg_data->adapter.nr = pdev->id;
-	alg_data->i2c_pnx = i2c_pnx;
+	alg_data->adapter.dev.parent = &pdev->dev;
+#ifdef CONFIG_OF
+	alg_data->adapter.dev.of_node = of_node_get(pdev->dev.of_node);
+#endif
 
 	alg_data->clk = clk_get(&pdev->dev, NULL);
 	if (IS_ERR(alg_data->clk)) {
@@ -608,16 +603,24 @@ static int __devinit i2c_pnx_probe(struct platform_device *pdev)
 	alg_data->mif.timer.data = (unsigned long)alg_data;
 
 	/* Register I/O resource */
-	if (!request_mem_region(i2c_pnx->base, I2C_PNX_REGION_SIZE,
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "Unable to get resources.\n");
+		return -ENXIO;
+	}
+	sprintf(alg_data->adapter.name, "%08x.i2c", res->start);
+
+	if (!request_mem_region(res->start, I2C_PNX_REGION_SIZE,
 				pdev->name)) {
 		dev_err(&pdev->dev,
 		       "I/O region 0x%08x for I2C already in use.\n",
-		       i2c_pnx->base);
+		       res->start);
 		ret = -ENODEV;
 		goto out_clkget;
 	}
 
-	alg_data->ioaddr = ioremap(i2c_pnx->base, I2C_PNX_REGION_SIZE);
+	alg_data->base = res->start;
+	alg_data->ioaddr = ioremap(res->start, I2C_PNX_REGION_SIZE);
 	if (!alg_data->ioaddr) {
 		dev_err(&pdev->dev, "Couldn't ioremap I2C I/O region\n");
 		ret = -ENOMEM;
@@ -654,7 +657,8 @@ static int __devinit i2c_pnx_probe(struct platform_device *pdev)
 	}
 	init_completion(&alg_data->mif.complete);
 
-	ret = request_irq(i2c_pnx->irq, i2c_pnx_interrupt,
+	alg_data->irq = platform_get_irq(pdev, 0);
+	ret = request_irq(alg_data->irq, i2c_pnx_interrupt,
 			0, pdev->name, alg_data);
 	if (ret)
 		goto out_clock;
@@ -667,18 +671,18 @@ static int __devinit i2c_pnx_probe(struct platform_device *pdev)
 	}
 
 	dev_dbg(&pdev->dev, "%s: Master at %#8x, irq %d.\n",
-	       alg_data->adapter.name, i2c_pnx->base, i2c_pnx->irq);
+	       alg_data->adapter.name, res->start, alg_data->irq);
 
 	return 0;
 
 out_irq:
-	free_irq(i2c_pnx->irq, alg_data);
+	free_irq(alg_data->irq, alg_data);
 out_clock:
 	clk_disable(alg_data->clk);
 out_unmap:
 	iounmap(alg_data->ioaddr);
 out_release:
-	release_mem_region(i2c_pnx->base, I2C_PNX_REGION_SIZE);
+	release_mem_region(res->start, I2C_PNX_REGION_SIZE);
 out_clkget:
 	clk_put(alg_data->clk);
 out_drvdata:
@@ -692,13 +696,12 @@ out:
 static int __devexit i2c_pnx_remove(struct platform_device *pdev)
 {
 	struct i2c_pnx_algo_data *alg_data = platform_get_drvdata(pdev);
-	struct i2c_pnx_data *i2c_pnx = alg_data->i2c_pnx;
 
-	free_irq(i2c_pnx->irq, alg_data);
+	free_irq(alg_data->irq, alg_data);
 	i2c_del_adapter(&alg_data->adapter);
 	clk_disable(alg_data->clk);
 	iounmap(alg_data->ioaddr);
-	release_mem_region(i2c_pnx->base, I2C_PNX_REGION_SIZE);
+	release_mem_region(alg_data->base, I2C_PNX_REGION_SIZE);
 	clk_put(alg_data->clk);
 	kfree(alg_data);
 	platform_set_drvdata(pdev, NULL);
@@ -706,10 +709,21 @@ static int __devexit i2c_pnx_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id i2c_pnx_of_match[] = {
+	{ .compatible = "nxp,pnx-i2c" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, i2c_pnx_of_match);
+#endif
+
 static struct platform_driver i2c_pnx_driver = {
 	.driver = {
 		.name = "pnx-i2c",
 		.owner = THIS_MODULE,
+#ifdef CONFIG_OF
+			.of_match_table = i2c_pnx_of_match,
+#endif
 	},
 	.probe = i2c_pnx_probe,
 	.remove = __devexit_p(i2c_pnx_remove),
diff --git a/drivers/mtd/nand/lpc313x_nand.c b/drivers/mtd/nand/lpc313x_nand.c
index 3e76633..398e3df 100644
--- a/drivers/mtd/nand/lpc313x_nand.c
+++ b/drivers/mtd/nand/lpc313x_nand.c
@@ -1306,6 +1306,56 @@ static void lpc313x_nand_update_chip(struct lpc313x_nand_info *info,
 	chip->ecc.prepad = 0;
 }
 
+#ifdef CONFIG_OF
+#define BLK_SIZE (2048 * 64)
+static struct mtd_partition ea313x_nand0_partitions[] = {
+	/* The EA3131 board uses the following block scheme:
+	128K: Blocks 0   - 0    - LPC31xx info and bad block table
+	384K: Blocks 1   - 3    - Apex bootloader
+	256K: Blocks 4   - 5    - Apex environment
+	4M:   Blocks 6   - 37   - Kernel image
+	16M:  Blocks 38  - 165  - Ramdisk image (if used)
+	???:  Blocks 166 - end  - Root filesystem/storage */
+	{
+		.name	= "lpc313x-rootfs",
+		.offset	= (BLK_SIZE * 166),
+		.size	= MTDPART_SIZ_FULL
+	},
+};
+
+static struct lpc313x_nand_timing ea313x_nanddev_timing = {
+	.ns_trsd	= 36,
+	.ns_tals	= 36,
+	.ns_talh	= 12,
+	.ns_tcls	= 36,
+	.ns_tclh	= 12,
+	.ns_tdrd	= 36,
+	.ns_tebidel	= 12,
+	.ns_tch		= 12,
+	.ns_tcs		= 48,
+	.ns_treh	= 24,
+	.ns_trp		= 48,
+	.ns_trw		= 24,
+	.ns_twp		= 36
+};
+
+static struct lpc313x_nand_dev_info ea313x_ndev[] = {
+	{
+		.name		= "nand0",
+		.nr_partitions	= ARRAY_SIZE(ea313x_nand0_partitions),
+		.partitions	= ea313x_nand0_partitions
+	}
+};
+
+static struct lpc313x_nand_cfg ea313x_plat_nand = {
+	.nr_devices	= ARRAY_SIZE(ea313x_ndev),
+	.devices	= ea313x_ndev,
+	.timing		= &ea313x_nanddev_timing,
+	.support_16bit	= 0,
+};
+#endif
+
+
 /*
  * Called by device layer when it finds a device matching
  * one our driver can handled. This code checks to see if
@@ -1335,6 +1385,10 @@ static int lpc313x_nand_probe(struct platform_device *pdev) {
 	/* Register driver data with platform */
 	platform_set_drvdata(pdev, host);
 
+#ifdef CONFIG_OF
+	plat = &ea313x_plat_nand;
+#endif
+
 	host->dev = &pdev->dev;
 	host->platform = plat;
 	host->irq = irq;
@@ -1342,7 +1396,7 @@ static int lpc313x_nand_probe(struct platform_device *pdev) {
 
 	/* Exit if no platform data */
 	if (plat == NULL) {
-		dev_err(&pdev->dev, "No memory for flash info\n");
+		dev_err(&pdev->dev, "No platform data\n");
 		goto exit_error;
 	}
 
@@ -1543,6 +1597,15 @@ static int lpc313x_nand_suspend(struct platform_device *pdev, pm_message_t pm)
 #define lpc313x_nand_suspend NULL
 #endif
 
+#if defined(CONFIG_OF)
+static const struct of_device_id lpc313x_nand_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-nand" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lpc313x_nand_of_match);
+#endif
+
+
 static struct platform_driver lpc313x_nand_driver = {
 	.probe		= lpc313x_nand_probe,
 	.remove		= lpc313x_nand_remove,
@@ -1551,6 +1614,9 @@ static struct platform_driver lpc313x_nand_driver = {
 	.driver = {
 		.name = "lpc313x_nand",
 		.owner = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = lpc313x_nand_of_match,
+#endif
 	},
 };
 
diff --git a/drivers/spi/spi_lpc313x.c b/drivers/spi/spi_lpc313x.c
index aa99f79..7e296ef 100644
--- a/drivers/spi/spi_lpc313x.c
+++ b/drivers/spi/spi_lpc313x.c
@@ -45,6 +45,7 @@
 #include <mach/registers.h>
 #include <mach/dma.h>
 #include <mach/board.h>
+#include <mach/gpio.h>
 
 /* Register access macros */
 #define spi_readl(reg) __raw_readl(&SPI_##reg)
@@ -745,6 +746,57 @@ static int lpc313x_spi_transfer(struct spi_device *spi, struct spi_message *m)
 	return 0;
 }
 
+#ifdef CONFIG_OF
+static void spi_set_cs0_state(int cs_num, int state)
+{
+	(void) cs_num;
+	lpc313x_gpio_set_value(GPIO_SPI_CS_OUT0, state);
+}
+
+static void spi_set_cs1_state(int cs_num, int state)
+{
+	(void) cs_num;
+printk("cs1 state %d\n", state);
+	lpc313x_gpio_set_value(GPIO_MUART_CTS_N, state);
+}
+
+static void spi_set_cs2_state(int cs_num, int state)
+{
+printk("cs2 state %d\n", state);
+	(void) cs_num;
+	lpc313x_gpio_set_value(GPIO_MUART_RTS_N, state);
+}
+
+struct lpc313x_spics_cfg lpc313x_stdspics_cfg[] =
+{
+	/* SPI CS0 */
+	[0] =
+	{
+		.spi_spo	= 0, /* Low clock between transfers */
+		.spi_sph	= 0, /* Data capture on first clock edge (high edge with spi_spo=0) */
+		.spi_cs_set	= spi_set_cs0_state,
+	},
+	[1] =
+	{
+		.spi_spo	= 0, /* Low clock between transfers */
+		.spi_sph	= 0, /* Data capture on first clofck edge (high edge with spi_spo=0) */
+		.spi_cs_set	= spi_set_cs1_state,
+	},
+	[2] =
+	{
+		.spi_spo	= 0, /* Low clock between transfers */
+		.spi_sph	= 1, /* Data capture on first clock edge (high edge with spi_spo=0) */
+		.spi_cs_set	= spi_set_cs2_state,
+	},
+};
+
+struct lpc313x_spi_cfg lpc313x_spidata =
+{
+	.num_cs			= ARRAY_SIZE(lpc313x_stdspics_cfg),
+	.spics_cfg		= lpc313x_stdspics_cfg,
+};
+#endif
+
 /*
  * SPI driver probe
  */
@@ -773,6 +825,9 @@ static int __init lpc313x_spi_probe(struct platform_device *pdev)
 
 	/* Is a board specific configuration available? */
 	spidat->psppcfg = (struct lpc313x_spi_cfg *) pdev->dev.platform_data;
+#ifdef CONFIG_OF
+	spidat->psppcfg = &lpc313x_spidata;
+#endif
 	if (spidat->psppcfg == NULL)
 	{
 		/* No platform data, exit */
@@ -972,6 +1027,14 @@ static int lpc313x_spi_resume(struct platform_device *pdev)
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id lpc313x_spi_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-spi" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lpc313x_spi_of_match);
+#endif
+
 static struct platform_driver lpc313x_spi_driver = {
 	.probe		= lpc313x_spi_probe,
 	.remove		= __devexit_p(lpc313x_spi_remove),
@@ -980,6 +1043,9 @@ static struct platform_driver lpc313x_spi_driver = {
 	.driver		= {
 		.name	= "spi_lpc313x",
 		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = lpc313x_spi_of_match,
+#endif
 	},
 };
 
diff --git a/include/linux/i2c-pnx.h b/include/linux/i2c-pnx.h
index a87124d..e857166 100644
--- a/include/linux/i2c-pnx.h
+++ b/include/linux/i2c-pnx.h
@@ -29,8 +29,9 @@ struct i2c_pnx_algo_data {
 	struct i2c_pnx_mif	mif;
 	int			last;
 	struct clk		*clk;
-	struct i2c_pnx_data	*i2c_pnx;
 	struct i2c_adapter	adapter;
+	void __iomem *base;
+	int irq;
 };
 
 struct i2c_pnx_data {
