Bottom: d90793d567f477f784df988b4f53d0f7f49b6a8f
Top:    79070f160fcfe92a3df0ffe38b2ebc8533c03365
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-06-12 16:01:51 -0400

Initial sound driver port


---

diff --git a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
index bed74a9..a347eff 100644
--- a/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
+++ b/arch/arm/boot/dts/sun7i-a20-cubietruck.dts
@@ -137,6 +137,10 @@
 			status = "okay";
 		};
 
+		codec@1c22c00 {
+			status = "okay";
+		};
+
 		ir0: ir@01c21800 {
 			pinctrl-names = "default";
 			pinctrl-0 = <&ir0_pins_a>;
diff --git a/arch/arm/boot/dts/sun7i-a20.dtsi b/arch/arm/boot/dts/sun7i-a20.dtsi
index 263eb79..4fbd64a 100644
--- a/arch/arm/boot/dts/sun7i-a20.dtsi
+++ b/arch/arm/boot/dts/sun7i-a20.dtsi
@@ -91,6 +91,14 @@
 			clock-output-names = "pll1";
 		};
 
+		pll2: clk@01c20008 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sun7i-a20-pll2-clk";
+			reg = <0x01c20008 0x4>;
+			clocks = <&osc24M>;
+			clock-output-names = "pll2";
+		};
+
 		pll4: clk@01c20018 {
 			#clock-cells = <0>;
 			compatible = "allwinner,sun7i-a20-pll4-clk";
@@ -327,6 +335,30 @@
 			clock-output-names = "ir1";
 		};
 
+		i2s0_clk: clk@01c200b8 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200b8 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s0";
+		};
+
+		ac97_clk: clk@01c200bc {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200bc 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "ac97";
+		};
+
+		spdif_clk: clk@01c200c0 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200c0 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "spdif";
+		};
+
 		usb_clk: clk@01c200cc {
 			#clock-cells = <1>;
 		        #reset-cells = <1>;
@@ -344,6 +376,30 @@
 			clock-output-names = "spi3";
 		};
 
+		i2s1_clk: clk@01c200d8 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200d8 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s1";
+		};
+
+		i2s2_clk: clk@01c200dc {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-audio-clk";
+			reg = <0x01c200dc 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "i2s2";
+		};
+
+		codec_clk: clk@01c20140 {
+			#clock-cells = <0>;
+			compatible = "allwinner,sunxi-codec-clk";
+			reg = <0x01c20140 0x4>;
+			clocks = <&pll2>;
+			clock-output-names = "codec";
+		};
+
 		mbus_clk: clk@01c2015c {
 			#clock-cells = <0>;
 			compatible = "allwinner,sun4i-a10-mod0-clk";
@@ -807,6 +863,81 @@
 			clocks = <&osc24M>;
 			#pwm-cells = <3>;
 		};
+		
+		spdif@1c21000 {
+			compatible = "allwinner,sun7i-a20-spdif";
+			reg = <0x01C21000 0x40>;
+			interrupts = <0 13 4>;
+			clocks = <&pll2>, <&apb0_gates 1>, <&spdif_clk>;
+			clock-names = "pll2", "apb", "spdif";
+			dmas = <&dma 0 2>, <&dma 0 2>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		ac97@1c21400 {
+			compatible = "allwinner,sun7i-a20-ac97";
+			reg = <0x01C21400 0x40>;
+			interrupts = <0 14 4>;
+			clocks = <&pll2>, <&apb0_gates 2>, <&ac97_clk>;
+			clock-names = "pll2", "apb", "ac97";
+			dmas = <&dma 0 5>, <&dma 0 5>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s0: i2s@1c22000 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C22000 0x40>;
+			interrupts = <0 16 4>;
+			clocks = <&pll2>, <&apb0_gates 3>, <&i2s0_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 3>, <&dma 0 3>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s1: i2s@1c22400 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C22400 0x40>;
+			interrupts = <0 87 4>;
+			clocks = <&pll2>, <&apb0_gates 4>, <&i2s1_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 4>, <&dma 0 4>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s2: i2s@1c24400 {
+			compatible = "allwinner,sun7i-a20-i2s";
+			reg = <0x01C24400 0x40>;
+			interrupts = <0 90 4>;
+			clocks = <&pll2>, <&apb0_gates 8>, <&i2s2_clk>;
+			clock-names = "pll2", "apb", "i2s";
+			dmas = <&dma 0 6>, <&dma 0 6>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		codec@1c22c00 {
+			compatible = "allwinner,sun7i-a20-codec";
+			reg = <0x01C22c00 0x40>;
+			interrupts = <0 30 4>;
+			clocks = <&pll2>, <&apb0_gates 0>, <&codec_clk>;
+			clock-names = "pll2", "apb", "codec";
+			dmas = <&dma 0 19>, <&dma 0 19>;
+			dma-names = "rx", "tx";
+			widgets =
+				"Microphone", "Microphone Jack",
+				"Headphone", "Headphone Jack",
+				"Line", "Line In Jack";
+			routing =
+				"MIC_IN", "Microphone Jack",
+				"Microphone Jack", "Mic Bias",
+				"LINE_IN", "Line In Jack",
+				"Headphone Jack", "HP_OUT";
+			status = "disabled";
+		};
 
 		ir0: ir@01c21800 {
 			compatible = "allwinner,sun7i-a20-ir";
diff --git a/drivers/clk/sunxi/clk-sunxi.c b/drivers/clk/sunxi/clk-sunxi.c
index 1d16c0c..b3483a7 100644
--- a/drivers/clk/sunxi/clk-sunxi.c
+++ b/drivers/clk/sunxi/clk-sunxi.c
@@ -212,6 +212,30 @@ static void sun8i_a23_get_pll1_factors(u32 *freq, u32 parent_rate,
 }
 
 /**
+ * sun7i_get_pll2_factors()
+ * parent_rate is always 24Mhz
+ */
+
+static void sun7i_get_pll2_factors(u32 *freq, u32 parent_rate,
+				   u8 *n, u8 *k, u8 *m, u8 *p)
+{
+	printk("JDS - sun7i_get_pll2_factors %d\n", *freq);
+	/* we were called to round the frequency, we can now return */
+	if (n == NULL)
+		return;
+	
+	if (*freq == 22579200) {
+		*n = 79;
+		*m = 21;  /* Pre */
+		*k = 4;   /* Post */
+	} else  {
+		*n = 86;
+		*m = 21;  /* Pre */
+		*k = 4;   /* Post */
+	}
+}
+
+/**
  * sun4i_get_pll5_factors() - calculates n, k factors for PLL5
  * PLL5 rate is calculated as follows
  * rate = parent_rate * n * (k + 1)
@@ -482,6 +506,15 @@ static struct clk_factors_config sun8i_a23_pll1_config = {
 	.n_from_one = 1,
 };
 
+static struct clk_factors_config sun7i_pll2_config = {
+	.nshift = 8,
+	.nwidth = 7,
+	.kshift = 26,
+	.kwidth = 4,
+	.mshift = 0,
+	.mwidth = 5,
+};
+
 static struct clk_factors_config sun4i_pll5_config = {
 	.nshift = 8,
 	.nwidth = 5,
@@ -538,6 +571,12 @@ static const struct factors_data sun8i_a23_pll1_data __initconst = {
 	.getter = sun8i_a23_get_pll1_factors,
 };
 
+static const struct factors_data sun7i_a20_pll2_data __initconst = {
+	.enable = 31,
+	.table = &sun7i_pll2_config,
+	.getter = sun7i_get_pll2_factors,
+};
+
 static const struct factors_data sun7i_a20_pll4_data __initconst = {
 	.enable = 31,
 	.table = &sun4i_pll5_config,
@@ -945,6 +984,10 @@ static const struct gates_data sun6i_a31_usb_gates_data __initconst = {
 	.reset_mask = BIT(2) | BIT(1) | BIT(0),
 };
 
+static const struct gates_data sunxi_codec_data __initconst = {
+	.mask = {BIT(31)},
+};
+
 static void __init sunxi_gates_clk_setup(struct device_node *node,
 					 struct gates_data *data)
 {
@@ -1195,12 +1238,12 @@ free_clkdata:
 }
 
 
-
 /* Matches for factors clocks */
 static const struct of_device_id clk_factors_match[] __initconst = {
 	{.compatible = "allwinner,sun4i-a10-pll1-clk", .data = &sun4i_pll1_data,},
 	{.compatible = "allwinner,sun6i-a31-pll1-clk", .data = &sun6i_a31_pll1_data,},
 	{.compatible = "allwinner,sun8i-a23-pll1-clk", .data = &sun8i_a23_pll1_data,},
+	{.compatible = "allwinner,sun7i-a20-pll2-clk", .data = &sun7i_a20_pll2_data,},
 	{.compatible = "allwinner,sun7i-a20-pll4-clk", .data = &sun7i_a20_pll4_data,},
 	{.compatible = "allwinner,sun4i-a10-apb1-clk", .data = &sun4i_apb1_data,},
 	{.compatible = "allwinner,sun4i-a10-mod0-clk", .data = &sun4i_mod0_data,},
@@ -1258,6 +1301,7 @@ static const struct of_device_id clk_gates_match[] __initconst = {
 	{.compatible = "allwinner,sun4i-a10-usb-clk", .data = &sun4i_a10_usb_gates_data,},
 	{.compatible = "allwinner,sun5i-a13-usb-clk", .data = &sun5i_a13_usb_gates_data,},
 	{.compatible = "allwinner,sun6i-a31-usb-clk", .data = &sun6i_a31_usb_gates_data,},
+	{.compatible = "allwinner,sunxi-codec-clk", .data = &sunxi_codec_data,},
 	{}
 };
 
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 0060b31..8f08e4b 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -52,6 +52,7 @@ source "sound/soc/s6000/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/sirf/Kconfig"
 source "sound/soc/spear/Kconfig"
+source "sound/soc/sunxi/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/txx9/Kconfig"
 source "sound/soc/ux500/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 5f1df02..50c7ab3 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -29,6 +29,7 @@ obj-$(CONFIG_SND_SOC)	+= s6000/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= sirf/
 obj-$(CONFIG_SND_SOC)	+= spear/
+obj-$(CONFIG_SND_SOC)	+= sunxi/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= txx9/
 obj-$(CONFIG_SND_SOC)	+= ux500/
diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
new file mode 100644
index 0000000..ccdbee3
--- /dev/null
+++ b/sound/soc/sunxi/Kconfig
@@ -0,0 +1,4 @@
+config SND_SUNXI_SOC_CODEC
+	tristate "APB On-Chip sun4i and sun5i Codec"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	default y
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
new file mode 100644
index 0000000..b8950d3
--- /dev/null
+++ b/sound/soc/sunxi/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_SND_SUNXI_SOC_CODEC) += sunxi-codec.o
+
diff --git a/sound/soc/sunxi/sunxi-codec.c b/sound/soc/sunxi/sunxi-codec.c
new file mode 100644
index 0000000..a7f0f72
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-codec.c
@@ -0,0 +1,1773 @@
+/*
+ *   Driver for CODEC on Allwinner CPUs
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License.
+ *
+ *
+ ***************************************************************************************************/
+#define DEBUG
+#ifndef CONFIG_PM
+#define CONFIG_PM
+#endif
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#ifdef CONFIG_PM
+#include <linux/pm.h>
+#endif
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include "sunxi-codec.h"
+
+enum sunxi_device_id {SUN4A, SUN4I, SUN5I, SUN7I}; 
+
+/* Structure/enum declaration ------------------------------- */
+struct card_data {
+	struct device *dev; /* parent device */
+	struct resource *codec_base_res; /* resources found */
+	struct resource *codec_base_req; /* resources found */
+
+	spinlock_t lock;
+
+	long samplerate;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	
+	enum sunxi_device_id id;
+	struct dma_chan		*rx_dma_chan;
+	struct dma_chan		*tx_dma_chan;
+};
+
+#define SCRIPT_AUDIO_OK (0)
+static int has_playback, has_capture;
+static int gpio_pa_shutdown = 0;
+struct clk *codec_apbclk, *codec_pll2clk, *codec_moduleclk;
+
+static volatile unsigned int capture_dmasrc = 0;
+static volatile unsigned int capture_dmadst = 0;
+static volatile unsigned int play_dmasrc = 0;
+static volatile unsigned int play_dmadst = 0;
+
+#ifdef JDS
+static struct sunxi_dma_params sunxi_codec_pcm_stereo_play = {
+	.client.name = "CODEC PCM Stereo PLAY",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel = DMACH_NADDA_PLAY,
+#endif
+	.dma_addr = CODEC_BASSADDRESS + SUNXI_DAC_TXDATA, //发送数据地址
+};
+
+static struct sunxi_dma_params sunxi_codec_pcm_stereo_capture = {
+	.client.name = "CODEC PCM Stereo CAPTURE",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel = DMACH_NADDA_CAPTURE, //only support half full
+#endif	
+	.dma_addr = CODEC_BASSADDRESS + SUNXI_ADC_RXDATA, //接收数据地址
+};
+#endif
+
+struct sunxi_playback_runtime_data {
+	spinlock_t lock;
+	int state;
+	unsigned int dma_loaded;
+	unsigned int dma_limit;
+	unsigned int dma_period;
+	dma_addr_t dma_start;
+	dma_addr_t dma_pos;
+	dma_addr_t dma_end;
+	struct sunxi_dma_params *params;
+};
+
+struct sunxi_capture_runtime_data {
+	spinlock_t lock;
+	int state;
+	unsigned int dma_loaded;
+	unsigned int dma_limit;
+	unsigned int dma_period;
+	dma_addr_t dma_start;
+	dma_addr_t dma_pos;
+	dma_addr_t dma_end;
+	struct sunxi_dma_params *params;
+};
+
+/*播放设备硬件定义*/
+static struct snd_pcm_hardware sunxi_pcm_playback_hardware =
+{
+	.info = (SNDRV_PCM_INFO_INTERLEAVED |
+			SNDRV_PCM_INFO_BLOCK_TRANSFER |
+			SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+			SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |SNDRV_PCM_RATE_11025 |\
+ SNDRV_PCM_RATE_22050| SNDRV_PCM_RATE_32000 |\
+ SNDRV_PCM_RATE_44100| SNDRV_PCM_RATE_48000 |SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000 |\
+ SNDRV_PCM_RATE_KNOT),
+	.rate_min = 8000,
+	.rate_max = 192000,
+	.channels_min = 1,
+	.channels_max = 2,
+	.buffer_bytes_max = 128*1024, //最大的缓冲区大小
+	.period_bytes_min = 1024*4,//最小周期大小
+	.period_bytes_max = 1024*32,//最大周期大小
+	.periods_min = 4,//最小周期数
+	.periods_max = 8,//最大周期数
+	.fifo_size = 32,//fifo字节数
+};
+
+/*录音设备硬件定义*/
+static struct snd_pcm_hardware sunxi_pcm_capture_hardware =
+{
+	.info = (SNDRV_PCM_INFO_INTERLEAVED |
+			SNDRV_PCM_INFO_BLOCK_TRANSFER |
+			SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+			SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |SNDRV_PCM_RATE_11025 |\
+ SNDRV_PCM_RATE_22050| SNDRV_PCM_RATE_32000 |\
+ SNDRV_PCM_RATE_44100| SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 |SNDRV_PCM_RATE_192000 |\
+ SNDRV_PCM_RATE_KNOT),
+	.rate_min = 8000,
+	.rate_max = 192000,
+	.channels_min = 1,
+	.channels_max = 2,
+	.buffer_bytes_max = 128*1024, //最大的缓冲区大小
+	.period_bytes_min = 1024*4,//最小周期大小
+	.period_bytes_max = 1024*32,//最大周期大小
+	.periods_min = 4,//最小周期数
+	.periods_max = 8,//最大周期数
+	.fifo_size = 32,//fifo字节数
+};
+
+static void codec_resume_events(struct work_struct *work);
+struct workqueue_struct *resume_work_queue;
+static DECLARE_WORK(codec_resume_work, codec_resume_events);
+
+static unsigned int rates[] = { 8000, 11025, 12000, 16000, 22050, 24000, 24000, 32000, 44100, 48000, 96000, 192000 };
+
+static struct snd_pcm_hw_constraint_list hw_constraints_rates =
+{
+	.count = ARRAY_SIZE(rates),
+	.list = rates,
+	.mask = 0,
+};
+
+/**
+ * codec_wrreg_bits - update codec register bits
+ * @reg: codec register
+ * @mask: register mask
+ * @value: new value
+ *
+ * Writes new register value.
+ * Return 1 for change else 0.
+ */
+int codec_wrreg_bits(unsigned short reg, unsigned int mask, unsigned int value)
+{
+	int change;
+	unsigned int old, new;
+
+	old = codec_rdreg(reg);
+	new = (old & ~mask) | value;
+	change = old != new;
+
+	if (change) {
+		codec_wrreg(reg, new);
+	}
+	return change;
+}
+
+/**
+ *	snd_codec_info_volsw	-	single	mixer	info	callback
+ *	@kcontrol:	mixer control
+ *	@uinfo:	control	element	information
+ *	Callback to provide information about a single mixer control
+ *
+ * 	info()函数用于获得该control的详细信息，该函数必须填充传递给它的第二个参数snd_ctl_elem_info结构体
+ *
+ *	Returns 0 for success
+ */
+int snd_codec_info_volsw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	struct codec_mixer_control *mc = (struct codec_mixer_control*) kcontrol->private_value;
+	int max = mc->max;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+
+	if (max == 1)
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN; //the info of type
+	else
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+
+	uinfo->count = shift == rshift ? 1 : 2; //the info of elem count
+	uinfo->value.integer.min = 0; //the info of min value
+	uinfo->value.integer.max = max; //the info of max value
+	return 0;
+}
+
+/**
+ *	snd_codec_get_volsw	-	single	mixer	get	callback
+ *	@kcontrol:	mixer	control
+ *	@ucontrol:	control	element	information
+ *
+ *	Callback to get the value of a single mixer control
+ *	get()函数用于得到control的目前值并返回用户空间
+ *	return 0 for success.
+ */
+int snd_codec_get_volsw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct codec_mixer_control *mc = (struct codec_mixer_control*) kcontrol->private_value;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	/*fls(7) = 3,fls(1)=1,fls(0)=0,fls(15)=4,fls(3)=2,fls(23)=5*/
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	unsigned int reg = mc->reg;
+
+	ucontrol->value.integer.value[0] = (codec_rdreg(reg) >> shift) & mask;
+	if (shift != rshift)
+		ucontrol->value.integer.value[1] = (codec_rdreg(reg) >> rshift) & mask;
+
+	/*将获得的值写入snd_ctl_elem_value*/
+	if (invert) {
+		ucontrol->value.integer.value[0] = max - ucontrol->value.integer.value[0];
+		if (shift != rshift)
+			ucontrol->value.integer.value[1] = max - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+
+/**
+ *	snd_codec_put_volsw	-	single	mixer put callback
+ *	@kcontrol:	mixer	control
+ *	@ucontrol:	control	element	information
+ *
+ *	put()用于从用户空间写入值，如果值被改变，该函数返回1，否则返回0.
+ *	Callback to put the value of a single mixer control
+ *
+ * return 0 for success.
+ */
+int snd_codec_put_volsw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct codec_mixer_control *mc = (struct codec_mixer_control*) kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	unsigned int val, val2, val_mask;
+
+	val = (ucontrol->value.integer.value[0] & mask);
+	if (invert)
+		val = max - val;
+	val <<= shift;
+	val_mask = mask << shift;
+	if (shift != rshift) {
+		val2 = (ucontrol->value.integer.value[1] & mask);
+		if (invert)
+			val2 = max - val2;
+		val_mask |= mask << rshift;
+		val |= val2 << rshift;
+	}
+
+	return codec_wrreg_bits(reg, val_mask, val);
+}
+
+int codec_wr_control(u32 reg, u32 mask, u32 shift, u32 val)
+{
+	u32 reg_val;
+	reg_val = val << shift;
+	mask = mask << shift;
+	codec_wrreg_bits(reg, mask, reg_val);
+	return 0;
+}
+
+int codec_rd_control(u32 reg, u32 bit, u32 *val)
+{
+	return 0;
+}
+
+/**
+ *	codec_reset - reset the codec
+ * @codec	SoC Audio Codec
+ * Reset the codec, set the register of codec default value
+ * Return 0 for success
+ */
+static int codec_init(struct card_data *priv)
+{
+	//enable dac digital
+	codec_wr_control(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x1);
+
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x1, 28, 0x1);
+	//set digital volume to maximum
+	if (priv->id == SUN4A)
+		codec_wr_control(SUNXI_DAC_DPC, 0x6, DIGITAL_VOL, 0x0);
+
+	//pa mute
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	//enable PA
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x1);
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x3, DRA_LEVEL, 0x3);
+	//set volume
+	if ((priv->id == SUN4A) || (priv->id == SUN4I)) {
+		int device_lr_change = 0;
+		if (priv->id == SUN4A)
+			codec_wr_control(SUNXI_DAC_ACTL, 0x6, VOLUME, 0x01);
+		else 
+			codec_wr_control(SUNXI_DAC_ACTL, 0x6, VOLUME, 0x3b);
+#ifdef JDS
+		rc = script_parser_fetch("audio_para", "audio_lr_change", &device_lr_change, 1);
+		if (rc != SCRIPT_AUDIO_OK) {
+			pr_err("No audio_lr_change in fex audio_para\n");
+			return -1;
+		}
+#endif
+		if (device_lr_change)
+			codec_wr_control(SUNXI_DAC_DEBUG, 0x1, DAC_CHANNEL, 0x1);
+	} else {
+		codec_wr_control(SUNXI_DAC_ACTL, 0x6, VOLUME, 0x3b);
+	}
+	return 0;
+}
+
+static int codec_play_open(struct snd_pcm_substream *substream)
+{
+	codec_wr_control(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x1);
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x1, DAC_FIFO_FLUSH, 0x1);
+	//set TX FIFO send drq level
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x4, TX_TRI_LEVEL, 0xf);
+	if (substream->runtime->rate > 32000) {
+		codec_wr_control(SUNXI_DAC_FIFOC, 0x1, 28, 0x0);
+	} else {
+		codec_wr_control(SUNXI_DAC_FIFOC, 0x1, 28, 0x1);
+	}
+	//set TX FIFO MODE
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x1, TX_FIFO_MODE, 0x1);
+	//send last sample when dac fifo under run
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x1, LAST_SE, 0x0);
+	//enable dac analog
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x1);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x1);
+	//enable dac to pa
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x1);
+	return 0;
+}
+
+static int codec_capture_open(struct card_data *priv)
+{
+	//enable mic1 pa
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, MIC1_EN, 0x1);
+	//mic1 gain 32dB
+	codec_wr_control(SUNXI_ADC_ACTL, 0x3, 25, 0x1);
+	//enable VMIC
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, VMIC_EN, 0x1);
+
+	if (priv->id == SUN7I) {
+		/* boost up record effect */
+		codec_wr_control(SUNXI_DAC_TUNE, 0x3, 8, 0x3);
+	}
+
+	//enable adc digital
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_DIG_EN, 0x1);
+	//set RX FIFO mode
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, RX_FIFO_MODE, 0x1);
+	//flush RX FIFO
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_FIFO_FLUSH, 0x1);
+	//set RX FIFO rec drq level
+	codec_wr_control(SUNXI_ADC_FIFOC, 0xf, RX_TRI_LEVEL, 0x7);
+	//enable adc1 analog
+	codec_wr_control(SUNXI_ADC_ACTL, 0x3, ADC_EN, 0x3);
+	return 0;
+}
+
+static int codec_play_start(void)
+{
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+#endif
+	//flush TX FIFO
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x1, DAC_FIFO_FLUSH, 0x1);
+	//enable dac drq
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x1, DAC_DRQ, 0x1);
+	return 0;
+}
+
+static int codec_play_stop(void)
+{
+	//pa mute
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+#endif
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	mdelay(5);
+	//disable dac drq
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x1, DAC_DRQ, 0x0);
+	//pa mute
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x0);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x0);
+	return 0;
+}
+
+static int codec_capture_start(void)
+{
+	//enable adc drq
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+#endif
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_DRQ, 0x1);
+	return 0;
+}
+
+static int codec_capture_stop(struct card_data *priv)
+{
+	//disable adc drq
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_DRQ, 0x0);
+	//enable mic1 pa
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, MIC1_EN, 0x0);
+
+	//enable VMIC
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, VMIC_EN, 0x0);
+	if (priv->id == SUN7I) {
+		codec_wr_control(SUNXI_DAC_TUNE, 0x3, 8, 0x0);
+	}
+	//enable adc digital
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_DIG_EN, 0x0);
+	//set RX FIFO mode
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, RX_FIFO_MODE, 0x0);
+	//flush RX FIFO
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_FIFO_FLUSH, 0x0);
+	//enable adc1 analog
+	codec_wr_control(SUNXI_ADC_ACTL, 0x3, ADC_EN, 0x0);
+	return 0;
+}
+
+static int codec_dev_free(struct snd_device *device)
+{
+	return 0;
+}
+
+struct sunxi_controls {
+	
+};
+
+/*	对sunxi-codec.c各寄存器的各种设定，或读取。主要实现函数有三个.
+ * 	.info = snd_codec_info_volsw, .get = snd_codec_get_volsw,\.put = snd_codec_put_volsw,
+ * It should be noted that the only difference between sunxi and sun5i is the Master Playback Volume
+ */
+static const struct snd_kcontrol_new sun4i_dac[] = {
+	//FOR B C VERSION
+	CODEC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), CODEC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	CODEC_SINGLE("Fm Volume", SUNXI_DAC_ACTL, 23, 7, 0), //Fm 音量
+	CODEC_SINGLE("Line Volume", SUNXI_DAC_ACTL, 26, 1, 0), //Line音量
+	CODEC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	CODEC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	CODEC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	CODEC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	CODEC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	CODEC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	CODEC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
+	CODEC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+};
+
+static const struct snd_kcontrol_new sun4a_dac[] = {
+	//For A VERSION
+	CODEC_SINGLE("Master Playback Volume", SUNXI_DAC_DPC, 12, 0x3f, 0), //62 steps, 3e + 1 = 3f 主音量控制
+	CODEC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	CODEC_SINGLE("Fm Volume", SUNXI_DAC_ACTL, 23, 7, 0), //Fm 音量
+	CODEC_SINGLE("Line Volume", SUNXI_DAC_ACTL, 26, 1, 0), //Line音量
+	CODEC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	CODEC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	CODEC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	CODEC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	CODEC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	CODEC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	CODEC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0),
+	CODEC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+};
+
+static const struct snd_kcontrol_new sunxi_adc_controls[] = { 
+	CODEC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
+	CODEC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
+	CODEC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0),
+	CODEC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0), //录音音量
+	CODEC_SINGLE("Line Capture Volume", SUNXI_ADC_ACTL, 13, 7, 0), 
+	CODEC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
+	CODEC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
+	CODEC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
+	CODEC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), CODEC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), CODEC_SINGLE("ADC Input Mux",
+	SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
+};
+
+static const struct snd_kcontrol_new sun7i_dac_ctls[] = {
+	/*SUNXI_DAC_ACTL = 0x10,PAVOL*/
+	CODEC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0), 
+	CODEC_SINGLE("Playback Switch", SUNXI_DAC_ACTL, 6, 1, 0), //全局输出开关
+	CODEC_SINGLE("FmL Switch", SUNXI_DAC_ACTL, 17, 1, 0), //Fm左开关
+	CODEC_SINGLE("FmR Switch", SUNXI_DAC_ACTL, 16, 1, 0), //Fm右开关
+	CODEC_SINGLE("LineL Switch", SUNXI_DAC_ACTL, 19, 1, 0), //Line左开关
+	CODEC_SINGLE("LineR Switch", SUNXI_DAC_ACTL, 18, 1, 0), //Line右开关
+	CODEC_SINGLE("Ldac Left Mixer", SUNXI_DAC_ACTL, 15, 1, 0), 
+	CODEC_SINGLE("Rdac Right Mixer", SUNXI_DAC_ACTL, 14, 1, 0), 
+	CODEC_SINGLE("Ldac Right Mixer", SUNXI_DAC_ACTL, 13, 1, 0), 
+	CODEC_SINGLE("Mic Input Mux", SUNXI_DAC_ACTL, 9, 15, 0), //from bit 9 to bit 12.Mic（麦克风）输入静音
+	CODEC_SINGLE("MIC output volume", SUNXI_DAC_ACTL, 20, 7, 0),
+	/*	FM Input to output mixer Gain Control
+	* 	From -4.5db to 6db,1.5db/step,default is 0db
+	*	-4.5db:0x0,-3.0db:0x1,-1.5db:0x2,0db:0x3
+	*	1.5db:0x4,3.0db:0x5,4.5db:0x6,6db:0x7
+	*/
+	CODEC_SINGLE("Fm output Volume", SUNXI_DAC_ACTL, 23, 7, 0),
+	/*	Line-in gain stage to output mixer Gain Control
+	*	0:-1.5db,1:0db
+	*/
+	CODEC_SINGLE("Line output Volume", SUNXI_DAC_ACTL, 26, 1, 0),
+};
+
+static const struct snd_kcontrol_new sun7i_adc_ctls[] = { 
+	CODEC_SINGLE("Master Capture Mute", SUNXI_ADC_ACTL, 4, 1, 0), 
+	CODEC_SINGLE("Right Capture Mute", SUNXI_ADC_ACTL, 31, 1, 0), 
+	CODEC_SINGLE("Left Capture Mute", SUNXI_ADC_ACTL, 30, 1, 0), 
+	CODEC_SINGLE("Linein Pre-AMP", SUNXI_ADC_ACTL, 13, 7, 0), CODEC_SINGLE("LINEIN APM Volume", SUNXI_MIC_CRT, 13, 0x7, 0),
+	/* ADC Input Gain Control, capture volume
+	* 000:-4.5db,001:-3db,010:-1.5db,011:0db,100:1.5db,101:3db,110:4.5db,111:6db
+	*/
+	CODEC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0),
+	/*
+	*	MIC2 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	CODEC_SINGLE("MicL Volume", SUNXI_ADC_ACTL, 25, 3, 0), //mic左音量
+	CODEC_SINGLE("MicR Volume", SUNXI_ADC_ACTL, 23, 3, 0), //mic右音量
+	CODEC_SINGLE("Mic2 Boost", SUNXI_ADC_ACTL, 29, 1, 0), 
+	CODEC_SINGLE("Mic1 Boost", SUNXI_ADC_ACTL, 28, 1, 0), 
+	CODEC_SINGLE("Mic Power", SUNXI_ADC_ACTL, 27, 1, 0), 
+	CODEC_SINGLE("ADC Input Mux", SUNXI_ADC_ACTL, 17, 7, 0), //ADC输入静音
+	CODEC_SINGLE("Mic2 gain Volume", SUNXI_MIC_CRT, 26, 7, 0),
+	/*
+	*	MIC1 pre-amplifier Gain Control
+	*	00:0db,01:35db,10:38db,11:41db
+	*/
+	CODEC_SINGLE("Mic1 gain Volume", SUNXI_MIC_CRT, 29, 3, 0), 
+};
+
+int snd_chip_codec_mixer_new(struct card_data *priv)
+{
+	/*
+	 *	每个alsa预定义的组件在构造时需调用snd_device_new()，而每个组件的析构方法则在函数集中被包含
+	 *	对于PCM、AC97此类预定义组件，我们不需要关心它们的析构，而对于自定义的组件，则需要填充snd_device_ops
+	 *	中的析构函数指针dev_free，这样，当snd_card_free()被调用时，组件将被自动释放。
+	 */
+	static struct snd_device_ops ops = {
+		.dev_free = codec_dev_free,
+	};
+	unsigned char *clnt = "codec";
+	int idx;
+	int err;
+	/*
+	 *	snd_ctl_new1函数用于创建一个snd_kcontrol并返回其指针，
+	 *	snd_ctl_add函数用于将创建的snd_kcontrol添加到对应的card中。
+	 */
+	if (priv->id == SUN4A) {
+		if (has_playback)
+			for (idx = 0; idx < ARRAY_SIZE(sun4a_dac); idx++)
+				if ((err = snd_ctl_add(priv->card, snd_ctl_new1(&sun4a_dac[idx], clnt))) < 0)
+					return err;
+		if (has_capture)
+			for (idx = 0; idx < ARRAY_SIZE(sunxi_adc_controls); idx++)
+				if ((err = snd_ctl_add(priv->card, snd_ctl_new1(&sunxi_adc_controls[idx], clnt))) < 0)
+					return err;
+	} else if ((priv->id == SUN4I) || (priv->id == SUN5I)) {
+		
+		if (has_playback)
+			for (idx = 0; idx < ARRAY_SIZE(sun4i_dac); idx++)
+				if ((err = snd_ctl_add(priv->card, snd_ctl_new1(&sun4i_dac[idx], clnt))) < 0)
+					return err;
+		if (has_capture)
+			for (idx = 0; idx < ARRAY_SIZE(sunxi_adc_controls); idx++)
+				if ((err = snd_ctl_add(priv->card, snd_ctl_new1(&sunxi_adc_controls[idx], clnt))) < 0)
+					return err;
+	} else if (priv->id == SUN7I) {
+		if (has_playback)
+			for (idx = 0; idx < ARRAY_SIZE(sun7i_dac_ctls); idx++)
+				if ((err = snd_ctl_add(priv->card, snd_ctl_new1(&sun7i_dac_ctls[idx], clnt))) < 0)
+					return err;
+		if (has_capture)
+			for (idx = 0; idx < ARRAY_SIZE(sun7i_adc_ctls); idx++)
+				if ((err = snd_ctl_add(priv->card, snd_ctl_new1(&sun7i_adc_ctls[idx], clnt))) < 0)
+					return err;
+	}
+	/*
+	 *	当card被创建后，设备（组件）能够被创建并关联于该card。第一个参数是snd_card_create
+	 *	创建的card指针，第二个参数type指的是device-level即设备类型，形式为SNDRV_DEV_XXX,包括
+	 *	SNDRV_DEV_CODEC、SNDRV_DEV_CONTROL、SNDRV_DEV_PCM、SNDRV_DEV_RAWMIDI等、用户自定义的
+	 *	设备的device-level是SNDRV_DEV_LOWLEVEL，ops参数是1个函数集（snd_device_ops结构体）的
+	 *	指针，device_data是设备数据指针，snd_device_new本身不会分配设备数据的内存，因此事先应
+	 *	分配。在这里在snd_card_create分配。
+	 */
+	if ((err = snd_device_new(priv->card, SNDRV_DEV_CODEC, clnt, &ops)) < 0) {
+		return err;
+	}
+
+	strcpy(priv->card->mixername, "codec Mixer");
+
+	return 0;
+}
+
+static void sunxi_pcm_enqueue(struct snd_pcm_substream *substream)
+{
+	int play_ret = 0, capture_ret = 0;
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+	dma_addr_t play_pos = 0, capture_pos = 0;
+	unsigned long play_len = 0, capture_len = 0;
+	unsigned int play_limit = 0, capture_limit = 0;
+	
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		play_prtd = substream->runtime->private_data;
+		play_pos = play_prtd->dma_pos;
+		play_len = play_prtd->dma_period;
+		play_limit = play_prtd->dma_limit;
+		while (play_prtd->dma_loaded < play_limit) {
+			if ((play_pos + play_len) > play_prtd->dma_end) {
+				play_len = play_prtd->dma_end - play_pos;
+			}
+//JDS			play_ret = sunxi_dma_enqueue(play_prtd->params, play_pos, play_len, 0);
+			if (play_ret == 0) {
+				play_prtd->dma_loaded++;
+				play_pos += play_prtd->dma_period;
+				if (play_pos >= play_prtd->dma_end)
+					play_pos = play_prtd->dma_start;
+			} else {
+				break;
+			}
+		}
+		play_prtd->dma_pos = play_pos;
+	} else {
+		capture_prtd = substream->runtime->private_data;
+		capture_pos = capture_prtd->dma_pos;
+		capture_len = capture_prtd->dma_period;
+		capture_limit = capture_prtd->dma_limit;
+		while (capture_prtd->dma_loaded < capture_limit) {
+			if ((capture_pos + capture_len) > capture_prtd->dma_end) {
+				capture_len = capture_prtd->dma_end - capture_pos;
+			}
+//JDS			capture_ret = sunxi_dma_enqueue(capture_prtd->params, capture_pos, capture_len, 1);
+			if (capture_ret == 0) {
+				capture_prtd->dma_loaded++;
+				capture_pos += capture_prtd->dma_period;
+				if (capture_pos >= capture_prtd->dma_end)
+					capture_pos = capture_prtd->dma_start;
+			} else {
+				break;
+			}
+		}
+		capture_prtd->dma_pos = capture_pos;
+	}
+}
+
+static void sunxi_audio_capture_buffdone(struct sunxi_dma_params *dma, void *dev_id)
+{
+	struct sunxi_capture_runtime_data *capture_prtd;
+	struct snd_pcm_substream *substream = dev_id;
+
+	capture_prtd = substream->runtime->private_data;
+	if (substream) {
+		snd_pcm_period_elapsed(substream);
+	}
+
+	spin_lock(&capture_prtd->lock);
+	{
+		capture_prtd->dma_loaded--;
+		sunxi_pcm_enqueue(substream);
+	}
+	spin_unlock(&capture_prtd->lock);
+}
+
+static void sunxi_audio_play_buffdone(struct sunxi_dma_params *dma, void *dev_id)
+{
+	struct sunxi_playback_runtime_data *play_prtd;
+	struct snd_pcm_substream *substream = dev_id;
+
+	play_prtd = substream->runtime->private_data;
+	if (substream) {
+		snd_pcm_period_elapsed(substream);
+	}
+
+	spin_lock(&play_prtd->lock);
+	{
+		play_prtd->dma_loaded--;
+		sunxi_pcm_enqueue(substream);
+	}
+	spin_unlock(&play_prtd->lock);
+}
+
+static snd_pcm_uframes_t snd_sunxi_codec_pointer(struct snd_pcm_substream *substream)
+{
+	unsigned long play_res = 0, capture_res = 0;
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		play_prtd = substream->runtime->private_data;
+		spin_lock(&play_prtd->lock);
+//JDS		sunxi_dma_getcurposition(play_prtd->params, (dma_addr_t*) &play_dmasrc, (dma_addr_t*) &play_dmadst);
+		play_res = play_dmasrc + play_prtd->dma_period - play_prtd->dma_start;
+		spin_unlock(&play_prtd->lock);
+		if (play_res >= snd_pcm_lib_buffer_bytes(substream)) {
+			if (play_res == snd_pcm_lib_buffer_bytes(substream))
+				play_res = 0;
+		}
+		return bytes_to_frames(substream->runtime, play_res);
+	} else {
+		capture_prtd = substream->runtime->private_data;
+		spin_lock(&capture_prtd->lock);
+//JDS		sunxi_dma_getcurposition(capture_prtd->params, (dma_addr_t*) &capture_dmasrc, (dma_addr_t*) &capture_dmadst);
+		capture_res = capture_dmadst + capture_prtd->dma_period - capture_prtd->dma_start;
+		spin_unlock(&capture_prtd->lock);
+		if (capture_res >= snd_pcm_lib_buffer_bytes(substream)) {
+			if (capture_res == snd_pcm_lib_buffer_bytes(substream))
+				capture_res = 0;
+		}
+		return bytes_to_frames(substream->runtime, capture_res);
+	}
+}
+
+static int sunxi_codec_pcm_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)
+{
+	int play_ret = 0, capture_ret = 0;
+	struct snd_pcm_runtime *play_runtime = NULL, *capture_runtime = NULL;
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+	unsigned long play_totbytes = 0, capture_totbytes = 0;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		play_runtime = substream->runtime;
+		play_prtd = play_runtime->private_data;
+		play_totbytes = params_buffer_bytes(params);
+		snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+		if (play_prtd->params == NULL) {
+//JDS			play_prtd->params = &sunxi_codec_pcm_stereo_play;
+//JDS			play_ret = sunxi_dma_request(play_prtd->params, 0);
+			if (play_ret < 0) {
+				printk(KERN_ERR "failed to get dma channel. ret == %d\n", play_ret);
+				return play_ret;
+			}
+//JDS			play_ret = sunxi_dma_set_callback(play_prtd->params, sunxi_audio_play_buffdone, substream);
+			if (play_ret < 0) {
+				printk(KERN_ERR "failed to set dma callback. ret == %d\n", play_ret);
+//JDS				sunxi_dma_release(play_prtd->params);
+				play_prtd->params = NULL;
+				return play_ret;
+			}
+			snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+			play_runtime->dma_bytes = play_totbytes;
+			spin_lock_irq(&play_prtd->lock);
+			play_prtd->dma_loaded = 0;
+			play_prtd->dma_limit = play_runtime->hw.periods_min;
+			play_prtd->dma_period = params_period_bytes(params);
+			play_prtd->dma_start = play_runtime->dma_addr;
+
+			play_dmasrc = play_prtd->dma_start;
+			play_prtd->dma_pos = play_prtd->dma_start;
+			play_prtd->dma_end = play_prtd->dma_start + play_totbytes;
+
+			spin_unlock_irq(&play_prtd->lock);
+		}
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		capture_runtime = substream->runtime;
+		capture_prtd = capture_runtime->private_data;
+		capture_totbytes = params_buffer_bytes(params);
+		snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+		if (capture_prtd->params == NULL) {
+//JDS			capture_prtd->params = &sunxi_codec_pcm_stereo_capture;
+//JDS			capture_ret = sunxi_dma_request(capture_prtd->params, 0);
+			if (capture_ret < 0) {
+				printk(KERN_ERR "failed to get dma channel. capture_ret == %d\n", capture_ret);
+				return capture_ret;
+			}
+//JDS			capture_ret = sunxi_dma_set_callback(capture_prtd->params, sunxi_audio_capture_buffdone, substream);
+			if (capture_ret < 0) {
+				printk(KERN_ERR "failed to set dma callback. capture_ret == %d\n", capture_ret);
+//JDS				sunxi_dma_release(capture_prtd->params);
+				capture_prtd->params = NULL;
+				return capture_ret;
+			}
+			snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+			capture_runtime->dma_bytes = capture_totbytes;
+			spin_lock_irq(&capture_prtd->lock);
+			capture_prtd->dma_loaded = 0;
+			capture_prtd->dma_limit = capture_runtime->hw.periods_min;
+			capture_prtd->dma_period = params_period_bytes(params);
+			capture_prtd->dma_start = capture_runtime->dma_addr;
+
+			capture_dmadst = capture_prtd->dma_start;
+			capture_prtd->dma_pos = capture_prtd->dma_start;
+			capture_prtd->dma_end = capture_prtd->dma_start + capture_totbytes;
+
+			spin_unlock_irq(&capture_prtd->lock);
+		}
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int snd_sunxi_codec_hw_free(struct snd_pcm_substream *substream)
+{
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		play_prtd = substream->runtime->private_data;
+#ifdef JDS
+		if (play_prtd->params)
+			sunxi_dma_flush(play_prtd->params);
+		snd_pcm_set_runtime_buffer(substream, NULL);
+		if (play_prtd->params) {
+			sunxi_dma_stop(play_prtd->params);
+			sunxi_dma_release(play_prtd->params);
+			play_prtd->params = NULL;
+			/*
+			 * Clear out the DMA and any allocated buffers.
+			 */
+			snd_pcm_lib_free_pages(substream);
+		}
+#endif
+	} else {
+		capture_prtd = substream->runtime->private_data;
+#ifdef JDS		
+		if (capture_prtd->params)
+			sunxi_dma_flush(capture_prtd->params);
+		snd_pcm_set_runtime_buffer(substream, NULL);
+		if (capture_prtd->params) {
+			sunxi_dma_stop(capture_prtd->params);
+			sunxi_dma_release(capture_prtd->params);
+			capture_prtd->params = NULL;
+			/*
+			 * Clear out the DMA and any allocated buffers.
+			 */
+			snd_pcm_lib_free_pages(substream);
+		}
+#endif
+	}
+	return 0;
+}
+
+static int snd_sunxi_codec_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct card_data *priv = rtd->cpu_dai->dev->platform_data;
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	struct dma_hw_conf codec_play_dma_conf;
+	struct dma_hw_conf codec_capture_dma_conf;
+#else
+#ifdef JDS
+	dma_config_t codec_play_dma_conf;
+	dma_config_t codec_capture_dma_conf;
+#endif
+#endif
+
+	int play_ret = 0, capture_ret = 0;
+	unsigned int reg_val;
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		switch (substream->runtime->rate) {
+		case 44100:
+			clk_set_rate(codec_pll2clk, 22579200);
+			clk_set_rate(codec_moduleclk, 22579200);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (0 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+
+			break;
+		case 22050:
+			clk_set_rate(codec_pll2clk, 22579200);
+			clk_set_rate(codec_moduleclk, 22579200);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (2 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 11025:
+			clk_set_rate(codec_pll2clk, 22579200);
+			clk_set_rate(codec_moduleclk, 22579200);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (4 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 48000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (0 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 96000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (7 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 192000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (6 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 32000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (1 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 24000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (2 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 16000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (3 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 12000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (4 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 8000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (5 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		default:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (0 << 29);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		}
+
+		switch (substream->runtime->channels) {
+		case 1:
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val |= (1 << 6);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		case 2:
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(1 << 6);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		default:
+			reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+			reg_val &= ~(1 << 6);
+			writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+			break;
+		}
+	} else {
+		switch (substream->runtime->rate) {
+		case 44100:
+			clk_set_rate(codec_pll2clk, 22579200);
+			clk_set_rate(codec_moduleclk, 22579200);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (0 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+
+			break;
+		case 22050:
+			clk_set_rate(codec_pll2clk, 22579200);
+			clk_set_rate(codec_moduleclk, 22579200);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (2 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 11025:
+			clk_set_rate(codec_pll2clk, 22579200);
+			clk_set_rate(codec_moduleclk, 22579200);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (4 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 48000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (0 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 32000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (1 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 24000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (2 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 16000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (3 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 12000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (4 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 8000:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (5 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		default:
+			clk_set_rate(codec_pll2clk, 24576000);
+			clk_set_rate(codec_moduleclk, 24576000);
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(7 << 29);
+			reg_val |= (0 << 29);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		}
+
+		switch (substream->runtime->channels) {
+		case 1:
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val |= (1 << 7);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		case 2:
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(1 << 7);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		default:
+			reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+			reg_val &= ~(1 << 7);
+			writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		}
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		play_prtd = substream->runtime->private_data;
+		/* return if this is a bufferless transfer e.g.
+		 * codec <--> BT codec or GSM modem -- lg FIXME */
+		if (!play_prtd->params)
+			return 0;
+		//open the dac channel register
+		codec_play_open(substream);
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+
+		codec_play_dma_conf.drqsrc_type = D_DRQSRC_SDRAM;
+		codec_play_dma_conf.drqdst_type = DRQ_TYPE_AUDIO;
+		codec_play_dma_conf.xfer_type = DMAXFER_D_BHALF_S_BHALF;
+		codec_play_dma_conf.address_type = DMAADDRT_D_FIX_S_INC;
+		codec_play_dma_conf.dir = SW_DMA_WDEV;
+		codec_play_dma_conf.reload = 0;
+		codec_play_dma_conf.hf_irq = SW_DMA_IRQ_FULL;
+		codec_play_dma_conf.from = play_prtd->dma_start;
+		codec_play_dma_conf.to = play_prtd->params->dma_addr;
+#else
+#ifdef JDS
+		memset(&codec_play_dma_conf, 0, sizeof(codec_play_dma_conf));
+		codec_play_dma_conf.xfer_type.src_data_width = DATA_WIDTH_16BIT;
+		codec_play_dma_conf.xfer_type.src_bst_len = DATA_BRST_4;
+		codec_play_dma_conf.xfer_type.dst_data_width = DATA_WIDTH_16BIT;
+		codec_play_dma_conf.xfer_type.dst_bst_len = DATA_BRST_4;
+		codec_play_dma_conf.address_type.src_addr_mode = NDMA_ADDR_INCREMENT;
+		codec_play_dma_conf.address_type.dst_addr_mode = NDMA_ADDR_NOCHANGE;
+		codec_play_dma_conf.src_drq_type = N_SRC_SDRAM;
+		codec_play_dma_conf.dst_drq_type = N_DST_AUDIO_CODEC_DA;
+		codec_play_dma_conf.bconti_mode = false;
+		codec_play_dma_conf.irq_spt = CHAN_IRQ_FD;
+#endif
+#endif
+
+//JDS		play_ret = sunxi_dma_config(play_prtd->params, &codec_play_dma_conf, 0);
+		/* flush the DMA channel */
+		play_prtd->dma_loaded = 0;
+//JDS		if (sunxi_dma_flush(play_prtd->params) == 0)
+//JDS			play_prtd->dma_pos = play_prtd->dma_start;
+		/* enqueue dma buffers */
+		sunxi_pcm_enqueue(substream);
+		return play_ret;
+	} else {
+		capture_prtd = substream->runtime->private_data;
+		/* return if this is a bufferless transfer e.g.
+		 * codec <--> BT codec or GSM modem -- lg FIXME */
+		if (!capture_prtd->params)
+			return 0;
+		//open the adc channel register
+		codec_capture_open(priv);
+		//set the dma
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+
+		codec_capture_dma_conf.drqsrc_type = DRQ_TYPE_AUDIO;
+		codec_capture_dma_conf.drqdst_type = D_DRQSRC_SDRAM;
+		codec_capture_dma_conf.xfer_type = DMAXFER_D_BHALF_S_BHALF;
+		codec_capture_dma_conf.address_type = DMAADDRT_D_INC_S_FIX;
+		codec_capture_dma_conf.dir = SW_DMA_RDEV;
+		codec_capture_dma_conf.reload = 0;
+		codec_capture_dma_conf.hf_irq = SW_DMA_IRQ_FULL;
+		codec_capture_dma_conf.from = capture_prtd->params->dma_addr;
+		codec_capture_dma_conf.to = capture_prtd->dma_start;
+#else
+#ifdef JDS
+		memset(&codec_capture_dma_conf, 0, sizeof(codec_capture_dma_conf));
+		codec_capture_dma_conf.xfer_type.src_data_width = DATA_WIDTH_16BIT;
+		codec_capture_dma_conf.xfer_type.src_bst_len = DATA_BRST_4;
+		codec_capture_dma_conf.xfer_type.dst_data_width = DATA_WIDTH_16BIT;
+		codec_capture_dma_conf.xfer_type.dst_bst_len = DATA_BRST_4;
+		codec_capture_dma_conf.address_type.src_addr_mode = NDMA_ADDR_NOCHANGE;
+		codec_capture_dma_conf.address_type.dst_addr_mode = NDMA_ADDR_INCREMENT;
+		codec_capture_dma_conf.src_drq_type = N_SRC_AUDIO_CODEC_AD;
+		codec_capture_dma_conf.dst_drq_type = N_DST_SDRAM;
+		codec_capture_dma_conf.bconti_mode = false;
+		codec_capture_dma_conf.irq_spt = CHAN_IRQ_FD;
+#endif
+#endif
+
+//JDS		capture_ret = sunxi_dma_config(capture_prtd->params, &codec_capture_dma_conf, 0);
+		/* flush the DMA channel */
+		capture_prtd->dma_loaded = 0;
+//JDS		if (sunxi_dma_flush(capture_prtd->params) == 0)
+//JDS			capture_prtd->dma_pos = capture_prtd->dma_start;
+
+		/* enqueue dma buffers */
+		sunxi_pcm_enqueue(substream);
+		return capture_ret;
+	}
+}
+
+static int snd_sunxi_codec_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct card_data *priv = rtd->cpu_dai->dev->platform_data;
+	int play_ret = 0, capture_ret = 0;
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		play_prtd = substream->runtime->private_data;
+		spin_lock(&play_prtd->lock);
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			play_prtd->state |= ST_RUNNING;
+			codec_play_start();
+			sunxi_pcm_enqueue(substream);
+//JDS			sunxi_dma_start(play_prtd->params);
+			if (substream->runtime->rate >= 192000) {
+			} else if (substream->runtime->rate > 22050) {
+				mdelay(2);
+			} else {
+				mdelay(7);
+			}
+			//pa unmute
+			codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x1);
+			break;
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+			codec_play_stop();
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+			play_prtd->state &= ~ST_RUNNING;
+			codec_play_stop();
+//JDS			sunxi_dma_stop(play_prtd->params);
+			break;
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			play_prtd->state &= ~ST_RUNNING;
+//JDS			sunxi_dma_stop(play_prtd->params);
+			play_prtd->dma_loaded = 0;
+			break;
+		default:
+			printk("error:%s,%d\n", __func__, __LINE__);
+			play_ret = -EINVAL;
+			break;
+		}
+		spin_unlock(&play_prtd->lock);
+	} else {
+		capture_prtd = substream->runtime->private_data;
+		spin_lock(&capture_prtd->lock);
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			capture_prtd->state |= ST_RUNNING;
+			codec_capture_start();
+			mdelay(1);
+			codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_FIFO_FLUSH, 0x1);
+//JDS			sunxi_dma_start(capture_prtd->params);
+			break;
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+			codec_capture_stop(priv);
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+			capture_prtd->state &= ~ST_RUNNING;
+			codec_capture_stop(priv);
+//JDS			sunxi_dma_stop(capture_prtd->params);
+			break;
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			capture_prtd->state &= ~ST_RUNNING;
+//JDS			sunxi_dma_stop(capture_prtd->params);
+			break;
+		default:
+			printk("error:%s,%d\n", __func__, __LINE__);
+			capture_ret = -EINVAL;
+			break;
+		}
+		spin_unlock(&capture_prtd->lock);
+	}
+	return 0;
+}
+
+static int snd_sunxicard_capture_open(struct snd_pcm_substream *substream)
+{
+	/*获得PCM运行时信息指针*/
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err;
+	struct sunxi_capture_runtime_data *capture_prtd;
+
+	capture_prtd = kzalloc(sizeof(struct sunxi_capture_runtime_data), GFP_KERNEL);
+	if (capture_prtd == NULL)
+		return -ENOMEM;
+
+	spin_lock_init(&capture_prtd->lock);
+
+	runtime->private_data = capture_prtd;
+
+	runtime->hw = sunxi_pcm_capture_hardware;
+
+	/* ensure that buffer size is a multiple of period size */
+	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+	if ((err = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates)) < 0)
+		return err;
+
+	return 0;
+}
+
+static int snd_sunxicard_capture_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	kfree(runtime->private_data);
+	return 0;
+}
+
+static int snd_sunxicard_playback_open(struct snd_pcm_substream *substream)
+{
+	/*获得PCM运行时信息指针*/
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err;
+	struct sunxi_playback_runtime_data *play_prtd;
+
+	play_prtd = kzalloc(sizeof(struct sunxi_playback_runtime_data), GFP_KERNEL);
+	if (play_prtd == NULL)
+		return -ENOMEM;
+
+	spin_lock_init(&play_prtd->lock);
+
+	runtime->private_data = play_prtd;
+
+	runtime->hw = sunxi_pcm_playback_hardware;
+
+	/* ensure that buffer size is a multiple of period size */
+	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+	if ((err = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates)) < 0)
+		return err;
+
+	return 0;
+}
+
+static int snd_sunxicard_playback_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	kfree(runtime->private_data);
+	return 0;
+}
+
+static struct snd_pcm_ops sunxi_pcm_playback_ops =
+{
+	.open = snd_sunxicard_playback_open, //打开
+	.close = snd_sunxicard_playback_close,//关闭
+	.ioctl = snd_pcm_lib_ioctl,//I/O控制
+	.hw_params = sunxi_codec_pcm_hw_params,//硬件参数
+	.hw_free = snd_sunxi_codec_hw_free,//资源释放
+	.prepare = snd_sunxi_codec_prepare,//准备
+	.trigger = snd_sunxi_codec_trigger,//在pcm被开始、停止或暂停时调用
+	.pointer = snd_sunxi_codec_pointer,//当前缓冲区的硬件位置
+};
+
+static struct snd_pcm_ops sunxi_pcm_capture_ops =
+{
+	.open = snd_sunxicard_capture_open, //打开
+	.close = snd_sunxicard_capture_close,//关闭
+	.ioctl = snd_pcm_lib_ioctl,//I/O控制
+	.hw_params = sunxi_codec_pcm_hw_params,//硬件参数
+	.hw_free = snd_sunxi_codec_hw_free,//资源释放
+	.prepare = snd_sunxi_codec_prepare,//准备
+	.trigger = snd_sunxi_codec_trigger,//在pcm被开始、停止或暂停时调用
+	.pointer = snd_sunxi_codec_pointer,//当前缓冲区的硬件位置
+};
+
+static int snd_card_sunxi_codec_pcm(struct card_data *card_data, int device)
+{
+	struct snd_pcm *pcm;
+	int err;
+
+	/*创建PCM实例*/
+	err = snd_pcm_new(card_data->card, "M1 PCM", device,
+			has_playback, has_capture, &pcm);
+	if (err < 0) {
+		pr_err("snd_pcm_new M1 PCM failed: %d\n", err);
+		return err;
+	}
+
+	/*
+	 * this sets up our initial buffers and sets the dma_type to isa.
+	 * isa works but I'm not sure why (or if) it's the right choice
+	 * this may be too large, trying it for now
+	 */
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+			snd_dma_isa_data(),
+			32*1024, 32*1024);
+	/*
+	 *	设置PCM操作，第1个参数是snd_pcm的指针，第2 个参数是SNDRV_PCM_STREAM_PLAYBACK
+	 *	或SNDRV_ PCM_STREAM_CAPTURE，而第3 个参数是PCM 操作结构体snd_pcm_ops
+	 */
+	if (has_playback)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &sunxi_pcm_playback_ops);
+	if (has_capture)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &sunxi_pcm_capture_ops);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &sunxi_pcm_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &sunxi_pcm_capture_ops);
+	pcm->private_data = card_data; //置pcm->private_data为芯片特定数据
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "sunxi PCM");
+	/* setup DMA controller */
+
+	return 0;
+}
+
+void snd_sunxi_codec_free(struct snd_card *card)
+{
+}
+
+static void codec_resume_events(struct work_struct *work)
+{
+	printk("%s,%d\n", __func__, __LINE__);
+#ifdef JDS
+	if (sunxi_is_sun7i())
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	else
+		codec_wr_control(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x1);
+#endif
+	msleep(20);
+	//enable PA
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x1);
+	msleep(550);
+	//enable dac analog
+#ifdef JDS
+	if (sunxi_is_sun7i()) {
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x1);
+		codec_wr_control(SUNXI_ADC_ACTL, 0x1, 8, 0x0);
+	} else {
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x1);
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x1);
+
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x1);
+	}
+#endif
+	if (gpio_pa_shutdown) {
+		msleep(50);
+//JDS		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+	}
+}
+
+static const struct of_device_id snd_sunxi_codec_ids[] = {
+	{ .compatible = "allwinner,sun4i-a10a-codec", .data = (void *)SUN4A},
+	{ .compatible = "allwinner,sun4i-a10-codec", .data = (void *)SUN4I},
+	{ .compatible = "allwinner,sun5i-a13-codec", .data = (void *)SUN5I},
+	{ .compatible = "allwinner,sun7i-a20-codec", .data = (void *)SUN7I},
+	{}
+};
+MODULE_DEVICE_TABLE(of, snd_sunxi_codec_ids);
+
+static int sunxi_codec_probe(struct platform_device *pdev)
+{
+	struct dma_slave_config dma_sconfig;
+	struct snd_card *card;
+	struct card_data *priv;
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	const struct of_device_id *of_id;
+	int err;
+	int ret;
+
+	has_playback = 1; 
+	has_capture = 1;
+	
+	/* Clock */
+	codec_apbclk = devm_clk_get(dev, "apb");
+	if (IS_ERR(codec_apbclk)) {
+		dev_err(dev, "failed to get apb clock.\n");
+		return PTR_ERR(codec_apbclk);
+	}
+	codec_pll2clk = devm_clk_get(dev, "pll2");
+	if (IS_ERR(codec_pll2clk)) {
+		dev_err(dev, "failed to get pll2 clock.\n");
+		return PTR_ERR(codec_pll2clk);
+	}
+	codec_moduleclk = devm_clk_get(dev, "codec");
+	if (IS_ERR(codec_moduleclk)) {
+		dev_err(dev, "failed to get codec clock.\n");
+		return PTR_ERR(codec_moduleclk);
+	}
+	ret = clk_set_rate(codec_pll2clk, 24576000);
+	if (ret) {
+		dev_err(dev, "set codec base clock failed!\n");
+		return ret;
+	}
+	if (clk_prepare_enable(codec_pll2clk)) {
+		dev_err(dev, "try to enable codec_pll2clk failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(codec_apbclk)) {
+		dev_err(dev, "try to enable apb_codec_clk failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(codec_moduleclk)) {
+		dev_err(dev, "try to enable codec failed\n");
+		ret = -EINVAL;
+		goto exit_clkdisable_apb_clk;
+	}
+	
+	ret = snd_card_create(0, "sunxi-codec", THIS_MODULE, sizeof(struct card_data),
+			      &card);
+	if (ret != 0) {
+		return -ENOMEM;
+	}
+	/*从private_data中取出分配的内存大小*/
+	priv = card->private_data;
+	/*声卡芯片的专用数据*/
+	card->private_free = snd_sunxi_codec_free; //card私有数据释放
+	
+	of_id = of_match_device(snd_sunxi_codec_ids, &pdev->dev);
+	priv->id = (int)of_id->data;
+	
+	priv->card = card;
+	priv->samplerate = AUDIO_RATE_DEFAULT;
+
+	/* IO */
+	priv->codec_base_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->dev = &pdev->dev;
+
+	if (priv->codec_base_res == NULL) {
+		ret = -ENOENT;
+		printk("codec insufficient resources\n");
+		goto out;
+	}
+	/* codec address remap */
+	priv->codec_base_req = request_mem_region(priv->codec_base_res->start, 0x40, pdev->name);
+	if (priv->codec_base_req == NULL) {
+		ret = -EIO;
+		printk("cannot claim codec address reg area\n");
+		goto out;
+	}
+	baseaddr = ioremap(priv->codec_base_res->start, 0x40);
+
+	if (baseaddr == NULL) {
+		ret = -EINVAL;
+		dev_err(priv->dev,"failed to ioremap codec address reg\n");
+		goto out;
+	}
+#ifdef JDS
+printk("jds - widgets");
+	/* off-codec widgets */
+	if (of_property_read_bool(np, "widgets")) {
+		ret = snd_soc_of_parse_audio_simple_widgets(&priv->snd_card, "widgets");
+		if (ret)
+			return ret;
+	}
+
+printk("jds - routes");
+	/* DAPM routes */
+	if (of_property_read_bool(np, "routing")) {
+		ret = snd_soc_of_parse_audio_routing(&priv->snd_card, "routing");
+		if (ret)
+			return ret;
+	}
+#endif
+	
+	priv->tx_dma_chan = dma_request_slave_channel_reason(&pdev->dev, "tx");
+	if (IS_ERR(priv->tx_dma_chan)) {
+		dev_err(priv->dev, "Unable to acquire DMA channel TX\n");
+		ret = PTR_ERR(priv->tx_dma_chan);
+		goto err_free_master;
+	}
+
+	dma_sconfig.direction = DMA_MEM_TO_DEV;
+	dma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	dma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	dma_sconfig.dst_addr = priv->codec_base_res->start + SUNXI_DAC_TXDATA;
+	dma_sconfig.src_maxburst = 1;
+	dma_sconfig.dst_maxburst = 1;
+
+	ret = dmaengine_slave_config(priv->tx_dma_chan, &dma_sconfig);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to configure TX DMA slave\n");
+		goto err_tx_dma_release;
+	}
+
+	priv->rx_dma_chan = dma_request_slave_channel_reason(&pdev->dev, "rx");
+	if (IS_ERR(priv->rx_dma_chan)) {
+		dev_err(&pdev->dev, "Unable to acquire DMA channel RX\n");
+		ret = PTR_ERR(priv->rx_dma_chan);
+		goto err_tx_dma_release;
+	}
+
+	dma_sconfig.direction = DMA_DEV_TO_MEM;
+	dma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	dma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	dma_sconfig.src_addr = priv->codec_base_res->start + SUNXI_ADC_RXDATA;
+	dma_sconfig.src_maxburst = 1;
+	dma_sconfig.dst_maxburst = 1;
+
+	ret = dmaengine_slave_config(priv->rx_dma_chan, &dma_sconfig);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to configure RX DMA slave\n");
+		goto err_rx_dma_release;
+	}
+
+	/*
+	 *	mixer,注册control(mixer)接口
+	 *	创建一个control至少要实现snd_kcontrol_new中的info(),get()和put()这三个成员函数
+	 */
+	if ((err = snd_chip_codec_mixer_new(priv)))
+		goto nodev;
+
+	/*
+	 *	PCM,录音放音相关，注册PCM接口
+	 */
+	if ((err = snd_card_sunxi_codec_pcm(priv, 0)) < 0)
+		goto nodev;
+
+	strcpy(card->driver, "sunxi-CODEC");
+	strcpy(card->shortname, "sunxi-CODEC");
+	sprintf(card->longname, "sunxi-CODEC  Audio Codec");
+
+	snd_card_set_dev(card, &pdev->dev);
+
+	//注册card
+	if ((err = snd_card_register(card)) == 0) {
+		platform_set_drvdata(pdev, card);
+	} else {
+		return err;
+	}
+
+#ifdef JDS
+	gpio_pa_shutdown = gpio_request_ex("audio_para", "audio_pa_ctrl");
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+#endif
+	codec_init(priv);
+#ifdef JDS
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+#endif
+	resume_work_queue = create_singlethread_workqueue("codec_resume");
+	if (resume_work_queue == NULL) {
+		printk("[su4i-codec] try to create workqueue for codec failed!\n");
+		ret = -ENOMEM;
+		goto err_resume_work_queue;
+	}
+	printk("jds - codec ok, %s\n", of_id->compatible);
+	return 0;
+	
+err_rx_dma_release:
+err_free_master:
+err_tx_dma_release:
+err_resume_work_queue:
+out:
+	dev_err(priv->dev, "not found (%d).\n", ret);
+exit_clkdisable_clk:
+	clk_disable_unprepare(codec_moduleclk);
+exit_clkdisable_apb_clk:
+	clk_disable_unprepare(codec_apbclk);
+
+nodev:
+	snd_card_free(card);
+	return err;
+}
+
+/*	suspend state,先disable左右声道，然后静音，再disable pa(放大器)，
+ *	disable 耳机，disable dac->pa，最后disable DAC
+ * 	顺序不可调，否则刚关闭声卡的时候可能出现噪音
+ */
+static int snd_sunxi_codec_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	printk("[audio codec]:suspend start5000\n");
+	if (gpio_pa_shutdown) {
+//JDS		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+		mdelay(50);
+	}
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x0);
+	mdelay(100);
+	//pa mute
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	mdelay(500);
+	//disable dac analog
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x0);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x0);
+
+	//disable dac to pa
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x0);
+	codec_wr_control(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x0);
+
+	clk_disable(codec_moduleclk);
+	printk("[audio codec]:suspend end\n");
+	return 0;
+}
+
+/*	resume state,先unmute，
+ *	再enable DAC，enable L/R DAC,enable PA，
+ * 	enable 耳机，enable dac to pa
+ *	顺序不可调，否则刚打开声卡的时候可能出现噪音
+ */
+static int snd_sunxi_codec_resume(struct platform_device *pdev)
+{
+	printk("[audio codec]:resume start\n");
+	if (-1 == clk_enable(codec_moduleclk)) {
+		printk("open codec_moduleclk failed; \n");
+	}
+
+	queue_work(resume_work_queue, &codec_resume_work);
+	printk("[audio codec]:resume end\n");
+	return 0;
+}
+
+static int sunxi_codec_remove(struct platform_device *devptr)
+{
+	clk_disable(codec_moduleclk);
+	//释放codec_pll2clk时钟句柄
+	clk_put(codec_pll2clk);
+	//释放codec_apbclk时钟句柄
+	clk_put(codec_apbclk);
+
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+	return 0;
+}
+
+static void sunxi_codec_shutdown(struct platform_device *devptr)
+{
+	if (gpio_pa_shutdown) {
+//JDS		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+		mdelay(50);
+	}
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x0);
+	mdelay(100);
+	//pa mute
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	mdelay(500);
+	//disable dac analog
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_L, 0x0);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACAEN_R, 0x0);
+
+	//disable dac to pa
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, DACPAS, 0x0);
+	codec_wr_control(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x0);
+
+	clk_disable(codec_moduleclk);
+}
+
+/*method relating*/
+static struct platform_driver sunxi_codec_driver =
+{
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_remove,
+	.shutdown = sunxi_codec_shutdown,
+#ifdef CONFIG_PM
+	.suspend = snd_sunxi_codec_suspend,
+	.resume = snd_sunxi_codec_resume,
+#endif
+	.driver = {
+		.name = "sunxi-codec",
+		.of_match_table = snd_sunxi_codec_ids,
+	},
+};
+
+module_platform_driver(sunxi_codec_driver);
+
+MODULE_ALIAS("platform:sunxi-codec-dai");
+MODULE_DESCRIPTION("sunxi CODEC ALSA codec driver");
+MODULE_AUTHOR("software");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/sunxi/sunxi-codec.h b/sound/soc/sunxi/sunxi-codec.h
new file mode 100644
index 0000000..4e12b42
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-codec.h
@@ -0,0 +1,137 @@
+/*
+ * sound/soc/sunxi/sunxi-codec.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef _SUNXI_CODEC_H
+#define _SUNXI_CODEC_H
+
+//Codec Register
+#define CODEC_BASSADDRESS         (0x01c22c00)
+#define SUNXI_DAC_DPC                (0x00)
+#define SUNXI_DAC_FIFOC              (0x04)
+#define SUNXI_DAC_FIFOS              (0x08)
+#define SUNXI_DAC_TXDATA             (0x0c)
+#define SUNXI_DAC_ACTL               (0x10)
+#define SUNXI_DAC_TUNE               (0x14)
+#define SUNXI_DAC_DEBUG              (0x18)
+#define SUNXI_ADC_FIFOC              (0x1c)
+#define SUNXI_ADC_FIFOS              (0x20)
+#define SUNXI_ADC_RXDATA             (0x24)
+#define SUNXI_ADC_ACTL               (0x28)
+#define SUNXI_ADC_DEBUG              (0x2c)
+#define SUNXI_DAC_TXCNT              (0x30)
+#define SUNXI_ADC_RXCNT              (0x34)
+#define SUNXI_BIAS_CRT               (0x38)
+#define SUNXI_MIC_CRT                (0x3c)
+#define SUNXI_CODEC_REGS_NUM         (13)
+
+#define DAIFMT_16BITS             (16)
+#define DAIFMT_20BITS             (20)
+
+#define DAIFMT_BS_MASK            (~(1<<16))  	//FIFO big small mode mask
+#define DAIFMT_BITS_MASK          (~(1<<5))		//FIFO Bits select mask,not used yet.
+#define SAMPLE_RATE_MASK          (~(7<<29))  	//Sample Rate slect mask
+
+#define DAC_EN                    (31)
+#define DIGITAL_VOL               (12)
+//For CODEC OLD VERSION
+#define DAC_VERSION               (23)
+
+#define DAC_CHANNEL		  (6)
+#define LAST_SE                   (26)
+#define TX_FIFO_MODE              (24)
+#define DRA_LEVEL                 (21)
+#define TX_TRI_LEVEL              (8)
+#define DAC_MODE                  (6)			//not used yet
+#define TASR                      (5)			//not used yet
+#define DAC_DRQ                   (4)
+#define DAC_FIFO_FLUSH            (0)
+
+#define VOLUME                    (0)
+#define PA_MUTE                   (6)
+#define MIXPAS                    (7)
+#define DACPAS                    (8)
+#define MIXEN                     (29)
+#define DACAEN_L                  (30)
+#define DACAEN_R                  (31)
+
+#define ADC_DIG_EN                (28)
+#define RX_FIFO_MODE              (24)
+#define RX_TRI_LEVEL              (8)
+#define ADC_MODE                  (7)
+#define RASR                      (6)
+#define ADC_DRQ                   (4)
+#define ADC_FIFO_FLUSH            (0)
+
+#define  ADC_LF_EN                (31)
+#define  ADC_RI_EN                (30)
+#define  ADC_EN                   (30)
+#define  MIC1_EN                  (29)
+#define  MIC2_EN                  (28)
+#define  VMIC_EN                  (27)
+#define  MIC_GAIN                 (25)
+#define  ADC_SELECT               (17)
+#define  PA_ENABLE                (4)
+#define  HP_DIRECT                (3)
+
+enum m1_codec_config {
+	CMD_MIC_SEL =0,
+	CMD_ADC_SEL,
+};
+
+#define AUDIO_RATE_DEFAULT	44100
+#define ST_RUNNING		(1<<0)
+#define ST_OPENED		(1<<1)
+
+void  __iomem *baseaddr;
+#define codec_rdreg(reg)	    readl((baseaddr+(reg)))
+#define codec_wrreg(reg,val)  writel((val),(baseaddr+(reg)))
+
+/*
+* Convenience kcontrol builders
+*/
+#define CODEC_SINGLE_VALUE(xreg, xshift, xmax,	xinvert)\
+		((unsigned long)&(struct codec_mixer_control)\
+		{.reg	=	xreg,	.shift	=	xshift,	.rshift	=	xshift,	.max	=	xmax,\
+   	.invert	=	xinvert})
+
+#define CODEC_SINGLE(xname,	reg,	shift,	max,	invert)\
+{	.iface	= SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\
+	.info	= snd_codec_info_volsw,	.get = snd_codec_get_volsw,\
+	.put	= snd_codec_put_volsw,\
+	.private_value	= CODEC_SINGLE_VALUE(reg, shift, max, invert)}
+
+/*	mixer control*/
+struct	codec_mixer_control{
+	int	min;
+	int     max;
+	int     where;
+	unsigned int mask;
+	unsigned int reg;
+	unsigned int rreg;
+	unsigned int shift;
+	unsigned int rshift;
+	unsigned int invert;
+	unsigned int value;
+};
+
+#endif
