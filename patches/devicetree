Bottom: 6f59c907c8ddc703a12a9928cd807d47745cb9e3
Top:    03db80a311947532a6e3dc529308bf26ae0a69d0
Author: Jon Smirl (none) <jonsmirl@smirl2>
Date:   2012-03-19 23:01:40 -0400

device trees


---

diff --git a/arch/arm/boot/dts/ea3131.dts b/arch/arm/boot/dts/ea3131.dts
new file mode 100644
index 0000000..5aaf2e7
--- /dev/null
+++ b/arch/arm/boot/dts/ea3131.dts
@@ -0,0 +1,37 @@
+/*
+ * ea3131.dts - Device Tree file for EA3131 board
+ *
+ *  Copyright (C) 2012 Jon Smirl <jonsmirl@gmail.com>
+ *
+ * Licensed under GPLv2.
+ */
+/dts-v1/;
+/include/ "lpc3131.dtsi"
+
+/ {
+	model = "Electronic Arts EA3131";
+	compatible = "ea,ea3131", "nxp,lpc3131";
+
+	chosen {
+		bootargs = "console=ttyS0,115200n8 root=/dev/mmcblk0p3 init=/etc/preinit rw rootwait loglevel=7";
+	};
+
+	ssd1289@20000000 {
+		compatible = "ssd,ssd1289";
+		reg = <0x20000000 0x10000 0x20010000 0x10000>;
+	};
+	dm9000@20000000 {
+		compatible = "davicom,dm9000";
+		reg = <0x20020000 0x100 0x20030000 0x100>;
+		interrupts = <37>;
+	};
+	memory@30000000 {
+		reg = <0x30000000 0x4000000>;
+	};
+	ahb {
+		sdmmc@18000000 {
+			cd-gpio = <&gpio 0x87 0>;
+			power-gpio = <&gpio 0x45 0>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/lpc3131.dtsi b/arch/arm/boot/dts/lpc3131.dtsi
new file mode 100644
index 0000000..ae6f45e
--- /dev/null
+++ b/arch/arm/boot/dts/lpc3131.dtsi
@@ -0,0 +1,200 @@
+/*
+ * lpc3131.dtsi - Device Tree Include file for LPC3131 family SoC
+ *
+ *  Copyright (C) 2011 Jon Smirl <jonsmirl@gmail.com>
+ *
+ * Licensed under GPLv2 or later.
+ */
+
+/ {
+	model = "NXP LPC3131 SoC";
+	compatible = "nxp,lpc3131";
+	#address-cells = <1>;
+	#size-cells = <1>;
+	interrupt-parent = <&intc>;
+
+	cpus {
+		cpu@0 {
+			compatible = "arm,arm926ejs";
+		};
+	};
+
+	ahb {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		isram0: memory@11028000 {
+			reg = <0x11028000 0x18000>;
+			interrupts = <28>;
+		};
+		isram1: memory@11040000 {
+			reg = <0x11040000 0x18000>;
+			interrupts = <29>;
+		};
+
+		apb0: apb@13000000 {
+			compatible = "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x13000000 0x13000000 0x8000>;
+
+			evtr@13000000 {
+				compatible = "nxp,lpc31xx-evtr";
+				reg = <0x13000000 0x800>;
+				interrupts = <1 2 3 4>;
+			};
+			adc@13002000 {
+				compatible = "nxp,lpc31xx-adc";
+				reg = <0x13002000 0x400>;
+				interrupts = <9>;
+			};
+			wdt@13002400 {
+				compatible = "nxp,lpc31xx-wdt";
+				reg = <0x13002400 0x400>;
+				interrupts = <30>;
+			};
+			sys@13002800 {
+				compatible = "nxp,lpc31xx-sys";
+				reg = <0x13002800 0x400>;
+			};
+			gpio: gpio@13003000 {
+				compatible = "nxp,lpc31xx-gpio";
+				reg = <0x13003000 0x1000>;
+			};
+			cgu@13004000 {
+				compatible = "nxp,lpc31xx-cgu";
+				reg = <0x13004000 0x1000>;
+			};
+			rng@13006000 {
+				compatible = "nxp,lpc31xx-rng";
+				reg = <0x13006000 0x200>;
+			};
+		};
+		apb1: apb@13008000 {
+			compatible = "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x13008000 0x13008000 0x4000>;
+
+			timer0: timer@13008000 {
+				compatible = "nxp,lpc31xx-timer";
+				reg = <0x13008000 0x400>;
+				interrupts = <5>;
+			};
+			timer1: timer@13008400 {
+				compatible = "nxp,lpc31xx-timer";
+				reg = <0x13008400 0x400>;
+				interrupts = <6>;
+			};
+			timer2: timer@13008800 {
+				compatible = "nxp,lpc31xx-timer";
+				reg = <0x13008800 0x400>;
+				interrupts = <7>;
+			};
+			timer3: timer@13008c00 {
+				compatible = "nxp,lpc31xx-timer";
+				reg = <0x13008c00 0x400>;
+				interrupts = <8>;
+			};
+			pwm@13009000 {
+				compatible = "nxp,lpc31xx-pwm";
+				reg = <0x13009000 0x200>;
+				interrupts = <11>;
+			};
+			i2c0: i2c@1300a000 {
+				compatible = "nxp,lpc31xx-i2c";
+				reg = <0x1300a000 0x400>;
+				interrupts = <11>;
+			};
+			i2c1: i2c@1300a400 {
+				compatible = "nxp,lpc31xx-i2c";
+				reg = <0x1300a400 0x400>;
+				interrupts = <12>;
+			};
+		};
+		apb2: apb@15000000 {
+			compatible = "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x15000000 0x15000000 0x3000>;
+
+			pcm@15000000 {
+				compatible = "nxp,lpc31xx-pcm";
+				reg = <0x15000000 0x400>;
+				interrupts = <14>;
+			};
+			lcd@15000400 {
+				compatible = "nxp,lpc31xx-lcd";
+				reg = <0x15000400 0x400>;
+				interrupts = <18>;
+			};
+			uart@15001000 {
+				compatible = "nxp,lpc31xx-uart";
+				reg = <0x15001000 0x1000>;
+				interrupts = <10>;
+			};
+			spi@15002000 {
+				compatible = "nxp,lpc31xx-spi";
+				reg = <0x15002000 0x1000>;
+				interrupts = <18 19 20 21 22 23>;
+			};
+		};
+		apb3: apb@16000000 {
+			compatible = "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x16000000 0x16000000 0x1000>;
+
+			i2s@16000000 {
+				compatible = "nxp,lpc31xx-i2s";
+				reg = <0x16000000 0x1000>;
+				interrupts = <13 14 15 16>;
+			};
+		};
+		apb4: apb@17000000 {
+			compatible = "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x17000000 0x17000000 0x1000>;
+
+			dma@17000000 {
+				compatible = "nxp,lpc31xx-dma";
+				reg = <0x17000000 0x800>;
+				interrupts = <24>;
+			};
+			nand@17000800 {
+				compatible = "nxp,lpc31xx-nand";
+				reg = <0x17000800 0x800>;
+				interrupts = <25>;
+			};
+		};
+		mpmc@17008000 {
+			compatible = "nxp,lpc31xx-mpmc";
+			reg = <0x17008000 0x1000>;
+			interrupts = <21>;
+		};
+		sdmmc@18000000 {
+			compatible = "nxp,lpc31xx-sdmmc";
+			reg = <0x18000000 0x1000>;
+			interrupts = <26>;
+		};
+		usb@19000000 {
+			compatible = "nxp,lpc31xx-usb", "usb-ehci";
+			reg = <0x19000000 0x1000>;
+			interrupts = <27>;
+		};
+		intc: intc@60000000 {
+			compatible = "nxp,lpc31xx-intc";
+			reg = <0x60000000 0x1000>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+		};
+		nand-buffer@70000000 {
+			compatible = "nxp,lpc31xx-nand-buffer";
+			reg = <0x70000000 0x1000>;
+			interrupts = <24>;
+		};
+	};
+};
diff --git a/arch/arm/mach-lpc31xx/Makefile b/arch/arm/mach-lpc31xx/Makefile
index 5298fdf..a8ab311 100644
--- a/arch/arm/mach-lpc31xx/Makefile
+++ b/arch/arm/mach-lpc31xx/Makefile
@@ -6,6 +6,7 @@
 
 obj-y			+= irq.o time.o generic.o i2c.o gpio.o dma.o usb.o wdt.o clock.o
 obj-$(CONFIG_GPIOLIB) += gpiolib.o
+obj-$(CONFIG_OF) += dt.o
 
 
 # Specific board support
diff --git a/arch/arm/mach-lpc31xx/board-ea313x.c b/arch/arm/mach-lpc31xx/board-ea313x.c
index 0e537ec..6673805 100644
--- a/arch/arm/mach-lpc31xx/board-ea313x.c
+++ b/arch/arm/mach-lpc31xx/board-ea313x.c
@@ -32,139 +32,36 @@
 #include <linux/spi/spi.h>
 #include <linux/leds-pca9532.h>
 #include <linux/gpio.h>
+#include <linux/of_platform.h>
 
 #include <asm/system.h>
-#include <mach/hardware.h>
 #include <asm/irq.h>
 #include <asm/pgtable.h>
 #include <asm/page.h>
 #include <asm/sizes.h>
-
 #include <asm/mach/map.h>
 #include <asm/mach-types.h>
-
 #include <asm/mach/arch.h>
+
+#include <mach/hardware.h>
 #include <mach/gpio.h>
 #include <mach/i2c.h>
 #include <mach/board.h>
 #include <mach/system.h>
+#include <mach/dt.h>
 
-static struct lpc313x_mci_irq_data irq_data = {
-	.irq = IRQ_SDMMC_CD,
-};
-
-static int mci_get_cd(u32 slot_id)
-{
-	return gpio_get_value(GPIO_MI2STX_BCK0);
-}
-
-static irqreturn_t ea313x_mci_detect_interrupt(int irq, void *data)
-{
-	struct lpc313x_mci_irq_data	*pdata = data;
-
-	/* select the opposite level senstivity */
-	int level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
-
-	irq_set_irq_type(pdata->irq, level);
-
-	/* change the polarity of irq trigger */
-	return pdata->irq_hdlr(irq, pdata->data);
-}
-
-static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
-{
-	int ret;
-	int level;
-
-	/* enable power to the slot */
-	gpio_request(GPIO_MI2STX_DATA0, "mmc power");
-	gpio_set_value(GPIO_MI2STX_DATA0, 0);
-	/* set cd pins as GPIO pins */
-	gpio_request(GPIO_MI2STX_BCK0, "mmc card detect");
-	gpio_direction_input(GPIO_MI2STX_BCK0);
-
-	/* select the opposite level senstivity */
-	level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
-	/* set card detect irq info */
-	irq_data.data = data;
-	irq_data.irq_hdlr = irqhdlr;
-	irq_set_irq_type(irq_data.irq, level);
-	ret = request_irq(irq_data.irq,
-			ea313x_mci_detect_interrupt,
-			level,
-			"mmc-cd", 
-			&irq_data);
-	/****temporary for PM testing */
-	enable_irq_wake(irq_data.irq);
-
-	return irq_data.irq;
-}
-
-static int mci_get_ro(u32 slot_id)
-{
-	return 0;
-}
-
-static int mci_get_ocr(u32 slot_id)
-{
-	return MMC_VDD_32_33 | MMC_VDD_33_34;
-}
-
-static void mci_setpower(u32 slot_id, u32 volt)
-{
-	/* on current version of EA board the card detect
-	 * pull-up in on switched power side. So can't do
-	 * power management so use the always enable power 
-	 * jumper.
-	 */
-}
-static int mci_get_bus_wd(u32 slot_id)
-{
-	return 4;
-}
-
-static void mci_exit(u32 slot_id)
-{
-	free_irq(irq_data.irq, &irq_data);
-}
-
-static struct resource lpc313x_mci_resources[] = {
-	[0] = {
-		.start  = IO_SDMMC_PHYS,
-		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_MCI,
-		.end	= IRQ_MCI,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-static struct lpc313x_mci_board ea313x_mci_platform_data = {
-	.num_slots		= 1,
-	.detect_delay_ms	= 250,
-	.init 			= mci_init,
-	.get_ro			= mci_get_ro,
-	.get_cd 		= mci_get_cd,
-	.get_ocr		= mci_get_ocr,
-	.get_bus_wd		= mci_get_bus_wd,
-	.setpower 		= mci_setpower,
-	.exit			= mci_exit,
-};
 
 static u64 mci_dmamask = 0xffffffffUL;
 static struct platform_device	lpc313x_mci_device = {
 	.name		= "lpc313x_mmc",
-	.num_resources	= ARRAY_SIZE(lpc313x_mci_resources),
 	.dev		= {
 		.dma_mask		= &mci_dmamask,
 		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &ea313x_mci_platform_data,
 	},
-	.resource	= lpc313x_mci_resources,
 };
 
 #if defined (CONFIG_FB_SSD1289)
+#ifndef CONFIG_OF
 static struct resource ssd1289_resource[] = {
 	[0] = {
 		.start = EXT_SRAM0_PHYS + 0x00000 + 0x0000,
@@ -184,6 +81,7 @@ static struct platform_device ssd1289_device = {
 	.num_resources = ARRAY_SIZE(ssd1289_resource),
 	.resource      = ssd1289_resource,
 };
+#endif
 
 static void __init ea_add_device_ssd1289(void)
 {
@@ -195,7 +93,9 @@ static void __init ea_add_device_ssd1289(void)
 	MPMC_STWTWR0   = 3;
 	MPMC_STWTTURN0 = 0;
 
+#ifndef CONFIG_OF
 	platform_device_register(&ssd1289_device);
+#endif
 }
 #else
 static void __init ea_add_device_ssd1289(void) {}
@@ -205,6 +105,7 @@ static void __init ea_add_device_ssd1289(void) {}
  * DM9000 ethernet device
  */
 #if defined(CONFIG_DM9000)
+#ifndef CONFIG_OF
 static struct resource dm9000_resource[] = {
 	[0] = {
 		.start	= EXT_SRAM1_PHYS,
@@ -222,6 +123,7 @@ static struct resource dm9000_resource[] = {
 		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
 	}
 };
+#endif
 /* ARM MPMC contoller as part of low power design doesn't de-assert nCS and nOE for consecutive 
 reads but just changes address. But DM9000 requires nCS and nOE change between address. So access
 other chip select area (nCS0) to force de-assertion of nCS1 and nOE1. Or else wait for long time 
@@ -264,6 +166,7 @@ static struct dm9000_plat_data dm9000_platdata = {
 	.inblk = dm9000_inblk,
 };
 
+#ifndef CONFIG_OF
 static struct platform_device dm9000_device = {
 	.name		= "dm9000",
 	.id		= 0,
@@ -273,6 +176,8 @@ static struct platform_device dm9000_device = {
 		.platform_data	= &dm9000_platdata,
 	}
 };
+#endif
+
 static void __init ea_add_device_dm9000(void)
 {
 	/*
@@ -290,6 +195,7 @@ static void __init ea_add_device_dm9000(void)
 	/* enable oe toggle between consec reads */
 	SYS_MPMC_WTD_DEL1 = _BIT(5) | 4;
 
+#ifndef CONFIG_OF
 	/* Configure Interrupt pin as input, no pull-up */
 	if (gpio_request(GPIO_MNAND_RYBN3, "dm9000 interrupt"))
 		return;
@@ -297,6 +203,7 @@ static void __init ea_add_device_dm9000(void)
 	gpio_direction_input(GPIO_MNAND_RYBN3);
 
 	platform_device_register(&dm9000_device);
+#endif
 }
 #else
 static void __init ea_add_device_dm9000(void) {}
@@ -678,6 +585,19 @@ void lpc313x_vbus_power(int enable)
 	gpio_set_value(VBUS_PWR_EN, enable);
 }
 
+#ifdef CONFIG_OF
+struct of_dev_auxdata ea3131_auxdata_lookup[] __initdata = {
+	OF_DEV_AUXDATA("davicom,dm9000", EXT_SRAM1_PHYS, "dm9000", &dm9000_platdata),
+	{}
+};
+
+static void __init ea3131_dt_init(void)
+{
+	lpc31xx_dt_init_common(ea3131_auxdata_lookup);
+	ea_add_device_ssd1289();
+	ea_add_device_dm9000();
+}
+#else
 static void __init ea313x_init(void)
 {
 	lpc313x_init();
@@ -700,14 +620,16 @@ static void __init ea313x_init(void)
 		ARRAY_SIZE(ea3152_i2c1_devices));
 #endif
 }
+#endif
 
 #if defined(CONFIG_USB_EHCI_HCD)
-static void __init ea_usb_power(void)
+static int __init ea_usb_power(void)
 {
 	int ret; 
 
 	ret = gpio_request(VBUS_PWR_EN, "vbus power");
 	ret = gpio_direction_output(VBUS_PWR_EN, 1);
+	return ret;
 }
 late_initcall(ea_usb_power);
 #endif
@@ -730,6 +652,7 @@ MACHINE_END
 #endif
 
 #if defined(CONFIG_MACH_EA313X)
+#ifndef CONFIG_OF
 MACHINE_START(EA313X, "NXP EA313X")
 	/* Maintainer: Durgesh Pattamatta, NXP */
 	.map_io		= ea313x_map_io,
@@ -738,6 +661,21 @@ MACHINE_START(EA313X, "NXP EA313X")
 	.init_machine	= ea313x_init,
 	.restart	= arch_reset,
 MACHINE_END
+#else
+static const char *ea3131_dt_match[] __initconst = {
+	"ea,ea3131",
+	NULL,
+};
+DT_MACHINE_START(EA313X, "NXP EA3131 (Device Tree Support)")
+	.map_io		= lpc313x_map_io,
+	.init_early	= lpc31xx_init_early,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= ea3131_dt_init,
+	.dt_compat	= ea3131_dt_match,
+	.restart	= arch_reset,
+MACHINE_END
+#endif
 #endif
 
 
diff --git a/arch/arm/mach-lpc31xx/clock.c b/arch/arm/mach-lpc31xx/clock.c
index 69ab97a..281a3f5 100644
--- a/arch/arm/mach-lpc31xx/clock.c
+++ b/arch/arm/mach-lpc31xx/clock.c
@@ -1076,7 +1076,7 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK(NULL, "wdog_pclk", clk_wdog_pclk)
 };
 
-static int __init clk_init(void)
+int __init clk_init(void)
 {
 	int i;
 
@@ -1085,5 +1085,4 @@ static int __init clk_init(void)
 
 	return 0;
 }
-core_initcall(clk_init);
 
diff --git a/arch/arm/mach-lpc31xx/dt.c b/arch/arm/mach-lpc31xx/dt.c
new file mode 100644
index 0000000..add35ad
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/dt.c
@@ -0,0 +1,69 @@
+/*
+ * NXP LPC3131 board support using the device tree
+ *
+ *  Copyright (C) 2010 Secret Lab Technologies Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/pgtable.h>
+
+#include <mach/hardware.h>
+#include <mach/board.h>
+#include <mach/clock.h>
+#include <mach/dt.h>
+#include <mach/system.h>
+
+static void __init lpc31xx_dt_init(void)
+{
+	lpc31xx_dt_init_common(NULL);
+}
+
+void __init lpc31xx_dt_init_common(struct of_dev_auxdata* auxdata)
+{
+	lpc313x_init();
+	of_platform_populate(NULL, of_default_bus_match_table,
+			     auxdata, NULL);
+}
+
+void __init lpc31xx_init_early(void)
+{
+printk("JDS - lpc31xx_init_early\n");
+}
+
+static const char *lpc31xx_dt_match[] __initconst = {
+	"ncp,lpc3130",
+	"nxp,lpc3131",
+	"nxp,lpc3152",
+	"nxp,lpc3153",
+	NULL,
+};
+
+DT_MACHINE_START(EA313X, "NXP LPC31xx (Device Tree Support)")
+	.map_io		= lpc313x_map_io,
+	.init_early	= lpc31xx_init_early,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= lpc31xx_dt_init,
+	.dt_compat	= lpc31xx_dt_match,
+	.restart	= arch_reset,
+MACHINE_END
diff --git a/arch/arm/mach-lpc31xx/generic.c b/arch/arm/mach-lpc31xx/generic.c
index 4980a58..1c50945 100644
--- a/arch/arm/mach-lpc31xx/generic.c
+++ b/arch/arm/mach-lpc31xx/generic.c
@@ -173,10 +173,26 @@ static struct map_desc lpc313x_io_desc[] __initdata = {
 		.length		= IO_ISRAM0_SIZE,
 		.type		= MT_DEVICE
 	},
+#ifdef CONFIG_OF
+	{
+		.virtual	= io_p2v(IO_USB_PHYS),
+		.pfn		= __phys_to_pfn(IO_USB_PHYS),
+		.length		= IO_USB_SIZE,
+		.type		= MT_DEVICE
+	},
+
+	{
+		.virtual	= io_p2v(IO_SDMMC_PHYS),
+		.pfn		= __phys_to_pfn(IO_SDMMC_PHYS),
+		.length		= IO_SDMMC_SIZE,
+		.type		= MT_DEVICE
+	},
+#endif
 };
 
 void __init lpc313x_map_io(void)
 {
+printk("JDS - lpc313x_map_io\n");
 	iotable_init(lpc313x_io_desc, ARRAY_SIZE(lpc313x_io_desc));
 }
 extern int __init cgu_init(char *str);
@@ -193,9 +209,10 @@ void __init lpc313x_uart_init(void)
 	}
 }
 
-int __init lpc313x_init(void)
+void __init lpc313x_init(void)
 {
 	/* cgu init */
+	clk_init();
 	cgu_init("");
 	/* Switch on the UART clocks */
 	cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
@@ -236,7 +253,9 @@ int __init lpc313x_init(void)
 
 	lpc313x_uart_init();
 
+#ifndef CONFIG_OF
 	return platform_add_devices(devices, ARRAY_SIZE(devices));
+#endif
 }
 
 
diff --git a/arch/arm/mach-lpc31xx/include/mach/board.h b/arch/arm/mach-lpc31xx/include/mach/board.h
index 5fe9ac2..2bcd065 100644
--- a/arch/arm/mach-lpc31xx/include/mach/board.h
+++ b/arch/arm/mach-lpc31xx/include/mach/board.h
@@ -32,7 +32,7 @@
 
 extern void __init lpc313x_map_io(void);
 extern void __init lpc313x_init_irq(void);
-extern int __init lpc313x_init(void);
+extern void __init lpc313x_init(void);
 extern int __init lpc313x_register_i2c_devices(void);
 extern void lpc313x_vbus_power(int enable);
 extern int lpc313x_entering_suspend_mem(void);
diff --git a/arch/arm/mach-lpc31xx/include/mach/clock.h b/arch/arm/mach-lpc31xx/include/mach/clock.h
index d7058b6..eb038b3 100644
--- a/arch/arm/mach-lpc31xx/include/mach/clock.h
+++ b/arch/arm/mach-lpc31xx/include/mach/clock.h
@@ -653,4 +653,7 @@ struct clk {
 	CGU_CLOCK_ID_T id;
 };
 
+
+int clk_init(void);
+
 #endif
diff --git a/arch/arm/mach-lpc31xx/include/mach/dt.h b/arch/arm/mach-lpc31xx/include/mach/dt.h
new file mode 100644
index 0000000..f4eb877
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/dt.h
@@ -0,0 +1,9 @@
+#ifndef LPC31XX_DT
+#define LPC31XX_DT
+
+void lpc31xx_dt_init_common(struct of_dev_auxdata* auxdata);
+void lpc31xx_init_early(void);
+void lpc31xx_restart(char mode, const char *cmd);
+
+#endif
+
diff --git a/arch/arm/mach-lpc31xx/irq.c b/arch/arm/mach-lpc31xx/irq.c
index 50dc8a7..4ff6533 100644
--- a/arch/arm/mach-lpc31xx/irq.c
+++ b/arch/arm/mach-lpc31xx/irq.c
@@ -24,6 +24,8 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/timer.h>
+#include <linux/of_irq.h>
+#include <linux/irqdomain.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
@@ -199,6 +201,10 @@ ROUTER_HDLR(2)
 ROUTER_HDLR(3)
 #endif /* IRQ_EVTR3_END */
 
+static const struct of_device_id intc_of_match[] __initconst = {
+	{ .compatible = "nxp,lpc31xx-intc", },
+	{},
+};
 
 void __init lpc313x_init_irq(void)
 {
@@ -206,6 +212,8 @@ void __init lpc313x_init_irq(void)
 	int i, j;
 	u32 bank, bit_pos;
 
+	irq_domain_generate_simple(intc_of_match, 0x60000000, 0);
+
 	/* enable clock to interrupt controller */
 	cgu_clk_en_dis(CGU_SB_AHB2INTC_CLK_ID, 1);
 	cgu_clk_en_dis(CGU_SB_INTC_CLK_ID, 1);
diff --git a/arch/arm/mach-lpc31xx/usb.c b/arch/arm/mach-lpc31xx/usb.c
index 57699b7..538f11b 100644
--- a/arch/arm/mach-lpc31xx/usb.c
+++ b/arch/arm/mach-lpc31xx/usb.c
@@ -95,6 +95,7 @@
 #define OTGSC_INT_STAT_MASK (0x007F0000)
 
 /*-------------------------------------------------------------------------*/
+#if defined(CONFIG_USB_GADGET_FSL_USB2) || defined(CONFIG_USB_OTG)
 static struct resource lpc313x_usb_resource[] = {
 	[0] = {
 		.start = (u32) (USBOTG_PHYS),
@@ -107,6 +108,7 @@ static struct resource lpc313x_usb_resource[] = {
 		.flags = IORESOURCE_IRQ,
 	}
 };
+#endif
 
 struct lpc313x_usb_board_t {
 	/* timer for VBUS enable */
@@ -118,18 +120,13 @@ struct lpc313x_usb_board_t {
 static struct lpc313x_usb_board_t lpc313x_usb_brd;
 
 static u64 usb_dmamask = 0xffffffffUL;;
-static void	lpc313x_usb_release(struct device *dev);
-
-struct fsl_usb2_platform_data lpc313x_fsl_config = {
-#if defined(CONFIG_USB_OTG) || (defined(CONFIG_USB_EHCI_HCD) && defined(CONFIG_USB_GADGET_FSL_USB2))
-	.operating_mode = FSL_USB2_DR_OTG,
-#elif defined(CONFIG_USB_GADGET_FSL_USB2) && !defined(CONFIG_USB_EHCI_HCD)
-	.operating_mode = FSL_USB2_DR_DEVICE,
-#elif !defined(CONFIG_USB_GADGET_FSL_USB2) && defined(CONFIG_USB_EHCI_HCD)
-	.operating_mode = FSL_USB2_DR_HOST,
-#endif
-	.phy_mode = FSL_USB2_PHY_UTMI,
-};
+/*-------------------------------------------------------------------------*/
+
+static void	lpc313x_usb_release(struct device *dev)
+{
+	// do nothing
+}
+
 
 #if defined(CONFIG_USB_GADGET_FSL_USB2) || defined(CONFIG_USB_OTG)
 
@@ -139,7 +136,6 @@ static struct platform_device lpc313x_udc_device = {
 		.dma_mask          = &usb_dmamask,
 		.coherent_dma_mask = 0xffffffff,
 		.release           = lpc313x_usb_release,
-		.platform_data     = &lpc313x_fsl_config,
 	},
 	.num_resources = ARRAY_SIZE(lpc313x_usb_resource),
 	.resource      = lpc313x_usb_resource,
@@ -148,26 +144,21 @@ static struct platform_device lpc313x_udc_device = {
 
 #if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_OTG)
 
+#ifndef CONFIG_OF
 static struct platform_device lpc313x_ehci_device = {
 	.name		= "lpc-ehci",
 	.dev = {
 		.dma_mask          = &usb_dmamask,
 		.coherent_dma_mask = 0xffffffff,
 		.release           = lpc313x_usb_release,
-		.platform_data     = &lpc313x_fsl_config,
 	},
 	.num_resources = ARRAY_SIZE(lpc313x_usb_resource),
 	.resource      = lpc313x_usb_resource,
 };
 #endif
+#endif
 
 
-/*-------------------------------------------------------------------------*/
-static void	lpc313x_usb_release(struct device *dev)
-{
-	// do nothing
-}
-
 static irqreturn_t lpc313x_vbus_ovrc_irq(int irq, void *data)
 {
 	struct lpc313x_usb_board_t* brd = data;
@@ -242,11 +233,12 @@ int __init usbotg_init(void)
 	} else {
 #if defined(CONFIG_USB_EHCI_HCD)
 		/* register host */
+#ifndef CONFIG_OF
 		printk(KERN_INFO "Registering USB host 0x%08x 0x%08x (%d)\n", USB_DEV_OTGSC, EVRT_RSR(bank), bank);
 		retval = platform_device_register(&lpc313x_ehci_device);
 		if ( 0 != retval )
 			printk(KERN_INFO "Can't register lpc313x_ehci_device device\n");
-
+#endif
 		/* Create VBUS enable timer */
 		setup_timer(&lpc313x_usb_brd.vbus_timer, lpc313x_vbusen_timer,
 				(unsigned long)&lpc313x_usb_brd);
diff --git a/arch/arm/mach-lpc31xx/wdt.c b/arch/arm/mach-lpc31xx/wdt.c
index 0cf5d37..160e8cc 100644
--- a/arch/arm/mach-lpc31xx/wdt.c
+++ b/arch/arm/mach-lpc31xx/wdt.c
@@ -24,6 +24,7 @@
 #include <mach/constants.h>
 #include <mach/irqs.h>
 
+#ifndef CONFIG_OF
 static struct resource watchdog_resources[] = {
 	{
 		.start = WDT_PHYS,
@@ -45,3 +46,4 @@ static int __init wdt_device_init(void)
 }
 
 arch_initcall(wdt_device_init);
+#endif
diff --git a/drivers/mmc/host/lpc31xx_mmc.c b/drivers/mmc/host/lpc31xx_mmc.c
index 73d67e7..c86b1904 100644
--- a/drivers/mmc/host/lpc31xx_mmc.c
+++ b/drivers/mmc/host/lpc31xx_mmc.c
@@ -37,6 +37,9 @@
 #include <linux/delay.h>
 #include <linux/irq.h>
 #include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/gpio.h>
 
 #include "lpc31xx_mmc.h"
 #include <mach/irqs.h>
@@ -1401,6 +1404,119 @@ static void lpc313x_mci_cleanup_slot(struct lpc313x_mci_slot *slot,
 	mmc_free_host(slot->mmc);
 }
 
+static struct lpc313x_mci_irq_data irq_data = {
+	.irq = IRQ_SDMMC_CD,
+};
+
+static int mci_get_cd(u32 slot_id)
+{
+	return gpio_get_value(GPIO_MI2STX_BCK0);
+}
+
+static irqreturn_t ea313x_mci_detect_interrupt(int irq, void *data)
+{
+	struct lpc313x_mci_irq_data	*pdata = data;
+
+	/* select the opposite level senstivity */
+	int level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
+
+	irq_set_irq_type(pdata->irq, level);
+
+	/* change the polarity of irq trigger */
+	return pdata->irq_hdlr(irq, pdata->data);
+}
+
+static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
+{
+	int ret;
+	int level;
+
+	/* enable power to the slot */
+	gpio_request(GPIO_MI2STX_DATA0, "mmc power");
+	gpio_set_value(GPIO_MI2STX_DATA0, 0);
+	/* set cd pins as GPIO pins */
+	gpio_request(GPIO_MI2STX_BCK0, "mmc card detect");
+	gpio_direction_input(GPIO_MI2STX_BCK0);
+
+	/* select the opposite level senstivity */
+	level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
+	/* set card detect irq info */
+	irq_data.data = data;
+	irq_data.irq_hdlr = irqhdlr;
+	irq_set_irq_type(irq_data.irq, level);
+	ret = request_irq(irq_data.irq,
+			ea313x_mci_detect_interrupt,
+			level,
+			"mmc-cd", 
+			&irq_data);
+	/****temporary for PM testing */
+	enable_irq_wake(irq_data.irq);
+
+	return irq_data.irq;
+}
+
+static int mci_get_ro(u32 slot_id)
+{
+	return 0;
+}
+
+static int mci_get_ocr(u32 slot_id)
+{
+	return MMC_VDD_32_33 | MMC_VDD_33_34;
+}
+
+static void mci_setpower(u32 slot_id, u32 volt)
+{
+	/* on current version of EA board the card detect
+	 * pull-up in on switched power side. So can't do
+	 * power management so use the always enable power 
+	 * jumper.
+	 */
+}
+static int mci_get_bus_wd(u32 slot_id)
+{
+	return 4;
+}
+
+static void mci_exit(u32 slot_id)
+{
+	free_irq(irq_data.irq, &irq_data);
+}
+
+#ifndef CONFIG_OF
+static struct resource lpc313x_mci_resources[] = {
+	[0] = {
+		.start  = IO_SDMMC_PHYS,
+		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_MCI,
+		.end	= IRQ_MCI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+#endif
+
+static struct lpc313x_mci_board ea313x_mci_platform_data = {
+	.num_slots		= 1,
+	.detect_delay_ms	= 250,
+	.init 			= mci_init,
+	.get_ro			= mci_get_ro,
+	.get_cd 		= mci_get_cd,
+	.get_ocr		= mci_get_ocr,
+	.get_bus_wd		= mci_get_bus_wd,
+	.setpower 		= mci_setpower,
+	.exit			= mci_exit,
+};
+
+#if defined(CONFIG_OF)
+static const struct of_device_id lpc313x_mci_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-sdmmc" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lpc313x_mci_of_match);
+#endif
 
 static int lpc313x_mci_probe(struct platform_device *pdev)
 {
@@ -1412,11 +1528,16 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 	int				ret = 0;
 	int i;
 
+#ifndef CONFIG_OF
+pdev->num_resources = ARRAY_SIZE(lpc313x_mci_resources);
+pdev->resource = lpc313x_mci_resources;
+#endif
+pdev->dev.platform_data = &ea313x_mci_platform_data;
+
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!regs)
 		return -ENXIO;
 
-
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
 		return irq;
@@ -1483,6 +1604,7 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 		goto err_freemap;
 	}
 #endif
+
 	clk = clk_get(NULL, "mmc_cclk_in");
 	host->bus_hz = clk_get_rate(clk); //40000000;
 	clk_put(clk);
@@ -1652,7 +1774,11 @@ static struct platform_driver lpc313x_mci_driver = {
 	.resume     = lpc313x_mci_resume,
 	.remove		= __exit_p(lpc313x_mci_remove),
 	.driver		= {
-		.name		= "lpc313x_mmc",
+		.name	= "lpc313x_mmc",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = lpc313x_mci_of_match,
+#endif
 	},
 };
 
diff --git a/drivers/net/ethernet/davicom/dm9000.c b/drivers/net/ethernet/davicom/dm9000.c
index f7ca4cc..f8fd607 100644
--- a/drivers/net/ethernet/davicom/dm9000.c
+++ b/drivers/net/ethernet/davicom/dm9000.c
@@ -1679,11 +1679,22 @@ dm9000_drv_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id dm9000_of_match[] = {
+	{ .compatible = "davicom,dm9000" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, dm9000_of_match);
+#endif
+
 static struct platform_driver dm9000_driver = {
 	.driver	= {
 		.name    = "dm9000",
 		.owner	 = THIS_MODULE,
 		.pm	 = &dm9000_drv_pm_ops,
+#ifdef CONFIG_OF
+		.of_match_table = dm9000_of_match,
+#endif
 	},
 	.probe   = dm9000_probe,
 	.remove  = __devexit_p(dm9000_drv_remove),
diff --git a/drivers/usb/host/ehci-lpc.c b/drivers/usb/host/ehci-lpc.c
index 9932f36..6044cc9 100644
--- a/drivers/usb/host/ehci-lpc.c
+++ b/drivers/usb/host/ehci-lpc.c
@@ -76,6 +76,17 @@ static const struct hc_driver lpc_ehci_hc_driver = {
 	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
 };
 
+struct fsl_usb2_platform_data lpc313x_fsl_config = {
+#if defined(CONFIG_USB_OTG) || (defined(CONFIG_USB_EHCI_HCD) && defined(CONFIG_USB_GADGET_FSL_USB2))
+	.operating_mode = FSL_USB2_DR_OTG,
+#elif defined(CONFIG_USB_GADGET_FSL_USB2) && !defined(CONFIG_USB_EHCI_HCD)
+	.operating_mode = FSL_USB2_DR_DEVICE,
+#elif !defined(CONFIG_USB_GADGET_FSL_USB2) && defined(CONFIG_USB_EHCI_HCD)
+	.operating_mode = FSL_USB2_DR_HOST,
+#endif
+	.phy_mode = FSL_USB2_PHY_UTMI,
+};
+
 static int lpc_ehci_probe(struct platform_device *pdev)
 {
 	struct fsl_usb2_platform_data *pdata;
@@ -89,7 +100,7 @@ static int lpc_ehci_probe(struct platform_device *pdev)
 		return -ENODEV;
 
 	/* Need platform data for setup */
-	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+	pdata = &lpc313x_fsl_config;
 	if (!pdata) {
 		dev_err(&pdev->dev,
 			"No platform data for %s.\n", dev_name(&pdev->dev));
@@ -342,6 +353,14 @@ static int lpc313x_ehci_resume(struct platform_device * pdev)
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id ehci_lpc_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-usb" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ehci_lpc_of_match);
+#endif
+
 static struct platform_driver ehci_lpc_driver = {
 	.probe = lpc_ehci_probe,
 	.remove = lpc_ehci_remove,
@@ -353,6 +372,9 @@ static struct platform_driver ehci_lpc_driver = {
 		.suspend = lpc_ehci_suspend,
 		.resume  = lpc_ehci_resume,
 #endif
+#ifdef CONFIG_OF
+		.of_match_table = ehci_lpc_of_match,
+#endif
 	},
 };
 
diff --git a/drivers/video/ssd1289.c b/drivers/video/ssd1289.c
index 21537ce..327cfb1 100644
--- a/drivers/video/ssd1289.c
+++ b/drivers/video/ssd1289.c
@@ -496,11 +496,23 @@ out:
 	return ret;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id ssd1289_of_match[] = {
+	{ .compatible = "ssd,ssd1289" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ssd1289_of_match);
+#endif
+
 static struct platform_driver ssd1289_driver = {
 	.probe = ssd1289_probe,
-	.driver = {
-		   .name = "ssd1289",
-		   },
+	.driver		= {
+		.name	= "ssd1289",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = ssd1289_of_match,
+#endif
+	},
 };
 
 static int __init ssd1289_init(void)
diff --git a/drivers/watchdog/wdt_lpc313x.c b/drivers/watchdog/wdt_lpc313x.c
index 22e12e2..f5c4978 100644
--- a/drivers/watchdog/wdt_lpc313x.c
+++ b/drivers/watchdog/wdt_lpc313x.c
@@ -329,12 +329,23 @@ static int lpc313x_wdt_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id lpc313x_wdt_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-wdt" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lpc313x_wdt_of_match);
+#endif
+
 static struct platform_driver lpc313x_wdt_driver = {
 	.probe = lpc313x_wdt_probe,
 	.remove = __devexit_p(lpc313x_wdt_remove),
 	.driver = {
-		   .owner = THIS_MODULE,
-		   .name = "lpc313x-wdt",
+			.owner = THIS_MODULE,
+			.name = "lpc313x-wdt",
+#ifdef CONFIG_OF
+			.of_match_table = lpc313x_wdt_of_match,
+#endif
 		   },
 };
