Bottom: 04bed845babf41ff9c2b756231a302af6bd4ce1d
Top:    e82caff3771ecdc051fa6c1163f0e0a12088ce10
Author: Jon Smirl (none) <jonsmirl@smirl2>
Date:   2012-03-19 23:01:40 -0400

device trees


---

diff --git a/arch/arm/boot/dts/ea3131.dts b/arch/arm/boot/dts/ea3131.dts
new file mode 100644
index 0000000..eee902e
--- /dev/null
+++ b/arch/arm/boot/dts/ea3131.dts
@@ -0,0 +1,34 @@
+/*
+ * ea3131.dts - Device Tree file for EA3131 board
+ *
+ *  Copyright (C) 2012 Jon Smirl <jonsmirl@gmail.com>
+ *
+ * Licensed under GPLv2.
+ */
+/dts-v1/;
+/include/ "lpc3131.dtsi"
+
+/ {
+	model = "Electronic Arts EA3131";
+	compatible = "ea,ea3131", "nxp,lpc3131";
+
+	chosen {
+		bootargs = "console=ttyS0,115200n8 root=/dev/mmcblk0p3 init=/etc/preinit rw rootwait loglevel=7";
+	};
+
+	ssd1289@20000000 {
+		compatible = "ssd,ssd1289";
+		reg = <0x20000000 0x10000 0x20010000 0x10000>;
+	};
+
+	memory@30000000 {
+		reg = <0x30000000 0x4000000>;
+	};
+
+	ahb {
+		sdmmc@18000000 {
+			cd-gpio = <&gpio 0x87 0>;
+			power-gpio = <&gpio 0x45 0>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/lpc3131.dtsi b/arch/arm/boot/dts/lpc3131.dtsi
new file mode 100644
index 0000000..901c469
--- /dev/null
+++ b/arch/arm/boot/dts/lpc3131.dtsi
@@ -0,0 +1,200 @@
+/*
+ * lpc3131.dtsi - Device Tree Include file for LPC3131 family SoC
+ *
+ *  Copyright (C) 2011 Jon Smirl <jonsmirl@gmail.com>
+ *
+ * Licensed under GPLv2 or later.
+ */
+
+/ {
+	model = "NXP LPC3131 SoC";
+	compatible = "nxp,lpc3131";
+	#address-cells = <1>;
+	#size-cells = <1>;
+	interrupt-parent = <&intc>;
+
+	cpus {
+		cpu@0 {
+			compatible = "arm,arm926ejs";
+		};
+	};
+
+	ahb {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		isram0: memory@11028000 {
+			reg = <0x11028000 0x18000>;
+			interrupts = <28>;
+		};
+		isram1: memory@11040000 {
+			reg = <0x11040000 0x18000>;
+			interrupts = <29>;
+		};
+
+		apb0: apb@13000000 {
+			compatible = "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x13000000 0x13000000 0x8000>;
+
+			evtr@13000000 {
+				compatible = "nxp,lpc31xx-evtr";
+				reg = <0x13000000 0x800>;
+				interrupts = <1 2 3 4>;
+			};
+			adc@13002000 {
+				compatible = "nxp,lpc31xx-adc";
+				reg = <0x13002000 0x400>;
+				interrupts = <9>;
+			};
+			wdt@13002400 {
+				compatible = "nxp,lpc31xx-wdt";
+				reg = <0x13002400 0x400>;
+				interrupts = <30>;
+			};
+			sys@13002800 {
+				compatible = "nxp,lpc31xx-sys";
+				reg = <0x13002800 0x400>;
+			};
+			gpio: gpio@13003000 {
+				compatible = "nxp,lpc31xx-gpio";
+				reg = <0x13003000 0x1000>;
+			};
+			cgu@13004000 {
+				compatible = "nxp,lpc31xx-cgu";
+				reg = <0x13004000 0x1000>;
+			};
+			rng@13006000 {
+				compatible = "nxp,lpc31xx-rng";
+				reg = <0x13006000 0x200>;
+			};
+		};
+		apb1: apb@13008000 {
+			compatible = "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x13008000 0x13008000 0x4000>;
+
+			timer0: timer@13008000 {
+				compatible = "nxp,lpc31xx-timer";
+				reg = <0x13008000 0x400>;
+				interrupts = <5>;
+			};
+			timer1: timer@13008400 {
+				compatible = "nxp,lpc31xx-timer";
+				reg = <0x13008400 0x400>;
+				interrupts = <6>;
+			};
+			timer2: timer@13008800 {
+				compatible = "nxp,lpc31xx-timer";
+				reg = <0x13008800 0x400>;
+				interrupts = <7>;
+			};
+			timer3: timer@13008c00 {
+				compatible = "nxp,lpc31xx-timer";
+				reg = <0x13008c00 0x400>;
+				interrupts = <8>;
+			};
+			pwm@13009000 {
+				compatible = "nxp,lpc31xx-pwm";
+				reg = <0x13009000 0x200>;
+				interrupts = <11>;
+			};
+			i2c0: i2c@1300a000 {
+				compatible = "nxp,lpc31xx-i2c";
+				reg = <0x1300a000 0x400>;
+				interrupts = <11>;
+			};
+			i2c1: i2c@1300a400 {
+				compatible = "nxp,lpc31xx-i2c";
+				reg = <0x1300a400 0x400>;
+				interrupts = <12>;
+			};
+		};
+		apb2: apb@15000000 {
+			compatible = "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x15000000 0x15000000 0x3000>;
+
+			pcm@15000000 {
+				compatible = "nxp,lpc31xx-pcm";
+				reg = <0x15000000 0x400>;
+				interrupts = <14>;
+			};
+			lcd@15000400 {
+				compatible = "nxp,lpc31xx-lcd";
+				reg = <0x15000400 0x400>;
+				interrupts = <18>;
+			};
+			uart@15001000 {
+				compatible = "nxp,lpc31xx-uart";
+				reg = <0x15001000 0x1000>;
+				interrupts = <10>;
+			};
+			spi@15002000 {
+				compatible = "nxp,lpc31xx-spi";
+				reg = <0x15002000 0x1000>;
+				interrupts = <18 19 20 21 22 23>;
+			};
+		};
+		apb3: apb@16000000 {
+			compatible = "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x16000000 0x16000000 0x1000>;
+
+			i2s@16000000 {
+				compatible = "nxp,lpc31xx-i2s";
+				reg = <0x16000000 0x1000>;
+				interrupts = <13 14 15 16>;
+			};
+		};
+		apb4: apb@17000000 {
+			compatible = "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x17000000 0x17000000 0x1000>;
+
+			dma@17000000 {
+				compatible = "nxp,lpc31xx-dma";
+				reg = <0x17000000 0x800>;
+				interrupts = <24>;
+			};
+			nand@17000800 {
+				compatible = "nxp,lpc31xx-nand";
+				reg = <0x17000800 0x800>;
+				interrupts = <25>;
+			};
+		};
+		mpmc@17008000 {
+			compatible = "nxp,lpc31xx-mpmc";
+			reg = <0x17008000 0x1000>;
+			interrupts = <21>;
+		};
+		sdmmc@18000000 {
+			compatible = "nxp,lpc31xx-sdmmc";
+			reg = <0x18000000 0x1000>;
+			interrupts = <26>;
+		};
+		usb@19000000 {
+			compatible = "nxp,lpc31xx-usb, usb-ehci";
+			reg = <0x19000000 0x1000>;
+			interrupts = <27>;
+		};
+		intc: intc@60000000 {
+			compatible = "nxp,lpc31xx-intc";
+			reg = <0x60000000 0x1000>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+		};
+		nand-buffer@70000000 {
+			compatible = "nxp,lpc31xx-nand-buffer";
+			reg = <0x70000000 0x1000>;
+			interrupts = <24>;
+		};
+	};
+};
diff --git a/arch/arm/mach-lpc31xx/Makefile b/arch/arm/mach-lpc31xx/Makefile
index 5298fdf..a8ab311 100644
--- a/arch/arm/mach-lpc31xx/Makefile
+++ b/arch/arm/mach-lpc31xx/Makefile
@@ -6,6 +6,7 @@
 
 obj-y			+= irq.o time.o generic.o i2c.o gpio.o dma.o usb.o wdt.o clock.o
 obj-$(CONFIG_GPIOLIB) += gpiolib.o
+obj-$(CONFIG_OF) += dt.o
 
 
 # Specific board support
diff --git a/arch/arm/mach-lpc31xx/board-ea313x.c b/arch/arm/mach-lpc31xx/board-ea313x.c
index b7864a4..7a24b9f 100644
--- a/arch/arm/mach-lpc31xx/board-ea313x.c
+++ b/arch/arm/mach-lpc31xx/board-ea313x.c
@@ -32,6 +32,8 @@
 #include <linux/spi/spi.h>
 #include <linux/leds-pca9532.h>
 #include <linux/gpio.h>
+#include <linux/of_platform.h>
+
 
 #include <asm/system.h>
 #include <mach/hardware.h>
@@ -47,123 +49,20 @@
 #include <mach/gpio.h>
 #include <mach/i2c.h>
 #include <mach/board.h>
+#include <mach/dt.h>
 
-static struct lpc313x_mci_irq_data irq_data = {
-	.irq = IRQ_SDMMC_CD,
-};
-
-static int mci_get_cd(u32 slot_id)
-{
-	return gpio_get_value(GPIO_MI2STX_BCK0);
-}
-
-static irqreturn_t ea313x_mci_detect_interrupt(int irq, void *data)
-{
-	struct lpc313x_mci_irq_data	*pdata = data;
-
-	/* select the opposite level senstivity */
-	int level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
-
-	irq_set_irq_type(pdata->irq, level);
-
-	/* change the polarity of irq trigger */
-	return pdata->irq_hdlr(irq, pdata->data);
-}
-
-static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
-{
-	int ret;
-	int level;
-
-	/* enable power to the slot */
-	gpio_request(GPIO_MI2STX_DATA0, "mmc power");
-	gpio_set_value(GPIO_MI2STX_DATA0, 0);
-	/* set cd pins as GPIO pins */
-	gpio_request(GPIO_MI2STX_BCK0, "mmc card detect");
-	gpio_direction_input(GPIO_MI2STX_BCK0);
-
-	/* select the opposite level senstivity */
-	level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
-	/* set card detect irq info */
-	irq_data.data = data;
-	irq_data.irq_hdlr = irqhdlr;
-	irq_set_irq_type(irq_data.irq, level);
-	ret = request_irq(irq_data.irq,
-			ea313x_mci_detect_interrupt,
-			level,
-			"mmc-cd", 
-			&irq_data);
-	/****temporary for PM testing */
-	enable_irq_wake(irq_data.irq);
-
-	return irq_data.irq;
-}
-
-static int mci_get_ro(u32 slot_id)
-{
-	return 0;
-}
-
-static int mci_get_ocr(u32 slot_id)
-{
-	return MMC_VDD_32_33 | MMC_VDD_33_34;
-}
-
-static void mci_setpower(u32 slot_id, u32 volt)
-{
-	/* on current version of EA board the card detect
-	 * pull-up in on switched power side. So can't do
-	 * power management so use the always enable power 
-	 * jumper.
-	 */
-}
-static int mci_get_bus_wd(u32 slot_id)
-{
-	return 4;
-}
-
-static void mci_exit(u32 slot_id)
-{
-	free_irq(irq_data.irq, &irq_data);
-}
-
-static struct resource lpc313x_mci_resources[] = {
-	[0] = {
-		.start  = IO_SDMMC_PHYS,
-		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_MCI,
-		.end	= IRQ_MCI,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-static struct lpc313x_mci_board ea313x_mci_platform_data = {
-	.num_slots		= 1,
-	.detect_delay_ms	= 250,
-	.init 			= mci_init,
-	.get_ro			= mci_get_ro,
-	.get_cd 		= mci_get_cd,
-	.get_ocr		= mci_get_ocr,
-	.get_bus_wd		= mci_get_bus_wd,
-	.setpower 		= mci_setpower,
-	.exit			= mci_exit,
-};
 
 static u64 mci_dmamask = 0xffffffffUL;
 static struct platform_device	lpc313x_mci_device = {
 	.name		= "lpc313x_mmc",
-	.num_resources	= ARRAY_SIZE(lpc313x_mci_resources),
 	.dev		= {
 		.dma_mask		= &mci_dmamask,
 		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &ea313x_mci_platform_data,
 	},
-	.resource	= lpc313x_mci_resources,
 };
 
 #if defined (CONFIG_FB_SSD1289)
+#ifndef CONFIG_OF
 static struct resource ssd1289_resource[] = {
 	[0] = {
 		.start = EXT_SRAM0_PHYS + 0x00000 + 0x0000,
@@ -183,6 +82,7 @@ static struct platform_device ssd1289_device = {
 	.num_resources = ARRAY_SIZE(ssd1289_resource),
 	.resource      = ssd1289_resource,
 };
+#endif
 
 static void __init ea_add_device_ssd1289(void)
 {
@@ -194,7 +94,9 @@ static void __init ea_add_device_ssd1289(void)
 	MPMC_STWTWR0   = 3;
 	MPMC_STWTTURN0 = 0;
 
+#ifndef CONFIG_OF
 	platform_device_register(&ssd1289_device);
+#endif
 }
 #else
 static void __init ea_add_device_ssd1289(void) {}
@@ -677,6 +579,13 @@ void lpc313x_vbus_power(int enable)
 	gpio_set_value(VBUS_PWR_EN, enable);
 }
 
+#ifdef CONFIG_OF
+static void __init ea3131_dt_init(void)
+{
+	lpc31xx_dt_init();
+	ea_add_device_ssd1289();
+}
+#else
 static void __init ea313x_init(void)
 {
 	lpc313x_init();
@@ -699,14 +608,16 @@ static void __init ea313x_init(void)
 		ARRAY_SIZE(ea3152_i2c1_devices));
 #endif
 }
+#endif
 
 #if defined(CONFIG_USB_EHCI_HCD)
-static void __init ea_usb_power(void)
+static int __init ea_usb_power(void)
 {
 	int ret; 
 
 	ret = gpio_request(VBUS_PWR_EN, "vbus power");
 	ret = gpio_direction_output(VBUS_PWR_EN, 1);
+	return ret;
 }
 late_initcall(ea_usb_power);
 #endif
@@ -729,6 +640,7 @@ MACHINE_END
 #endif
 
 #if defined(CONFIG_MACH_EA313X)
+#ifndef CONFIG_OF
 MACHINE_START(EA313X, "NXP EA313X")
 	/* Maintainer: Durgesh Pattamatta, NXP */
 	.map_io		= ea313x_map_io,
@@ -736,6 +648,21 @@ MACHINE_START(EA313X, "NXP EA313X")
 	.timer		= &lpc313x_timer,
 	.init_machine	= ea313x_init,
 MACHINE_END
+#else
+static const char *ea3131_dt_match[] __initconst = {
+	"ea,ea3131",
+	NULL,
+};
+DT_MACHINE_START(EA313X, "NXP EA3131 (Device Tree Support)")
+	.map_io		= lpc313x_map_io,
+	.init_early	= lpc31xx_init_early,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= ea3131_dt_init,
+	.dt_compat	= ea3131_dt_match,
+	.restart	= lpc31xx_restart,
+MACHINE_END
+#endif
 #endif
 
 
diff --git a/arch/arm/mach-lpc31xx/clock.c b/arch/arm/mach-lpc31xx/clock.c
index 69ab97a..281a3f5 100644
--- a/arch/arm/mach-lpc31xx/clock.c
+++ b/arch/arm/mach-lpc31xx/clock.c
@@ -1076,7 +1076,7 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK(NULL, "wdog_pclk", clk_wdog_pclk)
 };
 
-static int __init clk_init(void)
+int __init clk_init(void)
 {
 	int i;
 
@@ -1085,5 +1085,4 @@ static int __init clk_init(void)
 
 	return 0;
 }
-core_initcall(clk_init);
 
diff --git a/arch/arm/mach-lpc31xx/dt.c b/arch/arm/mach-lpc31xx/dt.c
new file mode 100644
index 0000000..774d6ba
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/dt.c
@@ -0,0 +1,66 @@
+/*
+ * NXP LPC3131 board support using the device tree
+ *
+ *  Copyright (C) 2010 Secret Lab Technologies Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <asm/hardware/vic.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+
+#include <mach/hardware.h>
+#include <mach/board.h>
+#include <mach/clock.h>
+
+void __init lpc31xx_dt_init(void)
+{
+	lpc313x_init();
+	of_platform_populate(NULL, of_default_bus_match_table,
+			     NULL, NULL);
+}
+
+void __init lpc31xx_init_early(void)
+{
+printk("JDS - lpc31xx_init_early\n");
+}
+
+void lpc31xx_restart(char mode, const char *cmd)
+{
+printk("JDS - lpc31xx_restart\n");
+}
+
+static const char *lpc31xx_dt_match[] __initconst = {
+	"ncp,lpc3130",
+	"nxp,lpc3131",
+	"nxp,lpc3152",
+	"nxp,lpc3153",
+	NULL,
+};
+
+DT_MACHINE_START(EA313X, "NXP LPC31xx (Device Tree Support)")
+	.map_io		= lpc313x_map_io,
+	.init_early	= lpc31xx_init_early,
+	.init_irq	= lpc313x_init_irq,
+	.timer		= &lpc313x_timer,
+	.init_machine	= lpc31xx_dt_init,
+	.dt_compat	= lpc31xx_dt_match,
+	.restart	= lpc31xx_restart,
+MACHINE_END
diff --git a/arch/arm/mach-lpc31xx/generic.c b/arch/arm/mach-lpc31xx/generic.c
index 4980a58..1c50945 100644
--- a/arch/arm/mach-lpc31xx/generic.c
+++ b/arch/arm/mach-lpc31xx/generic.c
@@ -173,10 +173,26 @@ static struct map_desc lpc313x_io_desc[] __initdata = {
 		.length		= IO_ISRAM0_SIZE,
 		.type		= MT_DEVICE
 	},
+#ifdef CONFIG_OF
+	{
+		.virtual	= io_p2v(IO_USB_PHYS),
+		.pfn		= __phys_to_pfn(IO_USB_PHYS),
+		.length		= IO_USB_SIZE,
+		.type		= MT_DEVICE
+	},
+
+	{
+		.virtual	= io_p2v(IO_SDMMC_PHYS),
+		.pfn		= __phys_to_pfn(IO_SDMMC_PHYS),
+		.length		= IO_SDMMC_SIZE,
+		.type		= MT_DEVICE
+	},
+#endif
 };
 
 void __init lpc313x_map_io(void)
 {
+printk("JDS - lpc313x_map_io\n");
 	iotable_init(lpc313x_io_desc, ARRAY_SIZE(lpc313x_io_desc));
 }
 extern int __init cgu_init(char *str);
@@ -193,9 +209,10 @@ void __init lpc313x_uart_init(void)
 	}
 }
 
-int __init lpc313x_init(void)
+void __init lpc313x_init(void)
 {
 	/* cgu init */
+	clk_init();
 	cgu_init("");
 	/* Switch on the UART clocks */
 	cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
@@ -236,7 +253,9 @@ int __init lpc313x_init(void)
 
 	lpc313x_uart_init();
 
+#ifndef CONFIG_OF
 	return platform_add_devices(devices, ARRAY_SIZE(devices));
+#endif
 }
 
 
diff --git a/arch/arm/mach-lpc31xx/include/mach/board.h b/arch/arm/mach-lpc31xx/include/mach/board.h
index 5fe9ac2..2bcd065 100644
--- a/arch/arm/mach-lpc31xx/include/mach/board.h
+++ b/arch/arm/mach-lpc31xx/include/mach/board.h
@@ -32,7 +32,7 @@
 
 extern void __init lpc313x_map_io(void);
 extern void __init lpc313x_init_irq(void);
-extern int __init lpc313x_init(void);
+extern void __init lpc313x_init(void);
 extern int __init lpc313x_register_i2c_devices(void);
 extern void lpc313x_vbus_power(int enable);
 extern int lpc313x_entering_suspend_mem(void);
diff --git a/arch/arm/mach-lpc31xx/include/mach/clock.h b/arch/arm/mach-lpc31xx/include/mach/clock.h
index d7058b6..eb038b3 100644
--- a/arch/arm/mach-lpc31xx/include/mach/clock.h
+++ b/arch/arm/mach-lpc31xx/include/mach/clock.h
@@ -653,4 +653,7 @@ struct clk {
 	CGU_CLOCK_ID_T id;
 };
 
+
+int clk_init(void);
+
 #endif
diff --git a/arch/arm/mach-lpc31xx/include/mach/dt.h b/arch/arm/mach-lpc31xx/include/mach/dt.h
new file mode 100644
index 0000000..198ee69
--- /dev/null
+++ b/arch/arm/mach-lpc31xx/include/mach/dt.h
@@ -0,0 +1,9 @@
+#ifndef LPC31XX_DT
+#define LPC31XX_DT
+
+void lpc31xx_dt_init(void);
+void lpc31xx_init_early(void);
+void lpc31xx_restart(char mode, const char *cmd);
+
+#endif
+
diff --git a/arch/arm/mach-lpc31xx/irq.c b/arch/arm/mach-lpc31xx/irq.c
index 50dc8a7..4ff6533 100644
--- a/arch/arm/mach-lpc31xx/irq.c
+++ b/arch/arm/mach-lpc31xx/irq.c
@@ -24,6 +24,8 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/timer.h>
+#include <linux/of_irq.h>
+#include <linux/irqdomain.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
@@ -199,6 +201,10 @@ ROUTER_HDLR(2)
 ROUTER_HDLR(3)
 #endif /* IRQ_EVTR3_END */
 
+static const struct of_device_id intc_of_match[] __initconst = {
+	{ .compatible = "nxp,lpc31xx-intc", },
+	{},
+};
 
 void __init lpc313x_init_irq(void)
 {
@@ -206,6 +212,8 @@ void __init lpc313x_init_irq(void)
 	int i, j;
 	u32 bank, bit_pos;
 
+	irq_domain_generate_simple(intc_of_match, 0x60000000, 0);
+
 	/* enable clock to interrupt controller */
 	cgu_clk_en_dis(CGU_SB_AHB2INTC_CLK_ID, 1);
 	cgu_clk_en_dis(CGU_SB_INTC_CLK_ID, 1);
diff --git a/drivers/mmc/host/lpc31xx_mmc.c b/drivers/mmc/host/lpc31xx_mmc.c
index 73d67e7..c86b1904 100644
--- a/drivers/mmc/host/lpc31xx_mmc.c
+++ b/drivers/mmc/host/lpc31xx_mmc.c
@@ -37,6 +37,9 @@
 #include <linux/delay.h>
 #include <linux/irq.h>
 #include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/gpio.h>
 
 #include "lpc31xx_mmc.h"
 #include <mach/irqs.h>
@@ -1401,6 +1404,119 @@ static void lpc313x_mci_cleanup_slot(struct lpc313x_mci_slot *slot,
 	mmc_free_host(slot->mmc);
 }
 
+static struct lpc313x_mci_irq_data irq_data = {
+	.irq = IRQ_SDMMC_CD,
+};
+
+static int mci_get_cd(u32 slot_id)
+{
+	return gpio_get_value(GPIO_MI2STX_BCK0);
+}
+
+static irqreturn_t ea313x_mci_detect_interrupt(int irq, void *data)
+{
+	struct lpc313x_mci_irq_data	*pdata = data;
+
+	/* select the opposite level senstivity */
+	int level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
+
+	irq_set_irq_type(pdata->irq, level);
+
+	/* change the polarity of irq trigger */
+	return pdata->irq_hdlr(irq, pdata->data);
+}
+
+static int mci_init(u32 slot_id, irq_handler_t irqhdlr, void *data)
+{
+	int ret;
+	int level;
+
+	/* enable power to the slot */
+	gpio_request(GPIO_MI2STX_DATA0, "mmc power");
+	gpio_set_value(GPIO_MI2STX_DATA0, 0);
+	/* set cd pins as GPIO pins */
+	gpio_request(GPIO_MI2STX_BCK0, "mmc card detect");
+	gpio_direction_input(GPIO_MI2STX_BCK0);
+
+	/* select the opposite level senstivity */
+	level = mci_get_cd(0) ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
+	/* set card detect irq info */
+	irq_data.data = data;
+	irq_data.irq_hdlr = irqhdlr;
+	irq_set_irq_type(irq_data.irq, level);
+	ret = request_irq(irq_data.irq,
+			ea313x_mci_detect_interrupt,
+			level,
+			"mmc-cd", 
+			&irq_data);
+	/****temporary for PM testing */
+	enable_irq_wake(irq_data.irq);
+
+	return irq_data.irq;
+}
+
+static int mci_get_ro(u32 slot_id)
+{
+	return 0;
+}
+
+static int mci_get_ocr(u32 slot_id)
+{
+	return MMC_VDD_32_33 | MMC_VDD_33_34;
+}
+
+static void mci_setpower(u32 slot_id, u32 volt)
+{
+	/* on current version of EA board the card detect
+	 * pull-up in on switched power side. So can't do
+	 * power management so use the always enable power 
+	 * jumper.
+	 */
+}
+static int mci_get_bus_wd(u32 slot_id)
+{
+	return 4;
+}
+
+static void mci_exit(u32 slot_id)
+{
+	free_irq(irq_data.irq, &irq_data);
+}
+
+#ifndef CONFIG_OF
+static struct resource lpc313x_mci_resources[] = {
+	[0] = {
+		.start  = IO_SDMMC_PHYS,
+		.end	= IO_SDMMC_PHYS + IO_SDMMC_SIZE,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_MCI,
+		.end	= IRQ_MCI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+#endif
+
+static struct lpc313x_mci_board ea313x_mci_platform_data = {
+	.num_slots		= 1,
+	.detect_delay_ms	= 250,
+	.init 			= mci_init,
+	.get_ro			= mci_get_ro,
+	.get_cd 		= mci_get_cd,
+	.get_ocr		= mci_get_ocr,
+	.get_bus_wd		= mci_get_bus_wd,
+	.setpower 		= mci_setpower,
+	.exit			= mci_exit,
+};
+
+#if defined(CONFIG_OF)
+static const struct of_device_id lpc313x_mci_of_match[] = {
+	{ .compatible = "nxp,lpc31xx-sdmmc" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lpc313x_mci_of_match);
+#endif
 
 static int lpc313x_mci_probe(struct platform_device *pdev)
 {
@@ -1412,11 +1528,16 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 	int				ret = 0;
 	int i;
 
+#ifndef CONFIG_OF
+pdev->num_resources = ARRAY_SIZE(lpc313x_mci_resources);
+pdev->resource = lpc313x_mci_resources;
+#endif
+pdev->dev.platform_data = &ea313x_mci_platform_data;
+
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!regs)
 		return -ENXIO;
 
-
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
 		return irq;
@@ -1483,6 +1604,7 @@ static int lpc313x_mci_probe(struct platform_device *pdev)
 		goto err_freemap;
 	}
 #endif
+
 	clk = clk_get(NULL, "mmc_cclk_in");
 	host->bus_hz = clk_get_rate(clk); //40000000;
 	clk_put(clk);
@@ -1652,7 +1774,11 @@ static struct platform_driver lpc313x_mci_driver = {
 	.resume     = lpc313x_mci_resume,
 	.remove		= __exit_p(lpc313x_mci_remove),
 	.driver		= {
-		.name		= "lpc313x_mmc",
+		.name	= "lpc313x_mmc",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = lpc313x_mci_of_match,
+#endif
 	},
 };
 
diff --git a/drivers/video/ssd1289.c b/drivers/video/ssd1289.c
index 21537ce..928ec27 100644
--- a/drivers/video/ssd1289.c
+++ b/drivers/video/ssd1289.c
@@ -376,6 +376,7 @@ static int __init ssd1289_probe(struct platform_device *dev)
 	dev_set_drvdata(&dev->dev, item);
 
 	ctrl_res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+printk("JDS ctrl %p %p\n", ctrl_res->end, ctrl_res->start);
 	if (!ctrl_res) {
 		dev_err(&dev->dev,
 			"%s: unable to platform_get_resource for ctrl_res\n",
@@ -402,6 +403,7 @@ static int __init ssd1289_probe(struct platform_device *dev)
 	}
 
 	data_res = platform_get_resource(dev, IORESOURCE_MEM, 1);
+printk("JDS data %p %p\n", data_res->end, data_res->start);
 	if (!data_res) {
 		dev_err(&dev->dev,
 			"%s: unable to platform_get_resource for data_res\n",
@@ -496,11 +498,23 @@ out:
 	return ret;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id ssd1289_of_match[] = {
+	{ .compatible = "ssd,ssd1289" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ssd1289_of_match);
+#endif
+
 static struct platform_driver ssd1289_driver = {
 	.probe = ssd1289_probe,
-	.driver = {
-		   .name = "ssd1289",
-		   },
+	.driver		= {
+		.name	= "ssd1289",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = ssd1289_of_match,
+#endif
+	},
 };
 
 static int __init ssd1289_init(void)
