Bottom: fedb347fc9ef5e31f0b5ef18602c7b2917adfd89
Top:    07bc6fe92f07a19caf9f3f65b4a6a0ebfe932f01
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2012-10-15 19:30:32 -0400

temp holding for USB work

---

diff --git a/arch/arm/boot/dts/ea3131.dts b/arch/arm/boot/dts/ea3131.dts
index 31346cf..a1957f1 100644
--- a/arch/arm/boot/dts/ea3131.dts
+++ b/arch/arm/boot/dts/ea3131.dts
@@ -91,6 +91,7 @@
 	};
 	usb@19000000 {
 		vbus-over =  <&gpio_i2srx_0 2 0>;
+		vbus-power = <&pca9532 6 1>;
 	};
 	sram@20000000 {
 		mpmc-config = <0x81 0 0 31 0 3 0>;
diff --git a/arch/arm/mach-lpc31xx/usb.c b/arch/arm/mach-lpc31xx/usb.c
index 45ad7e6..c23e768 100644
--- a/arch/arm/mach-lpc31xx/usb.c
+++ b/arch/arm/mach-lpc31xx/usb.c
@@ -1,4 +1,4 @@
-/* linux/arch/arm/mach-lpc31xx/usb.c -- platform level USB initialization
+/* linux/arch/arm/mach-lpc313x/usb.c -- platform level USB initialization
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
@@ -38,14 +38,24 @@
 #include <linux/io.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
-#include <linux/of_gpio.h>
 
 #include <asm/irq.h>
 #include <asm/system.h>
 #include <mach/board.h>
 #include <mach/gpio.h>
 
+#define IRQ_USB 27
+#define EVT_GET_BANK(evt)	(((evt) >> 5) & 0x3)
+#define EVT_usb_atx_pll_lock	0x79
 #define EVRT_RSR(bank)       __REG (EVTR_PHYS + 0xD20 + ((bank) << 2))
+#define IRQ_VBUS_OVRC  32  /* Detect VBUS over current - Host mode */
+#define IRQ_EA_VBUS_OVRC 32
+
+static void lpc313x_vbus_power(int enable)
+{
+	printk (KERN_INFO "enabling USB host vbus_power %d\n", enable);
+	//gpio_set_value(VBUS_PWR_EN, enable);
+}
 
 
 /****************************************************************************
@@ -99,11 +109,10 @@
 #define OTGSC_INT_STAT_MASK (0x007F0000)
 
 /*-------------------------------------------------------------------------*/
-#if defined(CONFIG_USB_GADGET_FSL_USB2) || defined(CONFIG_USB_OTG)
-static struct resource lpc31xx_usb_resource[] = {
+static struct resource lpc313x_usb_resource[] = {
 	[0] = {
-		.start = (uint32_t) (USBOTG_PHYS),
-		.end   = (uint32_t) (USBOTG_PHYS + SZ_4K),
+		.start = (u32) (USBOTG_PHYS),
+		.end   = (u32) (USBOTG_PHYS + SZ_4K),
 		.flags = IORESOURCE_MEM,
 	},
 	[1] = {
@@ -112,53 +121,56 @@ static struct resource lpc31xx_usb_resource[] = {
 		.flags = IORESOURCE_IRQ,
 	}
 };
-#endif
 
-struct lpc31xx_usb_board_t {
+struct lpc313x_usb_board_t {
 	/* timer for VBUS enable */
 	struct timer_list	vbus_timer;
 	/* board specific over current monitor */
 	int	vbus_ovrc_irq;
 };
 
-static struct lpc31xx_usb_board_t lpc31xx_usb_brd;
+static struct lpc313x_usb_board_t lpc313x_usb_brd;
 
-#if defined(CONFIG_USB_GADGET_FSL_USB2) || defined(CONFIG_USB_OTG)
+static u64 usb_dmamask = 0xffffffffUL;;
+static void	lpc313x_usb_release(struct device *dev);
 
-static struct platform_device lpc31xx_udc_device = {
-	.name = "fsl-usb2-udc",
-	.dev = {
-		.dma_mask          = &usb_dmamask,
-		.coherent_dma_mask = 0xffffffff,
-		.release           = lpc31xx_usb_release,
-	},
-	.num_resources = ARRAY_SIZE(lpc31xx_usb_resource),
-	.resource      = lpc31xx_usb_resource,
-};
+struct fsl_usb2_platform_data lpc313x_fsl_config = {
+#if defined(CONFIG_USB_OTG) || (defined(CONFIG_USB_EHCI_HCD) && defined(CONFIG_USB_GADGET_FSL_USB2))
+	.operating_mode = FSL_USB2_DR_OTG,
+#elif defined(CONFIG_USB_GADGET_FSL_USB2) && !defined(CONFIG_USB_EHCI_HCD)
+	.operating_mode = FSL_USB2_DR_DEVICE,
+#elif !defined(CONFIG_USB_GADGET_FSL_USB2) && defined(CONFIG_USB_EHCI_HCD)
+	.operating_mode = FSL_USB2_DR_HOST,
 #endif
+	.phy_mode = FSL_USB2_PHY_UTMI,
+};
 
-#if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_OTG)
+#if defined(CONFIG_USB_GADGET_FSL_USB2) || defined(CONFIG_USB_OTG)
 
-#ifndef CONFIG_OF
-static struct platform_device lpc31xx_ehci_device = {
-	.name		= "lpc-ehci",
+static struct platform_device lpc313x_udc_device = {
+	.name = "fsl-usb2-udc",
 	.dev = {
 		.dma_mask          = &usb_dmamask,
 		.coherent_dma_mask = 0xffffffff,
-		.release           = lpc31xx_usb_release,
+		.release           = lpc313x_usb_release,
+		.platform_data     = &lpc313x_fsl_config,
 	},
-	.num_resources = ARRAY_SIZE(lpc31xx_usb_resource),
-	.resource      = lpc31xx_usb_resource,
+	.num_resources = ARRAY_SIZE(lpc313x_usb_resource),
+	.resource      = lpc313x_usb_resource,
 };
 #endif
-#endif
 
+/*-------------------------------------------------------------------------*/
+static void	lpc313x_usb_release(struct device *dev)
+{
+	// do nothing
+}
 
-static irqreturn_t lpc31xx_vbus_ovrc_irq(int irq, void *data)
+static irqreturn_t lpc313x_vbus_ovrc_irq(int irq, void *data)
 {
-	struct lpc31xx_usb_board_t* brd = data;
+	struct lpc313x_usb_board_t* brd = data;
 	/* disable VBUS power */
-	lpc31xx_vbus_power(0);
+	lpc313x_vbus_power(0);
 	/* Disable over current IRQ */
 	disable_irq_nosync(irq);
 	printk(KERN_INFO "Disabling VBUS as device is drawing too much current!!\n");
@@ -170,26 +182,22 @@ static irqreturn_t lpc31xx_vbus_ovrc_irq(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static void lpc31xx_vbusen_timer(unsigned long data)
+static void lpc313x_vbusen_timer(unsigned long data)
 {
-	struct lpc31xx_usb_board_t* brd = (struct lpc31xx_usb_board_t*)data;
+	struct lpc313x_usb_board_t* brd = (struct lpc313x_usb_board_t*)data;
 	/* enable VBUS power */
-	lpc31xx_vbus_power(1);
+	lpc313x_vbus_power(1);
 	msleep(2);
 	/* enable the VBUS overcurrent monitoring IRQ */
 	enable_irq(brd->vbus_ovrc_irq);
 }
 
-/* Macros to compute the bank based on EVENT_T */
-#define EVT_GET_BANK(evt)	(((evt) >> 5) & 0x3)
-#define EVT_usb_atx_pll_lock	0x79
 
 /*-------------------------------------------------------------------------*/
 int __init usbotg_init(void)
 {
-	int over;
-	uint32_t bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
-	uint32_t bit_pos = EVT_usb_atx_pll_lock & 0x1F;
+	u32 bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
+	u32 bit_pos = EVT_usb_atx_pll_lock & 0x1F;
 	int retval = 0;
 
 	/* enable USB to AHB clock */
@@ -223,50 +231,40 @@ int __init usbotg_init(void)
 #if defined(CONFIG_USB_GADGET_FSL_USB2)
 		/* register gadget */
 		printk(KERN_INFO "Registering USB gadget 0x%08x 0x%08x (%d)\n", USB_DEV_OTGSC, EVRT_RSR(bank), bank);
-		retval = platform_device_register(&lpc31xx_udc_device);
+		retval = platform_device_register(&lpc313x_udc_device);
 		if ( 0 != retval )
-			printk(KERN_INFO "Can't register lpc31xx_udc_device device\n");
+			printk(KERN_INFO "Can't register lpc313x_udc_device device\n");
 #else
 		printk(KERN_ERR "Unable to register USB gadget. Check USB_ID jumper!!!!!\n");
 #endif
 	} else {
 #if defined(CONFIG_USB_EHCI_HCD)
-		/* register host */
-#ifndef CONFIG_OF
-		printk(KERN_INFO "Registering USB host 0x%08x 0x%08x (%d)\n", USB_DEV_OTGSC, EVRT_RSR(bank), bank);
-		retval = platform_device_register(&lpc31xx_ehci_device);
-		if ( 0 != retval )
-			printk(KERN_INFO "Can't register lpc31xx_ehci_device device\n");
-#endif
 		/* Create VBUS enable timer */
-		setup_timer(&lpc31xx_usb_brd.vbus_timer, lpc31xx_vbusen_timer,
-				(unsigned long)&lpc31xx_usb_brd);
+		setup_timer(&lpc313x_usb_brd.vbus_timer, lpc313x_vbusen_timer,
+				(unsigned long)&lpc313x_usb_brd);
+printk("JDS - fix the rest of OTG support\n");
+return 0;
 
 #if defined(CONFIG_MACH_EA313X) || defined(CONFIG_MACH_EA3152)
 		/* set thw I2SRX_WS0 pin as GPIO_IN for vbus overcurrent flag */
-#if 0
-		over = of_get_named_gpio(np, "vbus-over", 0);
-		retval = gpio_request(over, "vbus overcurrent");
+		retval = gpio_request(GPIO_I2SRX_WS0, "vbus overcurrent");
 		if ( 0 != retval )
-			printk(KERN_INFO "Can't acquire vbus-over GPIO\n");
-		gpio_direction_input(over);
-#endif
-#define IRQ_EA_VBUS_OVRC  37  /* Detect VBUS over current - Host mode */
-		lpc31xx_usb_brd.vbus_ovrc_irq = IRQ_EA_VBUS_OVRC;
+			printk(KERN_INFO "Can't acquire GPIO_I2SRX_WS0\n");
+		gpio_direction_input(GPIO_I2SRX_WS0);
+		lpc313x_usb_brd.vbus_ovrc_irq = IRQ_EA_VBUS_OVRC;
 
 #else
-		lpc31xx_usb_brd.vbus_ovrc_irq = IRQ_VBUS_OVRC;
+		lpc313x_usb_brd.vbus_ovrc_irq = IRQ_VBUS_OVRC;
 #endif
 
-#if 0
 		/* request IRQ to handle VBUS power event */
-		retval = request_irq( lpc31xx_usb_brd.vbus_ovrc_irq, lpc31xx_vbus_ovrc_irq,
+		retval = request_irq( lpc313x_usb_brd.vbus_ovrc_irq, lpc313x_vbus_ovrc_irq, 
 			IRQF_DISABLED, "VBUSOVR", 
-			&lpc31xx_usb_brd);
+			&lpc313x_usb_brd);
+
 		if ( 0 != retval )
 			printk(KERN_INFO "Unable to register IRQ_VBUS_OVRC handler\n");
-#endif
-		
+
 #else
 		printk(KERN_ERR "Unable to register USB host. Check USB_ID jumper!!!!!\n");
 #endif
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 654e248..c6fd9e9 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -96,6 +96,7 @@ static struct usb_device_id btusb_table[] = {
 	{ USB_DEVICE(0x0c10, 0x0000) },
 
 	/* Broadcom BCM20702A0 */
+	{ USB_DEVICE(0x0a5c, 0x21e8) },
 	{ USB_DEVICE(0x0489, 0xe042) },
 	{ USB_DEVICE(0x413c, 0x8197) },
 
diff --git a/drivers/leds/leds-pca9532.c b/drivers/leds/leds-pca9532.c
index 9a5ed95..1c65399 100644
--- a/drivers/leds/leds-pca9532.c
+++ b/drivers/leds/leds-pca9532.c
@@ -86,9 +86,19 @@ static const struct pca9532_chip_info pca9532_chip_info_tbl[] = {
 	},
 };
 
+static const struct of_device_id pca9532_of_match[] = {
+	{
+		.compatible = "nxp,pca9532",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, pca9532_of_match);
+
 static struct i2c_driver pca9532_driver = {
 	.driver = {
 		.name = "leds-pca953x",
+		.owner = THIS_MODULE,
+		.of_match_table = pca9532_of_match,
 	},
 	.probe = pca9532_probe,
 	.remove = pca9532_remove,
@@ -478,6 +488,7 @@ static int pca9532_probe(struct i2c_client *client,
 	struct pca9532_data *data = i2c_get_clientdata(client);
 	struct pca9532_platform_data *pca9532_pdata = client->dev.platform_data;
 
+	printk("JDS - pca9532_probe\n");
 #ifdef CONFIG_OF
 	pca9532_pdata = &of_gpios;
 #else
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 63d17db..9525f7d 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -172,8 +172,8 @@ config USB_FSL_USB2
 	select USB_GADGET_DUALSPEED
 	select USB_FSL_MPH_DR_OF if OF
 	help
-	   Some of Freescale PowerPCm LPC31xx and i.MX processors have a High Speed
-	   Dual-Role(DR) USB controller, which supports device mode.
+	   Some of Freescale PowerPC processors and LPC313x have a High 
+	   Speed Dual-Role(DR) USB controller, which supports device mode.
 
 	   The number of programmable endpoints is different through
 	   SOC revisions.
diff --git a/drivers/usb/gadget/fsl_lpc_udc.c b/drivers/usb/gadget/fsl_lpc_udc.c
index 362b757..68d862b 100644
--- a/drivers/usb/gadget/fsl_lpc_udc.c
+++ b/drivers/usb/gadget/fsl_lpc_udc.c
@@ -3,7 +3,7 @@
  *  Copyright (C) 2009 NXP semiconductors
  *
  * Description:
- * Helper routines for LPC31xx SoCs from NXP, needed by the fsl_udc_core.c
+ * Helper routines for LPC313x/4x/5x SoCs from NXP, needed by the fsl_udc_core.c
  * driver to function correctly on these systems.
  *
  * This program is free software; you can redistribute it and/or modify
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index 71f59b6..80dcbba 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -38,7 +38,7 @@
 #define gadget_is_imx(g)		(!strcmp("imx_udc", (g)->name))
 #define gadget_is_langwell(g)		(!strcmp("langwell_udc", (g)->name))
 #define gadget_is_lpc32xx(g)		(!strcmp("lpc32xx_udc", (g)->name))
-#define gadget_is_lpc31xx(g)		(!strcmp("lpc31xx_udc", (g)->name))
+#define gadget_is_lpc313x(g)		(!strcmp("lpc313x_udc", (g)->name))
 #define gadget_is_m66592(g)		(!strcmp("m66592_udc", (g)->name))
 #define gadget_is_musbhdrc(g)		(!strcmp("musb-hdrc", (g)->name))
 #define gadget_is_net2272(g)		(!strcmp("net2272", (g)->name))
@@ -120,16 +120,10 @@ static inline int usb_gadget_controller_number(struct usb_gadget *gadget)
 		return 0x31;
 	else if (gadget_is_dwc3(gadget))
 		return 0x32;
-<<<<<<< current
-<<<<<<< current
 	else if (gadget_is_lpc32xx(gadget))
-=======
-	else if (gadget_is_lpc313x(gadget))
->>>>>>> patched
-=======
-	else if (gadget_is_lpc31xx(gadget))
->>>>>>> patched
 		return 0x33;
+	else if (gadget_is_lpc313x(gadget))
+		return 0x34;
 
 	return -ENOENT;
 }
diff --git a/drivers/usb/host/ehci-lpc.c b/drivers/usb/host/ehci-lpc.c
index 18b908f..ca31dc6 100644
--- a/drivers/usb/host/ehci-lpc.c
+++ b/drivers/usb/host/ehci-lpc.c
@@ -1,5 +1,5 @@
 /*
- * LPC31xx EHCI Host Controller Driver
+ * LPC313x & LPC315x EHCI Host Controller Driver
  *
  * Author: Durgesh Pattamatta <durgesh.pattamatta@nxp.com>
  *
@@ -17,6 +17,19 @@
 #include <mach/board.h>
 #include <mach/hardware.h>
 
+/* Macros to compute the bank based on EVENT_T */
+#define EVT_GET_BANK(evt)	(((evt) >> 5) & 0x3)
+#define EVT_usb_atx_pll_lock	0x79
+#define EVRT_RSR(bank)       __REG (EVTR_PHYS + 0xD20 + ((bank) << 2))
+#define IRQ_VBUS_OVRC  32  /* Detect VBUS over current - Host mode */
+
+static void lpc313x_vbus_power(int enable)
+{
+	printk (KERN_INFO "enabling USB host vbus_power %d\n", enable);
+	//gpio_set_value(VBUS_PWR_EN, enable);
+}
+
+
 static struct platform_driver ehci_lpc_driver;
 
 static int lpc_ehci_init(struct usb_hcd *hcd)
@@ -46,7 +59,7 @@ static int lpc_ehci_init(struct usb_hcd *hcd)
 
 	ehci_port_power(ehci, 0);
 	/* board vbus power */
-	//lpc31xx_vbus_power(0);
+	//lpc313x_vbus_power(0);
 
 	return retval;
 }
@@ -77,7 +90,7 @@ static const struct hc_driver lpc_ehci_hc_driver = {
 	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
 };
 
-struct fsl_usb2_platform_data lpc31xx_fsl_config = {
+static struct fsl_usb2_platform_data lpc313x_fsl_config = {
 #if defined(CONFIG_USB_OTG) || (defined(CONFIG_USB_EHCI_HCD) && defined(CONFIG_USB_GADGET_FSL_USB2))
 	.operating_mode = FSL_USB2_DR_OTG,
 #elif defined(CONFIG_USB_GADGET_FSL_USB2) && !defined(CONFIG_USB_EHCI_HCD)
@@ -88,6 +101,8 @@ struct fsl_usb2_platform_data lpc31xx_fsl_config = {
 	.phy_mode = FSL_USB2_PHY_UTMI,
 };
 
+static u64 usb_dmamask = 0xffffffffUL;;
+
 static int lpc_ehci_probe(struct platform_device *pdev)
 {
 	struct fsl_usb2_platform_data *pdata;
@@ -100,8 +115,13 @@ static int lpc_ehci_probe(struct platform_device *pdev)
 	if (usb_disabled())
 		return -ENODEV;
 
+	pdev->dev.dma_mask          = &usb_dmamask,
+	pdev->dev.coherent_dma_mask = 0xffffffff,
+
+
 	/* Need platform data for setup */
-	pdata = &lpc31xx_fsl_config;
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+	pdata = &lpc313x_fsl_config;
 	if (!pdata) {
 		dev_err(&pdev->dev,
 			"No platform data for %s.\n", dev_name(&pdev->dev));
@@ -128,6 +148,7 @@ static int lpc_ehci_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 	irq = res->start;
+printk("JDS usb IRQ %d\n", irq);
 
 	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
 	if (!hcd) {
@@ -145,14 +166,16 @@ static int lpc_ehci_probe(struct platform_device *pdev)
 	}
 	hcd->rsrc_start = res->start;
 	hcd->rsrc_len = res->end - res->start + 1;
-/*	
+printk("JDS usb res->start %x\n", res->start);
+printk("JDS usb res->end %x\n", res->end);
+
 	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
 				driver->description)) {
 		dev_dbg(&pdev->dev, "controller already in use\n");
 		retval = -EBUSY;
 		goto fail_request_resource;
 	}
-*/
+
 	hcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);
 	if (hcd->regs == NULL) {
 		dev_dbg(&pdev->dev, "error mapping memory\n");
@@ -243,7 +266,7 @@ static int lpc_ehci_suspend(struct device *dev, pm_message_t state)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	uint32_t cmd;
+	u32 cmd;
 
 	dev_dbg(dev, "%s pdev=0x%p  ehci=0x%p  hcd=0x%p\n",
 		 __FUNCTION__, pdev, ehci, hcd);
@@ -267,7 +290,7 @@ static int lpc_ehci_suspend(struct device *dev, pm_message_t state)
 	/* put the device in idele mode */
 	writel(0, (hcd->regs + 0x1a8));
 	/* board vbus power */
-	//lpc31xx_vbus_power(0);
+	//lpc313x_vbus_power(0);
 
 	return 0;
 }
@@ -277,7 +300,7 @@ static int lpc_ehci_resume(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	uint32_t tmp;
+	u32 tmp;
 
 	dbg("%s pdev=0x%p  pdata=0x%p  ehci=0x%p  hcd=0x%p\n",
 	    __FUNCTION__, pdev, pdata, ehci, hcd);
@@ -299,7 +322,7 @@ static int lpc_ehci_resume(struct device *dev)
 	ehci_writel(ehci, tmp, &ehci->regs->command);
 
 	/* board vbus power */
-	//lpc31xx_vbus_power(1);
+	//lpc313x_vbus_power(1);
 
 
 	usb_hcd_resume_root_hub(hcd);
@@ -309,17 +332,16 @@ static int lpc_ehci_resume(struct device *dev)
 #endif				/* CONFIG_USB_OTG */
 /**
  * FIXME: This should get into a common header
- * currently declared in arch/arm/mach-lpc31xx/usb.c
+ * currently declared in arch/arm/mach-lpc313x/usb.c
  **/
 #define USB_DEV_PORTSC1			__REG(USBOTG_PHYS + 0x184)
 #define USBPRTS_PLPSCD	_BIT(23)
-static int lpc31xx_ehci_suspend(struct platform_device *pdev, pm_message_t state)
+static int lpc313x_ehci_suspend(struct platform_device *pdev, pm_message_t state)
 {
 #ifdef CONFIG_PM
-#define IRQ_VBUS_OVRC  32  /* Detect VBUS over current - Host mode */
 	disable_irq(IRQ_VBUS_OVRC);
 	/* Shutoff vbus power */
-	lpc31xx_vbus_power(0);
+	lpc313x_vbus_power(0);
 	/* Bring PHY to low power state */
 	USB_DEV_PORTSC1 |= USBPRTS_PLPSCD;
 	/* Bring PLL to low power state */
@@ -330,15 +352,11 @@ static int lpc31xx_ehci_suspend(struct platform_device *pdev, pm_message_t state
 	return 0;
 }
 
-/* Macros to compute the bank based on EVENT_T */
-#define EVT_GET_BANK(evt)	(((evt) >> 5) & 0x3)
-#define EVT_usb_atx_pll_lock	0x79
-
-static int lpc31xx_ehci_resume(struct platform_device * pdev)
+static int lpc313x_ehci_resume(struct platform_device * pdev)
 {
 #ifdef CONFIG_PM
-	uint32_t bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
-	uint32_t bit_pos = EVT_usb_atx_pll_lock & 0x1F;
+	u32 bank = EVT_GET_BANK(EVT_usb_atx_pll_lock);
+	u32 bit_pos = EVT_usb_atx_pll_lock & 0x1F;
 	int tout = 100;
 
 	/* Turn on IP Clock */
@@ -353,7 +371,7 @@ static int lpc31xx_ehci_resume(struct platform_device * pdev)
 	}
 	/* Bring PHY to active state */
 	USB_DEV_PORTSC1 &= ~USBPRTS_PLPSCD;
-	lpc31xx_vbus_power(1);
+	lpc313x_vbus_power(1);
 	enable_irq(IRQ_VBUS_OVRC);
 #endif
 	return 0;
@@ -370,8 +388,8 @@ MODULE_DEVICE_TABLE(of, ehci_lpc_of_match);
 static struct platform_driver ehci_lpc_driver = {
 	.probe = lpc_ehci_probe,
 	.remove = lpc_ehci_remove,
-	.suspend = lpc31xx_ehci_suspend,
-	.resume = lpc31xx_ehci_resume,
+	.suspend = lpc313x_ehci_suspend,
+	.resume = lpc313x_ehci_resume,
 	.driver = {
 		.name = "lpc-ehci",
 #ifdef CONFIG_USB_OTG
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index da07d98..5492fee 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -211,6 +211,12 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		has_ppcd:1; /* support per-port change bits */
 	u8			sbrn;		/* packed release number */
 
+	/*
+	 * OTG controllers and transceivers need software interaction;
+	 * other external transceivers should be software-transparent 
+	 */
+	struct otg_transceiver   *transceiver;
+
 	/* irq statistics */
 #ifdef EHCI_STATS
 	struct ehci_stats	stats;
diff --git a/drivers/usb/host/lpc-ehset.c b/drivers/usb/host/lpc-ehset.c
index 0e8e413..6a0e669 100644
--- a/drivers/usb/host/lpc-ehset.c
+++ b/drivers/usb/host/lpc-ehset.c
@@ -1,4 +1,4 @@
-/* linux/arch/arm/mach-lpc31xx/usb.c -- platform level USB initialization
+/* linux/arch/arm/mach-lpc313x/usb.c -- platform level USB initialization
  *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
@@ -88,7 +88,7 @@ static struct usb_driver hset_driver;
 /* Test routines */
 static inline void test_se0_nak(struct usb_hset *hset)
 {
-	uint32_t temp = USB_DEV_PORTSC1;
+	u32 temp = USB_DEV_PORTSC1;
 	printk(KERN_INFO "%s\n", __FUNCTION__);
 	
 	temp &= ~(0xF << 16);
@@ -98,7 +98,7 @@ static inline void test_se0_nak(struct usb_hset *hset)
 
 static inline void test_j(struct usb_hset *hset)
 {
-	uint32_t temp = USB_DEV_PORTSC1;
+	u32 temp = USB_DEV_PORTSC1;
 	printk(KERN_INFO "%s\n", __FUNCTION__);
 	
 	temp &= ~(0xF << 16);
@@ -108,7 +108,7 @@ static inline void test_j(struct usb_hset *hset)
 
 static inline void test_k(struct usb_hset *hset)
 {
-	uint32_t temp = USB_DEV_PORTSC1;
+	u32 temp = USB_DEV_PORTSC1;
 	printk(KERN_INFO "%s\n", __FUNCTION__);
 	
 	temp &= ~(0xF << 16);
@@ -118,7 +118,7 @@ static inline void test_k(struct usb_hset *hset)
 
 static inline void test_packet(struct usb_hset *hset)
 {
-	uint32_t temp = USB_DEV_PORTSC1;
+	u32 temp = USB_DEV_PORTSC1;
 	printk(KERN_INFO "%s\n", __FUNCTION__);
 	
 	temp &= ~(0xF << 16);
@@ -128,7 +128,7 @@ static inline void test_packet(struct usb_hset *hset)
 
 static inline void test_force_enable(struct usb_hset *hset)
 {
-	uint32_t temp = USB_DEV_PORTSC1;
+	u32 temp = USB_DEV_PORTSC1;
 	printk(KERN_INFO "%s\n", __FUNCTION__);
 	
 	temp &= ~(0xF << 16);
